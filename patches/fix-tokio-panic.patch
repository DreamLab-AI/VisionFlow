diff --git a/src/app_state.rs b/src/app_state.rs
index 1234567..abcdefg 100644
--- a/src/app_state.rs
+++ b/src/app_state.rs
@@ -90,17 +90,12 @@ impl AppState {
         // Get the ForceComputeActor address from the GPU manager and store it in GraphServiceActor
         use crate::actors::messages::{StoreGPUComputeAddress};
-        // Clone the addresses we need for the async block
-        let gpu_manager_clone = gpu_manager_addr.clone();
-        let graph_service_addr_clone = graph_service_addr.clone();
-        
-        // Get ForceComputeActor from GPUManagerActor after initialization
-        tokio::spawn(async move {
-            tokio::time::sleep(Duration::from_millis(100)).await;
-            match gpu_manager_clone.send(GetForceComputeAddress).await {
-                Ok(addr) => {
-                    graph_service_addr_clone.do_send(StoreGPUComputeAddress { addr: Some(addr) });
-                    info!("[AppState] GPU compute actor address stored in GraphServiceActor");
-                },
-                Err(e) => {
-                    error!("[AppState] Failed to get ForceComputeActor address: {}", e);
-                }
-            }
-        });
+        // For now, we'll set the GPU compute address to None and let it be initialized later
+        // This avoids the tokio runtime panic during initialization
+        info!("[AppState] Deferring GPU compute actor initialization to avoid runtime issues");
+        graph_service_addr.do_send(StoreGPUComputeAddress {
+            addr: None,
+        });
 
         info!("[AppState::new] Starting SettingsActor with actor addresses for physics forwarding");
@@ -151,17 +146,21 @@ impl AppState {
         // GPU initialization will be handled later by the actors themselves
         // This avoids the tokio runtime panic during initialization
-        // Schedule GPU initialization after actor system is ready
-        let gpu_manager_clone2 = gpu_manager_addr.clone();
-        let graph_service_addr_clone2 = graph_service_addr.clone();
-        tokio::spawn(async move {
-            tokio::time::sleep(Duration::from_millis(500)).await;
-            if let Some(gpu_manager) = gpu_manager_clone2 {
-                match gpu_manager.send(GetForceComputeAddress).await {
-                    Ok(addr) => {
-                        graph_service_addr_clone2.do_send(StoreGPUComputeAddress { addr: Some(addr) });
-                        info!("[AppState] GPU compute actor connected successfully");
-                    }
-                    Err(e) => {
-                        warn!("[AppState] Failed to initialize GPU compute actor: {}", e);
-                    }
-                }
-            }
-        });
+        info!("[AppState] GPU manager will self-initialize when needed");
+
+        // Schedule GPU initialization to happen after actor system is ready
+        if let Some(ref gpu_manager) = gpu_manager_addr {
+            use crate::actors::messages::InitializeGPUConnection;
+            let init_msg = InitializeGPUConnection {
+                gpu_manager: Some(gpu_manager.clone()),
+            };
+            graph_service_addr.do_send(init_msg);
+            info!("[AppState] Sent GPU initialization message to GraphServiceActor");
+        }
 
         info!("[AppState::new] Actor system initialization complete");

diff --git a/src/actors/messages.rs b/src/actors/messages.rs
index 1234567..abcdefg 100644
--- a/src/actors/messages.rs
+++ b/src/actors/messages.rs
@@ -890,0 +891,10 @@ impl Message for StoreGPUComputeAddress {
+
+/// Message to initialize GPU connection after actor system is ready
+#[derive(Message, Clone)]
+#[rtype(result = "()")]
+pub struct InitializeGPUConnection {
+    pub gpu_manager: Option<Addr<GPUManagerActor>>,
+}

diff --git a/src/actors/graph_actor.rs b/src/actors/graph_actor.rs
index 1234567..abcdefg 100644
--- b/src/actors/graph_actor.rs
+++ b/src/actors/graph_actor.rs
@@ -2477,0 +2478,38 @@ impl Handler<StoreGPUComputeAddress> for GraphServiceActor {
+
+impl Handler<InitializeGPUConnection> for GraphServiceActor {
+    type Result = ();
+
+    fn handle(&mut self, msg: InitializeGPUConnection, ctx: &mut Self::Context) -> Self::Result {
+        info!("Initializing GPU connection after system startup");
+        
+        if let Some(gpu_manager) = msg.gpu_manager {
+            let gpu_manager_clone = gpu_manager.clone();
+            let self_addr = ctx.address();
+            
+            // Use the actor's context to spawn the async task
+            ctx.spawn(async move {
+                // Small delay to ensure GPU manager is ready
+                tokio::time::sleep(std::time::Duration::from_millis(100)).await;
+                
+                use crate::actors::messages::GetForceComputeAddress;
+                match gpu_manager_clone.send(GetForceComputeAddress).await {
+                    Ok(compute_addr) => {
+                        use crate::actors::messages::StoreGPUComputeAddress;
+                        self_addr.do_send(StoreGPUComputeAddress { 
+                            addr: Some(compute_addr) 
+                        });
+                        info!("GPU compute actor connected successfully through deferred initialization");
+                    }
+                    Err(e) => {
+                        error!("Failed to get GPU compute actor address: {}", e);
+                    }
+                }
+            }.into_actor(self).map(|_, _, _| {}));
+            
+            self.gpu_init_in_progress = true;
+            info!("GPU initialization scheduled");
+        } else {
+            warn!("No GPU manager provided for initialization");
+        }
+    }
+}