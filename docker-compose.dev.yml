services:
  neo4j:
    image: neo4j:5.13.0
    container_name: visionflow-neo4j
    environment:
      - NEO4J_AUTH=neo4j/visionflow-dev-password
      - NEO4J_server_memory_pagecache_size=512M
      - NEO4J_server_memory_heap_max__size=1G
      - NEO4J_dbms_security_procedures_unrestricted=apoc.*
      - NEO4J_dbms_security_procedures_allowlist=apoc.*
    ports:
      - "7474:7474"  # HTTP
      - "7687:7687"  # Bolt
    volumes:
      - neo4j-data:/data
      - neo4j-logs:/logs
      - neo4j-conf:/conf
      - neo4j-plugins:/plugins
    networks:
      - docker_ragflow
    healthcheck:
      test: ["CMD-SHELL", "wget --spider --quiet http://localhost:7474 || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  webxr:
    container_name: visionflow_container
    depends_on:
      neo4j:
        condition: service_healthy
    build:
      context: .
      dockerfile: Dockerfile.dev
      args:
        CUDA_ARCH: ${CUDA_ARCH:-86}
    volumes:
      # Fully baked image - ALL code and config inside container
      # Only internal Docker volumes for data persistence and caching
      - visionflow-data:/app/data  # Internal volume for databases and markdown
      - visionflow-logs:/app/logs  # Internal volume for application logs
      - /var/run/docker.sock:/var/run/docker.sock:ro # Docker socket for controlled access
      - npm-cache:/root/.npm
      - cargo-cache:/root/.cargo/registry
      - cargo-git-cache:/root/.cargo/git
      - cargo-target-cache:/app/target
    env_file:
      - .env
    environment:
      - NVIDIA_VISIBLE_DEVICES=0  # Use GPU 0 (RTX A6000)
      - CUDA_ARCH=${CUDA_ARCH:-86} # Pass CUDA architecture for runtime PTX compilation (86 for RTX A6000)
      # RUST_LOG is now inherited from the .env file via env_file directive
      - VITE_DEBUG=${DEBUG_ENABLED:-true} # Pass master debug switch to frontend
      - NODE_ENV=development
      - DOCKER_ENV=true # Tell Vite it's running in Docker, Nginx handles proxying
      - VITE_DEV_SERVER_PORT=5173 # Internal Vite port, accessed via Nginx
      - VITE_API_PORT=4000
      - VITE_HMR_PORT=24678 # Internal HMR port, accessed via Nginx
      - RUST_LOG_REDIRECT=true
      # Override the port from settings.yaml for development environment
      # Ensure Rust backend listens on 4000, which Vite proxies to.
      - SYSTEM_NETWORK_PORT=4000
      # Claude Flow MCP WebSocket configuration
      - CLAUDE_FLOW_HOST=multi-agent-container
      - CLAUDE_FLOW_PORT=3002
      # MCP Orchestrator configuration (optional - will use mock data if not available)
      - ORCHESTRATOR_WS_URL=ws://mcp-orchestrator:9001/ws
      - MCP_RELAY_FALLBACK_TO_MOCK=true
      # Set BOTS_ORCHESTRATOR_URL to non-existent to trigger mock data
      - BOTS_ORCHESTRATOR_URL=ws://multi-agent-container:3002
      # Neo4j Configuration
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USER=neo4j
      - NEO4J_PASSWORD=visionflow-dev-password
      - NEO4J_DATABASE=neo4j
    deploy: # Indentation: 4 spaces
      resources:
        reservations:
          devices:
            - driver: nvidia
              capabilities: [compute,utility]
              device_ids: ['0']
    ports: # Indentation: 4 spaces
      # Expose only Nginx port 3001 to the host.
      # Other services (Vite 5173, Rust 4000, HMR 24678) are accessed via Nginx proxy.
      - "3001:3001"  # Nginx entry point
    networks: # Indentation: 4 spaces
      - docker_ragflow

networks: # Indentation: 2 spaces
  docker_ragflow:
    external: true

volumes: # Indentation: 2 spaces
  visionflow-data:  # Persistent data volume (databases, markdown, metadata, user_settings)
  visionflow-logs:  # Log files volume
  npm-cache:
  cargo-cache:
  cargo-git-cache:
  cargo-target-cache:
  neo4j-data:  # Neo4j database files
  neo4j-logs:  # Neo4j log files
  neo4j-conf:  # Neo4j configuration
  neo4j-plugins:  # Neo4j plugins (APOC, etc)
