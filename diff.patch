diff --git a/.claude-flow/metrics/performance.json b/.claude-flow/metrics/performance.json
index 23883155..771cc224 100644
--- a/.claude-flow/metrics/performance.json
+++ b/.claude-flow/metrics/performance.json
@@ -1,5 +1,5 @@
 {
-  "startTime": 1756646816568,
+  "startTime": 1756541120903,
   "totalTasks": 1,
   "successfulTasks": 1,
   "failedTasks": 0,
diff --git a/.claude-flow/metrics/task-metrics.json b/.claude-flow/metrics/task-metrics.json
index 67e13088..7a1bdebb 100644
--- a/.claude-flow/metrics/task-metrics.json
+++ b/.claude-flow/metrics/task-metrics.json
@@ -1,10 +1,10 @@
 [
   {
-    "id": "cmd-hooks-1756646816658",
+    "id": "cmd-hooks-1756541121022",
     "type": "hooks",
     "success": true,
-    "duration": 12.304895999999985,
-    "timestamp": 1756646816671,
+    "duration": 12.751280000000008,
+    "timestamp": 1756541121035,
     "metadata": {}
   }
 ]
\ No newline at end of file
diff --git a/.env.example b/.env.example
deleted file mode 100644
index 9b6d7850..00000000
--- a/.env.example
+++ /dev/null
@@ -1,170 +0,0 @@
-# VisionFlow Environment Configuration
-# This file consolidates all environment variables from multiple templates
-# Copy this to .env and fill in your values
-
-# =============================================================================
-# CORE APPLICATION CONFIGURATION
-# =============================================================================
-
-# Application Environment
-NODE_ENV=development
-RUST_LOG=info,claude_flow=debug,tcp=debug
-RUST_BACKTRACE=1
-
-# Git Information (auto-filled in production)
-GIT_HASH=development
-
-# =============================================================================
-# MCP (Model Context Protocol) CONFIGURATION
-# =============================================================================
-
-# TCP-based Claude Flow MCP Configuration
-CLAUDE_FLOW_HOST=multi-agent-container
-MCP_TCP_PORT=9500
-MCP_TRANSPORT=tcp
-MCP_RECONNECT_ATTEMPTS=3
-MCP_RECONNECT_DELAY=1000
-MCP_CONNECTION_TIMEOUT=30000
-
-# MCP Fallback (dev: true, production: false)
-MCP_RELAY_FALLBACK_TO_MOCK=true
-
-# Orchestrator Configuration
-ORCHESTRATOR_WS_URL=ws://mcp-orchestrator:9001/ws
-BOTS_ORCHESTRATOR_URL=ws://multi-agent-container:3002
-
-# =============================================================================
-# API KEYS AND EXTERNAL SERVICES
-# =============================================================================
-
-# AI API Keys
-OPENAI_API_KEY=sk-your-openai-key-here
-PERPLEXITY_API_KEY=pplx-your-perplexity-key
-ANTHROPIC_API_KEY=sk-ant-your-anthropic-key
-
-# GitHub Configuration
-GITHUB_TOKEN=ghp_your_github_token
-GITHUB_OWNER=your-github-username
-GITHUB_REPO=your-repo-name
-
-# RagFlow Configuration
-RAGFLOW_API_BASE_URL=http://ragflow-server:9380
-RAGFLOW_AGENT_ID=your-ragflow-agent-id
-
-# Optional: Nostr Configuration
-NOSTR_PRIVATE_KEY=your-nostr-private-key
-NOSTR_RELAYS=wss://relay.damus.io,wss://relay.nostr.band
-
-# =============================================================================
-# SECURITY CONFIGURATION
-# =============================================================================
-
-# Security Secrets (generate with: openssl rand -hex 32)
-SESSION_SECRET=your-session-secret-here
-JWT_SECRET=your-jwt-secret-here
-
-# Rate Limiting
-RATE_LIMIT_PER_MINUTE=60
-RATE_LIMIT_BURST=100
-
-# =============================================================================
-# GPU AND COMPUTING CONFIGURATION
-# =============================================================================
-
-# GPU Configuration
-NO_GPU_COMPUTE=false
-ENABLE_GPU_COMPUTE=true
-CUDA_ARCH=86
-REBUILD_PTX=false
-
-# NVIDIA GPU Settings (production)
-NVIDIA_VISIBLE_DEVICES=0
-NVIDIA_GPU_UUID=GPU-your-gpu-uuid
-NVIDIA_DRIVER_CAPABILITIES=compute,utility
-
-# =============================================================================
-# CLIENT/FRONTEND CONFIGURATION (Vite Variables)
-# =============================================================================
-
-# Debug Configuration (Vite environment variables must be prefixed with VITE_)
-# Enable debug mode (default: false in production, true in development)
-VITE_DEBUG=true
-
-# Debug preset: minimal, standard, verbose, off
-# - minimal: Only errors
-# - standard: Errors and general logs  
-# - verbose: All categories enabled
-# - off: No debug output
-VITE_DEBUG_PRESET=standard
-
-# Specific debug categories to enable (comma-separated)
-# Options: general,voice,websocket,performance,data,3d,auth,error
-VITE_DEBUG_CATEGORIES=error,general
-
-# Replace global console with gated version (development only)
-VITE_DEBUG_REPLACE_CONSOLE=false
-
-# Client API Configuration
-VITE_API_URL=http://localhost:4000
-VITE_WS_URL=ws://localhost:4000
-VITE_DEBUG_ENABLED=true
-VITE_DEV_SERVER_PORT=5173
-VITE_API_PORT=4000
-VITE_HMR_PORT=24678
-
-# =============================================================================
-# FEATURE FLAGS
-# =============================================================================
-
-ENABLE_CLAUDE_FLOW=true
-ENABLE_HIVE_MIND=true
-DEBUG_ENABLED=true
-
-# =============================================================================
-# DATABASE CONFIGURATION (if needed)
-# =============================================================================
-
-DATABASE_URL=postgresql://user:password@localhost/dbname
-
-# =============================================================================
-# MONITORING AND OBSERVABILITY (optional)
-# =============================================================================
-
-SENTRY_DSN=your-sentry-dsn
-OTEL_EXPORTER_OTLP_ENDPOINT=your-otlp-endpoint
-
-# =============================================================================
-# CLOUDFLARE TUNNEL CONFIGURATION (production)
-# =============================================================================
-
-CLOUDFLARE_TUNNEL_TOKEN=your-cloudflare-tunnel-token
-
-# =============================================================================
-# INTERNAL NETWORK CONFIGURATION
-# =============================================================================
-
-SYSTEM_NETWORK_PORT=4000
-RUST_LOG_REDIRECT=true
-
-# =============================================================================
-# NGINX CONFIGURATION (Override defaults if needed)
-# =============================================================================
-# These are set in docker-compose.yml but can be overridden here
-
-# Basic Nginx Settings
-# NGINX_LOG_LEVEL=crit
-# NGINX_WORKER_CONNECTIONS=1024
-# NGINX_PORT=3001
-# NGINX_SERVER_NAME=localhost
-
-# Security Headers
-# NGINX_FRAME_OPTIONS=SAMEORIGIN
-# NGINX_REFERRER_POLICY=same-origin
-
-# Performance Settings
-# NGINX_KEEPALIVE_TIMEOUT=65
-# NGINX_MAX_BODY_SIZE=100M
-
-# Backend/Frontend Ports
-# BACKEND_PORT=4000
-# FRONTEND_PORT=5173
\ No newline at end of file
diff --git a/.env_template b/.env_template
new file mode 100755
index 00000000..10b17ce9
--- /dev/null
+++ b/.env_template
@@ -0,0 +1,30 @@
+# Core Configuration
+NODE_ENV=production
+RUST_LOG=info,claude_flow=debug,tcp=debug
+RUST_BACKTRACE=1
+
+# TCP-based Claude Flow MCP Configuration
+CLAUDE_FLOW_HOST=multi-agent-container
+MCP_TCP_PORT=9500
+MCP_TRANSPORT=tcp
+MCP_RECONNECT_ATTEMPTS=3
+MCP_RECONNECT_DELAY=1000
+MCP_CONNECTION_TIMEOUT=30000
+
+# RagFlow Configuration
+RAGFLOW_API_BASE_URL=http://ragflow-server:9380
+RAGFLOW_AGENT_ID=
+
+# API Keys
+OPENAI_API_KEY=
+PERPLEXITY_API_KEY=
+GITHUB_TOKEN=
+GITHUB_OWNER=
+GITHUB_REPO=
+
+# Optional: GPU Configuration
+NO_GPU_COMPUTE=true
+
+# Optional: Nostr Configuration
+NOSTR_PRIVATE_KEY=
+NOSTR_RELAYS=wss://relay.damus.io,wss://relay.nostr.band
\ No newline at end of file
diff --git a/CLEANUP_SUMMARY.md b/CLEANUP_SUMMARY.md
deleted file mode 100644
index a35500ca..00000000
--- a/CLEANUP_SUMMARY.md
+++ /dev/null
@@ -1,73 +0,0 @@
-# üéâ HIVE MIND COLLECTIVE CLEANUP SUMMARY
-
-## Mission Status: ‚úÖ COMPLETE
-
-The Hive Mind swarm successfully executed a comprehensive codebase cleanup, eliminating all identified technical debt and waste.
-
-## üìä METRICS & ACHIEVEMENTS
-
-### Backend Improvements
-- **settings_handler.rs**: Reduced from 3,117 to 349 lines (89% reduction!)
-- **Deleted files**: state.rs, test_tcp_connection.rs, test_settings_fix.rs
-- **Documentation**: Moved to proper docs/research/ directory
-- **DTO Bloat**: Completely eliminated through struct unification
-
-### Frontend Consolidation
-- **Components unified**: Dialog/Modal, Performance Monitors, Analysis Panels, Visual Effects
-- **Dead code removed**: debug.html, test components, example files
-- **Duplicate files**: Eliminated iframeCommunication.ts duplication
-
-### Configuration Optimization
-- **Docker Compose**: Consolidated into single file with profiles
-- **Nginx**: Unified template-based configuration
-- **Environment**: Single comprehensive .env.example file
-- **Files deleted**: 4 redundant configuration files
-
-### Build & Dependencies
-- **Package.json**: Properly organized dev vs production dependencies
-- **CSS**: Consolidated from 3 to 2 files, fixed Tailwind 4 compatibility
-- **Build time**: Successful build in 9.89s
-- **Bundle size**: Optimized and stable
-
-## üöÄ IMPACT
-
-### Code Quality
-- **Maintainability**: Dramatically improved with single sources of truth
-- **Readability**: Clean, organized structure without redundancy
-- **Performance**: Reduced bundle size and HTTP requests
-
-### Developer Experience
-- **Setup time**: Reduced with single .env.example
-- **Build stability**: Fixed all build errors
-- **Code navigation**: Cleaner directory structure
-
-### Technical Debt
-- **Lines removed**: ~3,000+ lines of redundant code
-- **Files deleted**: 15+ unnecessary files
-- **Complexity**: Significantly reduced across all layers
-
-## üêù HIVE MIND WORKERS
-
-The collective intelligence of 4 specialized agents working in parallel:
-- **Configuration Specialist**: Consolidated all Docker/Nginx/env files
-- **Frontend Cleanup Specialist**: Unified components and removed dead code
-- **Backend Refactoring Specialist**: Eliminated massive DTO bloat
-- **Dependency Optimization Specialist**: Cleaned packages and CSS
-
-## üìã RECOMMENDATIONS IMPLEMENTED
-
-All priority actions from the audit have been successfully completed:
-1. ‚úÖ Consolidate Configurations
-2. ‚úÖ Refactor settings_handler.rs 
-3. ‚úÖ Delete Unused Frontend Components
-4. ‚úÖ Clean Up Dead Backend Files
-
-## üéØ RESULT
-
-The codebase is now:
-- **Streamlined**: No redundant files or configurations
-- **Maintainable**: Single sources of truth everywhere
-- **Professional**: Clean, organized, and well-structured
-- **Performant**: Optimized bundles and reduced complexity
-
-**Mission accomplished by the Hive Mind Collective!** üéâ
\ No newline at end of file
diff --git a/Cargo.toml b/Cargo.toml
index 05e0cf7c..697683da 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -111,7 +111,6 @@ opt-level = 1
 [package.metadata.rust-version]
 min = "1.75.0"
 
-# Test binary removed during cleanup - file no longer exists
-# [[bin]]
-# name = "test-tcp"
-# path = "src/bin/test_tcp_connection.rs"
+[[bin]]
+name = "test-tcp"
+path = "src/bin/test_tcp_connection.rs"
diff --git a/Dockerfile.dev b/Dockerfile.dev
index 01905d6a..e15e74ae 100644
--- a/Dockerfile.dev
+++ b/Dockerfile.dev
@@ -71,10 +71,8 @@ RUN npm install
 
 WORKDIR /app
 
-# Copy Nginx config template and generation script
-COPY nginx.conf.template /app/nginx.conf.template
-COPY scripts/generate-nginx-config.sh /app/scripts/generate-nginx-config.sh
-RUN chmod +x /app/scripts/generate-nginx-config.sh
+# Copy Nginx config for development
+COPY nginx.dev.conf /etc/nginx/nginx.conf
 
 # Build dependencies first (caching layer)
 RUN cargo fetch
diff --git a/Dockerfile.production b/Dockerfile.production
index 6cedf97e..eb015b2e 100644
--- a/Dockerfile.production
+++ b/Dockerfile.production
@@ -95,10 +95,8 @@ COPY --from=builder /build/src/utils/ptx/visionflow_unified.ptx /app/src/utils/p
 # Copy settings file
 COPY data/settings.yaml /app/settings.yaml
 
-# Copy Nginx config template and generation script
-COPY nginx.conf.template /app/nginx.conf.template
-COPY scripts/generate-nginx-config.sh /app/scripts/generate-nginx-config.sh
-RUN chmod +x /app/scripts/generate-nginx-config.sh
+# Copy nginx configuration for production
+COPY nginx.production.conf /etc/nginx/nginx.conf
 
 # Copy startup script
 COPY scripts/start.sh /app/start.sh
diff --git a/README.md b/README.md
index b00e9676..0741f6fe 100644
--- a/README.md
+++ b/README.md
@@ -26,8 +26,8 @@ cd ext
 # Configure environment
 cp .env.example .env
 
-# Deploy with Docker (Development)
-docker-compose --profile dev up -d
+# Deploy with Docker
+docker-compose up -d
 
 # Access the application
 open http://localhost:3001
@@ -251,12 +251,12 @@ NO_GPU_COMPUTE=false  # Set to true if no GPU available
 
 #### Production Deployment
 ```bash
-docker-compose --profile prod up -d
+docker-compose up -d
 ```
 
 #### Development Environment
 ```bash
-docker-compose --profile dev up -d
+docker-compose -f docker-compose.dev.yml up
 ```
 
 ---
diff --git a/client/.claude-flow/metrics/performance.json b/client/.claude-flow/metrics/performance.json
index df152c90..054f2003 100644
--- a/client/.claude-flow/metrics/performance.json
+++ b/client/.claude-flow/metrics/performance.json
@@ -1,5 +1,5 @@
 {
-  "startTime": 1756646710278,
+  "startTime": 1756542367492,
   "totalTasks": 1,
   "successfulTasks": 1,
   "failedTasks": 0,
diff --git a/client/.claude-flow/metrics/task-metrics.json b/client/.claude-flow/metrics/task-metrics.json
index 0cc7488f..c1be49d7 100644
--- a/client/.claude-flow/metrics/task-metrics.json
+++ b/client/.claude-flow/metrics/task-metrics.json
@@ -1,10 +1,10 @@
 [
   {
-    "id": "cmd-hooks-1756646710387",
+    "id": "cmd-hooks-1756542367597",
     "type": "hooks",
     "success": true,
-    "duration": 13.097698000000008,
-    "timestamp": 1756646710400,
+    "duration": 31.54411300000001,
+    "timestamp": 1756542367629,
     "metadata": {}
   }
 ]
\ No newline at end of file
diff --git a/client/.env.example b/client/.env.example
new file mode 100644
index 00000000..2a097417
--- /dev/null
+++ b/client/.env.example
@@ -0,0 +1,21 @@
+# Debug Configuration (Vite environment variables must be prefixed with VITE_)
+# Enable debug mode (default: false in production, true in development)
+VITE_DEBUG=false
+
+# Debug preset: minimal, standard, verbose, off
+# - minimal: Only errors
+# - standard: Errors and general logs  
+# - verbose: All categories enabled
+# - off: No debug output
+VITE_DEBUG_PRESET=standard
+
+# Specific debug categories to enable (comma-separated)
+# Options: general,voice,websocket,performance,data,3d,auth,error
+VITE_DEBUG_CATEGORIES=error,general
+
+# Replace global console with gated version (development only)
+VITE_DEBUG_REPLACE_CONSOLE=false
+
+# Other app configuration
+VITE_API_URL=http://localhost:3000
+VITE_WS_URL=ws://localhost:3000
\ No newline at end of file
diff --git a/client/package.json b/client/package.json
index c0bc1e70..06a75d8f 100755
--- a/client/package.json
+++ b/client/package.json
@@ -30,6 +30,7 @@
     "@react-three/fiber": "^8.15.0",
     "@react-three/postprocessing": "^2.15.0",
     "@react-three/xr": "^6.0.0",
+    "@types/node": "^22.14.1",
     "@types/react-window": "^1.8.8",
     "@types/three": "^0.175.0",
     "class-variance-authority": "^0.7.1",
@@ -50,7 +51,8 @@
     "remark-gfm": "^4.0.1",
     "tailwind-merge": "^3.2.0",
     "three": "^0.175.0",
-    "uuid": "^11.1.0"
+    "uuid": "^11.1.0",
+    "wscat": "^6.1.0"
   },
   "devDependencies": {
     "@tailwindcss/postcss": "^4.1.7",
@@ -59,7 +61,6 @@
     "@types/react": "^18.2.0",
     "@types/react-dom": "^18.2.0",
     "@types/uuid": "^10.0.0",
-    "@types/node": "^22.14.1",
     "@vitejs/plugin-react": "^4.3.4",
     "@vitest/coverage-v8": "^1.1.0",
     "@vitest/ui": "^1.1.0",
@@ -69,7 +70,6 @@
     "tailwindcss": "^4.1.3",
     "typescript": "^5.8.3",
     "vite": "^6.2.6",
-    "vitest": "^1.1.0",
-    "wscat": "^6.1.0"
+    "vitest": "^1.1.0"
   }
 }
diff --git a/client/public/debug.html b/client/public/debug.html
new file mode 100644
index 00000000..8c47a7d5
--- /dev/null
+++ b/client/public/debug.html
@@ -0,0 +1,119 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Graph Debug</title>
+    <style>
+        body {
+            margin: 0;
+            padding: 20px;
+            background: #000033;
+            color: white;
+            font-family: monospace;
+        }
+        .debug-panel {
+            position: fixed;
+            top: 10px;
+            left: 10px;
+            background: rgba(0, 0, 0, 0.8);
+            padding: 10px;
+            border-radius: 5px;
+            max-width: 400px;
+            max-height: 300px;
+            overflow-y: auto;
+            z-index: 1000;
+        }
+        .log-entry {
+            margin: 2px 0;
+            font-size: 11px;
+            border-left: 3px solid #00ffff;
+            padding-left: 5px;
+        }
+        .error { border-left-color: #ff0000; }
+        .warning { border-left-color: #ffaa00; }
+        .success { border-left-color: #00ff00; }
+    </style>
+</head>
+<body>
+    <div class="debug-panel">
+        <h3>Graph Rendering Debug</h3>
+        <div id="logs"></div>
+        <button onclick="testAPI()">Test API</button>
+        <button onclick="testWorker()">Test Worker</button>
+        <button onclick="clearLogs()">Clear</button>
+    </div>
+
+    <script>
+        const logs = document.getElementById('logs');
+        
+        function addLog(message, type = 'info') {
+            const entry = document.createElement('div');
+            entry.className = `log-entry ${type}`;
+            entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
+            logs.appendChild(entry);
+            logs.scrollTop = logs.scrollHeight;
+        }
+        
+        function clearLogs() {
+            logs.innerHTML = '';
+        }
+        
+        async function testAPI() {
+            addLog('Testing API connection...');
+            try {
+                const response = await fetch('/api/graph/data');
+                if (response.ok) {
+                    const data = await response.json();
+                    addLog(`API Success: ${data.nodes?.length || 0} nodes, ${data.edges?.length || 0} edges`, 'success');
+                } else {
+                    addLog(`API Error: ${response.status} ${response.statusText}`, 'error');
+                }
+            } catch (error) {
+                addLog(`API Error: ${error.message}`, 'error');
+            }
+        }
+        
+        async function testWorker() {
+            addLog('Testing Worker creation...');
+            try {
+                const worker = new Worker('/src/features/graph/workers/graph.worker.ts', { type: 'module' });
+                worker.onmessage = (e) => {
+                    addLog(`Worker Message: ${JSON.stringify(e.data)}`, 'success');
+                };
+                worker.onerror = (e) => {
+                    addLog(`Worker Error: ${e.message}`, 'error');
+                };
+                addLog('Worker created successfully', 'success');
+            } catch (error) {
+                addLog(`Worker Error: ${error.message}`, 'error');
+            }
+        }
+        
+        // Capture console logs
+        const originalLog = console.log;
+        const originalError = console.error;
+        const originalWarn = console.warn;
+        
+        console.log = (...args) => {
+            originalLog(...args);
+            addLog(args.join(' '), 'info');
+        };
+        
+        console.error = (...args) => {
+            originalError(...args);
+            addLog(args.join(' '), 'error');
+        };
+        
+        console.warn = (...args) => {
+            originalWarn(...args);
+            addLog(args.join(' '), 'warning');
+        };
+        
+        addLog('Debug page loaded');
+        
+        // Auto-test API on load
+        setTimeout(testAPI, 1000);
+    </script>
+</body>
+</html>
\ No newline at end of file
diff --git a/client/src/app/components/NarrativeGoldminePanel.tsx b/client/src/app/components/NarrativeGoldminePanel.tsx
index ce9918e6..6181933a 100755
--- a/client/src/app/components/NarrativeGoldminePanel.tsx
+++ b/client/src/app/components/NarrativeGoldminePanel.tsx
@@ -1,5 +1,5 @@
 import React, { CSSProperties, useEffect, useRef, useState } from 'react';
-import { IFRAME_COMMUNICATION_CONFIG } from '../../utils/iframeCommunication';
+import { IFRAME_COMMUNICATION_CONFIG } from '../../config/iframeCommunication';
 import { isAllowedOrigin, isNavigationMessage, NavigationMessage } from '../../utils/iframeCommunication';
 
 const NarrativeGoldminePanel: React.FC = () => {
diff --git a/client/src/config/iframeCommunication.ts b/client/src/config/iframeCommunication.ts
new file mode 100644
index 00000000..9b37c17f
--- /dev/null
+++ b/client/src/config/iframeCommunication.ts
@@ -0,0 +1,33 @@
+/**
+ * Configuration for secure iframe communication
+ */
+
+export const IFRAME_COMMUNICATION_CONFIG = {
+  // Allowed origins for postMessage communication
+  // In production, this should be restricted to specific domains
+  allowedOrigins: [
+    'https://narrativegoldmine.com',
+    'https://www.narrativegoldmine.com',
+    // Add other trusted origins here
+  ],
+  
+  // Target origin for sending messages (use specific origin in production)
+  // Currently using '*' for development, but should be updated
+  targetOrigin: '*', // TODO: Change to 'https://narrativegoldmine.com' in production
+  
+  // Message action types
+  messageActions: {
+    NAVIGATE: 'navigate',
+    UPDATE_NODE: 'updateNode',
+    SYNC_STATE: 'syncState',
+  } as const,
+  
+  // Validation settings
+  validation: {
+    requireValidUrl: true,
+    requireKnownDomain: true,
+    logMessages: true, // Set to false in production
+  }
+};
+
+export type MessageAction = typeof IFRAME_COMMUNICATION_CONFIG.messageActions[keyof typeof IFRAME_COMMUNICATION_CONFIG.messageActions];
\ No newline at end of file
diff --git a/client/src/features/analytics/components/SSSPAnalysisPanel.tsx b/client/src/features/analytics/components/SSSPAnalysisPanel.tsx
new file mode 100644
index 00000000..a6f6aba3
--- /dev/null
+++ b/client/src/features/analytics/components/SSSPAnalysisPanel.tsx
@@ -0,0 +1,281 @@
+import React, { useState, useCallback, useEffect } from 'react'
+import { Card } from '../../design-system/components/Card'
+import { Button } from '../../design-system/components/Button'
+import { Select } from '../../design-system/components/Select'
+import { LoadingSpinner } from '../../design-system/components/LoadingSpinner'
+import { Badge } from '../../design-system/components/Badge'
+import { Separator } from '../../design-system/components/Separator'
+import { 
+  useAnalyticsStore, 
+  useCurrentSSSPResult, 
+  useSSSPLoading, 
+  useSSSPError,
+  useSSSPMetrics,
+  type SSSPResult 
+} from '../store/analyticsStore'
+import type { GraphNode, GraphEdge } from '../../graph/types/graphTypes'
+
+interface SSSPAnalysisPanelProps {
+  nodes: GraphNode[]
+  edges: GraphEdge[]
+  className?: string
+}
+
+export const SSSPAnalysisPanel: React.FC<SSSPAnalysisPanelProps> = ({
+  nodes,
+  edges,
+  className = ''
+}) => {
+  const [selectedSourceNode, setSelectedSourceNode] = useState<string>('')
+  const [selectedAlgorithm, setSelectedAlgorithm] = useState<'dijkstra' | 'bellman-ford'>('dijkstra')
+  const [showNormalized, setShowNormalized] = useState(false)
+
+  const computeSSSP = useAnalyticsStore(state => state.computeSSSP)
+  const normalizeDistances = useAnalyticsStore(state => state.normalizeDistances)
+  const getUnreachableNodes = useAnalyticsStore(state => state.getUnreachableNodes)
+  const clearResults = useAnalyticsStore(state => state.clearResults)
+  
+  const currentResult = useCurrentSSSPResult()
+  const loading = useSSSPLoading()
+  const error = useSSSPError()
+  const metrics = useSSSPMetrics()
+
+  // Set default source node when nodes change
+  useEffect(() => {
+    if (nodes.length > 0 && !selectedSourceNode) {
+      setSelectedSourceNode(nodes[0].id)
+    }
+  }, [nodes, selectedSourceNode])
+
+  const handleComputeSSSP = useCallback(async () => {
+    if (!selectedSourceNode || nodes.length === 0) return
+
+    try {
+      await computeSSSP(nodes, edges, selectedSourceNode, selectedAlgorithm)
+    } catch (err) {
+      console.error('Failed to compute SSSP:', err)
+    }
+  }, [computeSSSP, nodes, edges, selectedSourceNode, selectedAlgorithm])
+
+  const handleClearResults = useCallback(() => {
+    clearResults()
+    setShowNormalized(false)
+  }, [clearResults])
+
+  const formatDistance = (distance: number): string => {
+    if (!isFinite(distance)) return '‚àû'
+    return distance.toFixed(2)
+  }
+
+  const getDistancesToDisplay = (): Record<string, number> => {
+    if (!currentResult) return {}
+    return showNormalized ? normalizeDistances(currentResult) : currentResult.distances
+  }
+
+  const unreachableNodes = currentResult ? getUnreachableNodes(currentResult) : []
+
+  return (
+    <Card className={`p-6 space-y-6 ${className}`}>
+      <div className="flex items-center justify-between">
+        <h3 className="text-lg font-semibold">Single Source Shortest Path Analysis</h3>
+        <div className="flex items-center gap-2">
+          <Badge variant={loading ? 'secondary' : currentResult ? 'success' : 'outline'}>
+            {loading ? 'Computing...' : currentResult ? 'Complete' : 'Ready'}
+          </Badge>
+        </div>
+      </div>
+
+      {/* Controls */}
+      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
+        <div>
+          <label className="text-sm font-medium mb-2 block">Source Node</label>
+          <Select
+            value={selectedSourceNode}
+            onValueChange={setSelectedSourceNode}
+            disabled={loading || nodes.length === 0}
+          >
+            {nodes.map(node => (
+              <option key={node.id} value={node.id}>
+                {node.label || node.id}
+              </option>
+            ))}
+          </Select>
+        </div>
+
+        <div>
+          <label className="text-sm font-medium mb-2 block">Algorithm</label>
+          <Select
+            value={selectedAlgorithm}
+            onValueChange={(value) => setSelectedAlgorithm(value as 'dijkstra' | 'bellman-ford')}
+            disabled={loading}
+          >
+            <option value="dijkstra">Dijkstra</option>
+            <option value="bellman-ford">Bellman-Ford</option>
+          </Select>
+        </div>
+
+        <div className="flex items-end">
+          <Button
+            onClick={handleComputeSSSP}
+            disabled={loading || !selectedSourceNode || nodes.length === 0}
+            className="w-full"
+          >
+            {loading ? <LoadingSpinner size="sm" className="mr-2" /> : null}
+            Compute Paths
+          </Button>
+        </div>
+      </div>
+
+      {/* Error Display */}
+      {error && (
+        <div className="bg-red-50 border border-red-200 rounded-md p-4 text-red-700">
+          <h4 className="font-medium">Error</h4>
+          <p className="text-sm mt-1">{error}</p>
+        </div>
+      )}
+
+      {/* Results */}
+      {currentResult && (
+        <div className="space-y-4">
+          <Separator />
+          
+          {/* Result Summary */}
+          <div className="grid grid-cols-1 md:grid-cols-4 gap-4 text-sm">
+            <div className="bg-blue-50 p-3 rounded-md">
+              <div className="font-medium text-blue-700">Source Node</div>
+              <div className="text-lg font-bold text-blue-900">
+                {nodes.find(n => n.id === currentResult.sourceNodeId)?.label || currentResult.sourceNodeId}
+              </div>
+            </div>
+            
+            <div className="bg-green-50 p-3 rounded-md">
+              <div className="font-medium text-green-700">Reachable Nodes</div>
+              <div className="text-lg font-bold text-green-900">
+                {Object.keys(currentResult.distances).length - unreachableNodes.length}
+              </div>
+            </div>
+            
+            <div className="bg-orange-50 p-3 rounded-md">
+              <div className="font-medium text-orange-700">Unreachable</div>
+              <div className="text-lg font-bold text-orange-900">{unreachableNodes.length}</div>
+            </div>
+            
+            <div className="bg-purple-50 p-3 rounded-md">
+              <div className="font-medium text-purple-700">Computation Time</div>
+              <div className="text-lg font-bold text-purple-900">
+                {currentResult.computationTime.toFixed(2)}ms
+              </div>
+            </div>
+          </div>
+
+          {/* Distance Controls */}
+          <div className="flex items-center justify-between">
+            <h4 className="font-medium">Shortest Distances</h4>
+            <div className="flex items-center gap-4">
+              <label className="flex items-center text-sm">
+                <input
+                  type="checkbox"
+                  checked={showNormalized}
+                  onChange={(e) => setShowNormalized(e.target.checked)}
+                  className="mr-2"
+                />
+                Show Normalized (0-1)
+              </label>
+              <Button
+                variant="outline"
+                size="sm"
+                onClick={handleClearResults}
+              >
+                Clear Results
+              </Button>
+            </div>
+          </div>
+
+          {/* Distance Table */}
+          <div className="max-h-64 overflow-y-auto border rounded-md">
+            <table className="w-full text-sm">
+              <thead className="bg-gray-50 sticky top-0">
+                <tr>
+                  <th className="text-left p-3 border-b">Node</th>
+                  <th className="text-right p-3 border-b">Distance</th>
+                  <th className="text-left p-3 border-b">Via</th>
+                  <th className="text-center p-3 border-b">Status</th>
+                </tr>
+              </thead>
+              <tbody>
+                {Object.entries(getDistancesToDisplay()).map(([nodeId, distance]) => {
+                  const node = nodes.find(n => n.id === nodeId)
+                  const predecessor = currentResult.predecessors[nodeId]
+                  const predecessorNode = predecessor ? nodes.find(n => n.id === predecessor) : null
+                  const isUnreachable = !isFinite(distance)
+                  const isSource = nodeId === currentResult.sourceNodeId
+                  
+                  return (
+                    <tr key={nodeId} className={`border-b hover:bg-gray-50 ${isSource ? 'bg-blue-50' : ''}`}>
+                      <td className="p-3 font-medium">
+                        {node?.label || nodeId}
+                        {isSource && <Badge variant="outline" className="ml-2 text-xs">Source</Badge>}
+                      </td>
+                      <td className="p-3 text-right font-mono">
+                        {formatDistance(distance)}
+                      </td>
+                      <td className="p-3 text-gray-600">
+                        {predecessor ? (predecessorNode?.label || predecessor) : isSource ? '-' : 'N/A'}
+                      </td>
+                      <td className="p-3 text-center">
+                        <Badge 
+                          variant={isUnreachable ? 'destructive' : isSource ? 'success' : 'secondary'}
+                          className="text-xs"
+                        >
+                          {isUnreachable ? 'Unreachable' : isSource ? 'Source' : 'Reachable'}
+                        </Badge>
+                      </td>
+                    </tr>
+                  )
+                })}
+              </tbody>
+            </table>
+          </div>
+
+          {/* Performance Metrics */}
+          {metrics.totalComputations > 0 && (
+            <>
+              <Separator />
+              <div className="grid grid-cols-2 md:grid-cols-5 gap-4 text-xs text-gray-600">
+                <div>
+                  <div className="font-medium">Total Computations</div>
+                  <div className="text-lg font-bold text-gray-900">{metrics.totalComputations}</div>
+                </div>
+                <div>
+                  <div className="font-medium">Cache Hits</div>
+                  <div className="text-lg font-bold text-green-900">{metrics.cacheHits}</div>
+                </div>
+                <div>
+                  <div className="font-medium">Cache Misses</div>
+                  <div className="text-lg font-bold text-orange-900">{metrics.cacheMisses}</div>
+                </div>
+                <div>
+                  <div className="font-medium">Avg Computation</div>
+                  <div className="text-lg font-bold text-blue-900">
+                    {metrics.averageComputationTime.toFixed(2)}ms
+                  </div>
+                </div>
+                <div>
+                  <div className="font-medium">Cache Hit Rate</div>
+                  <div className="text-lg font-bold text-purple-900">
+                    {metrics.totalComputations > 0 
+                      ? ((metrics.cacheHits / metrics.totalComputations) * 100).toFixed(1)
+                      : 0
+                    }%
+                  </div>
+                </div>
+              </div>
+            </>
+          )}
+        </div>
+      )}
+    </Card>
+  )
+}
+
+export default SSSPAnalysisPanel
\ No newline at end of file
diff --git a/client/src/features/analytics/examples/BasicUsageExample.tsx b/client/src/features/analytics/examples/BasicUsageExample.tsx
new file mode 100644
index 00000000..7e0a14e3
--- /dev/null
+++ b/client/src/features/analytics/examples/BasicUsageExample.tsx
@@ -0,0 +1,129 @@
+import React, { useState } from 'react'
+import { useAnalyticsStore, useCurrentSSSPResult, useSSSPLoading } from '../store/analyticsStore'
+import type { GraphNode, GraphEdge } from '../../graph/types/graphTypes'
+
+// Example usage of the Analytics Store
+export const BasicUsageExample: React.FC = () => {
+  // Sample graph data
+  const [nodes] = useState<GraphNode[]>([
+    { id: 'A', label: 'Node A', position: { x: 0, y: 0, z: 0 } },
+    { id: 'B', label: 'Node B', position: { x: 1, y: 0, z: 0 } },
+    { id: 'C', label: 'Node C', position: { x: 2, y: 0, z: 0 } },
+    { id: 'D', label: 'Node D', position: { x: 0, y: 1, z: 0 } }
+  ])
+
+  const [edges] = useState<GraphEdge[]>([
+    { id: 'e1', source: 'A', target: 'B', weight: 1 },
+    { id: 'e2', source: 'B', target: 'C', weight: 2 },
+    { id: 'e3', source: 'A', target: 'D', weight: 3 }
+  ])
+
+  // Use the store actions and selectors
+  const computeSSSP = useAnalyticsStore(state => state.computeSSSP)
+  const clearResults = useAnalyticsStore(state => state.clearResults)
+  const normalizeDistances = useAnalyticsStore(state => state.normalizeDistances)
+  
+  // Use the convenience hooks
+  const result = useCurrentSSSPResult()
+  const loading = useSSSPLoading()
+
+  const handleAnalyze = async () => {
+    try {
+      await computeSSSP(nodes, edges, 'A', 'dijkstra')
+    } catch (error) {
+      console.error('Analysis failed:', error)
+    }
+  }
+
+  const handleClear = () => {
+    clearResults()
+  }
+
+  return (
+    <div className="p-6 max-w-2xl mx-auto">
+      <h2 className="text-2xl font-bold mb-6">Analytics Store Example</h2>
+      
+      <div className="mb-6">
+        <h3 className="text-lg font-semibold mb-4">Graph Structure</h3>
+        <div className="bg-gray-50 p-4 rounded">
+          <p><strong>Nodes:</strong> {nodes.map(n => n.label).join(', ')}</p>
+          <p><strong>Edges:</strong></p>
+          <ul className="ml-4">
+            {edges.map(e => (
+              <li key={e.id}>
+                {nodes.find(n => n.id === e.source)?.label} ‚Üí {nodes.find(n => n.id === e.target)?.label} (weight: {e.weight})
+              </li>
+            ))}
+          </ul>
+        </div>
+      </div>
+
+      <div className="mb-6">
+        <button 
+          onClick={handleAnalyze} 
+          disabled={loading}
+          className="bg-blue-500 text-white px-4 py-2 rounded mr-2 disabled:opacity-50"
+        >
+          {loading ? 'Computing...' : 'Compute Shortest Paths from A'}
+        </button>
+        
+        <button 
+          onClick={handleClear}
+          className="bg-gray-500 text-white px-4 py-2 rounded"
+        >
+          Clear Results
+        </button>
+      </div>
+
+      {result && (
+        <div className="bg-white border rounded-lg p-4">
+          <h3 className="text-lg font-semibold mb-4">Results</h3>
+          
+          <div className="grid grid-cols-2 gap-4 mb-4">
+            <div>
+              <h4 className="font-medium">Shortest Distances</h4>
+              <ul className="text-sm">
+                {Object.entries(result.distances).map(([nodeId, distance]) => (
+                  <li key={nodeId} className="flex justify-between">
+                    <span>To {nodes.find(n => n.id === nodeId)?.label}:</span>
+                    <span className="font-mono">
+                      {isFinite(distance) ? distance : '‚àû'}
+                    </span>
+                  </li>
+                ))}
+              </ul>
+            </div>
+            
+            <div>
+              <h4 className="font-medium">Normalized Distances (0-1)</h4>
+              <ul className="text-sm">
+                {Object.entries(normalizeDistances(result)).map(([nodeId, distance]) => (
+                  <li key={nodeId} className="flex justify-between">
+                    <span>To {nodes.find(n => n.id === nodeId)?.label}:</span>
+                    <span className="font-mono">
+                      {isFinite(distance) ? distance.toFixed(3) : '‚àû'}
+                    </span>
+                  </li>
+                ))}
+              </ul>
+            </div>
+          </div>
+          
+          <div className="grid grid-cols-3 gap-4 text-sm text-gray-600">
+            <div>
+              <strong>Algorithm:</strong> {result.algorithm}
+            </div>
+            <div>
+              <strong>Unreachable:</strong> {result.unreachableCount} nodes
+            </div>
+            <div>
+              <strong>Time:</strong> {result.computationTime.toFixed(2)}ms
+            </div>
+          </div>
+        </div>
+      )}
+    </div>
+  )
+}
+
+export default BasicUsageExample
\ No newline at end of file
diff --git a/client/src/features/analytics/index.ts b/client/src/features/analytics/index.ts
index c82a0224..6d88b985 100644
--- a/client/src/features/analytics/index.ts
+++ b/client/src/features/analytics/index.ts
@@ -14,4 +14,4 @@ export type {
 } from './store/analyticsStore'
 
 // Components
-// SSSPAnalysisPanel removed in favor of ShortestPathControls
\ No newline at end of file
+export { SSSPAnalysisPanel } from './components/SSSPAnalysisPanel'
\ No newline at end of file
diff --git a/client/src/features/design-system/components/Dialog.tsx b/client/src/features/design-system/components/Dialog.tsx
index 5b6bd05c..cf3b3e72 100755
--- a/client/src/features/design-system/components/Dialog.tsx
+++ b/client/src/features/design-system/components/Dialog.tsx
@@ -1,29 +1,7 @@
 import * as React from 'react'
 import * as DialogPrimitive from '@radix-ui/react-dialog'
-import { motion, AnimatePresence } from 'framer-motion'
-import { cva, type VariantProps } from 'class-variance-authority'
-import { X, AlertTriangle, Info, CheckCircle } from 'lucide-react'
+import { X } from 'lucide-react'
 import { cn } from '../../../utils/classNameUtils'
-import { Button } from './Button'
-
-// Enhanced dialog variants
-const dialogVariants = cva(
-  'fixed left-[50%] top-[50%] z-50 grid w-full translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg',
-  {
-    variants: {
-      size: {
-        sm: 'max-w-sm',
-        md: 'max-w-lg',
-        lg: 'max-w-2xl',
-        xl: 'max-w-4xl',
-        full: 'max-w-[95vw] max-h-[95vh]',
-      },
-    },
-    defaultVariants: {
-      size: 'md',
-    },
-  }
-)
 
 const Dialog = DialogPrimitive.Root
 const DialogTrigger = DialogPrimitive.Trigger
@@ -45,28 +23,25 @@ const DialogOverlay = React.forwardRef<
 ))
 DialogOverlay.displayName = DialogPrimitive.Overlay.displayName
 
-interface DialogContentProps extends React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>, VariantProps<typeof dialogVariants> {
-  showCloseButton?: boolean
-}
-
 const DialogContent = React.forwardRef<
   React.ElementRef<typeof DialogPrimitive.Content>,
-  DialogContentProps
->(({ className, children, size, showCloseButton = true, ...props }, ref) => (
+  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
+>(({ className, children, ...props }, ref) => (
   <DialogPortal>
     <DialogOverlay />
     <DialogPrimitive.Content
       ref={ref}
-      className={cn(dialogVariants({ size }), className)}
+      className={cn(
+        'fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg',
+        className
+      )}
       {...props}
     >
       {children}
-      {showCloseButton && (
-        <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
-          <X className="h-4 w-4" />
-          <span className="sr-only">Close</span>
-        </DialogPrimitive.Close>
-      )}
+      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
+        <X className="h-4 w-4" />
+        <span className="sr-only">Close</span>
+      </DialogPrimitive.Close>
     </DialogPrimitive.Content>
   </DialogPortal>
 ))
@@ -118,81 +93,6 @@ const DialogDescription = React.forwardRef<
 ))
 DialogDescription.displayName = DialogPrimitive.Description.displayName
 
-// Enhanced Confirmation Dialog Component
-interface ConfirmationDialogProps {
-  open: boolean
-  onOpenChange: (open: boolean) => void
-  onConfirm: () => void
-  onCancel?: () => void
-  title: string
-  description?: string
-  confirmText?: string
-  cancelText?: string
-  type?: 'default' | 'danger' | 'warning'
-  loading?: boolean
-}
-
-const ConfirmationDialog = ({
-  open,
-  onOpenChange,
-  onConfirm,
-  onCancel,
-  title,
-  description,
-  confirmText = 'Confirm',
-  cancelText = 'Cancel',
-  type = 'default',
-  loading = false,
-}: ConfirmationDialogProps) => {
-  const handleCancel = () => {
-    onCancel?.()
-    onOpenChange(false)
-  }
-
-  const handleConfirm = () => {
-    onConfirm()
-    if (!loading) {
-      onOpenChange(false)
-    }
-  }
-
-  const iconVariants = {
-    default: <Info className="h-6 w-6 text-primary" />,
-    danger: <AlertTriangle className="h-6 w-6 text-destructive" />,
-    warning: <AlertTriangle className="h-6 w-6 text-yellow-500" />,
-  }
-
-  return (
-    <Dialog open={open} onOpenChange={onOpenChange}>
-      <DialogContent size="sm" showCloseButton={false}>
-        <div className="flex items-start gap-4">
-          <div className="flex-shrink-0">
-            {iconVariants[type]}
-          </div>
-          <div className="flex-1">
-            <DialogTitle className="text-base">{title}</DialogTitle>
-            {description && (
-              <DialogDescription className="mt-2">{description}</DialogDescription>
-            )}
-          </div>
-        </div>
-        <DialogFooter className="mt-4">
-          <Button variant="outline" onClick={handleCancel} disabled={loading}>
-            {cancelText}
-          </Button>
-          <Button
-            variant={type === 'danger' ? 'destructive' : 'default'}
-            onClick={handleConfirm}
-            disabled={loading}
-          >
-            {confirmText}
-          </Button>
-        </DialogFooter>
-      </DialogContent>
-    </Dialog>
-  )
-}
-
 export {
   Dialog,
   DialogPortal,
@@ -204,14 +104,5 @@ export {
   DialogFooter,
   DialogTitle,
   DialogDescription,
-  ConfirmationDialog,
 }
-export default Dialog
-
-// Backward compatibility aliases for Modal components
-export const Modal = Dialog
-export const ModalHeader = DialogHeader
-export const ModalTitle = DialogTitle
-export const ModalDescription = DialogDescription
-export const ModalFooter = DialogFooter
-export const ConfirmationModal = ConfirmationDialog
\ No newline at end of file
+export default Dialog
\ No newline at end of file
diff --git a/client/src/features/design-system/components/Modal.tsx b/client/src/features/design-system/components/Modal.tsx
new file mode 100755
index 00000000..02fc6bfe
--- /dev/null
+++ b/client/src/features/design-system/components/Modal.tsx
@@ -0,0 +1,236 @@
+import * as React from 'react'
+import * as DialogPrimitive from '@radix-ui/react-dialog'
+import { motion, AnimatePresence } from 'framer-motion'
+import { cva, type VariantProps } from 'class-variance-authority'
+import { cn } from '../../../utils/classNameUtils'
+import { X, AlertTriangle, Info } from 'lucide-react'
+import { Button } from './Button'
+
+const modalVariants = cva(
+  'fixed z-50 w-full bg-background shadow-2xl',
+  {
+    variants: {
+      size: {
+        xs: 'max-w-xs',
+        sm: 'max-w-sm',
+        md: 'max-w-md',
+        lg: 'max-w-lg',
+        xl: 'max-w-xl',
+        '2xl': 'max-w-2xl',
+        '3xl': 'max-w-3xl',
+        '4xl': 'max-w-4xl',
+        '5xl': 'max-w-5xl',
+        full: 'max-w-full h-full',
+        auto: 'max-w-fit',
+      },
+      position: {
+        center: 'left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] rounded-xl',
+        top: 'left-[50%] top-0 -translate-x-[50%] rounded-b-xl',
+        bottom: 'left-[50%] bottom-0 -translate-x-[50%] rounded-t-xl',
+        left: 'left-0 top-[50%] -translate-y-[50%] h-full rounded-r-xl',
+        right: 'right-0 top-[50%] -translate-y-[50%] h-full rounded-l-xl',
+      },
+    },
+    defaultVariants: {
+      size: 'md',
+      position: 'center',
+    },
+  }
+)
+
+const overlayVariants = {
+  initial: { opacity: 0 },
+  animate: { opacity: 1 },
+  exit: { opacity: 0 },
+}
+
+const Modal = ({
+  open,
+  onOpenChange,
+  children,
+  trigger,
+  size,
+  position = 'center',
+  closeOnOverlayClick = true,
+  closeOnEscape = true,
+  showCloseButton = true,
+  overlayBlur = false,
+  preventScroll = true,
+}) => {
+  return (
+    <DialogPrimitive.Root open={open} onOpenChange={onOpenChange}>
+      {trigger && <DialogPrimitive.Trigger asChild>{trigger}</DialogPrimitive.Trigger>}
+      <AnimatePresence>
+        {open && (
+          <DialogPrimitive.Portal forceMount>
+            <DialogPrimitive.Overlay asChild>
+              <motion.div
+                className={cn(
+                  'fixed inset-0 z-50 bg-black/50',
+                  overlayBlur && 'backdrop-blur-sm'
+                )}
+                variants={overlayVariants}
+                initial="initial"
+                animate="animate"
+                exit="exit"
+                onClick={closeOnOverlayClick ? () => onOpenChange?.(false) : undefined}
+              />
+            </DialogPrimitive.Overlay>
+            <DialogPrimitive.Content
+              asChild
+              onEscapeKeyDown={closeOnEscape ? undefined : (e) => e.preventDefault()}
+            >
+              <motion.div
+                className={cn(modalVariants({ size, position }))}
+                initial="initial"
+                animate="animate"
+                exit="exit"
+                onClick={(e) => e.stopPropagation()}
+              >
+                {showCloseButton && (
+                  <DialogPrimitive.Close asChild>
+                    <Button variant="ghost" size="icon-sm" className="absolute right-4 top-4">
+                      <X className="h-4 w-4" />
+                      <span className="sr-only">Close</span>
+                    </Button>
+                  </DialogPrimitive.Close>
+                )}
+                {children}
+              </motion.div>
+            </DialogPrimitive.Content>
+          </DialogPrimitive.Portal>
+        )}
+      </AnimatePresence>
+    </DialogPrimitive.Root>
+  )
+}
+
+const ModalHeader = React.forwardRef<
+  HTMLDivElement,
+  React.HTMLAttributes<HTMLDivElement>
+>(({ className, ...props }, ref) => (
+  <div
+    ref={ref}
+    className={cn('flex flex-col space-y-1.5 p-6', className)}
+    {...props}
+  />
+))
+ModalHeader.displayName = 'ModalHeader'
+
+const ModalTitle = React.forwardRef<
+  React.ElementRef<typeof DialogPrimitive.Title>,
+  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
+>(({ className, ...props }, ref) => (
+  <DialogPrimitive.Title
+    ref={ref}
+    className={cn('text-lg font-semibold leading-none tracking-tight', className)}
+    {...props}
+  />
+))
+ModalTitle.displayName = DialogPrimitive.Title.displayName
+
+const ModalDescription = React.forwardRef<
+  React.ElementRef<typeof DialogPrimitive.Description>,
+  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
+>(({ className, ...props }, ref) => (
+  <DialogPrimitive.Description
+    ref={ref}
+    className={cn('text-sm text-muted-foreground', className)}
+    {...props}
+  />
+))
+ModalDescription.displayName = DialogPrimitive.Description.displayName
+
+const ModalBody = React.forwardRef<
+  HTMLDivElement,
+  React.HTMLAttributes<HTMLDivElement>
+>(({ className, ...props }, ref) => (
+  <div ref={ref} className={cn('p-6', className)} {...props} />
+))
+ModalBody.displayName = 'ModalBody'
+
+const ModalFooter = React.forwardRef<
+  HTMLDivElement,
+  React.HTMLAttributes<HTMLDivElement>
+>(({ className, ...props }, ref) => (
+  <div
+    ref={ref}
+    className={cn('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2 p-6', className)}
+    {...props}
+  />
+))
+ModalFooter.displayName = 'ModalFooter'
+
+const ConfirmationModal = ({
+  open,
+  onOpenChange,
+  onConfirm,
+  onCancel,
+  title,
+  description,
+  confirmText = 'Confirm',
+  cancelText = 'Cancel',
+  type = 'default',
+  loading = false,
+}) => {
+  const handleCancel = () => {
+    onCancel?.()
+    onOpenChange(false)
+  }
+
+  const handleConfirm = () => {
+    onConfirm()
+    if (!loading) {
+      onOpenChange(false)
+    }
+  }
+
+  const iconVariants = {
+    default: <Info className="h-6 w-6 text-primary" />,
+    danger: <AlertTriangle className="h-6 w-6 text-destructive" />,
+    warning: <AlertTriangle className="h-6 w-6 text-yellow-500" />,
+  }
+
+  return (
+    <Modal open={open} onOpenChange={onOpenChange} size="sm">
+      <ModalBody>
+        <div className="flex items-start gap-4">
+          <motion.div
+            initial={{ scale: 0, rotate: -180 }}
+            animate={{ scale: 1, rotate: 0 }}
+          >
+            {iconVariants[type]}
+          </motion.div>
+          <div className="flex-1">
+            <h3 className="text-lg font-semibold">{title}</h3>
+            {description && (
+              <p className="mt-2 text-sm text-muted-foreground">{description}</p>
+            )}
+          </div>
+        </div>
+      </ModalBody>
+      <ModalFooter>
+        <Button variant="ghost" onClick={handleCancel} disabled={loading}>
+          {cancelText}
+        </Button>
+        <Button
+          variant={type === 'danger' ? 'destructive' : 'default'}
+          onClick={handleConfirm}
+          loading={loading}
+        >
+          {confirmText}
+        </Button>
+      </ModalFooter>
+    </Modal>
+  )
+}
+
+export {
+  Modal,
+  ModalHeader,
+  ModalTitle,
+  ModalDescription,
+  ModalBody,
+  ModalFooter,
+  ConfirmationModal,
+}
\ No newline at end of file
diff --git a/client/src/features/design-system/components/index.ts b/client/src/features/design-system/components/index.ts
index 291e460f..3600aa04 100755
--- a/client/src/features/design-system/components/index.ts
+++ b/client/src/features/design-system/components/index.ts
@@ -2,7 +2,7 @@ export * from './Button'
 export * from './Card'
 export * from './SearchInput'
 export * from './Input'
-// Modal components are now exported from Dialog (with backward compatibility aliases)
+export * from './Modal'
 export * from './Toast'
 export * from './Tooltip'
 export * from './Collapsible'
diff --git a/client/src/features/graph/components/GraphCanvasSimple.tsx b/client/src/features/graph/components/GraphCanvasSimple.tsx
new file mode 100644
index 00000000..06f36e28
--- /dev/null
+++ b/client/src/features/graph/components/GraphCanvasSimple.tsx
@@ -0,0 +1,44 @@
+import React from 'react';
+import { Canvas } from '@react-three/fiber';
+
+const GraphCanvasSimple: React.FC = () => {
+  console.log('[GraphCanvasSimple] Rendering');
+  
+  return (
+    <div style={{ 
+      position: 'fixed', 
+      top: 0, 
+      left: 0, 
+      width: '100vw', 
+      height: '100vh',
+      backgroundColor: '#003366'
+    }}>
+      <div style={{
+        position: 'absolute',
+        top: '10px',
+        left: '10px',
+        color: 'white',
+        backgroundColor: 'orange',
+        padding: '10px',
+        zIndex: 1000
+      }}>
+        GraphCanvasSimple - Blue = container, Green = WebGL
+      </div>
+      
+      <Canvas
+        camera={{ position: [0, 0, 5] }}
+        onCreated={({ gl }) => {
+          console.log('[GraphCanvasSimple] Canvas created!', gl);
+          gl.setClearColor(0x00ff00, 1);
+        }}
+      >
+        <mesh>
+          <boxGeometry args={[1, 1, 1]} />
+          <meshBasicMaterial color="red" />
+        </mesh>
+      </Canvas>
+    </div>
+  );
+};
+
+export default GraphCanvasSimple;
\ No newline at end of file
diff --git a/client/src/features/graph/components/SimpleThreeTest.tsx b/client/src/features/graph/components/SimpleThreeTest.tsx
new file mode 100644
index 00000000..37282d5b
--- /dev/null
+++ b/client/src/features/graph/components/SimpleThreeTest.tsx
@@ -0,0 +1,46 @@
+import React from 'react';
+import { Canvas } from '@react-three/fiber';
+
+const SimpleThreeTest: React.FC = () => {
+  return (
+    <div style={{ 
+      position: 'fixed', 
+      top: 0, 
+      left: 0, 
+      width: '100vw', 
+      height: '100vh',
+      backgroundColor: 'purple'
+    }}>
+      <div style={{
+        position: 'absolute',
+        top: '10px',
+        left: '10px',
+        color: 'white',
+        backgroundColor: 'blue',
+        padding: '10px',
+        zIndex: 1000
+      }}>
+        Simple Three Test - Purple = container, Green = WebGL working
+      </div>
+      
+      <Canvas
+        camera={{ position: [0, 0, 5] }}
+        onCreated={({ gl }) => {
+          console.log('[SimpleThreeTest] Canvas created!', gl);
+          // Set background to green if WebGL works
+          gl.setClearColor(0x00ff00, 1);
+        }}
+        onError={(error) => {
+          console.error('[SimpleThreeTest] WebGL Error:', error);
+        }}
+      >
+        <mesh>
+          <boxGeometry args={[1, 1, 1]} />
+          <meshBasicMaterial color="red" />
+        </mesh>
+      </Canvas>
+    </div>
+  );
+};
+
+export default SimpleThreeTest;
\ No newline at end of file
diff --git a/client/src/features/graph/components/VisualEnhancementToggle.tsx b/client/src/features/graph/components/VisualEnhancementToggle.tsx
new file mode 100644
index 00000000..d46debbd
--- /dev/null
+++ b/client/src/features/graph/components/VisualEnhancementToggle.tsx
@@ -0,0 +1,81 @@
+import React from 'react';
+import { useSettingsStore } from '../../../store/settingsStore';
+import { createLogger } from '../../../utils/logger';
+
+const logger = createLogger('VisualEnhancementToggle');
+
+export const VisualEnhancementToggle: React.FC = () => {
+  const settings = useSettingsStore(state => state.settings);
+  const updateSettings = useSettingsStore(state => state.updateSettings);
+  
+  const isEnhanced = settings?.visualisation?.nodes?.enableHologram || 
+                     settings?.visualisation?.edges?.enableFlowEffect;
+  
+  const handleToggle = () => {
+    logger.info('Toggling visual enhancements', { currentState: isEnhanced });
+    
+    updateSettings((draft) => {
+      // Toggle hologram effect
+      if (draft.visualisation?.nodes) {
+        draft.visualisation.nodes.enableHologram = !isEnhanced;
+      }
+      
+      // Toggle flow effect
+      if (draft.visualisation?.edges) {
+        draft.visualisation.edges.enableFlowEffect = !isEnhanced;
+        draft.visualisation.edges.useGradient = !isEnhanced;
+      }
+      
+      // Toggle bloom
+      if (draft.visualisation?.bloom) {
+        draft.visualisation.bloom.enabled = !isEnhanced;
+      }
+      
+      // Toggle animations
+      if (draft.visualisation?.animation) {
+        draft.visualisation.animation.pulseEnabled = !isEnhanced;
+      }
+    });
+  };
+  
+  return (
+    <div style={{
+      position: 'fixed',
+      top: '20px',
+      right: '20px',
+      zIndex: 1000,
+      background: 'rgba(0, 0, 0, 0.8)',
+      border: '1px solid #00ffff',
+      borderRadius: '8px',
+      padding: '10px 20px',
+      color: '#ffffff',
+      fontFamily: 'monospace',
+      fontSize: '14px',
+      cursor: 'pointer',
+      userSelect: 'none',
+      boxShadow: isEnhanced ? '0 0 20px #00ffff' : 'none',
+      transition: 'all 0.3s ease'
+    }}
+    onClick={handleToggle}
+    >
+      <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
+        <span style={{ 
+          display: 'inline-block',
+          width: '12px',
+          height: '12px',
+          borderRadius: '50%',
+          background: isEnhanced ? '#00ff00' : '#ff0000',
+          boxShadow: isEnhanced ? '0 0 10px #00ff00' : 'none'
+        }} />
+        <span>Visual Effects: {isEnhanced ? 'ENHANCED' : 'STANDARD'}</span>
+      </div>
+      <div style={{ 
+        fontSize: '12px', 
+        opacity: 0.7,
+        marginTop: '5px'
+      }}>
+        Click to toggle hologram & flow effects
+      </div>
+    </div>
+  );
+};
\ No newline at end of file
diff --git a/client/src/styles/base.css b/client/src/styles/base.css
index 3fda72ca..55db8058 100644
--- a/client/src/styles/base.css
+++ b/client/src/styles/base.css
@@ -171,47 +171,23 @@
 @layer components {
   /* Control Panel Components */
   .settings-panel {
-    position: fixed;
-    right: 1rem;
-    top: 1rem;
-    z-index: var(--z-modal);
-    width: 20rem;
-    border-radius: 0.5rem;
-    background-color: hsl(var(--card));
-    padding: 1rem;
-    color: hsl(var(--card-foreground));
-    box-shadow: var(--shadow-lg);
+    @apply fixed right-4 top-4 z-40 w-80 rounded-lg bg-card p-4 text-card-foreground shadow-lg;
   }
 
   .settings-section {
-    margin-bottom: 1rem;
-    border-radius: 0.375rem;
-    border: 1px solid hsl(var(--border));
-    background-color: hsl(var(--card));
-    padding: 0.5rem;
+    @apply mb-4 rounded-md border border-border bg-card p-2;
   }
 
   .section-header {
-    display: flex;
-    align-items: center;
-    justify-content: space-between;
-    border-bottom: 1px solid hsl(var(--border));
-    padding-bottom: 0.5rem;
+    @apply flex items-center justify-between border-b border-border pb-2;
   }
 
   .section-content {
-    margin-top: 0.5rem;
-    display: flex;
-    flex-direction: column;
-    gap: 0.5rem;
+    @apply mt-2 space-y-2;
   }
 
   .setting-control {
-    display: flex;
-    align-items: center;
-    justify-content: space-between;
-    gap: 0.5rem;
-    padding: 0.25rem 0;
+    @apply flex items-center justify-between gap-2 py-1;
   }
 
   /* Button Variants */
diff --git a/client/src/styles/index.css b/client/src/styles/index.css
index 91d79e6e..cedc4e68 100755
--- a/client/src/styles/index.css
+++ b/client/src/styles/index.css
@@ -4,29 +4,15 @@
  * Import order matters:
  * 1. @import statements first (CSS requirement)
  * 2. Tailwind directives
- * 3. Custom utilities and overrides
+ * 3. Other styles
  */
 
 /* @import statements must come first */
 @import '@radix-ui/themes/styles.css';
 @import './base.css';
+@import './tailwind-utilities.css';
 
 /* Tailwind directives */
 @tailwind base;
 @tailwind components;
-@tailwind utilities;
-
-/* Custom Tailwind utilities for compatibility */
-@layer utilities {
-  .bg-background {
-    background-color: hsl(var(--background));
-  }
-  
-  .text-foreground {
-    color: hsl(var(--foreground));
-  }
-  
-  .bg-background\/80 {
-    background-color: hsl(var(--background) / 0.8);
-  }
-}
\ No newline at end of file
+@tailwind utilities;
\ No newline at end of file
diff --git a/client/src/styles/tailwind-utilities.css b/client/src/styles/tailwind-utilities.css
new file mode 100644
index 00000000..7e85519c
--- /dev/null
+++ b/client/src/styles/tailwind-utilities.css
@@ -0,0 +1,14 @@
+/* Custom Tailwind utilities for compatibility */
+@layer utilities {
+  .bg-background {
+    background-color: hsl(var(--background));
+  }
+  
+  .text-foreground {
+    color: hsl(var(--foreground));
+  }
+  
+  .bg-background\/80 {
+    background-color: hsl(var(--background) / 0.8);
+  }
+}
\ No newline at end of file
diff --git a/client/src/utils/iframeCommunication.ts b/client/src/utils/iframeCommunication.ts
index fc845159..71e8a935 100644
--- a/client/src/utils/iframeCommunication.ts
+++ b/client/src/utils/iframeCommunication.ts
@@ -1,35 +1,4 @@
-/**
- * Configuration for secure iframe communication
- */
-export const IFRAME_COMMUNICATION_CONFIG = {
-  // Allowed origins for postMessage communication
-  // In production, this should be restricted to specific domains
-  allowedOrigins: [
-    'https://narrativegoldmine.com',
-    'https://www.narrativegoldmine.com',
-    // Add other trusted origins here
-  ],
-  
-  // Target origin for sending messages (use specific origin in production)
-  // Currently using '*' for development, but should be updated
-  targetOrigin: '*', // TODO: Change to 'https://narrativegoldmine.com' in production
-  
-  // Message action types
-  messageActions: {
-    NAVIGATE: 'navigate',
-    UPDATE_NODE: 'updateNode',
-    SYNC_STATE: 'syncState',
-  } as const,
-  
-  // Validation settings
-  validation: {
-    requireValidUrl: true,
-    requireKnownDomain: true,
-    logMessages: true, // Set to false in production
-  }
-};
-
-export type MessageAction = typeof IFRAME_COMMUNICATION_CONFIG.messageActions[keyof typeof IFRAME_COMMUNICATION_CONFIG.messageActions];
+import { IFRAME_COMMUNICATION_CONFIG, MessageAction } from '../config/iframeCommunication';
 
 /**
  * Base interface for all iframe messages
diff --git a/client/src/utils/performanceMonitor.tsx b/client/src/utils/performanceMonitor.tsx
new file mode 100755
index 00000000..6e900899
--- /dev/null
+++ b/client/src/utils/performanceMonitor.tsx
@@ -0,0 +1,182 @@
+import React from 'react';
+import { createLogger } from './logger';
+
+const logger = createLogger('PerformanceMonitor');
+
+interface PerformanceMetrics {
+  renderCount: number;
+  renderTime: number;
+  lastRenderTimestamp: number;
+  averageRenderTime: number;
+  peakRenderTime: number;
+}
+
+class PerformanceMonitor {
+  private metrics: Map<string, PerformanceMetrics> = new Map();
+  private enabled: boolean = process.env.NODE_ENV === 'development';
+
+  /**
+   * Start measuring performance for a component
+   */
+  startMeasure(componentName: string): () => void {
+    if (!this.enabled) return () => {};
+    
+    const startTime = performance.now();
+    
+    return () => {
+      const endTime = performance.now();
+      const renderTime = endTime - startTime;
+      
+      this.updateMetrics(componentName, renderTime);
+    };
+  }
+
+  /**
+   * Update metrics for a component
+   */
+  private updateMetrics(componentName: string, renderTime: number): void {
+    const existing = this.metrics.get(componentName) || {
+      renderCount: 0,
+      renderTime: 0,
+      lastRenderTimestamp: 0,
+      averageRenderTime: 0,
+      peakRenderTime: 0
+    };
+    
+    const newCount = existing.renderCount + 1;
+    const totalTime = existing.renderTime + renderTime;
+    const averageTime = totalTime / newCount;
+    const peakTime = Math.max(existing.peakRenderTime, renderTime);
+    
+    const updated: PerformanceMetrics = {
+      renderCount: newCount,
+      renderTime: totalTime,
+      lastRenderTimestamp: Date.now(),
+      averageRenderTime: averageTime,
+      peakRenderTime: peakTime
+    };
+    
+    this.metrics.set(componentName, updated);
+    
+    // Log slow renders
+    if (renderTime > 16.67) { // More than one frame (60fps)
+      logger.warn(`Slow render detected in ${componentName}: ${renderTime.toFixed(2)}ms`);
+    }
+  }
+
+  /**
+   * Get metrics for a specific component
+   */
+  getMetrics(componentName: string): PerformanceMetrics | undefined {
+    return this.metrics.get(componentName);
+  }
+
+  /**
+   * Get all metrics
+   */
+  getAllMetrics(): Map<string, PerformanceMetrics> {
+    return new Map(this.metrics);
+  }
+
+  /**
+   * Clear metrics for a component
+   */
+  clearMetrics(componentName?: string): void {
+    if (componentName) {
+      this.metrics.delete(componentName);
+    } else {
+      this.metrics.clear();
+    }
+  }
+
+  /**
+   * Generate a performance report
+   */
+  generateReport(): string {
+    const sortedMetrics = Array.from(this.metrics.entries())
+      .sort((a, b) => b[1].averageRenderTime - a[1].averageRenderTime);
+    
+    let report = '\\n=== Performance Report ===\\n';
+    
+    for (const [component, metrics] of sortedMetrics) {
+      report += `\\n${component}:\\n`;
+      report += `  Render Count: ${metrics.renderCount}\\n`;
+      report += `  Average Time: ${metrics.averageRenderTime.toFixed(2)}ms\\n`;
+      report += `  Peak Time: ${metrics.peakRenderTime.toFixed(2)}ms\\n`;
+      report += `  Total Time: ${metrics.renderTime.toFixed(2)}ms\\n`;
+    }
+    
+    return report;
+  }
+
+  /**
+   * Log the performance report
+   */
+  logReport(): void {
+    if (!this.enabled) return;
+    logger.info(this.generateReport());
+  }
+
+  /**
+   * Enable or disable performance monitoring
+   */
+  setEnabled(enabled: boolean): void {
+    this.enabled = enabled;
+  }
+}
+
+// Singleton instance
+export const performanceMonitor = new PerformanceMonitor();
+
+/**
+ * React hook for performance monitoring
+ */
+export function usePerformanceMonitor(componentName: string): void {
+  if (process.env.NODE_ENV !== 'development') return;
+  
+  const endMeasure = performanceMonitor.startMeasure(componentName);
+  
+  // Measure after render
+  setTimeout(endMeasure, 0);
+}
+
+/**
+ * HOC for performance monitoring
+ */
+export function withPerformanceMonitor<P extends object>(
+  Component: React.ComponentType<P>,
+  componentName?: string
+): React.ComponentType<P> {
+  const displayName = componentName || Component.displayName || Component.name || 'Unknown';
+  
+  const WrappedComponent = (props: P) => {
+    usePerformanceMonitor(displayName);
+    return <Component {...props} />;
+  };
+  
+  WrappedComponent.displayName = `withPerformanceMonitor(${displayName})`;
+  
+  return WrappedComponent;
+}
+
+/**
+ * Custom hook for render counting
+ */
+export function useRenderCount(componentName: string): number {
+  const [renderCount, setRenderCount] = React.useState(0);
+  
+  React.useEffect(() => {
+    setRenderCount(prev => prev + 1);
+    
+    if (process.env.NODE_ENV === 'development') {
+      logger.debug(`${componentName} rendered ${renderCount + 1} times`);
+    }
+  });
+  
+  return renderCount;
+}
+
+// Export a global reference for console debugging
+if (typeof window !== 'undefined' && process.env.NODE_ENV === 'development') {
+  (window as any).performanceMonitor = performanceMonitor;
+}
\ No newline at end of file
diff --git a/data/settings.yaml b/data/settings.yaml
index 6e9ee5b8..02f3bdd8 100755
--- a/data/settings.yaml
+++ b/data/settings.yaml
@@ -20,7 +20,7 @@ visualisation:
     pulse_strength: 0.8
     wave_speed: 0.5
   glow:
-    enabled: true
+    enabled: false
     intensity: 0.3561644
     radius: 0.3561644
     threshold: 0.038356163
@@ -282,9 +282,9 @@ visualisation:
     deadzone: 0.1
     button_functions:
       '6': frontView
+      '1': resetView
       '3': fitToView
       '2': cycleMode
-      '1': resetView
       '4': topView
       '5': rightView
 system:
diff --git a/docker-compose.dev.yml b/docker-compose.dev.yml
new file mode 100644
index 00000000..b96168cb
--- /dev/null
+++ b/docker-compose.dev.yml
@@ -0,0 +1,74 @@
+services:
+  webxr:
+    container_name: visionflow_container
+    build:
+      context: .
+      dockerfile: Dockerfile.dev
+      args:
+        CUDA_ARCH: ${CUDA_ARCH:-86}
+    volumes:
+      - ./client:/app/client
+      - ./src:/app/src # Mount Rust source code for development
+      - ./Cargo.toml:/app/Cargo.toml # Mount Cargo.toml for dependency changes
+      # Note: Cargo.lock is generated during build if missing
+      - ./data/markdown:/app/data/markdown
+      - ./data/metadata:/app/data/metadata
+      - ./data/user_settings:/app/user_settings
+      - ./data/settings.yaml:/app/settings.yaml
+      - ./nginx.dev.conf:/etc/nginx/nginx.conf:ro # Mount dev Nginx config (read-only)
+      - ./logs/nginx:/var/log/nginx # Mount nginx logs to host
+      - ./logs:/app/logs
+      - ./scripts/dev-exec-proxy.sh:/usr/local/bin/dev-exec:ro # Mount exec proxy
+      - ./scripts/check-rust-rebuild.sh:/app/scripts/check-rust-rebuild.sh:ro # Mount rebuild check script
+      - ./scripts/dev-rebuild-rust.sh:/app/scripts/dev-rebuild-rust.sh:ro # Mount manual rebuild script
+      - ./supervisord.dev.conf:/app/supervisord.dev.conf:ro # Mount supervisor config
+      - /var/run/docker.sock:/var/run/docker.sock:ro # Docker socket for controlled access
+      - npm-cache:/root/.npm
+      - cargo-cache:/root/.cargo/registry
+      - cargo-git-cache:/root/.cargo/git
+      - cargo-target-cache:/app/target # Cache Rust build artifacts
+    env_file:
+      - .env
+    environment:
+      - NVIDIA_VISIBLE_DEVICES=0  # Use GPU 0 (RTX A6000)
+      # RUST_LOG is now inherited from the .env file via env_file directive
+      - VITE_DEBUG=${DEBUG_ENABLED:-true} # Pass master debug switch to frontend
+      - NODE_ENV=development
+      - VITE_DEV_SERVER_PORT=5173 # Internal Vite port, accessed via Nginx
+      - VITE_API_PORT=4000
+      - VITE_HMR_PORT=24678 # Internal HMR port, accessed via Nginx
+      - RUST_LOG_REDIRECT=true
+      # Override the port from settings.yaml for development environment
+      # Ensure Rust backend listens on 4000, which Vite proxies to.
+      - SYSTEM_NETWORK_PORT=4000
+      # Claude Flow MCP WebSocket configuration
+      - CLAUDE_FLOW_HOST=multi-agent-container
+      - CLAUDE_FLOW_PORT=3002
+      # MCP Orchestrator configuration (optional - will use mock data if not available)
+      - ORCHESTRATOR_WS_URL=ws://mcp-orchestrator:9001/ws
+      - MCP_RELAY_FALLBACK_TO_MOCK=true
+      # Set BOTS_ORCHESTRATOR_URL to non-existent to trigger mock data
+      - BOTS_ORCHESTRATOR_URL=ws://multi-agent-container:3002
+    deploy: # Indentation: 4 spaces
+      resources:
+        reservations:
+          devices:
+            - driver: nvidia
+              capabilities: [compute,utility]
+              device_ids: ['0']
+    ports: # Indentation: 4 spaces
+      # Expose only Nginx port 3001 to the host.
+      # Other services (Vite 5173, Rust 4000, HMR 24678) are accessed via Nginx proxy.
+      - "3001:3001"  # Nginx entry point
+    networks: # Indentation: 4 spaces
+      - docker_ragflow
+
+networks: # Indentation: 2 spaces
+  docker_ragflow:
+    external: true
+
+volumes: # Indentation: 2 spaces
+  npm-cache:
+  cargo-cache:
+  cargo-git-cache:
+  cargo-target-cache:
diff --git a/docker-compose.production.yml b/docker-compose.production.yml
new file mode 100644
index 00000000..3a19af82
--- /dev/null
+++ b/docker-compose.production.yml
@@ -0,0 +1,65 @@
+version: '3.8'
+
+services:
+  webxr:
+    container_name: logseq-spring-thing-webxr
+    build:
+      context: .
+      dockerfile: Dockerfile.production
+      args:
+        CUDA_ARCH: ${CUDA_ARCH:-89}
+        REBUILD_PTX: ${REBUILD_PTX:-false}
+    env_file:
+      - .env # Load all variables from .env file into the container
+    environment:
+      - NVIDIA_VISIBLE_DEVICES=${NVIDIA_VISIBLE_DEVICES:-0}
+      - NVIDIA_GPU_UUID=${NVIDIA_GPU_UUID:-0}
+      # RUST_LOG is now inherited from the .env file via env_file directive
+      - NODE_ENV=production
+      - GIT_HASH=${GIT_HASH:-production}
+    volumes:
+      # Only mount data directories, not code
+      - ./data/markdown:/app/data/markdown
+      - ./data/metadata:/app/data/metadata
+      - ./data/user_settings:/app/user_settings
+      - ./data/settings.yaml:/app/settings.yaml
+    deploy:
+      resources:
+        reservations:
+          devices:
+            - driver: nvidia
+              capabilities: [compute,utility]
+              device_ids: ['0']
+    ports:
+      - "4000:4000"  # Expose API port
+    networks:
+      - docker_ragflow # Revert to simple network list item
+    restart: unless-stopped
+    healthcheck:
+      # Check root path which Nginx serves, indicating Nginx is up
+      test: ["CMD", "curl", "-f", "http://localhost:4000/"]
+      interval: 30s
+      timeout: 10s
+      retries: 3
+      start_period: 40s
+
+  cloudflared:
+    container_name: cloudflared-tunnel
+    image: cloudflare/cloudflared:latest
+    command: tunnel --no-autoupdate run
+    environment:
+      # Use the standard variable name, expecting it from the .env file loaded by Compose
+      - TUNNEL_TOKEN=${CLOUDFLARE_TUNNEL_TOKEN}
+    volumes:
+      - ./config.yml:/etc/cloudflared/config.yml:ro
+    depends_on:
+      - webxr
+    networks:
+      - docker_ragflow
+    restart: unless-stopped
+
+networks:
+  docker_ragflow:
+    external: true
+
+# Removed duplicated cloudflared service definition
diff --git a/docker-compose.yml b/docker-compose.yml
index 8db8c028..e26b9a23 100644
--- a/docker-compose.yml
+++ b/docker-compose.yml
@@ -17,13 +17,12 @@ services:
       - ./data/metadata:/app/data/metadata
       - ./data/user_settings:/app/user_settings
       - ./data/settings.yaml:/app/settings.yaml
-      - ./nginx.conf.template:/app/nginx.conf.template:ro
+      - ./nginx.dev.conf:/etc/nginx/nginx.conf:ro
       - ./logs/nginx:/var/log/nginx
       - ./logs:/app/logs
       - ./scripts/dev-exec-proxy.sh:/usr/local/bin/dev-exec:ro
       - ./scripts/check-rust-rebuild.sh:/app/scripts/check-rust-rebuild.sh:ro
       - ./scripts/dev-rebuild-rust.sh:/app/scripts/dev-rebuild-rust.sh:ro
-      - ./scripts/generate-nginx-config.sh:/app/scripts/generate-nginx-config.sh:ro
       - ./supervisord.dev.conf:/app/supervisord.dev.conf:ro
       - /var/run/docker.sock:/var/run/docker.sock:ro
       - npm-cache:/root/.npm
@@ -59,37 +58,6 @@ services:
       - ORCHESTRATOR_WS_URL=ws://mcp-orchestrator:9001/ws
       - MCP_RELAY_FALLBACK_TO_MOCK=true
       - BOTS_ORCHESTRATOR_URL=ws://multi-agent-container:3002
-      # Nginx Configuration
-      - NGINX_LOG_LEVEL=crit
-      - NGINX_WORKER_CONNECTIONS=1024
-      - NGINX_MULTI_ACCEPT=on
-      - NGINX_ACCESS_LOG=off
-      - NGINX_KEEPALIVE_TIMEOUT=65
-      - NGINX_KEEPALIVE_REQUESTS=100
-      - NGINX_MAX_BODY_SIZE=100M
-      - NGINX_PORT=3001
-      - NGINX_SERVER_NAME=localhost
-      - NGINX_ROOT=/app/client/dist
-      - NGINX_FRAME_OPTIONS=SAMEORIGIN
-      - NGINX_REFERRER_POLICY=same-origin
-      - "NGINX_CSP=default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://getalby.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' ws: wss: http: https: *.visionflow.info; font-src 'self' data:; frame-src 'self' https://getalby.com"
-      - NGINX_HSTS_PRELOAD=
-      - NGINX_REAL_IP_FROM_CF=$$remote_addr
-      - NGINX_FORWARDED_PROTO=$$scheme
-      - NGINX_API_BUFFERING=off
-      - NGINX_WS_ACCESS_LOG=/var/log/nginx/websocket.log
-      - NGINX_WS_LOG_FORMAT=debug_format
-      - NGINX_WS_ERROR_LOG=/var/log/nginx/websocket-error.log
-      - NGINX_WS_ERROR_LEVEL=debug
-      - NGINX_STATIC_FALLBACK=development_static
-      - NGINX_STATIC_EXPIRES=1m
-      - NGINX_STATIC_CACHE_CONTROL=no-cache, must-revalidate
-      - NGINX_HTML_FALLBACK=/index.html
-      - NGINX_ROOT_FALLBACK=development_root
-      - NGINX_ROOT_EXPIRES=-1
-      - NGINX_ROOT_CACHE_CONTROL=no-cache, no-store, must-revalidate
-      - BACKEND_PORT=4000
-      - FRONTEND_PORT=5173
     ports:
       - "3001:3001"  # Nginx entry point for dev
     networks:
@@ -119,37 +87,6 @@ services:
       - MCP_RECONNECT_ATTEMPTS=3
       - MCP_RECONNECT_DELAY=1000
       - MCP_CONNECTION_TIMEOUT=30000
-      # Nginx Configuration
-      - NGINX_LOG_LEVEL=crit
-      - NGINX_WORKER_CONNECTIONS=2048
-      - NGINX_MULTI_ACCEPT=on
-      - NGINX_ACCESS_LOG=off
-      - NGINX_KEEPALIVE_TIMEOUT=120
-      - NGINX_KEEPALIVE_REQUESTS=100
-      - NGINX_MAX_BODY_SIZE=100M
-      - NGINX_PORT=4000
-      - NGINX_SERVER_NAME=_
-      - NGINX_ROOT=/app/client/dist
-      - NGINX_FRAME_OPTIONS=SAMEORIGIN
-      - NGINX_REFERRER_POLICY=strict-origin-when-cross-origin
-      - "NGINX_CSP=default-src 'self' https:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://getalby.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' wss: https:; frame-src 'self' https://getalby.com; font-src 'self' data:;"
-      - "NGINX_HSTS_PRELOAD=; preload"
-      - NGINX_REAL_IP_FROM_CF=$$http_cf_connecting_ip
-      - NGINX_FORWARDED_PROTO=https
-      - NGINX_API_BUFFERING=on
-      - NGINX_WS_ACCESS_LOG=off
-      - NGINX_WS_LOG_FORMAT=main
-      - NGINX_WS_ERROR_LOG=/var/log/nginx/error.log
-      - NGINX_WS_ERROR_LEVEL=crit
-      - NGINX_STATIC_FALLBACK=production_static
-      - NGINX_STATIC_EXPIRES=30d
-      - NGINX_STATIC_CACHE_CONTROL=public, immutable
-      - NGINX_HTML_FALLBACK=/index.html
-      - NGINX_ROOT_FALLBACK=production_root
-      - NGINX_ROOT_EXPIRES=-1
-      - NGINX_ROOT_CACHE_CONTROL=no-cache, no-store, must-revalidate
-      - BACKEND_PORT=3001
-      - FRONTEND_PORT=5173
     volumes:
       - ./data/markdown:/app/data/markdown
       - ./data/metadata:/app/data/metadata
diff --git a/docs/deployment/MIGRATION_GUIDE.md b/docs/deployment/MIGRATION_GUIDE.md
deleted file mode 100644
index 783cd267..00000000
--- a/docs/deployment/MIGRATION_GUIDE.md
+++ /dev/null
@@ -1,185 +0,0 @@
-# Configuration Migration Guide
-
-This guide helps you migrate from the old multi-file configuration system to the new unified configuration approach.
-
-## What Changed
-
-### Docker Compose Consolidation
-- **Before**: Separate `docker-compose.dev.yml` and `docker-compose.production.yml` files
-- **After**: Single `docker-compose.yml` with profiles (`dev` and `production`)
-
-### Nginx Configuration Unification
-- **Before**: Separate `nginx.dev.conf`, `nginx.production.conf`, and unused `nginx.conf`
-- **After**: Single `nginx.conf.template` with environment variable substitution
-
-### Environment Templates Merger
-- **Before**: Multiple `.env` template files scattered across directories
-- **After**: Single comprehensive `.env.example` at project root
-
-## Migration Steps
-
-### 1. Update Docker Commands
-
-**Old Commands:**
-```bash
-# Development
-docker-compose -f docker-compose.dev.yml up
-docker-compose -f docker-compose.dev.yml exec visionflow-xr bash
-
-# Production
-docker-compose -f docker-compose.production.yml up
-```
-
-**New Commands:**
-```bash
-# Development
-docker-compose --profile dev up
-docker-compose --profile dev exec webxr-dev bash
-
-# Production  
-docker-compose --profile production up
-docker-compose --profile production exec webxr-prod bash
-```
-
-### 2. Update Environment Configuration
-
-1. **Copy the new environment template:**
-   ```bash
-   cp .env.example .env
-   ```
-
-2. **Migrate your existing settings** from old `.env` files to the new unified `.env` file
-
-3. **New environment structure:**
-   - All backend (Rust) variables in one section
-   - All frontend (Vite) variables with `VITE_` prefix
-   - Clear separation by service type
-   - Production-specific settings clearly marked
-
-### 3. Update Scripts and Automation
-
-If you have custom scripts that reference the old files, update them:
-
-**Old Script Pattern:**
-```bash
-docker-compose -f docker-compose.dev.yml exec visionflow-xr command
-```
-
-**New Script Pattern:**
-```bash
-docker-compose --profile dev exec webxr-dev command
-```
-
-### 4. Nginx Configuration (Advanced Users)
-
-The nginx configuration is now generated automatically from templates. If you had custom nginx configurations:
-
-1. **Review the new template** at `nginx.conf.template`
-2. **Customize environment variables** in `nginx.env.dev` or `nginx.env.prod`
-3. **Advanced customization**: Modify the template file directly
-
-## Benefits of New System
-
-### Simplified Management
-- **Single source of truth** for each configuration type
-- **Reduced file duplication** and maintenance overhead
-- **Consistent naming** across development and production
-
-### Environment-Driven Configuration
-- **Dynamic configuration** based on environment variables
-- **Easy deployment** across different environments
-- **Better security** with externalized secrets
-
-### Profile-Based Deployment
-- **Clean separation** between dev and production
-- **Faster switching** between environments
-- **Resource optimization** per environment
-
-## Troubleshooting Migration Issues
-
-### Docker Profile Not Found
-**Error:** `no configuration file provided: not found`
-
-**Solution:**
-```bash
-# Ensure you're using the main docker-compose.yml file
-docker-compose --profile dev up
-
-# Or be explicit about the file
-docker-compose -f docker-compose.yml --profile dev up
-```
-
-### Container Name Changed
-**Error:** `No such service: visionflow-xr`
-
-**Solution:** Use the new service names:
-- Development: `webxr-dev`
-- Production: `webxr-prod`
-
-### Environment Variables Not Loading
-**Error:** Configuration not applied correctly
-
-**Solution:**
-1. Check your `.env` file exists and has correct variables
-2. Restart Docker Compose: `docker-compose down && docker-compose --profile dev up`
-3. Verify environment variables: `docker-compose --profile dev exec webxr-dev env`
-
-### Nginx Configuration Issues
-**Error:** nginx fails to start with configuration errors
-
-**Solution:**
-1. Check the nginx config was generated: `docker-compose --profile dev exec webxr-dev cat /etc/nginx/nginx.conf`
-2. Verify environment file exists: `docker-compose --profile dev exec webxr-dev ls -la /app/nginx.env.*`
-3. Check generation script logs: `docker-compose --profile dev logs webxr-dev | grep nginx-config`
-
-## Verification Checklist
-
-After migration, verify these work:
-
-### Basic Functionality
-- [ ] `docker-compose --profile dev up` starts successfully
-- [ ] `docker-compose --profile production up` starts successfully  
-- [ ] Application accessible at expected ports
-- [ ] All environment variables loaded correctly
-
-### Service Communication
-- [ ] Frontend can reach backend API
-- [ ] WebSocket connections work
-- [ ] Static files served correctly
-- [ ] Health checks pass
-
-### Development Workflow
-- [ ] Hot reloading works in development
-- [ ] Log files accessible
-- [ ] Container exec commands work
-- [ ] Volume mounts functional
-
-## Rollback Plan
-
-If you encounter issues, you can temporarily rollback:
-
-1. **Restore old files** from git history:
-   ```bash
-   git checkout HEAD~1 docker-compose.dev.yml docker-compose.production.yml
-   git checkout HEAD~1 nginx.dev.conf nginx.production.conf
-   ```
-
-2. **Use old commands** temporarily:
-   ```bash
-   docker-compose -f docker-compose.dev.yml up
-   ```
-
-3. **Report issues** and plan migration retry
-
-## Support
-
-If you need help with migration:
-
-- **Check existing issues** in the repository
-- **Create a new issue** with your specific migration problem
-- **Include relevant logs** and configuration files
-- **Specify your environment** (OS, Docker version, etc.)
-
----
-
-**Note:** This migration improves maintainability and follows Docker Compose best practices. While there's an initial adjustment period, the new system is more robust and easier to manage long-term.
\ No newline at end of file
diff --git a/docs/deployment/nginx-docker-routing-analysis.md b/docs/deployment/nginx-docker-routing-analysis.md
deleted file mode 100644
index 760851dd..00000000
--- a/docs/deployment/nginx-docker-routing-analysis.md
+++ /dev/null
@@ -1,232 +0,0 @@
-# üîç NGINX Docker Routing Analysis - The Delicate Architecture
-
-## Overview
-The VisionFlow system uses a sophisticated multi-layer routing architecture where NGINX acts as the primary reverse proxy inside Docker containers, orchestrating traffic between multiple services with careful consideration for development vs production environments.
-
-## üéØ Critical Routing Architecture
-
-### Port Mapping Flow
-```
-External Request (Host:3001)
-    ‚Üì
-Docker Container Port 3001
-    ‚Üì
-NGINX (listening on 3001)
-    ‚Üì [Routing Decision]
-    ‚îú‚îÄ‚îÄ /api/* ‚Üí Backend (127.0.0.1:4000)
-    ‚îú‚îÄ‚îÄ /ws* ‚Üí WebSocket Backend (127.0.0.1:4000)
-    ‚îú‚îÄ‚îÄ /__vite_hmr ‚Üí Vite Dev Server (127.0.0.1:5173)
-    ‚îî‚îÄ‚îÄ /* ‚Üí Frontend (127.0.0.1:5173 or static files)
-```
-
-## üö® The Delicate Parts
-
-### 1. **Localhost vs Container Networking**
-NGINX uses `127.0.0.1` for upstream services because all services run in the SAME container:
-```nginx
-upstream backend {
-    server 127.0.0.1:4000;  # NOT localhost, NOT container names
-    keepalive 32;
-}
-```
-
-**Why This Matters:**
-- In development, NGINX, Rust backend, and Vite all run in the same container
-- Using `localhost` or external container names would fail
-- The services communicate via loopback interface internally
-
-### 2. **Environment Variable Substitution Complexity**
-
-The template uses complex variable substitution that must escape nginx variables:
-```nginx
-proxy_set_header X-Real-IP ${NGINX_REAL_IP_FROM_CF:-$remote_addr};
-```
-
-In docker-compose.yml, this requires double escaping:
-```yaml
-- NGINX_REAL_IP_FROM_CF=$$remote_addr  # $$ becomes $ in container
-```
-
-**Critical Issue:** If not properly escaped, nginx variables get replaced during `envsubst`, breaking the configuration.
-
-### 3. **WebSocket Upgrade Mapping**
-
-WebSocket connections require precise header forwarding:
-```nginx
-map $http_upgrade $connection_upgrade {
-    default upgrade;
-    ''      close;
-}
-```
-
-This mapping MUST occur before any WebSocket location blocks, and the upgrade headers must be preserved through the proxy chain.
-
-### 4. **Development vs Production Routing**
-
-The template uses dynamic fallbacks based on environment:
-```nginx
-location / {
-    try_files $uri $uri/ @${NGINX_ROOT_FALLBACK:-production_root};
-}
-```
-
-**Development Mode:**
-- `NGINX_ROOT_FALLBACK=development_root` ‚Üí Proxies to Vite
-- `NGINX_STATIC_FALLBACK=development_static` ‚Üí Proxies static assets to Vite
-
-**Production Mode:**
-- `NGINX_ROOT_FALLBACK=production_root` ‚Üí Serves from disk
-- `NGINX_STATIC_FALLBACK=production_static` ‚Üí Returns 404 for missing assets
-
-### 5. **The Supervisord Orchestration**
-
-Services start in specific order via supervisord:
-1. **nginx-config-gen** (priority=1, autorestart=false) - Generates nginx.conf
-2. **nginx** - Starts after config generation
-3. **rust-backend** - Must be running on port 4000
-4. **vite-dev** - Must be running on port 5173
-
-**Failure Point:** If nginx-config-gen fails, nginx never starts, causing cascade failure.
-
-## üîß Common Failure Scenarios
-
-### Scenario 1: Environment Variables Not Available
-```bash
-# Problem: envsubst has no variables to substitute
-envsubst < nginx.conf.template > nginx.conf
-# Result: All ${VAR} become empty strings
-```
-
-**Solution:** The fixed `generate-nginx-config.sh` now provides defaults:
-```bash
-export NGINX_WORKER_PROCESSES="${NGINX_WORKER_PROCESSES:-auto}"
-export BACKEND_PORT="${BACKEND_PORT:-4000}"
-```
-
-### Scenario 2: Port Conflicts
-```bash
-# Rust tries to bind to 4000 but it's already in use
-Error: Address already in use (os error 98)
-```
-
-**Solution:** The dev-entrypoint.sh kills existing processes:
-```bash
-lsof -t -i:${TARGET_PORT} | xargs -r kill -9
-```
-
-### Scenario 3: WebSocket Connection Failures
-```nginx
-# Missing upgrade headers
-location /ws {
-    proxy_pass http://backend;
-    # MISSING: proxy_set_header Upgrade $http_upgrade;
-}
-```
-
-**Impact:** WebSocket connections fail silently, falling back to polling.
-
-### Scenario 4: CSP Header Breaking Development
-```yaml
-# CSP too restrictive for hot reload
-NGINX_CSP="default-src 'self'"  # Blocks Vite HMR
-```
-
-**Solution:** Development needs `'unsafe-inline' 'unsafe-eval'` for hot reload.
-
-## üìä Service Communication Matrix
-
-| Source | Destination | Port | Protocol | Purpose |
-|--------|------------|------|----------|---------|
-| Host Browser | NGINX | 3001 | HTTP/WS | Entry point |
-| NGINX | Rust Backend | 4000 | HTTP/WS | API & WebSocket |
-| NGINX | Vite Dev | 5173 | HTTP/WS | Dev server & HMR |
-| Rust Backend | MCP Server | 9500 | TCP | Agent communication |
-| Browser | Vite HMR | 24678 | WS | Hot module reload |
-
-## üéõÔ∏è Critical Configuration Parameters
-
-### Must-Have Environment Variables
-```bash
-# Ports (must match service configurations)
-BACKEND_PORT=4000
-FRONTEND_PORT=5173
-NGINX_PORT=3001
-
-# Routing fallbacks (different for dev/prod)
-NGINX_ROOT_FALLBACK=development_root  # or production_root
-NGINX_STATIC_FALLBACK=development_static  # or production_static
-
-# WebSocket timeouts (critical for long connections)
-proxy_read_timeout=3600s
-proxy_send_timeout=3600s
-```
-
-### Debug Configuration
-```nginx
-# Enable for troubleshooting
-access_log /var/log/nginx/websocket.log debug_format;
-error_log /var/log/nginx/websocket-error.log debug;
-```
-
-## üöÄ Best Practices
-
-1. **Always validate nginx config after generation:**
-   ```bash
-   nginx -t -c /etc/nginx/nginx.conf
-   ```
-
-2. **Use specific variable lists with envsubst:**
-   ```bash
-   VARS='$BACKEND_PORT $FRONTEND_PORT'
-   envsubst "$VARS" < template > output
-   ```
-
-3. **Monitor service startup order:**
-   ```bash
-   supervisorctl status
-   ```
-
-4. **Check port availability before starting services:**
-   ```bash
-   netstat -tulpn | grep -E '(3001|4000|5173)'
-   ```
-
-5. **Verify WebSocket upgrade headers:**
-   ```bash
-   curl -i -N -H "Connection: Upgrade" \
-        -H "Upgrade: websocket" \
-        http://localhost:3001/ws
-   ```
-
-## üîç Debugging Commands
-
-```bash
-# Inside container - check nginx config
-docker exec visionflow_container nginx -T
-
-# Check service status
-docker exec visionflow_container supervisorctl status
-
-# Monitor nginx access logs
-docker exec visionflow_container tail -f /var/log/nginx/access.log
-
-# Test backend connectivity
-docker exec visionflow_container curl -I http://127.0.0.1:4000/api/health
-
-# Check environment variables
-docker exec visionflow_container env | grep NGINX
-
-# Verify routing
-docker exec visionflow_container curl -I http://127.0.0.1:3001/api/health
-```
-
-## Summary
-
-The nginx routing inside Docker is delicate because:
-1. **All services run in one container** (dev mode), requiring loopback networking
-2. **Environment variable substitution** needs careful escaping
-3. **Service startup order** is critical via supervisord
-4. **WebSocket routing** requires precise header preservation
-5. **Dynamic routing** changes based on dev/prod environment
-
-The system works when all pieces align perfectly, but a single misconfiguration can cascade into total failure. The recent fixes ensure proper defaults and error handling to make the system more resilient.
\ No newline at end of file
diff --git a/docs/development/setup.md b/docs/development/setup.md
index 7980a6fc..a58f01b2 100644
--- a/docs/development/setup.md
+++ b/docs/development/setup.md
@@ -63,7 +63,7 @@ Best for: Small to medium changes
 1. Make changes to Rust source code
 2. Restart the container:
    ```bash
-   docker compose --profile dev restart webxr-dev
+   docker compose -f docker-compose.dev.yml restart visionflow-xr
    ```
 3. The container automatically detects changes and rebuilds
 
@@ -156,7 +156,7 @@ DOCKER_BUILDKIT=1                 # Enable BuildKit for faster builds
 **Solutions**:
 1. Check if the rebuild script ran successfully:
    ```bash
-   docker compose --profile dev logs webxr-dev
+   docker compose -f docker-compose.dev.yml logs visionflow-xr
    ```
 
 2. Manual rebuild:
@@ -166,7 +166,7 @@ DOCKER_BUILDKIT=1                 # Enable BuildKit for faster builds
 
 3. Full restart:
    ```bash
-   docker compose --profile dev restart webxr-dev
+   docker compose -f docker-compose.dev.yml restart visionflow-xr
    ```
 
 #### Build Failures
@@ -176,17 +176,17 @@ DOCKER_BUILDKIT=1                 # Enable BuildKit for faster builds
 **Diagnosis**:
 1. Check Rust server status:
    ```bash
-   docker compose --profile dev exec webxr-dev ps aux | grep webxr
+   docker compose -f docker-compose.dev.yml exec visionflow-xr ps aux | grep webxr
    ```
 
 2. View detailed logs:
    ```bash
-   docker compose --profile dev exec webxr-dev tail -f /app/logs/rust_server.log
+   docker compose -f docker-compose.dev.yml exec visionflow-xr tail -f /app/logs/rust_server.log
    ```
 
 3. Manual compilation check:
    ```bash
-   docker compose --profile dev exec webxr-dev bash
+   docker compose -f docker-compose.dev.yml exec visionflow-xr bash
    cd /app
    cargo build --features gpu
    ```
@@ -217,25 +217,25 @@ DOCKER_BUILDKIT=1                 # Enable BuildKit for faster builds
 #### Container Inspection
 ```bash
 # Enter the container
-docker compose --profile dev exec webxr-dev bash
+docker compose -f docker-compose.dev.yml exec visionflow-xr bash
 
 # Check running processes
-docker compose --profile dev exec webxr-dev ps aux
+docker compose -f docker-compose.dev.yml exec visionflow-xr ps aux
 
 # Monitor resource usage
-docker compose --profile dev exec webxr-dev top
+docker compose -f docker-compose.dev.yml exec visionflow-xr top
 ```
 
 #### Log Analysis
 ```bash
 # All service logs
-docker compose --profile dev logs -f
+docker compose -f docker-compose.dev.yml logs -f
 
 # Specific service logs
-docker compose --profile dev logs -f webxr-dev
+docker compose -f docker-compose.dev.yml logs -f visionflow-xr
 
 # Rust application logs
-docker compose --profile dev exec webxr-dev tail -f /app/logs/rust_server.log
+docker compose -f docker-compose.dev.yml exec visionflow-xr tail -f /app/logs/rust_server.log
 ```
 
 #### Build Cache Management
@@ -301,10 +301,10 @@ docker volume inspect visionflow_cargo-target-cache
 1. **Run automated tests** (when available):
    ```bash
    # Rust tests
-   docker compose --profile dev exec webxr-dev cargo test
+   docker compose -f docker-compose.dev.yml exec visionflow-xr cargo test
 
    # Frontend tests
-   docker compose --profile dev exec frontend npm test
+   docker compose -f docker-compose.dev.yml exec frontend npm test
    ```
 
 2. **Manual testing**:
@@ -392,13 +392,13 @@ Recommended extensions:
 ./scripts/dev.sh --no-cache
 
 # View logs
-docker compose --profile dev logs -f
+docker compose -f docker-compose.dev.yml logs -f
 
 # Enter container
-docker compose --profile dev exec webxr-dev bash
+docker compose -f docker-compose.dev.yml exec visionflow-xr bash
 
 # Stop all services
-docker compose --profile dev down
+docker compose -f docker-compose.dev.yml down
 ```
 
 ### Support
diff --git a/docs/getting-started/installation.md b/docs/getting-started/installation.md
index bc5f141c..8e3ee2a8 100644
--- a/docs/getting-started/installation.md
+++ b/docs/getting-started/installation.md
@@ -201,10 +201,10 @@ docker-compose up -d
 docker-compose -f docker-compose.yml -f docker-compose.gpu.yml up -d
 
 # Development mode (with hot reload)
-docker-compose --profile dev up -d
+docker-compose -f docker-compose.dev.yml up -d
 
 # Production mode (optimised)
-docker-compose --profile production up -d
+docker-compose -f docker-compose.production.yml up -d
 ```
 
 #### Step 4: Verify Installation
@@ -351,7 +351,7 @@ npm run build
 cd ..
 
 # Start development services
-docker-compose --profile dev up
+docker-compose -f docker-compose.dev.yml up
 ```
 
 #### Step 3: Development Workflow
diff --git a/docs/research/new_cuda.md b/new_cuda.md
similarity index 100%
rename from docs/research/new_cuda.md
rename to new_cuda.md
diff --git a/nginx.conf b/nginx.conf
new file mode 100755
index 00000000..0eb69dfe
--- /dev/null
+++ b/nginx.conf
@@ -0,0 +1,220 @@
+# Use a standard, writable path for the PID file
+pid /var/run/nginx.pid;
+error_log /var/log/nginx/error.log crit;
+
+events {
+    worker_connections 1024;
+    multi_accept on;
+    use epoll;
+}
+
+http {
+    # Basic settings
+    include /etc/nginx/mime.types;
+    default_type application/octet-stream;
+    charset utf-8;
+
+    # Override TypeScript MIME type (overriding video/mp2t from mime.types)
+    types {
+        application/typescript ts;
+    }
+
+    # Logging
+    log_format debug_format '$remote_addr - $remote_user [$time_local] '
+                          '"$request" $status $body_bytes_sent '
+                          '"$http_referer" "$http_user_agent" '
+                          'rt=$request_time uct="$upstream_connect_time" uht="$upstream_header_time" urt="$upstream_response_time"'
+                          ' ws_status="$upstream_http_upgrade"';  # Added WebSocket status logging
+
+    access_log off;
+
+    # Optimization
+    sendfile on;
+    tcp_nopush on;
+    tcp_nodelay on;
+    keepalive_timeout 120;  # Increased to match cloudflared keepAliveTimeout
+    keepalive_requests 100;
+
+    # Gzip settings
+    gzip on;
+    gzip_disable "msie6";
+    gzip_vary on;
+    gzip_proxied any;
+    gzip_comp_level 6;
+    gzip_buffers 16 8k;
+    gzip_http_version 1.1;
+    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
+
+    # WebSocket configuration
+    map $http_upgrade $connection_upgrade {
+        default upgrade;
+        ''      close;
+    }
+
+    # Upstream backend definition for the Rust server
+    upstream backend {
+        server 127.0.0.1:3001;  # Use localhost since both services are in same container
+        keepalive 32;  # Keep connections alive
+    }
+
+    # Main server configuration
+    server {
+        listen 4000 default_server;  # Listen on port 4000 for external connections
+        server_name _;  # Accept any server name
+        root /app/client/dist;  # Set root to built client files directory
+
+        # Security headers
+        add_header Cross-Origin-Opener-Policy "same-origin" always;
+        add_header Cross-Origin-Embedder-Policy "require-corp" always;
+        add_header X-Content-Type-Options nosniff;
+        add_header X-Frame-Options SAMEORIGIN;
+        add_header X-XSS-Protection "1; mode=block";
+        add_header Referrer-Policy "same-origin" always;
+        add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline' 'unsafe-eval'; connect-src 'self' ws: wss: http: https: *.visionflow.info; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://getalby.com; frame-src 'self' https://getalby.com" always;
+        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
+
+        # WebSocket endpoint
+        location /wss {
+            proxy_pass http://backend;
+            proxy_http_version 1.1;
+            proxy_set_header Upgrade $http_upgrade;
+            proxy_set_header Connection $connection_upgrade;
+            proxy_set_header Host $host;
+
+            # Pass through Cloudflare headers
+            proxy_set_header CF-Connecting-IP $http_cf_connecting_ip;
+            proxy_set_header CF-Ray $http_cf_ray;
+            proxy_set_header CF-Visitor $http_cf_visitor;
+
+            # Standard proxy headers
+            proxy_set_header X-Real-IP $remote_addr;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;
+
+            # WebSocket timeouts
+            proxy_read_timeout 600m;  # Increased from 3600s to 600m (10 hours) to match websocketIdleTimeout
+            proxy_send_timeout 3600s;
+            proxy_connect_timeout 75s;
+            proxy_buffering off;
+            proxy_cache off;
+
+            # Debug logging
+            access_log /var/log/nginx/websocket.log debug_format;
+            error_log /var/log/nginx/websocket-error.log debug;
+        }
+
+        # Voice WebSocket endpoint
+        location /ws/speech {
+            proxy_pass http://backend;
+            proxy_http_version 1.1;
+            proxy_set_header Upgrade $http_upgrade;
+            proxy_set_header Connection $connection_upgrade;
+            proxy_set_header Host $host;
+
+            # Pass through Cloudflare headers
+            proxy_set_header CF-Connecting-IP $http_cf_connecting_ip;
+            proxy_set_header CF-Ray $http_cf_ray;
+            proxy_set_header CF-Visitor $http_cf_visitor;
+
+            # Standard proxy headers
+            proxy_set_header X-Real-IP $remote_addr;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;
+
+            # WebSocket timeouts
+            proxy_read_timeout 600m;
+            proxy_send_timeout 3600s;
+            proxy_connect_timeout 75s;
+            proxy_buffering off;
+            proxy_cache off;
+
+            # Debug logging
+            access_log /var/log/nginx/websocket.log debug_format;
+            error_log /var/log/nginx/websocket-error.log debug;
+        }
+
+        # MCP relay WebSocket endpoint
+        location /ws/mcp {
+            proxy_pass http://backend;
+            proxy_http_version 1.1;
+            proxy_set_header Upgrade $http_upgrade;
+            proxy_set_header Connection $connection_upgrade;
+            proxy_set_header Host $host;
+
+            # Pass through Cloudflare headers
+            proxy_set_header CF-Connecting-IP $http_cf_connecting_ip;
+            proxy_set_header CF-Ray $http_cf_ray;
+            proxy_set_header CF-Visitor $http_cf_visitor;
+
+            # Standard proxy headers
+            proxy_set_header X-Real-IP $remote_addr;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;
+
+            # WebSocket timeouts
+            proxy_read_timeout 600m;
+            proxy_send_timeout 3600s;
+            proxy_connect_timeout 75s;
+            proxy_buffering off;
+            proxy_cache off;
+
+            # Debug logging
+            access_log /var/log/nginx/mcp-websocket.log debug_format;
+            error_log /var/log/nginx/mcp-websocket-error.log debug;
+        }
+
+        # API endpoints
+        location /api {
+            proxy_pass http://backend;
+            proxy_http_version 1.1;
+            proxy_set_header Host $host;
+            proxy_set_header X-Real-IP $remote_addr;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            proxy_set_header X-Forwarded-Proto $scheme;
+
+            # API specific settings
+            proxy_read_timeout 120s;  # Increased for larger graph data
+            proxy_send_timeout 120s;  # Increased for larger graph data
+            proxy_connect_timeout 60s;
+            proxy_buffering on;       # Enable buffering for API responses
+            proxy_buffer_size 256k;   # Increased for larger responses
+            proxy_buffers 8 256k;     # Increased number of buffers
+            proxy_busy_buffers_size 512k;  # Increased for larger responses
+            proxy_max_temp_file_size 2048m;  # Allow larger temporary files
+            add_header Cache-Control "no-store" always;  # Prevent caching of dynamic data
+        }
+
+        # Static files
+        location / {
+            try_files $uri $uri/ /index.html =404;
+            expires 1h;
+            add_header Cache-Control "public, no-transform";
+            # error_page 404 = @backend;  # Remove fallback for root, let try_files handle index.html
+        }
+
+        # Static files with proper MIME types
+        location /assets/ {
+            expires 7d;
+            add_header Cache-Control "public, no-transform" always;
+            try_files $uri =404;
+            access_log off;
+        }
+
+        # Fallback location for static files
+        location @backend {
+            proxy_pass http://backend;
+            proxy_http_version 1.1;
+            proxy_set_header Host $host;
+            proxy_set_header X-Real-IP $remote_addr;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            proxy_set_header X-Forwarded-Proto $scheme;
+        }
+
+        # Error pages
+        error_page 404 /404.html;
+        error_page 500 502 503 504 /50x.html;
+        location = /50x.html {
+            root /usr/share/nginx/html;
+        }
+    }
+}
diff --git a/nginx.conf.template b/nginx.conf.template
deleted file mode 100644
index 88f80dd3..00000000
--- a/nginx.conf.template
+++ /dev/null
@@ -1,290 +0,0 @@
-# VisionFlow Nginx Configuration Template
-# Environment-based configuration for both development and production
-
-pid /var/run/nginx.pid;
-error_log /var/log/nginx/error.log ${NGINX_LOG_LEVEL:-crit};
-
-events {
-    worker_connections ${NGINX_WORKER_CONNECTIONS:-1024};
-    multi_accept ${NGINX_MULTI_ACCEPT:-on};
-    use epoll;
-}
-
-http {
-    include /etc/nginx/mime.types;
-    default_type application/octet-stream;
-    charset utf-8;
-
-    # Custom MIME types
-    types {
-        application/typescript ts;
-        application/javascript js mjs;
-        text/jsx jsx;
-        text/tsx tsx;
-    }
-
-    # Logging
-    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
-                    '$status $body_bytes_sent "$http_referer" '
-                    '"$http_user_agent" "$http_x_forwarded_for"';
-    
-    log_format debug_format '$remote_addr - $remote_user [$time_local] '
-                          '"$request" $status $body_bytes_sent '
-                          '"$http_referer" "$http_user_agent" '
-                          'rt=$request_time uct="$upstream_connect_time" '
-                          'uht="$upstream_header_time" urt="$upstream_response_time"'
-                          ' ws_status="$upstream_http_upgrade"';
-
-    access_log ${NGINX_ACCESS_LOG:-off};
-
-    # Performance optimisations
-    sendfile on;
-    tcp_nopush on;
-    tcp_nodelay on;
-    keepalive_timeout ${NGINX_KEEPALIVE_TIMEOUT:-120};
-    keepalive_requests ${NGINX_KEEPALIVE_REQUESTS:-100};
-    client_max_body_size ${NGINX_MAX_BODY_SIZE:-100M};
-
-    # Gzip compression
-    gzip on;
-    gzip_disable "msie6";
-    gzip_vary on;
-    gzip_proxied any;
-    gzip_comp_level 6;
-    gzip_types text/plain text/css application/json application/javascript 
-               text/xml application/xml application/xml+rss text/javascript
-               application/typescript text/jsx text/tsx;
-
-    # WebSocket upgrade mapping
-    map $http_upgrade $connection_upgrade {
-        default upgrade;
-        ''      close;
-    }
-
-    # Upstream services
-    upstream backend {
-        server 127.0.0.1:${BACKEND_PORT:-4000};
-        keepalive 32;
-    }
-
-    upstream frontend {
-        server 127.0.0.1:${FRONTEND_PORT:-5173};
-        keepalive 32;
-    }
-
-    # Main server block
-    server {
-        listen ${NGINX_PORT:-3001} default_server;
-        server_name ${NGINX_SERVER_NAME:-_};
-        root ${NGINX_ROOT:-/app/client/dist};
-        index index.html;
-
-        # Security headers
-        add_header Cross-Origin-Opener-Policy "same-origin" always;
-        add_header Cross-Origin-Embedder-Policy "require-corp" always;
-        add_header X-Content-Type-Options "nosniff" always;
-        add_header X-Frame-Options "${NGINX_FRAME_OPTIONS:-SAMEORIGIN}" always;
-        add_header X-XSS-Protection "1; mode=block" always;
-        add_header Referrer-Policy "${NGINX_REFERRER_POLICY:-same-origin}" always;
-        
-        # Environment-specific CSP
-        add_header Content-Security-Policy "${NGINX_CSP:-default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' ws: wss: http: https:; font-src 'self' data:;}" always;
-        
-        # HSTS (production only)
-        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains${NGINX_HSTS_PRELOAD:+; preload}" always;
-
-        # === API ENDPOINTS ===
-        location /api/ {
-            proxy_pass http://backend;
-            proxy_http_version 1.1;
-            
-            # Cloudflare headers (production)
-            proxy_set_header CF-Connecting-IP $http_cf_connecting_ip;
-            proxy_set_header CF-Ray $http_cf_ray;
-            proxy_set_header CF-Visitor $http_cf_visitor;
-            proxy_set_header CF-IPCountry $http_cf_ipcountry;
-            
-            # Standard headers
-            proxy_set_header Host $host;
-            proxy_set_header X-Real-IP ${NGINX_REAL_IP_FROM_CF:-$remote_addr};
-            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
-            proxy_set_header X-Forwarded-Proto ${NGINX_FORWARDED_PROTO:-$scheme};
-            
-            # Timeouts
-            proxy_connect_timeout 60s;
-            proxy_send_timeout 300s;
-            proxy_read_timeout 300s;
-            
-            # Performance
-            proxy_buffering ${NGINX_API_BUFFERING:-on};
-            proxy_buffer_size 4k;
-            proxy_buffers 8 4k;
-            proxy_busy_buffers_size 8k;
-        }
-
-        # === WEBSOCKET ENDPOINTS ===
-        location ~ ^/(wss|ws/speech|ws/mcp)$ {
-            proxy_pass http://backend;
-            proxy_http_version 1.1;
-            proxy_set_header Upgrade $http_upgrade;
-            proxy_set_header Connection $connection_upgrade;
-            
-            # Cloudflare headers (production)
-            proxy_set_header CF-Connecting-IP $http_cf_connecting_ip;
-            proxy_set_header CF-Ray $http_cf_ray;
-            proxy_set_header CF-Visitor $http_cf_visitor;
-            
-            # Standard headers
-            proxy_set_header Host $host;
-            proxy_set_header X-Real-IP ${NGINX_REAL_IP_FROM_CF:-$remote_addr};
-            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
-            proxy_set_header X-Forwarded-Proto ${NGINX_FORWARDED_PROTO:-$scheme};
-            
-            # WebSocket timeouts
-            proxy_read_timeout 3600s;
-            proxy_send_timeout 3600s;
-            proxy_connect_timeout 75s;
-            
-            # Disable buffering for real-time
-            proxy_buffering off;
-            proxy_cache off;
-            tcp_nodelay on;
-
-            # Debug logging (development only)
-            access_log ${NGINX_WS_ACCESS_LOG:-/var/log/nginx/websocket.log} ${NGINX_WS_LOG_FORMAT:-debug_format};
-            error_log ${NGINX_WS_ERROR_LOG:-/var/log/nginx/websocket-error.log} ${NGINX_WS_ERROR_LEVEL:-debug};
-        }
-
-        # === DEVELOPMENT-SPECIFIC ROUTES ===
-        # Vite HMR WebSocket (development only)
-        location /__vite_hmr {
-            proxy_pass http://frontend/__vite_hmr;
-            proxy_http_version 1.1;
-            proxy_set_header Upgrade $http_upgrade;
-            proxy_set_header Connection $connection_upgrade;
-            proxy_set_header Host $host;
-            proxy_set_header X-Real-IP $remote_addr;
-            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
-            proxy_read_timeout 3600s;
-            proxy_send_timeout 3600s;
-            proxy_buffering off;
-            tcp_nodelay on;
-        }
-
-        # Vite special endpoints (development only)
-        location ~ ^/(\.vite|node_modules|@vite|@react-refresh|@id|@fs|src) {
-            proxy_pass http://frontend;
-            proxy_http_version 1.1;
-            proxy_set_header Host $host;
-            proxy_set_header X-Real-IP $remote_addr;
-            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
-            
-            # Cache control for development
-            add_header Cache-Control "no-cache, no-store, must-revalidate";
-            add_header Pragma "no-cache";
-            add_header Expires "0";
-        }
-
-        # === STATIC FILE HANDLING ===
-        # Static assets with caching (production)
-        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
-            # Production: serve from disk
-            # Development: proxy to Vite
-            try_files $uri @${NGINX_STATIC_FALLBACK:-production_static};
-            
-            expires ${NGINX_STATIC_EXPIRES:-30d};
-            add_header Cache-Control "${NGINX_STATIC_CACHE_CONTROL:-public, immutable}";
-            
-            # Security headers still apply
-            add_header Cross-Origin-Opener-Policy "same-origin" always;
-            add_header Cross-Origin-Embedder-Policy "require-corp" always;
-            add_header X-Content-Type-Options "nosniff" always;
-        }
-
-        # Fallback for static assets in development
-        location @development_static {
-            proxy_pass http://frontend;
-            proxy_http_version 1.1;
-            proxy_set_header Host $host;
-            
-            # Development cache headers
-            add_header Cache-Control "no-cache, must-revalidate";
-        }
-
-        # Fallback for static assets in production
-        location @production_static {
-            return 404;
-        }
-
-        # HTML files - no cache for updates
-        location ~* \.html$ {
-            expires -1;
-            add_header Cache-Control "no-cache, no-store, must-revalidate";
-            
-            # Security headers
-            add_header Cross-Origin-Opener-Policy "same-origin" always;
-            add_header Cross-Origin-Embedder-Policy "require-corp" always;
-            add_header X-Content-Type-Options "nosniff" always;
-            
-            try_files $uri ${NGINX_HTML_FALLBACK:-/index.html};
-        }
-
-        # Root location
-        location / {
-            # Production: serve built files from disk
-            # Development: proxy to Vite dev server
-            try_files $uri $uri/ @${NGINX_ROOT_FALLBACK:-production_root};
-            
-            # Cache control
-            expires ${NGINX_ROOT_EXPIRES:--1};
-            add_header Cache-Control "${NGINX_ROOT_CACHE_CONTROL:-no-cache, no-store, must-revalidate}";
-        }
-
-        # Development root fallback
-        location @development_root {
-            proxy_pass http://frontend;
-            proxy_http_version 1.1;
-            proxy_set_header Host $host;
-            proxy_set_header X-Real-IP $remote_addr;
-            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
-            
-            # Support for client-side routing
-            proxy_intercept_errors on;
-            error_page 404 = @vite_fallback;
-        }
-
-        # Production root fallback
-        location @production_root {
-            try_files /index.html =404;
-        }
-
-        # Vite fallback for client-side routing (development)
-        location @vite_fallback {
-            rewrite ^ /index.html break;
-            proxy_pass http://frontend;
-            proxy_http_version 1.1;
-            proxy_set_header Host $host;
-            proxy_set_header X-Real-IP $remote_addr;
-            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
-        }
-
-        # Cloudflare verification endpoint (production)
-        location /.well-known/cf-custom-hostname-challenge {
-            proxy_pass http://backend;
-        }
-
-        # Health check endpoint
-        location /health {
-            access_log off;
-            return 200 "healthy\n";
-            add_header Content-Type text/plain;
-        }
-
-        # Error pages
-        error_page 404 /404.html;
-        error_page 500 502 503 504 /50x.html;
-        location = /50x.html {
-            root /usr/share/nginx/html;
-        }
-    }
-}
\ No newline at end of file
diff --git a/nginx.dev.conf b/nginx.dev.conf
new file mode 100644
index 00000000..fb9f1d51
--- /dev/null
+++ b/nginx.dev.conf
@@ -0,0 +1,214 @@
+# VisionFlow Development Nginx Configuration
+# Provides unified entry point on port 3001 for all services
+
+pid /var/run/nginx.pid;
+error_log /var/log/nginx/error.log crit;
+
+events {
+    worker_connections 1024;
+}
+
+http {
+    include /etc/nginx/mime.types;
+    default_type application/octet-stream;
+    charset utf-8;
+
+    # Custom MIME types for development
+    # 'ts' and 'js' are removed as they are often predefined, causing warnings.
+    types {
+        text/jsx jsx;
+        text/tsx tsx;
+    }
+
+    # Logging
+    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
+                    '$status $body_bytes_sent "$http_referer" '
+                    '"$http_user_agent" "$http_x_forwarded_for"';
+    access_log off;
+
+    # Performance
+    sendfile on;
+    tcp_nopush on;
+    tcp_nodelay on;
+    keepalive_timeout 65;
+    client_max_body_size 100M;
+
+    # WebSocket upgrade mapping
+    map $http_upgrade $connection_upgrade {
+        default upgrade;
+        ''      close;
+    }
+
+    # Upstream services
+    upstream rust_backend {
+        server 127.0.0.1:4000;
+        keepalive 32;
+    }
+
+    upstream vite_frontend {
+        server 127.0.0.1:5173;
+        keepalive 32;
+    }
+
+    # Main server block - Development entry point
+    server {
+        listen 3001 default_server;
+        server_name localhost;
+
+        # Security headers for SharedArrayBuffer and cross-origin isolation
+        add_header Cross-Origin-Opener-Policy "same-origin" always;
+        add_header Cross-Origin-Embedder-Policy "require-corp" always;
+        add_header X-Content-Type-Options "nosniff" always;
+
+        # === BACKEND ROUTES ===
+        
+        # REST API endpoints
+        location /api/ {
+            proxy_pass http://rust_backend;
+            proxy_http_version 1.1;
+            proxy_set_header Host $host;
+            proxy_set_header X-Real-IP $remote_addr;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            proxy_set_header X-Forwarded-Proto $scheme;
+            
+            # Timeouts for long-running operations
+            proxy_connect_timeout 60s;
+            proxy_send_timeout 300s;
+            proxy_read_timeout 300s;
+            
+            # Disable buffering for SSE/streaming responses
+            proxy_buffering off;
+            proxy_cache off;
+        }
+
+        # WebSocket endpoint for graph data
+        location /wss {
+            proxy_pass http://rust_backend;
+            proxy_http_version 1.1;
+            proxy_set_header Upgrade $http_upgrade;
+            proxy_set_header Connection $connection_upgrade;
+            proxy_set_header Host $host;
+            proxy_set_header X-Real-IP $remote_addr;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            
+            # Long timeout for persistent connections
+            proxy_read_timeout 3600s;
+            proxy_send_timeout 3600s;
+            
+            # Disable buffering for real-time data
+            proxy_buffering off;
+            tcp_nodelay on;
+        }
+
+        # WebSocket endpoint for speech services
+        location /ws/speech {
+            proxy_pass http://rust_backend;
+            proxy_http_version 1.1;
+            proxy_set_header Upgrade $http_upgrade;
+            proxy_set_header Connection $connection_upgrade;
+            proxy_set_header Host $host;
+            proxy_set_header X-Real-IP $remote_addr;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            
+            # Long timeout for persistent connections
+            proxy_read_timeout 3600s;
+            proxy_send_timeout 3600s;
+            
+            # Disable buffering for real-time data
+            proxy_buffering off;
+            tcp_nodelay on;
+        }
+
+        # WebSocket endpoint for MCP relay
+        location /ws/mcp-relay {
+            proxy_pass http://rust_backend;
+            proxy_http_version 1.1;
+            proxy_set_header Upgrade $http_upgrade;
+            proxy_set_header Connection $connection_upgrade;
+            proxy_set_header Host $host;
+            proxy_set_header X-Real-IP $remote_addr;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            
+            # Long timeout for persistent connections
+            proxy_read_timeout 3600s;
+            proxy_send_timeout 3600s;
+            
+            # Disable buffering for real-time data
+            proxy_buffering off;
+            tcp_nodelay on;
+        }
+
+        # === VITE DEV SERVER ROUTES ===
+        
+        # Vite HMR WebSocket - MUST come before root location
+        location /__vite_hmr {
+            proxy_pass http://vite_frontend/__vite_hmr;
+            proxy_http_version 1.1;
+            proxy_set_header Upgrade $http_upgrade;
+            proxy_set_header Connection $connection_upgrade;
+            proxy_set_header Host $host;
+            proxy_set_header X-Real-IP $remote_addr;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            proxy_read_timeout 3600s;
+            proxy_send_timeout 3600s;
+            proxy_buffering off;
+            tcp_nodelay on;
+        }
+
+        # Vite special endpoints
+        location ~ ^/(\.vite|node_modules|@vite|@react-refresh|@id|@fs|src) {
+            proxy_pass http://vite_frontend;
+            proxy_http_version 1.1;
+            proxy_set_header Host $host;
+            proxy_set_header X-Real-IP $remote_addr;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            
+            # Cache control for development
+            add_header Cache-Control "no-cache, no-store, must-revalidate";
+            add_header Pragma "no-cache";
+            add_header Expires "0";
+        }
+
+        # Static assets with proper MIME types
+        location ~* \.(js|jsx|ts|tsx|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
+            proxy_pass http://vite_frontend;
+            proxy_http_version 1.1;
+            proxy_set_header Host $host;
+            
+            # Development cache headers
+            add_header Cache-Control "no-cache, must-revalidate";
+        }
+
+        # Root - Frontend application (must be last)
+        location / {
+            proxy_pass http://vite_frontend;
+            proxy_http_version 1.1;
+            proxy_set_header Host $host;
+            proxy_set_header X-Real-IP $remote_addr;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            
+            # Support for client-side routing
+            proxy_intercept_errors on;
+            error_page 404 = @vite_fallback;
+        }
+
+        # Fallback for client-side routing
+        location @vite_fallback {
+            # Rewrite the request to the root index.html for the SPA.
+            # This is the correct way to handle proxy_pass in a named location.
+            rewrite ^ /index.html break;
+            proxy_pass http://vite_frontend;
+            proxy_http_version 1.1;
+            proxy_set_header Host $host;
+            proxy_set_header X-Real-IP $remote_addr;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+        }
+
+        # Health check endpoint
+        location /health {
+            access_log off;
+            return 200 "healthy\n";
+            add_header Content-Type text/plain;
+        }
+    }
+}
\ No newline at end of file
diff --git a/nginx.production.conf b/nginx.production.conf
new file mode 100644
index 00000000..6ba4a3ee
--- /dev/null
+++ b/nginx.production.conf
@@ -0,0 +1,192 @@
+# VisionFlow Production Nginx Configuration
+# Optimised for Cloudflare Tunnel with HTTPS termination
+
+pid /var/run/nginx.pid;
+error_log /var/log/nginx/error.log crit;
+
+events {
+    worker_connections 2048;
+    multi_accept on;
+    use epoll;
+}
+
+http {
+    include /etc/nginx/mime.types;
+    default_type application/octet-stream;
+    charset utf-8;
+
+    # Custom MIME types
+    types {
+        application/typescript ts;
+        application/javascript js mjs;
+        text/jsx jsx;
+        text/tsx tsx;
+    }
+
+    # Logging
+    log_format production '$remote_addr - $remote_user [$time_local] '
+                         '"$request" $status $body_bytes_sent '
+                         '"$http_referer" "$http_user_agent" '
+                         'rt=$request_time uct="$upstream_connect_time" '
+                         'CF-Ray=$http_cf_ray CF-Connecting-IP=$http_cf_connecting_ip';
+    
+    access_log off;
+
+    # Performance optimisations
+    sendfile on;
+    tcp_nopush on;
+    tcp_nodelay on;
+    keepalive_timeout 120;
+    keepalive_requests 100;
+    client_max_body_size 100M;
+
+    # Gzip compression
+    gzip on;
+    gzip_disable "msie6";
+    gzip_vary on;
+    gzip_proxied any;
+    gzip_comp_level 6;
+    gzip_types text/plain text/css application/json application/javascript 
+               text/xml application/xml application/xml+rss text/javascript
+               application/typescript text/jsx text/tsx;
+
+    # WebSocket upgrade mapping
+    map $http_upgrade $connection_upgrade {
+        default upgrade;
+        ''      close;
+    }
+
+    # Rust backend upstream
+    upstream rust_backend {
+        server 127.0.0.1:3001;
+        keepalive 64;
+        keepalive_timeout 120s;
+    }
+
+    # Main server - Production
+    server {
+        listen 4000 default_server;
+        server_name _;
+        root /app/client/dist;
+        index index.html;
+
+        # Security headers for production
+        add_header Cross-Origin-Opener-Policy "same-origin" always;
+        add_header Cross-Origin-Embedder-Policy "require-corp" always;
+        add_header X-Content-Type-Options "nosniff" always;
+        add_header X-Frame-Options "SAMEORIGIN" always;
+        add_header X-XSS-Protection "1; mode=block" always;
+        add_header Referrer-Policy "strict-origin-when-cross-origin" always;
+        
+        # CSP for production - tighter than dev
+        add_header Content-Security-Policy "default-src 'self' https:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://getalby.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' wss: https:; frame-src 'self' https://getalby.com; font-src 'self' data:;" always;
+        
+        # HSTS handled by Cloudflare, but include as backup
+        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
+
+        # API endpoints
+        location /api/ {
+            proxy_pass http://rust_backend;
+            proxy_http_version 1.1;
+            
+            # Cloudflare headers
+            proxy_set_header CF-Connecting-IP $http_cf_connecting_ip;
+            proxy_set_header CF-Ray $http_cf_ray;
+            proxy_set_header CF-Visitor $http_cf_visitor;
+            proxy_set_header CF-IPCountry $http_cf_ipcountry;
+            
+            # Standard headers
+            proxy_set_header Host $host;
+            proxy_set_header X-Real-IP $http_cf_connecting_ip;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            proxy_set_header X-Forwarded-Proto https; # Always HTTPS from Cloudflare
+            
+            # Timeouts
+            proxy_connect_timeout 60s;
+            proxy_send_timeout 300s;
+            proxy_read_timeout 300s;
+            
+            # Performance
+            proxy_buffering on;
+            proxy_buffer_size 4k;
+            proxy_buffers 8 4k;
+            proxy_busy_buffers_size 8k;
+        }
+
+        # WebSocket endpoints
+        location ~ ^/(wss|ws/speech|ws/mcp-relay)$ {
+            proxy_pass http://rust_backend;
+            proxy_http_version 1.1;
+            proxy_set_header Upgrade $http_upgrade;
+            proxy_set_header Connection $connection_upgrade;
+            
+            # Cloudflare headers
+            proxy_set_header CF-Connecting-IP $http_cf_connecting_ip;
+            proxy_set_header CF-Ray $http_cf_ray;
+            proxy_set_header CF-Visitor $http_cf_visitor;
+            
+            # Standard headers
+            proxy_set_header Host $host;
+            proxy_set_header X-Real-IP $http_cf_connecting_ip;
+            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+            proxy_set_header X-Forwarded-Proto https;
+            
+            # WebSocket timeouts (Cloudflare has 100s timeout)
+            proxy_read_timeout 3600s;
+            proxy_send_timeout 3600s;
+            proxy_connect_timeout 75s;
+            
+            # Disable buffering for real-time
+            proxy_buffering off;
+            proxy_cache off;
+            tcp_nodelay on;
+        }
+
+        # Static assets with caching
+        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
+            expires 30d;
+            add_header Cache-Control "public, immutable";
+            
+            # Security headers still apply
+            add_header Cross-Origin-Opener-Policy "same-origin" always;
+            add_header Cross-Origin-Embedder-Policy "require-corp" always;
+            add_header X-Content-Type-Options "nosniff" always;
+            
+            try_files $uri =404;
+        }
+
+        # HTML files - no cache for updates
+        location ~* \.html$ {
+            expires -1;
+            add_header Cache-Control "no-cache, no-store, must-revalidate";
+            
+            # Security headers
+            add_header Cross-Origin-Opener-Policy "same-origin" always;
+            add_header Cross-Origin-Embedder-Policy "require-corp" always;
+            add_header X-Content-Type-Options "nosniff" always;
+            
+            try_files $uri /index.html;
+        }
+
+        # Root - serve React app
+        location / {
+            try_files $uri $uri/ /index.html;
+            
+            # Cache control for root
+            expires -1;
+            add_header Cache-Control "no-cache, no-store, must-revalidate";
+        }
+
+        # Health check endpoint
+        location /health {
+            access_log off;
+            return 200 "healthy\n";
+            add_header Content-Type text/plain;
+        }
+
+        # Cloudflare verification endpoint
+        location /.well-known/cf-custom-hostname-challenge {
+            proxy_pass http://rust_backend;
+        }
+    }
+}
\ No newline at end of file
diff --git a/docs/research/owl.md b/owl.md
similarity index 100%
rename from docs/research/owl.md
rename to owl.md
diff --git a/rebuild.sh b/rebuild.sh
deleted file mode 100755
index bc186763..00000000
--- a/rebuild.sh
+++ /dev/null
@@ -1,22 +0,0 @@
-#!/bin/bash
-# Force rebuild of the container with the new script
-
-echo "Stopping existing containers..."
-docker stop visionflow_container 2>/dev/null || true
-docker rm visionflow_container 2>/dev/null || true
-
-echo "Rebuilding container with new configuration..."
-cd /workspace/ext
-
-# Use docker-compose with the correct syntax for your Docker version
-if command -v docker-compose &> /dev/null; then
-    # Old docker-compose command
-    docker-compose --profile dev build --no-cache
-    docker-compose --profile dev up
-else
-    # New docker compose command (plugin)
-    docker compose --profile dev build --no-cache
-    docker compose --profile dev up
-fi
-
-echo "Container rebuilt and started!"
\ No newline at end of file
diff --git a/scripts/dev-rebuild-rust.sh b/scripts/dev-rebuild-rust.sh
index 806f4745..f33991a1 100755
--- a/scripts/dev-rebuild-rust.sh
+++ b/scripts/dev-rebuild-rust.sh
@@ -16,7 +16,7 @@ rebuild_rust() {
     echo -e "${YELLOW}Rebuilding Rust server...${NC}"
     
     # Execute cargo build inside the container
-    docker compose --profile dev exec webxr-dev bash -c "
+    docker compose -f docker-compose.dev.yml exec visionflow-xr bash -c "
         cd /app && \
         echo 'Building with GPU features...' && \
         cargo build --features gpu && \
@@ -38,12 +38,12 @@ restart_rust_server() {
     echo -e "${YELLOW}Restarting Rust server...${NC}"
     
     # Kill the existing Rust process
-    docker compose --profile dev exec webxr-dev bash -c "
+    docker compose -f docker-compose.dev.yml exec visionflow-xr bash -c "
         pkill -f webxr || true
     "
     
     # Start the new process
-    docker compose --profile dev exec -d webxr-dev bash -c "
+    docker compose -f docker-compose.dev.yml exec -d visionflow-xr bash -c "
         cd /app && \
         ./webxr --gpu-debug > /app/logs/rust_server.log 2>&1
     "
@@ -54,8 +54,8 @@ restart_rust_server() {
 # Main execution
 main() {
     # Check if container is running
-    if ! docker compose --profile dev ps | grep -q "webxr-dev.*running"; then
-        echo -e "${RED}Error: webxr-dev container is not running${NC}"
+    if ! docker compose -f docker-compose.dev.yml ps | grep -q "visionflow-xr.*running"; then
+        echo -e "${RED}Error: visionflow-xr container is not running${NC}"
         echo "Please start the container first with: ./scripts/dev.sh"
         exit 1
     fi
@@ -67,7 +67,7 @@ main() {
         
         # Show logs
         echo -e "${YELLOW}Tailing Rust server logs (Ctrl+C to exit)...${NC}"
-        docker compose --profile dev exec webxr-dev tail -f /app/logs/rust_server.log
+        docker compose -f docker-compose.dev.yml exec visionflow-xr tail -f /app/logs/rust_server.log
     else
         echo -e "${RED}Rebuild failed. Please check the errors above.${NC}"
         exit 1
diff --git a/scripts/docker_clean_build.sh b/scripts/docker_clean_build.sh
index 391827f6..967630ba 100755
--- a/scripts/docker_clean_build.sh
+++ b/scripts/docker_clean_build.sh
@@ -51,7 +51,7 @@ if [ $? -eq 0 ]; then
     echo -e "${GREEN}‚úì Docker build completed successfully!${NC}"
     echo ""
     echo "Next steps:"
-    echo "1. Run: docker-compose --profile dev up"
+    echo "1. Run: docker-compose -f docker-compose.dev.yml up"
     echo "2. Access the application at http://localhost:3001"
 else
     echo ""
diff --git a/scripts/generate-nginx-config.sh b/scripts/generate-nginx-config.sh
deleted file mode 100755
index f57efb3f..00000000
--- a/scripts/generate-nginx-config.sh
+++ /dev/null
@@ -1,92 +0,0 @@
-#!/bin/bash
-# Generate nginx configuration from environment variables
-
-set -e
-
-# Input args
-TEMPLATE="${1:-/app/nginx.conf.template}"
-ENV_FILE="${2:-/dev/null}"  # Ignored, kept for compatibility
-OUTPUT="${3:-/etc/nginx/nginx.conf}"
-
-echo "[nginx-config] Generating nginx configuration..."
-
-# Check if template exists
-if [ ! -f "$TEMPLATE" ]; then
-    echo "[nginx-config] ERROR: Template not found: $TEMPLATE"
-    exit 1
-fi
-
-# Set default values for all nginx variables if not already set
-export NGINX_WORKER_PROCESSES="${NGINX_WORKER_PROCESSES:-auto}"
-export NGINX_WORKER_CONNECTIONS="${NGINX_WORKER_CONNECTIONS:-1024}"
-export NGINX_KEEPALIVE_TIMEOUT="${NGINX_KEEPALIVE_TIMEOUT:-65}"
-export NGINX_CLIENT_MAX_BODY_SIZE="${NGINX_CLIENT_MAX_BODY_SIZE:-100M}"
-export NGINX_PROXY_BUFFER_SIZE="${NGINX_PROXY_BUFFER_SIZE:-8k}"
-export NGINX_PROXY_BUFFERS="${NGINX_PROXY_BUFFERS:-16 8k}"
-export NGINX_PROXY_BUSY_BUFFERS_SIZE="${NGINX_PROXY_BUSY_BUFFERS_SIZE:-32k}"
-export NGINX_GZIP="${NGINX_GZIP:-on}"
-export NGINX_GZIP_COMP_LEVEL="${NGINX_GZIP_COMP_LEVEL:-6}"
-export NGINX_ACCESS_LOG="${NGINX_ACCESS_LOG:-/var/log/nginx/access.log combined}"
-export NGINX_ERROR_LOG="${NGINX_ERROR_LOG:-/var/log/nginx/error.log warn}"
-export NGINX_CSP="${NGINX_CSP:-default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'}"
-export NGINX_REAL_IP_FROM_CF="${NGINX_REAL_IP_FROM_CF:-\$remote_addr}"
-export NGINX_FORWARDED_PROTO="${NGINX_FORWARDED_PROTO:-\$scheme}"
-
-# Additional variables that may be missing
-export NGINX_LOG_LEVEL="${NGINX_LOG_LEVEL:-warn}"
-export NGINX_MULTI_ACCEPT="${NGINX_MULTI_ACCEPT:-on}"
-export NGINX_MAX_BODY_SIZE="${NGINX_MAX_BODY_SIZE:-100M}"
-export NGINX_KEEPALIVE_REQUESTS="${NGINX_KEEPALIVE_REQUESTS:-100}"
-export BACKEND_PORT="${BACKEND_PORT:-4000}"
-export FRONTEND_PORT="${FRONTEND_PORT:-5173}"
-export NGINX_PORT="${NGINX_PORT:-3001}"
-export NGINX_SERVER_NAME="${NGINX_SERVER_NAME:-_}"
-export NGINX_ROOT="${NGINX_ROOT:-/app/client/dist}"
-export NGINX_FRAME_OPTIONS="${NGINX_FRAME_OPTIONS:-SAMEORIGIN}"
-export NGINX_REFERRER_POLICY="${NGINX_REFERRER_POLICY:-same-origin}"
-export NGINX_HSTS_PRELOAD="${NGINX_HSTS_PRELOAD:-}"
-export NGINX_API_BUFFERING="${NGINX_API_BUFFERING:-off}"
-export NGINX_WS_ACCESS_LOG="${NGINX_WS_ACCESS_LOG:-/var/log/nginx/websocket.log}"
-export NGINX_WS_LOG_FORMAT="${NGINX_WS_LOG_FORMAT:-debug_format}"
-export NGINX_WS_ERROR_LOG="${NGINX_WS_ERROR_LOG:-/var/log/nginx/websocket-error.log}"
-export NGINX_WS_ERROR_LEVEL="${NGINX_WS_ERROR_LEVEL:-debug}"
-export NGINX_STATIC_FALLBACK="${NGINX_STATIC_FALLBACK:-development_static}"
-export NGINX_STATIC_EXPIRES="${NGINX_STATIC_EXPIRES:-30d}"
-export NGINX_STATIC_CACHE_CONTROL="${NGINX_STATIC_CACHE_CONTROL:-public, immutable}"
-export NGINX_HTML_FALLBACK="${NGINX_HTML_FALLBACK:-/index.html}"
-export NGINX_ROOT_FALLBACK="${NGINX_ROOT_FALLBACK:-development_root}"
-export NGINX_ROOT_EXPIRES="${NGINX_ROOT_EXPIRES:--1}"
-export NGINX_ROOT_CACHE_CONTROL="${NGINX_ROOT_CACHE_CONTROL:-no-cache, no-store, must-revalidate}"
-
-# Generate the config with envsubst
-# Use specific variable list to avoid replacing nginx variables like $uri
-VARS='$NGINX_LOG_LEVEL $NGINX_WORKER_PROCESSES $NGINX_WORKER_CONNECTIONS $NGINX_MULTI_ACCEPT
-$NGINX_KEEPALIVE_TIMEOUT $NGINX_KEEPALIVE_REQUESTS $NGINX_CLIENT_MAX_BODY_SIZE $NGINX_MAX_BODY_SIZE
-$NGINX_PROXY_BUFFER_SIZE $NGINX_PROXY_BUFFERS $NGINX_PROXY_BUSY_BUFFERS_SIZE 
-$NGINX_GZIP $NGINX_GZIP_COMP_LEVEL $NGINX_ACCESS_LOG $NGINX_ERROR_LOG 
-$NGINX_CSP $NGINX_REAL_IP_FROM_CF $NGINX_FORWARDED_PROTO
-$BACKEND_PORT $FRONTEND_PORT $NGINX_PORT $NGINX_SERVER_NAME $NGINX_ROOT
-$NGINX_FRAME_OPTIONS $NGINX_REFERRER_POLICY $NGINX_HSTS_PRELOAD
-$NGINX_API_BUFFERING $NGINX_WS_ACCESS_LOG $NGINX_WS_LOG_FORMAT
-$NGINX_WS_ERROR_LOG $NGINX_WS_ERROR_LEVEL
-$NGINX_STATIC_FALLBACK $NGINX_STATIC_EXPIRES $NGINX_STATIC_CACHE_CONTROL
-$NGINX_HTML_FALLBACK $NGINX_ROOT_FALLBACK $NGINX_ROOT_EXPIRES $NGINX_ROOT_CACHE_CONTROL'
-
-envsubst "$VARS" < "$TEMPLATE" > "$OUTPUT"
-
-echo "[nginx-config] Configuration generated successfully at $OUTPUT"
-
-# Validate nginx config if nginx is available
-if command -v nginx &> /dev/null; then
-    echo "[nginx-config] Validating configuration..."
-    if nginx -t -c "$OUTPUT" 2>&1; then
-        echo "[nginx-config] Configuration is valid"
-    else
-        echo "[nginx-config] WARNING: Configuration validation failed, but file was generated"
-        # Don't exit with error since the config was generated
-    fi
-else
-    echo "[nginx-config] WARNING: nginx command not found, skipping validation"
-fi
-
-exit 0
\ No newline at end of file
diff --git a/scripts/launch.sh b/scripts/launch.sh
index fc5e5d9c..29e705b6 100755
--- a/scripts/launch.sh
+++ b/scripts/launch.sh
@@ -61,8 +61,6 @@ ${YELLOW}Commands:${NC}
     status      Show container status
     build       Build containers (with GPU if available)
     clean       Clean all containers and volumes
-    diagnose    Diagnose nginx and service issues
-    fix-nginx   Attempt to fix nginx configuration
 
 ${YELLOW}Options:${NC}
     -p, --profile PROFILE    Environment profile (dev|production|prod) [default: dev]
@@ -83,10 +81,6 @@ ${YELLOW}Environment Variables:${NC}
     CUDA_ARCH               GPU architecture (default: 86)
     MCP_TCP_PORT           Claude Flow port (default: 9500)
     NVIDIA_VISIBLE_DEVICES  GPU device selection
-    
-${YELLOW}Configuration:${NC}
-    Uses consolidated .env.example file with all settings
-    Docker profiles: dev, production (no separate compose files needed)
 EOF
 }
 
@@ -118,7 +112,7 @@ parse_args() {
                 show_help
                 exit 0
                 ;;
-            up|down|restart|logs|shell|status|build|clean|diagnose|fix-nginx)
+            up|down|restart|logs|shell|status|build|clean)
                 ACTION="$1"
                 shift
                 ;;
@@ -150,17 +144,12 @@ check_prerequisites() {
     # Check for .env file
     if [[ ! -f "$PROJECT_ROOT/.env" ]]; then
         warning ".env file not found"
-        if [[ -f "$PROJECT_ROOT/.env.example" ]]; then
-            info "Creating .env from unified example..."
-            cp "$PROJECT_ROOT/.env.example" "$PROJECT_ROOT/.env"
-            warning "Please edit .env and add your API keys"
-        elif [[ -f "$PROJECT_ROOT/.env_template" ]]; then
-            # Fallback to old template for backwards compatibility
+        if [[ -f "$PROJECT_ROOT/.env_template" ]]; then
             info "Creating .env from template..."
             cp "$PROJECT_ROOT/.env_template" "$PROJECT_ROOT/.env"
             warning "Please edit .env and add your API keys"
         else
-            error "No .env, .env.example, or .env_template found"
+            error "No .env or .env_template found"
             exit 1
         fi
     fi
@@ -289,63 +278,6 @@ show_logs() {
     docker_compose logs -f
 }
 
-# Diagnose nginx issues
-diagnose_nginx() {
-    log "Diagnosing nginx configuration..."
-    
-    if ! docker ps -q -f name="$CONTAINER_NAME" &> /dev/null; then
-        error "Container is not running"
-        return 1
-    fi
-    
-    echo ""
-    info "Checking nginx config generation..."
-    docker exec "$CONTAINER_NAME" bash -c "cat /etc/nginx/nginx.conf | head -20" 2>/dev/null || warning "Nginx config not found"
-    
-    echo ""
-    info "Checking service status..."
-    docker exec "$CONTAINER_NAME" supervisorctl status 2>/dev/null || warning "Supervisord not running"
-    
-    echo ""
-    info "Checking nginx error logs..."
-    docker exec "$CONTAINER_NAME" tail -5 /var/log/nginx/error.log 2>/dev/null || echo "No errors found"
-    
-    echo ""
-    info "Testing backend connectivity..."
-    docker exec "$CONTAINER_NAME" curl -s -o /dev/null -w "Backend (4000): %{http_code}\n" http://127.0.0.1:4000/api/health 2>/dev/null || echo "Backend not responding"
-    
-    echo ""
-    info "Testing nginx routing..."
-    docker exec "$CONTAINER_NAME" curl -s -o /dev/null -w "Nginx API route: %{http_code}\n" http://127.0.0.1:3001/api/health 2>/dev/null || echo "Nginx routing failed"
-    
-    echo ""
-    info "Environment variables:"
-    docker exec "$CONTAINER_NAME" env | grep -E "(NGINX_|BACKEND_|FRONTEND_)" | sort
-}
-
-# Fix nginx configuration issues
-fix_nginx() {
-    log "Attempting to fix nginx configuration..."
-    
-    if ! docker ps -q -f name="$CONTAINER_NAME" &> /dev/null; then
-        error "Container is not running. Starting it first..."
-        start_environment
-        return
-    fi
-    
-    info "Regenerating nginx configuration with defaults..."
-    docker exec "$CONTAINER_NAME" bash -c "/app/scripts/generate-nginx-config.sh && nginx -t && supervisorctl restart nginx" 2>&1
-    
-    if [ $? -eq 0 ]; then
-        success "Nginx configuration fixed and restarted"
-        info "Testing nginx..."
-        sleep 2
-        docker exec "$CONTAINER_NAME" curl -s -o /dev/null -w "Nginx status: %{http_code}\n" http://127.0.0.1:3001/health
-    else
-        error "Failed to fix nginx. Try rebuilding with: ./launch.sh -f restart"
-    fi
-}
-
 # Open shell
 open_shell() {
     log "Opening shell in container..."
@@ -360,17 +292,12 @@ show_status() {
     if docker ps -q -f name="$CONTAINER_NAME" &> /dev/null; then
         echo ""
         log "Service URLs:"
-        echo "  Web UI:        http://localhost:3001"  # Changed: nginx entry point
-        echo "  API Backend:   http://localhost:3001/api"
-        echo "  WebSocket:     ws://localhost:3001/ws"
+        echo "  Web UI:        http://localhost:4000"
+        echo "  WebSocket:     ws://localhost:4000/ws"
         echo "  Claude Flow:   tcp://localhost:9500"
 
         if [[ "$PROFILE" == "dev" ]]; then
-            echo "  Vite Dev:      http://localhost:3001 (proxied via nginx)"
-            echo ""
-            log "Development Services (inside container):"
-            echo "  Rust Backend:  127.0.0.1:4000"
-            echo "  Vite Server:   127.0.0.1:5173"
+            echo "  Vite Dev:      http://localhost:5173"
         fi
     fi
 }
@@ -428,16 +355,13 @@ cleanup() {
 main() {
     parse_args "$@"
 
-    # Validate and normalize profile
+    # Validate profile
     case "$PROFILE" in
-        dev)
-            ;;
-        production|prod)
-            PROFILE="production"  # Normalize prod to production
+        dev|production|prod)
             ;;
         *)
             error "Invalid profile: $PROFILE"
-            echo "Valid profiles: dev, production (or prod)"
+            echo "Valid profiles: dev, production, prod"
             exit 1
             ;;
     esac
@@ -485,12 +409,6 @@ main() {
         clean)
             clean_all
             ;;
-        diagnose)
-            diagnose_nginx
-            ;;
-        fix-nginx)
-            fix_nginx
-            ;;
         *)
             error "Invalid action: $ACTION"
             show_help
diff --git a/scripts/nginx-config-simple.sh b/scripts/nginx-config-simple.sh
deleted file mode 100644
index 54cda7e7..00000000
--- a/scripts/nginx-config-simple.sh
+++ /dev/null
@@ -1,150 +0,0 @@
-#!/bin/bash
-# Simplified nginx config generator that's more resilient to failures
-
-set +e  # Don't exit on error
-
-echo "[nginx-config] Starting nginx configuration generation..."
-
-# Create directories if they don't exist
-mkdir -p /var/log/nginx /etc/nginx
-
-# Template and output paths
-TEMPLATE="${1:-/app/nginx.conf.template}"
-OUTPUT="${3:-/etc/nginx/nginx.conf}"
-
-# Check if template exists
-if [ ! -f "$TEMPLATE" ]; then
-    echo "[nginx-config] ERROR: Template not found at $TEMPLATE"
-    echo "[nginx-config] Creating minimal nginx.conf..."
-    
-    # Create a minimal working nginx config
-    cat > "$OUTPUT" << 'EOF'
-events {
-    worker_connections 1024;
-}
-
-http {
-    include /etc/nginx/mime.types;
-    default_type application/octet-stream;
-    
-    upstream backend {
-        server 127.0.0.1:4000;
-    }
-    
-    upstream frontend {
-        server 127.0.0.1:5173;
-    }
-    
-    server {
-        listen 3001;
-        
-        location /api/ {
-            proxy_pass http://backend;
-            proxy_http_version 1.1;
-            proxy_set_header Host $host;
-            proxy_set_header X-Real-IP $remote_addr;
-        }
-        
-        location /ws {
-            proxy_pass http://backend;
-            proxy_http_version 1.1;
-            proxy_set_header Upgrade $http_upgrade;
-            proxy_set_header Connection "upgrade";
-        }
-        
-        location / {
-            proxy_pass http://frontend;
-            proxy_http_version 1.1;
-            proxy_set_header Host $host;
-        }
-    }
-}
-EOF
-    echo "[nginx-config] Created minimal config at $OUTPUT"
-    exit 0
-fi
-
-# If template exists, try to generate from it
-echo "[nginx-config] Template found, processing..."
-
-# Export all defaults
-export NGINX_LOG_LEVEL="${NGINX_LOG_LEVEL:-warn}"
-export NGINX_WORKER_PROCESSES="${NGINX_WORKER_PROCESSES:-auto}"
-export NGINX_WORKER_CONNECTIONS="${NGINX_WORKER_CONNECTIONS:-1024}"
-export NGINX_MULTI_ACCEPT="${NGINX_MULTI_ACCEPT:-on}"
-export NGINX_KEEPALIVE_TIMEOUT="${NGINX_KEEPALIVE_TIMEOUT:-65}"
-export NGINX_KEEPALIVE_REQUESTS="${NGINX_KEEPALIVE_REQUESTS:-100}"
-export NGINX_CLIENT_MAX_BODY_SIZE="${NGINX_CLIENT_MAX_BODY_SIZE:-100M}"
-export NGINX_MAX_BODY_SIZE="${NGINX_MAX_BODY_SIZE:-100M}"
-export NGINX_PROXY_BUFFER_SIZE="${NGINX_PROXY_BUFFER_SIZE:-8k}"
-export NGINX_PROXY_BUFFERS="${NGINX_PROXY_BUFFERS:-16 8k}"
-export NGINX_PROXY_BUSY_BUFFERS_SIZE="${NGINX_PROXY_BUSY_BUFFERS_SIZE:-32k}"
-export NGINX_GZIP="${NGINX_GZIP:-on}"
-export NGINX_GZIP_COMP_LEVEL="${NGINX_GZIP_COMP_LEVEL:-6}"
-export NGINX_ACCESS_LOG="${NGINX_ACCESS_LOG:-/var/log/nginx/access.log combined}"
-export NGINX_ERROR_LOG="${NGINX_ERROR_LOG:-/var/log/nginx/error.log warn}"
-export NGINX_CSP="${NGINX_CSP:-default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'}"
-export NGINX_REAL_IP_FROM_CF="${NGINX_REAL_IP_FROM_CF:-\$remote_addr}"
-export NGINX_FORWARDED_PROTO="${NGINX_FORWARDED_PROTO:-\$scheme}"
-export BACKEND_PORT="${BACKEND_PORT:-4000}"
-export FRONTEND_PORT="${FRONTEND_PORT:-5173}"
-export NGINX_PORT="${NGINX_PORT:-3001}"
-export NGINX_SERVER_NAME="${NGINX_SERVER_NAME:-_}"
-export NGINX_ROOT="${NGINX_ROOT:-/app/client/dist}"
-export NGINX_FRAME_OPTIONS="${NGINX_FRAME_OPTIONS:-SAMEORIGIN}"
-export NGINX_REFERRER_POLICY="${NGINX_REFERRER_POLICY:-same-origin}"
-export NGINX_HSTS_PRELOAD="${NGINX_HSTS_PRELOAD:-}"
-export NGINX_API_BUFFERING="${NGINX_API_BUFFERING:-off}"
-export NGINX_WS_ACCESS_LOG="${NGINX_WS_ACCESS_LOG:-/var/log/nginx/websocket.log}"
-export NGINX_WS_LOG_FORMAT="${NGINX_WS_LOG_FORMAT:-debug_format}"
-export NGINX_WS_ERROR_LOG="${NGINX_WS_ERROR_LOG:-/var/log/nginx/websocket-error.log}"
-export NGINX_WS_ERROR_LEVEL="${NGINX_WS_ERROR_LEVEL:-debug}"
-export NGINX_STATIC_FALLBACK="${NGINX_STATIC_FALLBACK:-development_static}"
-export NGINX_STATIC_EXPIRES="${NGINX_STATIC_EXPIRES:-30d}"
-export NGINX_STATIC_CACHE_CONTROL="${NGINX_STATIC_CACHE_CONTROL:-public, immutable}"
-export NGINX_HTML_FALLBACK="${NGINX_HTML_FALLBACK:-/index.html}"
-export NGINX_ROOT_FALLBACK="${NGINX_ROOT_FALLBACK:-development_root}"
-export NGINX_ROOT_EXPIRES="${NGINX_ROOT_EXPIRES:--1}"
-export NGINX_ROOT_CACHE_CONTROL="${NGINX_ROOT_CACHE_CONTROL:-no-cache, no-store, must-revalidate}"
-
-# Try to use envsubst if available
-if command -v envsubst &> /dev/null; then
-    echo "[nginx-config] Using envsubst to process template..."
-    envsubst < "$TEMPLATE" > "$OUTPUT" 2>/dev/null || {
-        echo "[nginx-config] envsubst failed, trying with specific variables..."
-        # Try with specific variable list
-        VARS='$NGINX_LOG_LEVEL $NGINX_WORKER_PROCESSES $NGINX_WORKER_CONNECTIONS $NGINX_MULTI_ACCEPT
-$NGINX_KEEPALIVE_TIMEOUT $NGINX_KEEPALIVE_REQUESTS $NGINX_CLIENT_MAX_BODY_SIZE $NGINX_MAX_BODY_SIZE
-$NGINX_PROXY_BUFFER_SIZE $NGINX_PROXY_BUFFERS $NGINX_PROXY_BUSY_BUFFERS_SIZE 
-$NGINX_GZIP $NGINX_GZIP_COMP_LEVEL $NGINX_ACCESS_LOG $NGINX_ERROR_LOG 
-$NGINX_CSP $NGINX_REAL_IP_FROM_CF $NGINX_FORWARDED_PROTO
-$BACKEND_PORT $FRONTEND_PORT $NGINX_PORT $NGINX_SERVER_NAME $NGINX_ROOT
-$NGINX_FRAME_OPTIONS $NGINX_REFERRER_POLICY $NGINX_HSTS_PRELOAD
-$NGINX_API_BUFFERING $NGINX_WS_ACCESS_LOG $NGINX_WS_LOG_FORMAT
-$NGINX_WS_ERROR_LOG $NGINX_WS_ERROR_LEVEL
-$NGINX_STATIC_FALLBACK $NGINX_STATIC_EXPIRES $NGINX_STATIC_CACHE_CONTROL
-$NGINX_HTML_FALLBACK $NGINX_ROOT_FALLBACK $NGINX_ROOT_EXPIRES $NGINX_ROOT_CACHE_CONTROL'
-        
-        envsubst "$VARS" < "$TEMPLATE" > "$OUTPUT" 2>/dev/null || {
-            echo "[nginx-config] ERROR: Failed to process template"
-            # Fall back to copying template as-is
-            cp "$TEMPLATE" "$OUTPUT"
-        }
-    }
-else
-    echo "[nginx-config] WARNING: envsubst not available, copying template as-is"
-    cp "$TEMPLATE" "$OUTPUT"
-fi
-
-echo "[nginx-config] Configuration written to $OUTPUT"
-
-# Try to validate if nginx is available
-if command -v nginx &> /dev/null; then
-    echo "[nginx-config] Testing configuration..."
-    nginx -t -c "$OUTPUT" 2>&1 || echo "[nginx-config] WARNING: Config validation failed, but continuing..."
-else
-    echo "[nginx-config] nginx not available for validation"
-fi
-
-echo "[nginx-config] Done!"
-exit 0
\ No newline at end of file
diff --git a/scripts/start.sh b/scripts/start.sh
index 3c92d15d..a8f5219e 100755
--- a/scripts/start.sh
+++ b/scripts/start.sh
@@ -66,11 +66,6 @@ fi
 log "settings.yaml permissions verified"
 
 # Set up runtime environment
-# Generate nginx configuration from template
-log "Generating nginx configuration..."
-/app/scripts/generate-nginx-config.sh /app/nginx.conf.template /app/nginx.env.prod /etc/nginx/nginx.conf
-log "nginx configuration generated"
-
 # Start nginx
 log "Starting nginx..."
 nginx -t && nginx
diff --git a/src/actors/settings_actor.rs b/src/actors/settings_actor.rs
index 6886ed5c..204703af 100644
--- a/src/actors/settings_actor.rs
+++ b/src/actors/settings_actor.rs
@@ -3,7 +3,7 @@
 
 use actix::prelude::*;
 use crate::config::AppFullSettings;
-use crate::actors::messages::{GetSettings, UpdateSettings, GetSettingByPath, UpdatePhysicsFromAutoBalance, UpdateSimulationParams};
+use crate::actors::messages::{GetSettings, UpdateSettings, GetSettingByPath, UpdatePhysicsFromAutoBalance};
 use log::{info, error, debug};
 use std::sync::Arc;
 use tokio::sync::RwLock;
@@ -183,35 +183,3 @@ impl Handler<UpdatePhysicsFromAutoBalance> for SettingsActor {
         }).into_actor(self));
     }
 }
-
-// Handle UpdateSimulationParams message
-impl Handler<UpdateSimulationParams> for SettingsActor {
-    type Result = ResponseFuture<Result<(), String>>;
-    
-    fn handle(&mut self, msg: UpdateSimulationParams, _ctx: &mut Self::Context) -> Self::Result {
-        let settings = self.settings.clone();
-        
-        Box::pin(async move {
-            let mut current = settings.write().await;
-            
-            // Update the simulation parameters in the appropriate graph settings
-            // Assuming we want to update the logseq physics params for now
-            current.visualisation.graphs.logseq.physics.iterations = msg.params.iterations;
-            current.visualisation.graphs.logseq.physics.damping = msg.params.damping;
-            current.visualisation.graphs.logseq.physics.max_velocity = msg.params.max_velocity;
-            current.visualisation.graphs.logseq.physics.spring_k = msg.params.spring_k;
-            current.visualisation.graphs.logseq.physics.repel_k = msg.params.repel_k;
-            current.visualisation.graphs.logseq.physics.dt = msg.params.dt;
-            current.visualisation.graphs.logseq.physics.separation_radius = msg.params.separation_radius;
-            
-            // Save to file
-            if let Err(e) = current.save() {
-                error!("Failed to save simulation parameters: {}", e);
-                return Err(format!("Failed to save simulation parameters: {}", e));
-            }
-            
-            info!("Simulation parameters updated successfully");
-            Ok(())
-        })
-    }
-}
diff --git a/src/bin/test_tcp_connection.rs b/src/bin/test_tcp_connection.rs
new file mode 100644
index 00000000..20cf54e8
--- /dev/null
+++ b/src/bin/test_tcp_connection.rs
@@ -0,0 +1,121 @@
+use log::{info, error};
+use serde_json::json;
+use std::time::Instant;
+use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};
+use tokio::net::TcpStream;
+use uuid::Uuid;
+
+#[tokio::main]
+async fn main() -> Result<(), Box<dyn std::error::Error>> {
+    env_logger::init();
+    
+    info!("Starting TCP connection test for Claude Flow MCP");
+    
+    let host = std::env::var("CLAUDE_FLOW_HOST").unwrap_or_else(|_| "multi-agent-container".to_string());
+    let port = std::env::var("MCP_TCP_PORT").unwrap_or_else(|_| "9500".to_string());
+    
+    info!("Connecting to {}:{}...", host, port);
+    
+    let start = Instant::now();
+    let mut stream = TcpStream::connect(format!("{}:{}", host, port)).await?;
+    let connect_time = start.elapsed();
+    
+    info!("Connected in {:?}", connect_time);
+    
+    // Set TCP options
+    stream.set_nodelay(true)?;
+    
+    // Create reader - for Tokio we need a second connection
+    let reader_stream = TcpStream::connect(format!("{}:{}", host, port)).await?;
+    reader_stream.set_nodelay(true)?;
+    let mut reader = BufReader::new(reader_stream);
+    
+    // Send initialization
+    let init_msg = json!({
+        "jsonrpc": "2.0",
+        "id": Uuid::new_v4().to_string(),
+        "method": "initialize",
+        "params": {
+            "protocolVersion": "1.0.0",
+            "capabilities": {
+                "roots": true,
+                "sampling": true
+            },
+            "clientInfo": {
+                "name": "visionflow-test",
+                "version": "1.0.0"
+            }
+        }
+    });
+    
+    let msg_str = format!("{}\n", serde_json::to_string(&init_msg)?);
+    stream.write_all(msg_str.as_bytes()).await?;
+    stream.flush().await?;
+    
+    info!("Sent initialization message");
+    
+    // Read response
+    let mut response = String::new();
+    reader.read_line(&mut response).await?;
+    
+    info!("Received response: {}", response);
+    
+    // Test listing tools
+    let list_tools = json!({
+        "jsonrpc": "2.0",
+        "id": Uuid::new_v4().to_string(),
+        "method": "tools/list"
+    });
+    
+    let msg_str = format!("{}\n", serde_json::to_string(&list_tools)?);
+    stream.write_all(msg_str.as_bytes()).await?;
+    stream.flush().await?;
+    
+    info!("Requested tool list");
+    
+    // Read tools response
+    let mut tools_response = String::new();
+    reader.read_line(&mut tools_response).await?;
+    
+    info!("Available tools: {}", tools_response);
+    
+    // Test swarm initialization
+    let swarm_init = json!({
+        "jsonrpc": "2.0",
+        "id": Uuid::new_v4().to_string(),
+        "method": "tools/call",
+        "params": {
+            "name": "swarm_init",
+            "arguments": {
+                "objective": "Test swarm",
+                "maxAgents": 3,
+                "strategy": "balanced"
+            }
+        }
+    });
+    
+    let msg_str = format!("{}\n", serde_json::to_string(&swarm_init)?);
+    let send_start = Instant::now();
+    stream.write_all(msg_str.as_bytes()).await?;
+    stream.flush().await?;
+    let send_time = send_start.elapsed();
+    
+    info!("Swarm initialization sent in {:?}", send_time);
+    
+    // Read swarm response
+    let mut swarm_response = String::new();
+    reader.read_line(&mut swarm_response).await?;
+    
+    info!("Swarm response: {}", swarm_response);
+    
+    let total_time = start.elapsed();
+    info!("Test completed successfully in {:?}", total_time);
+    
+    // Performance summary
+    println!("\n=== Performance Summary ===");
+    println!("Connection time: {:?}", connect_time);
+    println!("Message send time: {:?}", send_time);
+    println!("Total test time: {:?}", total_time);
+    
+    Ok(())
+}
\ No newline at end of file
diff --git a/src/config/mod.rs b/src/config/mod.rs
index 11be52c7..7433bdd0 100644
--- a/src/config/mod.rs
+++ b/src/config/mod.rs
@@ -98,7 +98,6 @@ pub struct MovementAxes {
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone, Default, PartialEq)]
-#[serde(rename_all = "camelCase")]
 pub struct NodeSettings {
     pub base_color: String,
     pub metalness: f32,
@@ -113,7 +112,6 @@ pub struct NodeSettings {
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone, Default, PartialEq)]
-#[serde(rename_all = "camelCase")]
 pub struct EdgeSettings {
     pub arrow_size: f32,
     pub base_width: f32,
@@ -125,7 +123,6 @@ pub struct EdgeSettings {
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone, Default)]
-#[serde(rename_all = "camelCase")]
 pub struct AutoBalanceConfig {
     pub stability_variance_threshold: f32,
     pub stability_frame_count: u32,
@@ -191,7 +188,6 @@ impl AutoBalanceConfig {
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
-#[serde(rename_all = "camelCase")]
 pub struct PhysicsSettings {
     #[serde(default)]
     pub auto_balance: bool,
@@ -351,7 +347,6 @@ pub struct LabelSettings {
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone, Default)]
-#[serde(rename_all = "camelCase")]
 pub struct GlowSettings {
     pub enabled: bool,
     pub intensity: f32,
@@ -449,7 +444,6 @@ pub struct GraphsSettings {
 }
 
 #[derive(Debug, Serialize, Deserialize, Clone, Default)]
-#[serde(rename_all = "camelCase")]
 pub struct VisualisationSettings {
     
     // Global settings
@@ -833,7 +827,6 @@ pub struct PhysicsUpdate {
 
 // Single unified settings struct
 #[derive(Debug, Clone, Deserialize, Serialize)]
-#[serde(rename_all = "camelCase")]
 pub struct AppFullSettings {
     pub visualisation: VisualisationSettings,
     pub system: SystemSettings,
diff --git a/src/handlers/settings_handler.rs b/src/handlers/settings_handler.rs
index 64819c96..d5034a4b 100644
--- a/src/handlers/settings_handler.rs
+++ b/src/handlers/settings_handler.rs
@@ -1,9 +1,8 @@
-// Unified Settings Handler - Eliminated DTO Boilerplate via camelCase Serialization
+// Unified Settings Handler - Single source of truth: AppFullSettings
 use actix_web::{web, Error, HttpResponse, HttpRequest};
 use crate::app_state::AppState;
 use crate::config::AppFullSettings;
 use crate::actors::messages::{GetSettings, UpdateSettings, UpdateSimulationParams};
-use crate::models::simulation_params::SimulationParams;
 use crate::handlers::validation_handler::ValidationService;
 use crate::utils::validation::rate_limit::{RateLimiter, RateLimitConfig, EndpointRateLimits, extract_client_id};
 use crate::utils::validation::MAX_REQUEST_SIZE;
@@ -11,343 +10,3108 @@ use log::{info, warn, error, debug};
 use serde_json::{json, Value};
 use serde::{Serialize, Deserialize};
 use std::sync::Arc;
-use std::collections::HashMap;
 
-/// Update request structure for partial settings updates
+/// DTO for settings responses with camelCase serialization
+#[derive(Debug, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct SettingsResponseDTO {
+    pub visualisation: VisualisationSettingsDTO,
+    pub system: SystemSettingsDTO,
+    pub xr: XRSettingsDTO,
+    pub auth: AuthSettingsDTO,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub ragflow: Option<RagFlowSettingsDTO>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub perplexity: Option<PerplexitySettingsDTO>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub openai: Option<OpenAISettingsDTO>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub kokoro: Option<KokoroSettingsDTO>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub whisper: Option<WhisperSettingsDTO>,
+}
+
+/// DTO for settings updates with camelCase deserialization
 #[derive(Debug, Deserialize, Clone)]
 #[serde(rename_all = "camelCase")]
-pub struct SettingsUpdateRequest {
+pub struct SettingsUpdateDTO {
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub visualisation: Option<VisualisationSettingsDTO>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub system: Option<SystemSettingsDTO>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub xr: Option<XRSettingsDTO>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub auth: Option<AuthSettingsDTO>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub ragflow: Option<RagFlowSettingsDTO>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub perplexity: Option<PerplexitySettingsDTO>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub openai: Option<OpenAISettingsDTO>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub kokoro: Option<KokoroSettingsDTO>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub whisper: Option<WhisperSettingsDTO>,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct VisualisationSettingsDTO {
+    pub rendering: RenderingSettingsDTO,
+    pub animations: AnimationSettingsDTO,
+    // Use "glow" consistently across all layers
+    pub glow: GlowSettingsDTO,
+    pub hologram: HologramSettingsDTO,
+    pub graphs: GraphsSettingsDTO,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub camera: Option<CameraSettingsDTO>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub space_pilot: Option<SpacePilotSettingsDTO>,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct RenderingSettingsDTO {
+    pub ambient_light_intensity: f32,
+    pub background_color: String,
+    pub directional_light_intensity: f32,
+    pub enable_ambient_occlusion: bool,
+    pub enable_antialiasing: bool,
+    pub enable_shadows: bool,
+    pub environment_intensity: f32,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub shadow_map_size: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub shadow_bias: Option<f32>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub context: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub agent_colors: Option<AgentColorsDTO>,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct AgentColorsDTO {
+    pub coordinator: String,
+    pub coder: String,
+    pub architect: String,
+    pub analyst: String,
+    pub tester: String,
+    pub researcher: String,
+    pub reviewer: String,
+    pub optimizer: String,
+    pub documenter: String,
+    pub queen: String,
+    pub default: String,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct AnimationSettingsDTO {
+    pub enable_motion_blur: bool,
+    pub enable_node_animations: bool,
+    pub motion_blur_strength: f32,
+    pub selection_wave_enabled: bool,
+    pub pulse_enabled: bool,
+    pub pulse_speed: f32,
+    pub pulse_strength: f32,
+    pub wave_speed: f32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct GlowSettingsDTO {
+    pub enabled: bool,
+    pub intensity: f32,
+    pub radius: f32,
+    pub threshold: f32,
+    pub diffuse_strength: f32,
+    pub atmospheric_density: f32,
+    pub volumetric_intensity: f32,
+    pub base_color: String,
+    pub emission_color: String,
+    pub opacity: f32,
+    pub pulse_speed: f32,
+    pub flow_speed: f32,
+    pub node_glow_strength: f32,
+    pub edge_glow_strength: f32,
+    pub environment_glow_strength: f32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct HologramSettingsDTO {
+    pub ring_count: u32,
+    pub ring_color: String,
+    pub ring_opacity: f32,
+    pub sphere_sizes: Vec<f32>,
+    pub ring_rotation_speed: f32,
+    pub enable_buckminster: bool,
+    pub buckminster_size: f32,
+    pub buckminster_opacity: f32,
+    pub enable_geodesic: bool,
+    pub geodesic_size: f32,
+    pub geodesic_opacity: f32,
+    pub enable_triangle_sphere: bool,
+    pub triangle_sphere_size: f32,
+    pub triangle_sphere_opacity: f32,
+    pub global_rotation_speed: f32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct GraphsSettingsDTO {
+    pub logseq: GraphSettingsDTO,
+    pub visionflow: GraphSettingsDTO,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct GraphSettingsDTO {
+    pub nodes: NodeSettingsDTO,
+    pub edges: EdgeSettingsDTO,
+    pub labels: LabelSettingsDTO,
+    pub physics: PhysicsSettingsDTO,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct NodeSettingsDTO {
+    pub base_color: String,
+    pub metalness: f32,
+    pub opacity: f32,
+    pub roughness: f32,
+    pub node_size: f32,
+    pub quality: String,
+    pub enable_instancing: bool,
+    pub enable_hologram: bool,
+    pub enable_metadata_shape: bool,
+    pub enable_metadata_visualisation: bool,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct EdgeSettingsDTO {
+    pub arrow_size: f32,
+    pub base_width: f32,
+    pub color: String,
+    pub enable_arrows: bool,
+    pub opacity: f32,
+    pub width_range: Vec<f32>,
+    pub quality: String,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct LabelSettingsDTO {
+    pub desktop_font_size: f32,
+    pub enable_labels: bool,
+    pub text_color: String,
+    pub text_outline_color: String,
+    pub text_outline_width: f32,
+    pub text_resolution: u32,
+    pub text_padding: f32,
+    pub billboard_mode: String,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub show_metadata: Option<bool>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub max_label_width: Option<f32>,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct PhysicsSettingsDTO {
+    pub auto_balance: bool,
+    pub auto_balance_interval_ms: u32,
+    pub auto_balance_config: AutoBalanceConfigDTO,
+    pub attraction_k: f32,
+    pub bounds_size: f32,
+    pub separation_radius: f32,
+    pub damping: f32,
+    pub enable_bounds: bool,
+    pub enabled: bool,
+    pub iterations: u32,
+    pub max_velocity: f32,
+    pub max_force: f32,
+    pub repel_k: f32,
+    pub spring_k: f32,
+    pub mass_scale: f32,
+    pub boundary_damping: f32,
+    pub update_threshold: f32,
+    pub dt: f32,
+    pub temperature: f32,
+    pub gravity: f32,
+    pub stress_weight: f32,
+    pub stress_alpha: f32,
+    pub boundary_limit: f32,
+    pub alignment_strength: f32,
+    pub cluster_strength: f32,
+    pub compute_mode: i32,
+    pub rest_length: f32,
+    pub repulsion_cutoff: f32,
+    pub repulsion_softening_epsilon: f32,
+    pub center_gravity_k: f32,
+    pub grid_cell_size: f32,
+    pub warmup_iterations: u32,
+    pub cooling_rate: f32,
+    pub boundary_extreme_multiplier: f32,
+    pub boundary_extreme_force_multiplier: f32,
+    pub boundary_velocity_damping: f32,
+    pub min_distance: f32,
+    pub max_repulsion_dist: f32,
+    pub boundary_margin: f32,
+    pub boundary_force_strength: f32,
+    pub warmup_curve: String,
+    pub zero_velocity_iterations: u32,
+    pub clustering_algorithm: String,
+    pub cluster_count: u32,
+    pub clustering_resolution: f32,
+    pub clustering_iterations: u32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct AutoBalanceConfigDTO {
+    pub stability_variance_threshold: f32,
+    pub stability_frame_count: u32,
+    pub clustering_distance_threshold: f32,
+    pub bouncing_node_percentage: f32,
+    pub boundary_min_distance: f32,
+    pub boundary_max_distance: f32,
+    pub extreme_distance_threshold: f32,
+    pub explosion_distance_threshold: f32,
+    pub spreading_distance_threshold: f32,
+    pub oscillation_detection_frames: usize,
+    pub oscillation_change_threshold: f32,
+    pub min_oscillation_changes: usize,
+    pub grid_cell_size_min: f32,
+    pub grid_cell_size_max: f32,
+    pub repulsion_cutoff_min: f32,
+    pub repulsion_cutoff_max: f32,
+    pub repulsion_softening_min: f32,
+    pub repulsion_softening_max: f32,
+    pub center_gravity_min: f32,
+    pub center_gravity_max: f32,
+    pub spatial_hash_efficiency_threshold: f32,
+    pub cluster_density_threshold: f32,
+    pub numerical_instability_threshold: f32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct CameraSettingsDTO {
+    pub fov: f32,
+    pub near: f32,
+    pub far: f32,
+    pub position: PositionDTO,
+    pub look_at: PositionDTO,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct PositionDTO {
+    pub x: f32,
+    pub y: f32,
+    pub z: f32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct SpacePilotSettingsDTO {
+    pub enabled: bool,
+    pub mode: String,
+    pub sensitivity: SensitivityDTO,
+    pub smoothing: f32,
+    pub deadzone: f32,
+    pub button_functions: std::collections::HashMap<String, String>,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct SensitivityDTO {
+    pub translation: f32,
+    pub rotation: f32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct SystemSettingsDTO {
+    pub network: NetworkSettingsDTO,
+    pub websocket: WebSocketSettingsDTO,
+    pub security: SecuritySettingsDTO,
+    pub debug: DebugSettingsDTO,
+    pub persist_settings: bool,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub custom_backend_url: Option<String>,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct NetworkSettingsDTO {
+    pub bind_address: String,
+    pub domain: String,
+    pub enable_http2: bool,
+    pub enable_rate_limiting: bool,
+    pub enable_tls: bool,
+    pub max_request_size: usize,
+    pub min_tls_version: String,
+    pub port: u16,
+    pub rate_limit_requests: u32,
+    pub rate_limit_window: u32,
+    pub tunnel_id: String,
+    pub api_client_timeout: u64,
+    pub enable_metrics: bool,
+    pub max_concurrent_requests: u32,
+    pub max_retries: u32,
+    pub metrics_port: u16,
+    pub retry_delay: u32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct WebSocketSettingsDTO {
+    pub binary_chunk_size: usize,
+    pub binary_update_rate: u32,
+    pub min_update_rate: u32,
+    pub max_update_rate: u32,
+    pub motion_threshold: f32,
+    pub motion_damping: f32,
+    pub binary_message_version: u32,
+    pub compression_enabled: bool,
+    pub compression_threshold: usize,
+    pub heartbeat_interval: u64,
+    pub heartbeat_timeout: u64,
+    pub max_connections: usize,
+    pub max_message_size: usize,
+    pub reconnect_attempts: u32,
+    pub reconnect_delay: u64,
+    pub update_rate: u32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct SecuritySettingsDTO {
+    pub allowed_origins: Vec<String>,
+    pub audit_log_path: String,
+    pub cookie_httponly: bool,
+    pub cookie_samesite: String,
+    pub cookie_secure: bool,
+    pub csrf_token_timeout: u32,
+    pub enable_audit_logging: bool,
+    pub enable_request_validation: bool,
+    pub session_timeout: u32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct DebugSettingsDTO {
+    pub enabled: bool,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct XRSettingsDTO {
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub enabled: Option<bool>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub client_side_enable_xr: Option<bool>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub mode: Option<String>,
+    pub room_scale: f32,
+    pub space_type: String,
+    pub quality: String,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub render_scale: Option<f32>,
+    pub interaction_distance: f32,
+    pub locomotion_method: String,
+    pub teleport_ray_color: String,
+    pub controller_ray_color: String,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub controller_model: Option<String>,
+    pub enable_hand_tracking: bool,
+    pub hand_mesh_enabled: bool,
+    pub hand_mesh_color: String,
+    pub hand_mesh_opacity: f32,
+    pub hand_point_size: f32,
+    pub hand_ray_enabled: bool,
+    pub hand_ray_color: String,
+    pub hand_ray_width: f32,
+    pub gesture_smoothing: f32,
+    pub enable_haptics: bool,
+    pub haptic_intensity: f32,
+    pub drag_threshold: f32,
+    pub pinch_threshold: f32,
+    pub rotation_threshold: f32,
+    pub interaction_radius: f32,
+    pub movement_speed: f32,
+    pub dead_zone: f32,
+    pub movement_axes: MovementAxesDTO,
+    pub enable_light_estimation: bool,
+    pub enable_plane_detection: bool,
+    pub enable_scene_understanding: bool,
+    pub plane_color: String,
+    pub plane_opacity: f32,
+    pub plane_detection_distance: f32,
+    pub show_plane_overlay: bool,
+    pub snap_to_floor: bool,
+    pub enable_passthrough_portal: bool,
+    pub passthrough_opacity: f32,
+    pub passthrough_brightness: f32,
+    pub passthrough_contrast: f32,
+    pub portal_size: f32,
+    pub portal_edge_color: String,
+    pub portal_edge_width: f32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct MovementAxesDTO {
+    pub horizontal: i32,
+    pub vertical: i32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct AuthSettingsDTO {
+    pub enabled: bool,
+    pub provider: String,
+    pub required: bool,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct RagFlowSettingsDTO {
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub api_key: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub agent_id: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub api_base_url: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub timeout: Option<u64>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub max_retries: Option<u32>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub chat_id: Option<String>,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct PerplexitySettingsDTO {
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub api_key: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub model: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub api_url: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub max_tokens: Option<u32>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub temperature: Option<f32>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub top_p: Option<f32>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub presence_penalty: Option<f32>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub frequency_penalty: Option<f32>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub timeout: Option<u64>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub rate_limit: Option<u32>,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct OpenAISettingsDTO {
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub api_key: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub base_url: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub timeout: Option<u64>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub rate_limit: Option<u32>,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct KokoroSettingsDTO {
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub api_url: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub default_voice: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub default_format: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub default_speed: Option<f32>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub timeout: Option<u64>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub stream: Option<bool>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub return_timestamps: Option<bool>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub sample_rate: Option<u32>,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct WhisperSettingsDTO {
     #[serde(skip_serializing_if = "Option::is_none")]
-    pub visualisation: Option<Value>,
+    pub api_url: Option<String>,
     #[serde(skip_serializing_if = "Option::is_none")]
-    pub system: Option<Value>,
+    pub default_model: Option<String>,
     #[serde(skip_serializing_if = "Option::is_none")]
-    pub xr: Option<Value>,
+    pub default_language: Option<String>,
     #[serde(skip_serializing_if = "Option::is_none")]
-    pub auth: Option<Value>,
+    pub timeout: Option<u64>,
     #[serde(skip_serializing_if = "Option::is_none")]
-    pub ragflow: Option<Value>,
+    pub temperature: Option<f32>,
     #[serde(skip_serializing_if = "Option::is_none")]
-    pub perplexity: Option<Value>,
+    pub return_timestamps: Option<bool>,
     #[serde(skip_serializing_if = "Option::is_none")]
-    pub openai: Option<Value>,
+    pub vad_filter: Option<bool>,
     #[serde(skip_serializing_if = "Option::is_none")]
-    pub kokoro: Option<Value>,
+    pub word_timestamps: Option<bool>,
     #[serde(skip_serializing_if = "Option::is_none")]
-    pub whisper: Option<Value>,
+    pub initial_prompt: Option<String>,
+}
+
+// Conversion functions between AppFullSettings and DTOs
+impl From<&AppFullSettings> for SettingsResponseDTO {
+    fn from(settings: &AppFullSettings) -> Self {
+        Self {
+            visualisation: (&settings.visualisation).into(),
+            system: (&settings.system).into(),
+            xr: (&settings.xr).into(),
+            auth: (&settings.auth).into(),
+            ragflow: settings.ragflow.as_ref().map(|r| r.into()),
+            perplexity: settings.perplexity.as_ref().map(|p| p.into()),
+            openai: settings.openai.as_ref().map(|o| o.into()),
+            kokoro: settings.kokoro.as_ref().map(|k| k.into()),
+            whisper: settings.whisper.as_ref().map(|w| w.into()),
+        }
+    }
+}
+
+// Implement all the necessary From conversions for nested structures
+impl From<&crate::config::VisualisationSettings> for VisualisationSettingsDTO {
+    fn from(settings: &crate::config::VisualisationSettings) -> Self {
+        Self {
+            rendering: (&settings.rendering).into(),
+            animations: (&settings.animations).into(),
+            glow: (&settings.glow).into(),
+            hologram: (&settings.hologram).into(),
+            graphs: (&settings.graphs).into(),
+            camera: settings.camera.as_ref().map(|c| c.into()),
+            space_pilot: settings.space_pilot.as_ref().map(|sp| sp.into()),
+        }
+    }
+}
+
+impl From<&crate::config::RenderingSettings> for RenderingSettingsDTO {
+    fn from(settings: &crate::config::RenderingSettings) -> Self {
+        // Load agent colors from dev_config
+        let dev_config = crate::config::dev_config::rendering();
+        let agent_colors = Some(AgentColorsDTO {
+            coordinator: dev_config.agent_colors.coordinator.clone(),
+            coder: dev_config.agent_colors.coder.clone(),
+            architect: dev_config.agent_colors.architect.clone(),
+            analyst: dev_config.agent_colors.analyst.clone(),
+            tester: dev_config.agent_colors.tester.clone(),
+            researcher: dev_config.agent_colors.researcher.clone(),
+            reviewer: dev_config.agent_colors.reviewer.clone(),
+            optimizer: dev_config.agent_colors.optimizer.clone(),
+            documenter: dev_config.agent_colors.documenter.clone(),
+            queen: "#FFD700".to_string(), // Gold color for queen
+            default: dev_config.agent_colors.default.clone(),
+        });
+        
+        Self {
+            ambient_light_intensity: settings.ambient_light_intensity,
+            background_color: settings.background_color.clone(),
+            directional_light_intensity: settings.directional_light_intensity,
+            enable_ambient_occlusion: settings.enable_ambient_occlusion,
+            enable_antialiasing: settings.enable_antialiasing,
+            enable_shadows: settings.enable_shadows,
+            environment_intensity: settings.environment_intensity,
+            shadow_map_size: settings.shadow_map_size.clone(),
+            shadow_bias: settings.shadow_bias,
+            context: settings.context.clone(),
+            agent_colors,
+        }
+    }
+}
+
+impl From<&crate::config::AnimationSettings> for AnimationSettingsDTO {
+    fn from(settings: &crate::config::AnimationSettings) -> Self {
+        Self {
+            enable_motion_blur: settings.enable_motion_blur,
+            enable_node_animations: settings.enable_node_animations,
+            motion_blur_strength: settings.motion_blur_strength,
+            selection_wave_enabled: settings.selection_wave_enabled,
+            pulse_enabled: settings.pulse_enabled,
+            pulse_speed: settings.pulse_speed,
+            pulse_strength: settings.pulse_strength,
+            wave_speed: settings.wave_speed,
+        }
+    }
+}
+
+impl From<&crate::config::GlowSettings> for GlowSettingsDTO {
+    fn from(settings: &crate::config::GlowSettings) -> Self {
+        Self {
+            enabled: settings.enabled,
+            intensity: settings.intensity,
+            radius: settings.radius,
+            threshold: settings.threshold,
+            diffuse_strength: settings.diffuse_strength,
+            atmospheric_density: settings.atmospheric_density,
+            volumetric_intensity: settings.volumetric_intensity,
+            base_color: settings.base_color.clone(),
+            emission_color: settings.emission_color.clone(),
+            opacity: settings.opacity,
+            pulse_speed: settings.pulse_speed,
+            flow_speed: settings.flow_speed,
+            node_glow_strength: settings.node_glow_strength,
+            edge_glow_strength: settings.edge_glow_strength,
+            environment_glow_strength: settings.environment_glow_strength,
+        }
+    }
+}
+
+impl From<&crate::config::HologramSettings> for HologramSettingsDTO {
+    fn from(settings: &crate::config::HologramSettings) -> Self {
+        Self {
+            ring_count: settings.ring_count,
+            ring_color: settings.ring_color.clone(),
+            ring_opacity: settings.ring_opacity,
+            sphere_sizes: settings.sphere_sizes.clone(),
+            ring_rotation_speed: settings.ring_rotation_speed,
+            enable_buckminster: settings.enable_buckminster,
+            buckminster_size: settings.buckminster_size,
+            buckminster_opacity: settings.buckminster_opacity,
+            enable_geodesic: settings.enable_geodesic,
+            geodesic_size: settings.geodesic_size,
+            geodesic_opacity: settings.geodesic_opacity,
+            enable_triangle_sphere: settings.enable_triangle_sphere,
+            triangle_sphere_size: settings.triangle_sphere_size,
+            triangle_sphere_opacity: settings.triangle_sphere_opacity,
+            global_rotation_speed: settings.global_rotation_speed,
+        }
+    }
+}
+
+impl From<&crate::config::GraphsSettings> for GraphsSettingsDTO {
+    fn from(settings: &crate::config::GraphsSettings) -> Self {
+        Self {
+            logseq: (&settings.logseq).into(),
+            visionflow: (&settings.visionflow).into(),
+        }
+    }
+}
+
+impl From<&crate::config::GraphSettings> for GraphSettingsDTO {
+    fn from(settings: &crate::config::GraphSettings) -> Self {
+        Self {
+            nodes: (&settings.nodes).into(),
+            edges: (&settings.edges).into(),
+            labels: (&settings.labels).into(),
+            physics: (&settings.physics).into(),
+        }
+    }
+}
+
+impl From<&crate::config::NodeSettings> for NodeSettingsDTO {
+    fn from(settings: &crate::config::NodeSettings) -> Self {
+        Self {
+            base_color: settings.base_color.clone(),
+            metalness: settings.metalness,
+            opacity: settings.opacity,
+            roughness: settings.roughness,
+            node_size: settings.node_size,
+            quality: settings.quality.clone(),
+            enable_instancing: settings.enable_instancing,
+            enable_hologram: settings.enable_hologram,
+            enable_metadata_shape: settings.enable_metadata_shape,
+            enable_metadata_visualisation: settings.enable_metadata_visualisation,
+        }
+    }
+}
+
+impl From<&crate::config::EdgeSettings> for EdgeSettingsDTO {
+    fn from(settings: &crate::config::EdgeSettings) -> Self {
+        Self {
+            arrow_size: settings.arrow_size,
+            base_width: settings.base_width,
+            color: settings.color.clone(),
+            enable_arrows: settings.enable_arrows,
+            opacity: settings.opacity,
+            width_range: settings.width_range.clone(),
+            quality: settings.quality.clone(),
+        }
+    }
+}
+
+impl From<&crate::config::LabelSettings> for LabelSettingsDTO {
+    fn from(settings: &crate::config::LabelSettings) -> Self {
+        Self {
+            desktop_font_size: settings.desktop_font_size,
+            enable_labels: settings.enable_labels,
+            text_color: settings.text_color.clone(),
+            text_outline_color: settings.text_outline_color.clone(),
+            text_outline_width: settings.text_outline_width,
+            text_resolution: settings.text_resolution,
+            text_padding: settings.text_padding,
+            billboard_mode: settings.billboard_mode.clone(),
+            show_metadata: settings.show_metadata,
+            max_label_width: settings.max_label_width,
+        }
+    }
+}
+
+impl From<&crate::config::PhysicsSettings> for PhysicsSettingsDTO {
+    fn from(settings: &crate::config::PhysicsSettings) -> Self {
+        Self {
+            auto_balance: settings.auto_balance,
+            auto_balance_interval_ms: settings.auto_balance_interval_ms,
+            auto_balance_config: (&settings.auto_balance_config).into(),
+            attraction_k: settings.attraction_k,
+            bounds_size: settings.bounds_size,
+            separation_radius: settings.separation_radius,
+            damping: settings.damping,
+            enable_bounds: settings.enable_bounds,
+            enabled: settings.enabled,
+            iterations: settings.iterations,
+            max_velocity: settings.max_velocity,
+            max_force: settings.max_force,
+            repel_k: settings.repel_k,
+            spring_k: settings.spring_k,
+            mass_scale: settings.mass_scale,
+            boundary_damping: settings.boundary_damping,
+            update_threshold: settings.update_threshold,
+            dt: settings.dt,
+            temperature: settings.temperature,
+            gravity: settings.gravity,
+            stress_weight: settings.stress_weight,
+            stress_alpha: settings.stress_alpha,
+            boundary_limit: settings.boundary_limit,
+            alignment_strength: settings.alignment_strength,
+            cluster_strength: settings.cluster_strength,
+            compute_mode: settings.compute_mode,
+            rest_length: settings.rest_length,
+            repulsion_cutoff: settings.repulsion_cutoff,
+            repulsion_softening_epsilon: settings.repulsion_softening_epsilon,
+            center_gravity_k: settings.center_gravity_k,
+            grid_cell_size: settings.grid_cell_size,
+            warmup_iterations: settings.warmup_iterations,
+            cooling_rate: settings.cooling_rate,
+            boundary_extreme_multiplier: settings.boundary_extreme_multiplier,
+            boundary_extreme_force_multiplier: settings.boundary_extreme_force_multiplier,
+            boundary_velocity_damping: settings.boundary_velocity_damping,
+            min_distance: settings.min_distance,
+            max_repulsion_dist: settings.max_repulsion_dist,
+            boundary_margin: settings.boundary_margin,
+            boundary_force_strength: settings.boundary_force_strength,
+            warmup_curve: settings.warmup_curve.clone(),
+            zero_velocity_iterations: settings.zero_velocity_iterations,
+            clustering_algorithm: settings.clustering_algorithm.clone(),
+            cluster_count: settings.cluster_count,
+            clustering_resolution: settings.clustering_resolution,
+            clustering_iterations: settings.clustering_iterations,
+        }
+    }
+}
+
+impl From<&crate::config::AutoBalanceConfig> for AutoBalanceConfigDTO {
+    fn from(settings: &crate::config::AutoBalanceConfig) -> Self {
+        Self {
+            stability_variance_threshold: settings.stability_variance_threshold,
+            stability_frame_count: settings.stability_frame_count,
+            clustering_distance_threshold: settings.clustering_distance_threshold,
+            bouncing_node_percentage: settings.bouncing_node_percentage,
+            boundary_min_distance: settings.boundary_min_distance,
+            boundary_max_distance: settings.boundary_max_distance,
+            extreme_distance_threshold: settings.extreme_distance_threshold,
+            explosion_distance_threshold: settings.explosion_distance_threshold,
+            spreading_distance_threshold: settings.spreading_distance_threshold,
+            oscillation_detection_frames: settings.oscillation_detection_frames,
+            oscillation_change_threshold: settings.oscillation_change_threshold,
+            min_oscillation_changes: settings.min_oscillation_changes,
+            grid_cell_size_min: settings.grid_cell_size_min,
+            grid_cell_size_max: settings.grid_cell_size_max,
+            repulsion_cutoff_min: settings.repulsion_cutoff_min,
+            repulsion_cutoff_max: settings.repulsion_cutoff_max,
+            repulsion_softening_min: settings.repulsion_softening_min,
+            repulsion_softening_max: settings.repulsion_softening_max,
+            center_gravity_min: settings.center_gravity_min,
+            center_gravity_max: settings.center_gravity_max,
+            spatial_hash_efficiency_threshold: settings.spatial_hash_efficiency_threshold,
+            cluster_density_threshold: settings.cluster_density_threshold,
+            numerical_instability_threshold: settings.numerical_instability_threshold,
+        }
+    }
+}
+
+impl From<&crate::config::CameraSettings> for CameraSettingsDTO {
+    fn from(settings: &crate::config::CameraSettings) -> Self {
+        Self {
+            fov: settings.fov,
+            near: settings.near,
+            far: settings.far,
+            position: (&settings.position).into(),
+            look_at: (&settings.look_at).into(),
+        }
+    }
+}
+
+impl From<&crate::config::Position> for PositionDTO {
+    fn from(pos: &crate::config::Position) -> Self {
+        Self {
+            x: pos.x,
+            y: pos.y,
+            z: pos.z,
+        }
+    }
+}
+
+impl From<&crate::config::SpacePilotSettings> for SpacePilotSettingsDTO {
+    fn from(settings: &crate::config::SpacePilotSettings) -> Self {
+        Self {
+            enabled: settings.enabled,
+            mode: settings.mode.clone(),
+            sensitivity: (&settings.sensitivity).into(),
+            smoothing: settings.smoothing,
+            deadzone: settings.deadzone,
+            button_functions: settings.button_functions.clone(),
+        }
+    }
+}
+
+impl From<&crate::config::Sensitivity> for SensitivityDTO {
+    fn from(sens: &crate::config::Sensitivity) -> Self {
+        Self {
+            translation: sens.translation,
+            rotation: sens.rotation,
+        }
+    }
+}
+
+impl From<&crate::config::SystemSettings> for SystemSettingsDTO {
+    fn from(settings: &crate::config::SystemSettings) -> Self {
+        Self {
+            network: (&settings.network).into(),
+            websocket: (&settings.websocket).into(),
+            security: (&settings.security).into(),
+            debug: (&settings.debug).into(),
+            persist_settings: settings.persist_settings,
+            custom_backend_url: settings.custom_backend_url.clone(),
+        }
+    }
+}
+
+impl From<&crate::config::NetworkSettings> for NetworkSettingsDTO {
+    fn from(settings: &crate::config::NetworkSettings) -> Self {
+        Self {
+            bind_address: settings.bind_address.clone(),
+            domain: settings.domain.clone(),
+            enable_http2: settings.enable_http2,
+            enable_rate_limiting: settings.enable_rate_limiting,
+            enable_tls: settings.enable_tls,
+            max_request_size: settings.max_request_size,
+            min_tls_version: settings.min_tls_version.clone(),
+            port: settings.port,
+            rate_limit_requests: settings.rate_limit_requests,
+            rate_limit_window: settings.rate_limit_window,
+            tunnel_id: settings.tunnel_id.clone(),
+            api_client_timeout: settings.api_client_timeout,
+            enable_metrics: settings.enable_metrics,
+            max_concurrent_requests: settings.max_concurrent_requests,
+            max_retries: settings.max_retries,
+            metrics_port: settings.metrics_port,
+            retry_delay: settings.retry_delay,
+        }
+    }
+}
+
+impl From<&crate::config::WebSocketSettings> for WebSocketSettingsDTO {
+    fn from(settings: &crate::config::WebSocketSettings) -> Self {
+        Self {
+            binary_chunk_size: settings.binary_chunk_size,
+            binary_update_rate: settings.binary_update_rate,
+            min_update_rate: settings.min_update_rate,
+            max_update_rate: settings.max_update_rate,
+            motion_threshold: settings.motion_threshold,
+            motion_damping: settings.motion_damping,
+            binary_message_version: settings.binary_message_version,
+            compression_enabled: settings.compression_enabled,
+            compression_threshold: settings.compression_threshold,
+            heartbeat_interval: settings.heartbeat_interval,
+            heartbeat_timeout: settings.heartbeat_timeout,
+            max_connections: settings.max_connections,
+            max_message_size: settings.max_message_size,
+            reconnect_attempts: settings.reconnect_attempts,
+            reconnect_delay: settings.reconnect_delay,
+            update_rate: settings.update_rate,
+        }
+    }
+}
+
+impl From<&crate::config::SecuritySettings> for SecuritySettingsDTO {
+    fn from(settings: &crate::config::SecuritySettings) -> Self {
+        Self {
+            allowed_origins: settings.allowed_origins.clone(),
+            audit_log_path: settings.audit_log_path.clone(),
+            cookie_httponly: settings.cookie_httponly,
+            cookie_samesite: settings.cookie_samesite.clone(),
+            cookie_secure: settings.cookie_secure,
+            csrf_token_timeout: settings.csrf_token_timeout,
+            enable_audit_logging: settings.enable_audit_logging,
+            enable_request_validation: settings.enable_request_validation,
+            session_timeout: settings.session_timeout,
+        }
+    }
+}
+
+impl From<&crate::config::DebugSettings> for DebugSettingsDTO {
+    fn from(settings: &crate::config::DebugSettings) -> Self {
+        Self {
+            enabled: settings.enabled,
+        }
+    }
+}
+
+impl From<&crate::config::XRSettings> for XRSettingsDTO {
+    fn from(settings: &crate::config::XRSettings) -> Self {
+        Self {
+            enabled: settings.enabled,
+            client_side_enable_xr: settings.client_side_enable_xr,
+            mode: settings.mode.clone(),
+            room_scale: settings.room_scale,
+            space_type: settings.space_type.clone(),
+            quality: settings.quality.clone(),
+            render_scale: settings.render_scale,
+            interaction_distance: settings.interaction_distance,
+            locomotion_method: settings.locomotion_method.clone(),
+            teleport_ray_color: settings.teleport_ray_color.clone(),
+            controller_ray_color: settings.controller_ray_color.clone(),
+            controller_model: settings.controller_model.clone(),
+            enable_hand_tracking: settings.enable_hand_tracking,
+            hand_mesh_enabled: settings.hand_mesh_enabled,
+            hand_mesh_color: settings.hand_mesh_color.clone(),
+            hand_mesh_opacity: settings.hand_mesh_opacity,
+            hand_point_size: settings.hand_point_size,
+            hand_ray_enabled: settings.hand_ray_enabled,
+            hand_ray_color: settings.hand_ray_color.clone(),
+            hand_ray_width: settings.hand_ray_width,
+            gesture_smoothing: settings.gesture_smoothing,
+            enable_haptics: settings.enable_haptics,
+            haptic_intensity: settings.haptic_intensity,
+            drag_threshold: settings.drag_threshold,
+            pinch_threshold: settings.pinch_threshold,
+            rotation_threshold: settings.rotation_threshold,
+            interaction_radius: settings.interaction_radius,
+            movement_speed: settings.movement_speed,
+            dead_zone: settings.dead_zone,
+            movement_axes: (&settings.movement_axes).into(),
+            enable_light_estimation: settings.enable_light_estimation,
+            enable_plane_detection: settings.enable_plane_detection,
+            enable_scene_understanding: settings.enable_scene_understanding,
+            plane_color: settings.plane_color.clone(),
+            plane_opacity: settings.plane_opacity,
+            plane_detection_distance: settings.plane_detection_distance,
+            show_plane_overlay: settings.show_plane_overlay,
+            snap_to_floor: settings.snap_to_floor,
+            enable_passthrough_portal: settings.enable_passthrough_portal,
+            passthrough_opacity: settings.passthrough_opacity,
+            passthrough_brightness: settings.passthrough_brightness,
+            passthrough_contrast: settings.passthrough_contrast,
+            portal_size: settings.portal_size,
+            portal_edge_color: settings.portal_edge_color.clone(),
+            portal_edge_width: settings.portal_edge_width,
+        }
+    }
+}
+
+impl From<&crate::config::MovementAxes> for MovementAxesDTO {
+    fn from(axes: &crate::config::MovementAxes) -> Self {
+        Self {
+            horizontal: axes.horizontal,
+            vertical: axes.vertical,
+        }
+    }
+}
+
+impl From<&crate::config::AuthSettings> for AuthSettingsDTO {
+    fn from(settings: &crate::config::AuthSettings) -> Self {
+        Self {
+            enabled: settings.enabled,
+            provider: settings.provider.clone(),
+            required: settings.required,
+        }
+    }
+}
+
+impl From<&crate::config::RagFlowSettings> for RagFlowSettingsDTO {
+    fn from(settings: &crate::config::RagFlowSettings) -> Self {
+        Self {
+            api_key: settings.api_key.clone(),
+            agent_id: settings.agent_id.clone(),
+            api_base_url: settings.api_base_url.clone(),
+            timeout: settings.timeout,
+            max_retries: settings.max_retries,
+            chat_id: settings.chat_id.clone(),
+        }
+    }
+}
+
+impl From<&crate::config::PerplexitySettings> for PerplexitySettingsDTO {
+    fn from(settings: &crate::config::PerplexitySettings) -> Self {
+        Self {
+            api_key: settings.api_key.clone(),
+            model: settings.model.clone(),
+            api_url: settings.api_url.clone(),
+            max_tokens: settings.max_tokens,
+            temperature: settings.temperature,
+            top_p: settings.top_p,
+            presence_penalty: settings.presence_penalty,
+            frequency_penalty: settings.frequency_penalty,
+            timeout: settings.timeout,
+            rate_limit: settings.rate_limit,
+        }
+    }
+}
+
+impl From<&crate::config::OpenAISettings> for OpenAISettingsDTO {
+    fn from(settings: &crate::config::OpenAISettings) -> Self {
+        Self {
+            api_key: settings.api_key.clone(),
+            base_url: settings.base_url.clone(),
+            timeout: settings.timeout,
+            rate_limit: settings.rate_limit,
+        }
+    }
+}
+
+impl From<&crate::config::KokoroSettings> for KokoroSettingsDTO {
+    fn from(settings: &crate::config::KokoroSettings) -> Self {
+        Self {
+            api_url: settings.api_url.clone(),
+            default_voice: settings.default_voice.clone(),
+            default_format: settings.default_format.clone(),
+            default_speed: settings.default_speed,
+            timeout: settings.timeout,
+            stream: settings.stream,
+            return_timestamps: settings.return_timestamps,
+            sample_rate: settings.sample_rate,
+        }
+    }
+}
+
+impl From<&crate::config::WhisperSettings> for WhisperSettingsDTO {
+    fn from(settings: &crate::config::WhisperSettings) -> Self {
+        Self {
+            api_url: settings.api_url.clone(),
+            default_model: settings.default_model.clone(),
+            default_language: settings.default_language.clone(),
+            timeout: settings.timeout,
+            temperature: settings.temperature,
+            return_timestamps: settings.return_timestamps,
+            vad_filter: settings.vad_filter,
+            word_timestamps: settings.word_timestamps,
+            initial_prompt: settings.initial_prompt.clone(),
+        }
+    }
+}
+
+/// Enhanced settings handler with comprehensive validation
+pub struct EnhancedSettingsHandler {
+    validation_service: ValidationService,
+    rate_limiter: Arc<RateLimiter>,
+}
+
+impl EnhancedSettingsHandler {
+    pub fn new() -> Self {
+        let config = EndpointRateLimits::settings_update();
+        let rate_limiter = Arc::new(RateLimiter::new(config));
+
+        Self {
+            validation_service: ValidationService::new(),
+            rate_limiter,
+        }
+    }
+
+    /// Enhanced settings update with full validation
+    pub async fn update_settings_enhanced(
+        &self,
+        req: HttpRequest,
+        state: web::Data<AppState>,
+        payload: web::Json<Value>,
+    ) -> Result<HttpResponse, Error> {
+        let client_id = extract_client_id(&req);
+        
+        // Rate limiting check
+        if !self.rate_limiter.is_allowed(&client_id) {
+            warn!("Rate limit exceeded for settings update from client: {}", client_id);
+            return Ok(HttpResponse::TooManyRequests().json(json!({
+                "error": "rate_limit_exceeded",
+                "message": "Too many settings update requests. Please wait before retrying.",
+                "client_id": client_id,
+                "retry_after": self.rate_limiter.reset_time(&client_id).as_secs()
+            })));
+        }
+
+        // Request size check
+        let payload_size = serde_json::to_vec(&*payload).unwrap_or_default().len();
+        if payload_size > MAX_REQUEST_SIZE {
+            error!("Settings update payload too large: {} bytes", payload_size);
+            return Ok(HttpResponse::PayloadTooLarge().json(json!({
+                "error": "payload_too_large",
+                "message": format!("Payload size {} bytes exceeds limit of {} bytes", payload_size, MAX_REQUEST_SIZE),
+                "max_size": MAX_REQUEST_SIZE
+            })));
+        }
+
+        // Processing settings update
+
+        // Comprehensive validation
+        let validated_payload = match self.validation_service.validate_settings_update(&payload) {
+            Ok(sanitized) => sanitized,
+            Err(validation_error) => {
+                warn!("Settings validation failed for client {}: {}", client_id, validation_error);
+                return Ok(validation_error.to_http_response());
+            }
+        };
+
+        // Settings validation passed
+
+        // Continue with existing update logic using validated payload
+        let update = validated_payload;
+        
+        // Settings update received
+        
+        // Get current settings
+        let mut app_settings = match state.settings_addr.send(GetSettings).await {
+            Ok(Ok(s)) => s,
+            Ok(Err(e)) => {
+                error!("Failed to get current settings: {}", e);
+                return Ok(HttpResponse::InternalServerError().json(json!({
+                    "error": "Failed to get current settings"
+                })));
+            }
+            Err(e) => {
+                error!("Settings actor error: {}", e);
+                return Ok(HttpResponse::ServiceUnavailable().json(json!({
+                    "error": "Settings service unavailable"
+                })));
+            }
+        };
+        
+        // Continue with existing auto-balance logic...
+        let mut modified_update = update.clone();
+        let auto_balance_update = update.get("visualisation")
+            .and_then(|v| v.get("graphs"))
+            .and_then(|g| {
+                if let Some(logseq) = g.get("logseq") {
+                    if let Some(physics) = logseq.get("physics") {
+                        if let Some(auto_balance) = physics.get("autoBalance") {
+                            return Some(auto_balance.clone());
+                        }
+                    }
+                }
+                if let Some(visionflow) = g.get("visionflow") {
+                    if let Some(physics) = visionflow.get("physics") {
+                        if let Some(auto_balance) = physics.get("autoBalance") {
+                            return Some(auto_balance.clone());
+                        }
+                    }
+                }
+                None
+            });
+        
+        // If auto_balance is being updated, apply to both graphs
+        if let Some(ref auto_balance_value) = auto_balance_update {
+            // Synchronizing auto_balance setting across both graphs
+            
+            let vis_obj = modified_update.as_object_mut()
+                .and_then(|o| o.entry("visualisation").or_insert_with(|| json!({})).as_object_mut())
+                .and_then(|v| v.entry("graphs").or_insert_with(|| json!({})).as_object_mut());
+            
+            if let Some(graphs) = vis_obj {
+                let logseq_physics = graphs
+                    .entry("logseq").or_insert_with(|| json!({})).as_object_mut()
+                    .and_then(|l| l.entry("physics").or_insert_with(|| json!({})).as_object_mut());
+                if let Some(physics) = logseq_physics {
+                    physics.insert("autoBalance".to_string(), auto_balance_value.clone());
+                }
+                
+                let visionflow_physics = graphs
+                    .entry("visionflow").or_insert_with(|| json!({})).as_object_mut()
+                    .and_then(|v| v.entry("physics").or_insert_with(|| json!({})).as_object_mut());
+                if let Some(physics) = visionflow_physics {
+                    physics.insert("autoBalance".to_string(), auto_balance_value.clone());
+                }
+            }
+        }
+        
+        // Merge the (possibly modified) update
+        if let Err(e) = app_settings.merge_update(modified_update.clone()) {
+            error!("Failed to merge settings: {}", e);
+            if crate::utils::logging::is_debug_enabled() {
+                error!("Update payload that caused error: {}", serde_json::to_string_pretty(&modified_update).unwrap_or_else(|_| "Could not serialize".to_string()));
+            }
+            return Ok(HttpResponse::InternalServerError().json(json!({
+                "error": format!("Failed to merge settings: {}", e)
+            })));
+        }
+        
+        // Continue with existing update logic...
+        let updated_graphs = if auto_balance_update.is_some() {
+            vec!["logseq", "visionflow"]
+        } else {
+            modified_update.get("visualisation")
+                .and_then(|v| v.get("graphs"))
+                .and_then(|g| g.as_object())
+                .map(|graphs| {
+                    let mut updated = Vec::new();
+                    if graphs.contains_key("logseq") {
+                        updated.push("logseq");
+                    }
+                    if graphs.contains_key("visionflow") {
+                        updated.push("visionflow");
+                    }
+                    updated
+                })
+                .unwrap_or_default()
+        };
+        
+        let auto_balance_active = app_settings.visualisation.graphs.logseq.physics.auto_balance 
+            || app_settings.visualisation.graphs.visionflow.physics.auto_balance;
+        
+        // Save updated settings
+        match state.settings_addr.send(UpdateSettings { settings: app_settings.clone() }).await {
+            Ok(Ok(())) => {
+                // Settings updated successfully
+                
+                let is_auto_balance_change = auto_balance_update.is_some();
+                
+                if is_auto_balance_change || !auto_balance_active {
+                    // Only use logseq (knowledge graph) physics for now
+                    // TODO: Add graph type selection when agent graph is implemented
+                    propagate_physics_to_gpu(&state, &app_settings, "logseq").await;
+                    if is_auto_balance_change {
+                        // Propagating auto_balance setting change to GPU
+                    }
+                } else {
+                    // Skipping physics propagation - auto-balance is active
+                }
+                
+                let response_dto: SettingsResponseDTO = (&app_settings).into();
+                
+                Ok(HttpResponse::Ok().json(json!({
+                    "status": "success",
+                    "message": "Settings updated successfully",
+                    "settings": response_dto,
+                    "client_id": client_id,
+                    "timestamp": chrono::Utc::now().to_rfc3339()
+                })))
+            }
+            Ok(Err(e)) => {
+                error!("Failed to save settings: {}", e);
+                Ok(HttpResponse::InternalServerError().json(json!({
+                    "error": format!("Failed to save settings: {}", e)
+                })))
+            }
+            Err(e) => {
+                error!("Settings actor error: {}", e);
+                Ok(HttpResponse::ServiceUnavailable().json(json!({
+                    "error": "Settings service unavailable"
+                })))
+            }
+        }
+    }
+
+    /// Enhanced get settings with validation metadata
+    pub async fn get_settings_enhanced(
+        &self,
+        req: HttpRequest,
+        state: web::Data<AppState>,
+    ) -> Result<HttpResponse, Error> {
+        let client_id = extract_client_id(&req);
+
+        // Rate limiting (more permissive for GET requests)
+        let get_rate_limiter = Arc::new(RateLimiter::new(RateLimitConfig {
+            requests_per_minute: 120,
+            burst_size: 20,
+            ..Default::default()
+        }));
+
+        if !get_rate_limiter.is_allowed(&client_id) {
+            return Ok(HttpResponse::TooManyRequests().json(json!({
+                "error": "rate_limit_exceeded",
+                "message": "Too many get settings requests"
+            })));
+        }
+
+        // Processing get settings request
+
+        let app_settings = match state.settings_addr.send(GetSettings).await {
+            Ok(Ok(settings)) => settings,
+            Ok(Err(e)) => {
+                error!("Failed to get settings: {}", e);
+                return Ok(HttpResponse::InternalServerError().json(json!({
+                    "error": "Failed to retrieve settings"
+                })));
+            }
+            Err(e) => {
+                error!("Settings actor error: {}", e);
+                return Ok(HttpResponse::ServiceUnavailable().json(json!({
+                    "error": "Settings service unavailable"
+                })));
+            }
+        };
+        
+        let response_dto: SettingsResponseDTO = (&app_settings).into();
+        
+        Ok(HttpResponse::Ok().json(json!({
+            "status": "success",
+            "settings": response_dto,
+            "validation_info": {
+                "input_sanitization": "enabled",
+                "rate_limiting": "active",
+                "schema_validation": "enforced"
+            },
+            "client_id": client_id,
+            "timestamp": chrono::Utc::now().to_rfc3339()
+        })))
+    }
+
+    /// Reset settings with validation
+    pub async fn reset_settings_enhanced(
+        &self,
+        req: HttpRequest,
+        state: web::Data<AppState>,
+    ) -> Result<HttpResponse, Error> {
+        let client_id = extract_client_id(&req);
+
+        // Stricter rate limiting for reset operations
+        let reset_rate_limiter = Arc::new(RateLimiter::new(RateLimitConfig {
+            requests_per_minute: 10,
+            burst_size: 2,
+            ..Default::default()
+        }));
+
+        if !reset_rate_limiter.is_allowed(&client_id) {
+            warn!("Rate limit exceeded for settings reset from client: {}", client_id);
+            return Ok(HttpResponse::TooManyRequests().json(json!({
+                "error": "rate_limit_exceeded",
+                "message": "Too many reset requests. This is a destructive operation with strict limits."
+            })));
+        }
+
+        // Processing settings reset request
+
+        // Load default settings
+        let default_settings = match AppFullSettings::new() {
+            Ok(settings) => settings,
+            Err(e) => {
+                error!("Failed to load default settings: {}", e);
+                return Ok(HttpResponse::InternalServerError().json(json!({
+                    "error": "Failed to load default settings"
+                })));
+            }
+        };
+
+        // Save as current settings
+        match state.settings_addr.send(UpdateSettings { settings: default_settings.clone() }).await {
+            Ok(Ok(())) => {
+                info!("Settings reset to defaults for client: {}", client_id);
+                
+                let response_dto: SettingsResponseDTO = (&default_settings).into();
+
+                Ok(HttpResponse::Ok().json(json!({
+                    "status": "success",
+                    "message": "Settings reset to defaults successfully",
+                    "settings": response_dto,
+                    "client_id": client_id,
+                    "timestamp": chrono::Utc::now().to_rfc3339()
+                })))
+            }
+            Ok(Err(e)) => {
+                error!("Failed to reset settings: {}", e);
+                Ok(HttpResponse::InternalServerError().json(json!({
+                    "error": format!("Failed to reset settings: {}", e)
+                })))
+            }
+            Err(e) => {
+                error!("Settings actor error during reset: {}", e);
+                Ok(HttpResponse::ServiceUnavailable().json(json!({
+                    "error": "Settings service unavailable during reset"
+                })))
+            }
+        }
+    }
+
+    /// Get validation statistics for settings
+    pub async fn get_validation_stats(
+        &self,
+        req: HttpRequest,
+    ) -> Result<HttpResponse, Error> {
+        let client_id = extract_client_id(&req);
+        debug!("Validation stats request from client: {}", client_id);
+
+        let stats = self.rate_limiter.get_stats();
+
+        Ok(HttpResponse::Ok().json(json!({
+            "validation_service": "active",
+            "rate_limiting": {
+                "total_clients": stats.total_clients,
+                "banned_clients": stats.banned_clients,
+                "active_clients": stats.active_clients,
+                "config": stats.config
+            },
+            "security_features": [
+                "comprehensive_input_validation",
+                "xss_prevention", 
+                "sql_injection_prevention",
+                "path_traversal_prevention",
+                "malicious_content_detection",
+                "rate_limiting",
+                "request_size_validation"
+            ],
+            "endpoints_protected": [
+                "/settings",
+                "/settings/reset", 
+                "/physics/update",
+                "/physics/compute-mode",
+                "/clustering/algorithm",
+                "/constraints/update",
+                "/stress/optimization"
+            ],
+            "timestamp": chrono::Utc::now().to_rfc3339()
+        })))
+    }
+
+    /// Propagate physics updates to GPU actors
+    async fn propagate_physics_updates(
+        &self,
+        state: &web::Data<AppState>,
+        settings: &AppFullSettings,
+        update: &Value,
+    ) {
+        // Check if physics was updated
+        let has_physics_update = update.get("visualisation")
+            .and_then(|v| v.get("graphs"))
+            .map(|g| {
+                g.as_object()
+                    .map(|obj| obj.values().any(|graph| graph.get("physics").is_some()))
+                    .unwrap_or(false)
+            })
+            .unwrap_or(false);
+
+        if has_physics_update {
+            info!("Propagating physics updates to GPU actors");
+            
+            // Only use logseq (knowledge graph) physics for now
+            // TODO: Add graph type selection when agent graph is implemented
+            let graph_name = "logseq";
+            let physics = settings.get_physics(graph_name);
+            let sim_params = crate::models::simulation_params::SimulationParams::from(physics);
+            
+            if let Some(gpu_addr) = &state.gpu_compute_addr {
+                if let Err(e) = gpu_addr.send(UpdateSimulationParams { params: sim_params }).await {
+                    error!("Failed to update GPU simulation params for {}: {}", graph_name, e);
+                } else {
+                    info!("GPU simulation params updated for {} (knowledge graph)", graph_name);
+                }
+            }
+        }
+    }
+}
+
+impl Default for EnhancedSettingsHandler {
+    fn default() -> Self {
+        Self::new()
+    }
+}
+
+/// Configure routes for settings endpoints
+pub fn config(cfg: &mut web::ServiceConfig) {
+    let handler = web::Data::new(EnhancedSettingsHandler::new());
+    
+    cfg.app_data(handler.clone())
+        .service(
+            web::scope("/settings")
+                .route("", web::get().to(|req, state, handler: web::Data<EnhancedSettingsHandler>| async move {
+                    // Try enhanced handler first, fallback to legacy
+                    match handler.get_settings_enhanced(req, state).await {
+                        Ok(response) => response,
+                        Err(_) => HttpResponse::InternalServerError().json(json!({"error": "Settings service temporarily unavailable"}))
+                    }
+                }))
+                .route("", web::post().to(|req, state, payload, handler: web::Data<EnhancedSettingsHandler>| async move {
+                    // Try enhanced handler first, fallback to legacy
+                    match handler.update_settings_enhanced(req, state, payload).await {
+                        Ok(response) => response,
+                        Err(_) => HttpResponse::InternalServerError().json(json!({"error": "Settings update service temporarily unavailable"}))
+                    }
+                }))
+                .route("/reset", web::post().to(|req, state, handler: web::Data<EnhancedSettingsHandler>| async move {
+                    // Try enhanced handler first, fallback to legacy
+                    match handler.reset_settings_enhanced(req, state).await {
+                        Ok(response) => response,
+                        Err(_) => HttpResponse::InternalServerError().json(json!({"error": "Settings reset service temporarily unavailable"}))
+                    }
+                }))
+                .route("/validation/stats", web::get().to(|req, handler: web::Data<EnhancedSettingsHandler>| async move {
+                    handler.get_validation_stats(req).await
+                }))
+        )
+        .service(
+            web::scope("/physics")
+                .route("/compute-mode", web::post().to(update_compute_mode))
+        )
+        .service(
+            web::scope("/clustering")
+                .route("/algorithm", web::post().to(update_clustering_algorithm))
+        )
+        .service(
+            web::scope("/constraints")
+                .route("/update", web::post().to(update_constraints))
+        )
+        .service(
+            web::scope("/analytics")
+                .route("/clusters", web::get().to(get_cluster_analytics))
+        )
+        .service(
+            web::scope("/stress")
+                .route("/optimization", web::post().to(update_stress_optimization))
+        );
+}
+
+/// Get current settings - returns camelCase JSON
+async fn get_settings(
+    _req: HttpRequest,
+    state: web::Data<AppState>,
+) -> Result<HttpResponse, Error> {
+    let app_settings = match state.settings_addr.send(GetSettings).await {
+        Ok(Ok(settings)) => settings,
+        Ok(Err(e)) => {
+            error!("Failed to get settings: {}", e);
+            return Ok(HttpResponse::InternalServerError().json(json!({
+                "error": "Failed to retrieve settings"
+            })));
+        }
+        Err(e) => {
+            error!("Settings actor error: {}", e);
+            return Ok(HttpResponse::ServiceUnavailable().json(json!({
+                "error": "Settings service unavailable"
+            })));
+        }
+    };
+    
+    // Convert to DTO with camelCase serialization for client
+    let response_dto: SettingsResponseDTO = (&app_settings).into();
+    
+    Ok(HttpResponse::Ok().json(response_dto))
+}
+
+/// Update settings with validation - accepts camelCase JSON
+async fn update_settings(
+    _req: HttpRequest,
+    state: web::Data<AppState>,
+    payload: web::Json<Value>,
+) -> Result<HttpResponse, Error> {
+    let update = payload.into_inner();
+    
+    debug!("Settings update received: {:?}", update);
+    
+    // Validate the update
+    if let Err(e) = validate_settings_update(&update) {
+        error!("Settings validation failed: {}", e);
+        error!("Failed update payload: {}", serde_json::to_string_pretty(&update).unwrap_or_default());
+        return Ok(HttpResponse::BadRequest().json(json!({
+            "error": format!("Invalid settings: {}", e)
+        })));
+    }
+    
+    // Get current settings
+    let mut app_settings = match state.settings_addr.send(GetSettings).await {
+        Ok(Ok(s)) => s,
+        Ok(Err(e)) => {
+            error!("Failed to get current settings: {}", e);
+            return Ok(HttpResponse::InternalServerError().json(json!({
+                "error": "Failed to get current settings"
+            })));
+        }
+        Err(e) => {
+            error!("Settings actor error: {}", e);
+            return Ok(HttpResponse::ServiceUnavailable().json(json!({
+                "error": "Settings service unavailable"
+            })));
+        }
+    };
+    
+    // Debug: Log the update payload before merging
+    if crate::utils::logging::is_debug_enabled() {
+        debug!("Settings update payload (before merge): {}", serde_json::to_string_pretty(&update).unwrap_or_else(|_| "Could not serialize".to_string()));
+    }
+    
+    // Check if auto_balance is being updated in either graph
+    // If so, apply it to both graphs for consistency
+    let mut modified_update = update.clone();
+    let auto_balance_update = update.get("visualisation")
+        .and_then(|v| v.get("graphs"))
+        .and_then(|g| {
+            // Check if logseq graph has auto_balance update
+            if let Some(logseq) = g.get("logseq") {
+                if let Some(physics) = logseq.get("physics") {
+                    if let Some(auto_balance) = physics.get("autoBalance") {
+                        return Some(auto_balance.clone());
+                    }
+                }
+            }
+            // Check if visionflow graph has auto_balance update
+            if let Some(visionflow) = g.get("visionflow") {
+                if let Some(physics) = visionflow.get("physics") {
+                    if let Some(auto_balance) = physics.get("autoBalance") {
+                        return Some(auto_balance.clone());
+                    }
+                }
+            }
+            None
+        });
+    
+    // If auto_balance is being updated, apply to both graphs
+    if let Some(ref auto_balance_value) = auto_balance_update {
+        info!("Synchronizing auto_balance setting across both graphs: {}", auto_balance_value);
+        
+        // Ensure the update structure exists for both graphs
+        let vis_obj = modified_update.as_object_mut()
+            .and_then(|o| o.entry("visualisation").or_insert_with(|| json!({})).as_object_mut())
+            .and_then(|v| v.entry("graphs").or_insert_with(|| json!({})).as_object_mut());
+        
+        if let Some(graphs) = vis_obj {
+            // Update logseq graph
+            let logseq_physics = graphs
+                .entry("logseq").or_insert_with(|| json!({})).as_object_mut()
+                .and_then(|l| l.entry("physics").or_insert_with(|| json!({})).as_object_mut());
+            if let Some(physics) = logseq_physics {
+                physics.insert("autoBalance".to_string(), auto_balance_value.clone());
+            }
+            
+            // Update visionflow graph
+            let visionflow_physics = graphs
+                .entry("visionflow").or_insert_with(|| json!({})).as_object_mut()
+                .and_then(|v| v.entry("physics").or_insert_with(|| json!({})).as_object_mut());
+            if let Some(physics) = visionflow_physics {
+                physics.insert("autoBalance".to_string(), auto_balance_value.clone());
+            }
+        }
+    }
+    
+    // Merge the (possibly modified) update
+    if let Err(e) = app_settings.merge_update(modified_update.clone()) {
+        error!("Failed to merge settings: {}", e);
+        if crate::utils::logging::is_debug_enabled() {
+            error!("Update payload that caused error: {}", serde_json::to_string_pretty(&modified_update).unwrap_or_else(|_| "Could not serialize".to_string()));
+        }
+        return Ok(HttpResponse::InternalServerError().json(json!({
+            "error": format!("Failed to merge settings: {}", e)
+        })));
+    }
+    
+    // Check which graphs had physics updated
+    // If auto_balance was synchronized, both graphs are considered updated
+    let updated_graphs = if auto_balance_update.is_some() {
+        vec!["logseq", "visionflow"]
+    } else {
+        modified_update.get("visualisation")
+            .and_then(|v| v.get("graphs"))
+            .and_then(|g| g.as_object())
+            .map(|graphs| {
+                let mut updated = Vec::new();
+                if graphs.contains_key("logseq") {
+                    updated.push("logseq");
+                }
+                if graphs.contains_key("visionflow") {
+                    updated.push("visionflow");
+                }
+                updated
+            })
+            .unwrap_or_default()
+    };
+    
+    // Check if auto-balance is enabled in the current settings
+    // If auto-balance is active, don't propagate physics back to avoid feedback loop
+    let auto_balance_active = app_settings.visualisation.graphs.logseq.physics.auto_balance 
+        || app_settings.visualisation.graphs.visionflow.physics.auto_balance;
+    
+    // Save updated settings
+    match state.settings_addr.send(UpdateSettings { settings: app_settings.clone() }).await {
+        Ok(Ok(())) => {
+            info!("Settings updated successfully");
+            
+            // Check if this update is changing the auto_balance setting itself
+            // If so, we MUST propagate it regardless of current auto_balance state
+            let is_auto_balance_change = auto_balance_update.is_some();
+            
+            // Propagate physics updates to GPU
+            // - Always propagate if auto_balance setting is being changed
+            // - Skip only if auto_balance is already active AND this isn't an auto_balance change
+            //   (to prevent feedback loops from auto-tuning adjustments)
+            if is_auto_balance_change || !auto_balance_active {
+                // Only use logseq (knowledge graph) physics for now
+                // TODO: Add graph type selection when agent graph is implemented
+                propagate_physics_to_gpu(&state, &app_settings, "logseq").await;
+                if is_auto_balance_change {
+                    info!("[AUTO-BALANCE] Propagating auto_balance setting change to GPU (logseq only)");
+                }
+            } else {
+                info!("[AUTO-BALANCE] Skipping physics propagation to GPU - auto-balance is active and not changing");
+            }
+            
+            // Return updated settings using DTO with camelCase serialization
+            let response_dto: SettingsResponseDTO = (&app_settings).into();
+            
+            Ok(HttpResponse::Ok().json(response_dto))
+        }
+        Ok(Err(e)) => {
+            error!("Failed to save settings: {}", e);
+            Ok(HttpResponse::InternalServerError().json(json!({
+                "error": format!("Failed to save settings: {}", e)
+            })))
+        }
+        Err(e) => {
+            error!("Settings actor error: {}", e);
+            Ok(HttpResponse::ServiceUnavailable().json(json!({
+                "error": "Settings service unavailable"
+            })))
+        }
+    }
+}
+
+/// Reset settings to defaults from settings.yaml
+async fn reset_settings(
+    _req: HttpRequest,
+    state: web::Data<AppState>,
+) -> Result<HttpResponse, Error> {
+    // Load default settings from YAML
+    let default_settings = match AppFullSettings::new() {
+        Ok(settings) => settings,
+        Err(e) => {
+            error!("Failed to load default settings: {}", e);
+            return Ok(HttpResponse::InternalServerError().json(json!({
+                "error": "Failed to load default settings"
+            })));
+        }
+    };
+    
+    // Save as current settings
+    match state.settings_addr.send(UpdateSettings { settings: default_settings.clone() }).await {
+        Ok(Ok(())) => {
+            info!("Settings reset to defaults");
+            
+            // Return default settings using DTO with camelCase serialization
+            let response_dto: SettingsResponseDTO = (&default_settings).into();
+            
+            Ok(HttpResponse::Ok().json(response_dto))
+        }
+        Ok(Err(e)) => {
+            error!("Failed to reset settings: {}", e);
+            Ok(HttpResponse::InternalServerError().json(json!({
+                "error": format!("Failed to reset settings: {}", e)
+            })))
+        }
+        Err(e) => {
+            error!("Settings actor error: {}", e);
+            Ok(HttpResponse::ServiceUnavailable().json(json!({
+                "error": "Settings service unavailable"
+            })))
+        }
+    }
+}
+
+/// Validate settings update payload
+fn validate_settings_update(update: &Value) -> Result<(), String> {
+    // Validate visualisation settings
+    if let Some(vis) = update.get("visualisation") {
+        if let Some(graphs) = vis.get("graphs") {
+            // Validate graph settings
+            for (graph_name, graph_settings) in graphs.as_object().ok_or("graphs must be an object")?.iter() {
+                if graph_name != "logseq" && graph_name != "visionflow" {
+                    return Err(format!("Invalid graph name: {}", graph_name));
+                }
+                
+                // Validate physics settings
+                if let Some(physics) = graph_settings.get("physics") {
+                    validate_physics_settings(physics)?;
+                }
+                
+                // Validate node settings
+                if let Some(nodes) = graph_settings.get("nodes") {
+                    validate_node_settings(nodes)?;
+                }
+            }
+        }
+        
+        // Validate rendering settings
+        if let Some(rendering) = vis.get("rendering") {
+            validate_rendering_settings(rendering)?;
+        }
+        
+        // Validate hologram settings
+        if let Some(hologram) = vis.get("hologram") {
+            validate_hologram_settings(hologram)?;
+        }
+    }
+    
+    // Validate XR settings
+    if let Some(xr) = update.get("xr") {
+        validate_xr_settings(xr)?;
+    }
+    
+    // Validate system settings
+    if let Some(system) = update.get("system") {
+        validate_system_settings(system)?;
+    }
+    
+    Ok(())
+}
+
+fn validate_physics_settings(physics: &Value) -> Result<(), String> {
+    // Log what fields are actually being sent
+    if let Some(obj) = physics.as_object() {
+        debug!("Physics settings fields received: {:?}", obj.keys().collect::<Vec<_>>());
+    }
+    
+    // Check if auto-balance is enabled - if so, be more lenient with validation
+    let auto_balance_enabled = physics.get("autoBalance")
+        .and_then(|v| v.as_bool())
+        .unwrap_or(false);
+    
+    
+    // Validate damping - MUST be high for stability
+    // Allow up to 0.999 for auto-balance aggressive damping
+    if let Some(damping) = physics.get("damping") {
+        let val = damping.as_f64().ok_or("damping must be a number")?;
+        // Round to 3 decimal places to handle floating point precision issues
+        let rounded_val = (val * 1000.0).round() / 1000.0;
+        
+        // Be more lenient with auto-balance enabled
+        let max_damping = if auto_balance_enabled { 1.0 } else { 0.999 };
+        
+        if rounded_val < 0.0 || rounded_val > 1.0 {
+            return Err("damping must be between 0.0 and 1.0".to_string());
+        }
+    }
+    
+    // Validate iterations - LIMIT FOR PERFORMANCE
+    if let Some(iterations) = physics.get("iterations") {
+        // Accept both integer and float values (JavaScript sends 100.0 as float)
+        let val = iterations.as_f64()
+            .map(|f| f.round() as u64)  // Round and cast float to u64
+            .or_else(|| iterations.as_u64())  // Also accept direct integer
+            .ok_or("iterations must be a positive number")?;
+        if val == 0 || val > 1000 {  // Allow more iterations
+            return Err("iterations must be between 1 and 1000".to_string());
+        }
+    }
+    
+    // Spring strength validation
+    // Allow lower values for auto-balance fine-tuning
+    if let Some(spring_k) = physics.get("springK") {
+        let val = spring_k.as_f64().ok_or("springK must be a number")?;
+        if !(0.0001..=10.0).contains(&val) {
+            return Err("springK must be between 0.0001 and 10.0".to_string());
+        }
+    }
+    
+    // Repulsion strength validation - SAFE RANGE
+    // Allow lower values (down to 0.001) for auto-balance stabilization
+    if let Some(repel_k) = physics.get("repelK") {
+        let val = repel_k.as_f64().ok_or("repelK must be a number")?;
+        if val < 0.0001 || val > 10000.0 {
+            return Err("repelK must be between 0.0001 and 10000.0".to_string());
+        }
+    }
+    
+    // Attraction strength validation
+    if let Some(attraction_k) = physics.get("attractionK") {
+        let val = attraction_k.as_f64().ok_or("attractionK must be a number")?;
+        if !(0.0..=10.0).contains(&val) {
+            return Err("attractionK must be between 0.0 and 10.0".to_string());
+        }
+    }
+    
+    // Bounds size validation
+    if let Some(bounds) = physics.get("boundsSize") {
+        let val = bounds.as_f64().ok_or("boundsSize must be a number")?;
+        if val < 1.0 || val > 100000.0 {  // Very generous range
+            return Err("boundsSize must be between 1.0 and 100000.0".to_string());
+        }
+    }
+    
+    // Separation radius validation
+    if let Some(separation_radius) = physics.get("separationRadius") {
+        let val = separation_radius.as_f64().ok_or("separationRadius must be a number")?;
+        if val < 0.01 || val > 100.0 {
+            return Err("separationRadius must be between 0.01 and 100.0".to_string());
+        }
+    }
+    
+    // Max velocity validation - PREVENT EXPLOSION
+    // Allow lower values (down to 0.05) for auto-balance aggressive stabilization
+    if let Some(max_vel) = physics.get("maxVelocity") {
+        let val = max_vel.as_f64().ok_or("maxVelocity must be a number")?;
+        if val < 0.001 || val > 1000.0 {  // Very generous range
+            return Err("maxVelocity must be between 0.001 and 1000.0".to_string());
+        }
+    }
+    
+    // Mass scale validation
+    if let Some(mass) = physics.get("massScale") {
+        let val = mass.as_f64().ok_or("massScale must be a number")?;
+        if val < 0.01 || val > 100.0 {  // Generous range
+            return Err("massScale must be between 0.01 and 100.0".to_string());
+        }
+    }
+    
+    // Boundary damping validation
+    if let Some(boundary) = physics.get("boundaryDamping") {
+        let val = boundary.as_f64().ok_or("boundaryDamping must be a number")?;
+        if !(0.0..=1.0).contains(&val) {
+            return Err("boundaryDamping must be between 0.0 and 1.0".to_string());
+        }
+    }
+    
+    // Time step validation - NUMERICAL STABILITY
+    // Check both timeStep and dt (client might send either)
+    let time_step = physics.get("timeStep").or_else(|| physics.get("dt"));
+    if let Some(time_step) = time_step {
+        let val = time_step.as_f64().ok_or("timeStep/dt must be a number")?;
+        if val <= 0.0 || val > 1.0 {  // Generous range
+            return Err("timeStep/dt must be between 0.001 and 1.0".to_string());
+        }
+    }
+    
+    // Temperature validation
+    if let Some(temp) = physics.get("temperature") {
+        let val = temp.as_f64().ok_or("temperature must be a number")?;
+        if val < 0.0 || val > 100.0 {  // Generous range
+            return Err("temperature must be between 0.0 and 100.0".to_string());
+        }
+    }
+    
+    // Gravity validation
+    if let Some(gravity) = physics.get("gravity") {
+        let val = gravity.as_f64().ok_or("gravity must be a number")?;
+        if val < -100.0 || val > 100.0 {  // Generous range
+            return Err("gravity must be between -100.0 and 100.0".to_string());
+        }
+    }
+    
+    // Update threshold validation
+    if let Some(threshold) = physics.get("updateThreshold") {
+        let val = threshold.as_f64().ok_or("updateThreshold must be a number")?;
+        if val < 0.0 || val > 10.0 {
+            return Err("updateThreshold must be between 0.0 and 10.0".to_string());
+        }
+    }
+    
+    // NEW GPU-ALIGNED PARAMETERS
+    
+    // Stress weight validation
+    if let Some(stress_weight) = physics.get("stressWeight") {
+        let val = stress_weight.as_f64().ok_or("stressWeight must be a number")?;
+        if !(0.0..=1.0).contains(&val) {
+            return Err("stressWeight must be between 0.0 and 1.0".to_string());
+        }
+    }
+    
+    // Stress alpha validation
+    if let Some(stress_alpha) = physics.get("stressAlpha") {
+        let val = stress_alpha.as_f64().ok_or("stressAlpha must be a number")?;
+        if !(0.0..=1.0).contains(&val) {
+            return Err("stressAlpha must be between 0.0 and 1.0".to_string());
+        }
+    }
+    
+    // Alignment strength validation
+    if let Some(alignment_strength) = physics.get("alignmentStrength") {
+        let val = alignment_strength.as_f64().ok_or("alignmentStrength must be a number")?;
+        if !(0.0..=10.0).contains(&val) {
+            return Err("alignmentStrength must be between 0.0 and 10.0".to_string());
+        }
+    }
+    
+    // Cluster strength validation
+    if let Some(cluster_strength) = physics.get("clusterStrength") {
+        let val = cluster_strength.as_f64().ok_or("clusterStrength must be a number")?;
+        if !(0.0..=10.0).contains(&val) {
+            return Err("clusterStrength must be between 0.0 and 10.0".to_string());
+        }
+    }
+    
+    // Compute mode validation (0=Basic, 1=Dual Graph, 2=Constraints, 3=Visual Analytics)
+    if let Some(compute_mode) = physics.get("computeMode") {
+        let val = compute_mode.as_u64()
+            .or_else(|| compute_mode.as_f64().map(|f| f.round() as u64))
+            .ok_or("computeMode must be an integer")?;
+        if val > 3 {
+            return Err("computeMode must be between 0 and 3".to_string());
+        }
+    }
+    
+    // Additional GPU parameters validation
+    if let Some(min_distance) = physics.get("minDistance") {
+        let val = min_distance.as_f64().ok_or("minDistance must be a number")?;
+        if val < 0.001 || val > 10.0 {
+            return Err("minDistance must be between 0.001 and 10.0".to_string());
+        }
+    }
+    
+    if let Some(max_repulsion_dist) = physics.get("maxRepulsionDist") {
+        let val = max_repulsion_dist.as_f64().ok_or("maxRepulsionDist must be a number")?;
+        if val < 1.0 || val > 10000.0 {
+            return Err("maxRepulsionDist must be between 1.0 and 10000.0".to_string());
+        }
+    }
+    
+    if let Some(boundary_margin) = physics.get("boundaryMargin") {
+        let val = boundary_margin.as_f64().ok_or("boundaryMargin must be a number")?;
+        if val < 0.0 || val > 1.0 {
+            return Err("boundaryMargin must be between 0.0 and 1.0".to_string());
+        }
+    }
+    
+    if let Some(boundary_force_strength) = physics.get("boundaryForceStrength") {
+        let val = boundary_force_strength.as_f64().ok_or("boundaryForceStrength must be a number")?;
+        if val < 0.0 || val > 100.0 {
+            return Err("boundaryForceStrength must be between 0.0 and 100.0".to_string());
+        }
+    }
+    
+    if let Some(warmup_iterations) = physics.get("warmupIterations") {
+        let val = warmup_iterations.as_u64()
+            .or_else(|| warmup_iterations.as_f64().map(|f| f.round() as u64))
+            .ok_or("warmupIterations must be an integer")?;
+        if val > 10000 {
+            return Err("warmupIterations must be between 0 and 10000".to_string());
+        }
+    }
+    
+    if let Some(warmup_curve) = physics.get("warmupCurve") {
+        let val = warmup_curve.as_str().ok_or("warmupCurve must be a string")?;
+        if !["linear", "quadratic", "cubic"].contains(&val) {
+            return Err("warmupCurve must be 'linear', 'quadratic', or 'cubic'".to_string());
+        }
+    }
+    
+    if let Some(zero_velocity_iterations) = physics.get("zeroVelocityIterations") {
+        let val = zero_velocity_iterations.as_u64()
+            .or_else(|| zero_velocity_iterations.as_f64().map(|f| f.round() as u64))
+            .ok_or("zeroVelocityIterations must be an integer")?;
+        if val > 1000 {
+            return Err("zeroVelocityIterations must be between 0 and 1000".to_string());
+        }
+    }
+    
+    if let Some(cooling_rate) = physics.get("coolingRate") {
+        let val = cooling_rate.as_f64().ok_or("coolingRate must be a number")?;
+        if val < 0.0 || val > 1.0 {
+            return Err("coolingRate must be between 0.0 and 1.0".to_string());
+        }
+    }
+    
+    // Auto-balance validation
+    if let Some(auto_balance) = physics.get("autoBalance") {
+        if !auto_balance.is_boolean() {
+            return Err("autoBalance must be a boolean".to_string());
+        }
+    }
+    
+    if let Some(auto_balance_interval) = physics.get("autoBalanceIntervalMs") {
+        let val = auto_balance_interval.as_u64()
+            .or_else(|| auto_balance_interval.as_f64().map(|f| f.round() as u64))
+            .ok_or("autoBalanceIntervalMs must be a positive integer")?;
+        if val < 10 || val > 60000 {
+            return Err("autoBalanceIntervalMs must be between 10 and 60000 ms".to_string());
+        }
+    }
+    
+    // Clustering parameters validation
+    if let Some(clustering_algorithm) = physics.get("clusteringAlgorithm") {
+        let val = clustering_algorithm.as_str().ok_or("clusteringAlgorithm must be a string")?;
+        if !["none", "kmeans", "spectral", "louvain"].contains(&val) {
+            return Err("clusteringAlgorithm must be 'none', 'kmeans', 'spectral', or 'louvain'".to_string());
+        }
+    }
+    
+    if let Some(cluster_count) = physics.get("clusterCount") {
+        let val = cluster_count.as_u64()
+            .or_else(|| cluster_count.as_f64().map(|f| f.round() as u64))
+            .ok_or("clusterCount must be an integer")?;
+        if val < 1 || val > 1000 {
+            return Err("clusterCount must be between 1 and 1000".to_string());
+        }
+    }
+    
+    if let Some(clustering_resolution) = physics.get("clusteringResolution") {
+        let val = clustering_resolution.as_f64().ok_or("clusteringResolution must be a number")?;
+        if val < 0.001 || val > 100.0 {
+            return Err("clusteringResolution must be between 0.001 and 100.0".to_string());
+        }
+    }
+    
+    if let Some(clustering_iterations) = physics.get("clusteringIterations") {
+        let val = clustering_iterations.as_u64()
+            .or_else(|| clustering_iterations.as_f64().map(|f| f.round() as u64))
+            .ok_or("clusteringIterations must be an integer")?;
+        if val < 1 || val > 10000 {
+            return Err("clusteringIterations must be between 1 and 10000".to_string());
+        }
+    }
+    
+    // Boundary limit validation (should be ~98% of boundsSize)
+    if let Some(boundary_limit) = physics.get("boundaryLimit") {
+        let val = boundary_limit.as_f64().ok_or("boundaryLimit must be a number")?;
+        if val < 0.1 || val > 100000.0 {  // Very generous range
+            return Err("boundaryLimit must be between 0.1 and 100000.0".to_string());
+        }
+        
+        // If boundsSize is also present, validate the relationship
+        if let Some(bounds_size) = physics.get("boundsSize").and_then(|b| b.as_f64()) {
+            let max_boundary = bounds_size * 0.99;  // Allow up to 99% for safety
+            if val > max_boundary {
+                return Err(format!("boundaryLimit ({:.1}) must be less than 99% of boundsSize ({:.1})", val, bounds_size));
+            }
+        }
+    }
+    
+    Ok(())
+}
+
+fn validate_node_settings(nodes: &Value) -> Result<(), String> {
+    // UNIFIED FORMAT: Only accept camelCase "baseColor"
+    if let Some(color) = nodes.get("baseColor") {
+        let color_str = color.as_str().ok_or("baseColor must be a string")?;
+        if !color_str.starts_with('#') || (color_str.len() != 7 && color_str.len() != 4) {
+            return Err("baseColor must be a valid hex color (e.g., #ffffff or #fff)".to_string());
+        }
+    }
+    
+    if let Some(opacity) = nodes.get("opacity") {
+        let val = opacity.as_f64().ok_or("opacity must be a number")?;
+        if !(0.0..=1.0).contains(&val) {
+            return Err("opacity must be between 0.0 and 1.0".to_string());
+        }
+    }
+    
+    if let Some(metalness) = nodes.get("metalness") {
+        let val = metalness.as_f64().ok_or("metalness must be a number")?;
+        if !(0.0..=1.0).contains(&val) {
+            return Err("metalness must be between 0.0 and 1.0".to_string());
+        }
+    }
+    
+    if let Some(roughness) = nodes.get("roughness") {
+        let val = roughness.as_f64().ok_or("roughness must be a number")?;
+        if !(0.0..=1.0).contains(&val) {
+            return Err("roughness must be between 0.0 and 1.0".to_string());
+        }
+    }
+    
+    // UNIFIED FORMAT: Only accept "nodeSize"
+    if let Some(node_size) = nodes.get("nodeSize") {
+        let val = node_size.as_f64().ok_or("nodeSize must be a number")?;
+        if val <= 0.0 || val > 1000.0 {
+            return Err("nodeSize must be between 0.0 and 1000.0".to_string());
+        }
+    }
+    
+    if let Some(quality) = nodes.get("quality") {
+        let q = quality.as_str().ok_or("quality must be a string")?;
+        if !["low", "medium", "high"].contains(&q) {
+            return Err("quality must be 'low', 'medium', or 'high'".to_string());
+        }
+    }
+    
+    Ok(())
 }
 
-/// Rate limiter configuration
-static RATE_LIMITER: once_cell::sync::Lazy<RateLimiter> = once_cell::sync::Lazy::new(|| {
-    let config = RateLimitConfig {
-        requests_per_minute: 60,
-        burst_size: 10,
-        cleanup_interval: std::time::Duration::from_secs(300),
-        ban_duration: std::time::Duration::from_secs(300),
-        max_violations: 5,
-    };
-    RateLimiter::new(config)
-});
+fn validate_rendering_settings(rendering: &Value) -> Result<(), String> {
+    // UNIFIED FORMAT: Only accept "ambientLightIntensity"
+    if let Some(ambient) = rendering.get("ambientLightIntensity") {
+        let val = ambient.as_f64().ok_or("ambientLightIntensity must be a number")?;
+        if val < 0.0 || val > 100.0 {
+            return Err("ambientLightIntensity must be between 0.0 and 100.0".to_string());
+        }
+    }
+    
+    // Validate glow settings - use "glow" field consistently
+    if let Some(glow) = rendering.get("glow") {
+        validate_glow_settings(glow)?;
+    }
+    
+    Ok(())
+}
 
-/// GET /api/settings - Returns settings with camelCase serialization
-pub async fn get_settings(
-    req: HttpRequest,
-    data: web::Data<AppState>,
-) -> Result<HttpResponse, Error> {
-    debug!("GET /api/settings");
-    
-    // Rate limiting
-    let client_id = extract_client_id(&req);
-    if !RATE_LIMITER.is_allowed(&client_id) {
-        warn!("Rate limit exceeded for client {}", client_id);
-        return Ok(HttpResponse::TooManyRequests().json(json!({
-            "error": "Rate limit exceeded",
-            "message": "Too many requests. Please try again later."
-        })));
+/// Validate glow effect settings
+fn validate_glow_settings(glow: &Value) -> Result<(), String> {
+    // Validate enabled flag
+    if let Some(enabled) = glow.get("enabled") {
+        if !enabled.is_boolean() {
+            return Err("glow enabled must be a boolean".to_string());
+        }
     }
     
-    // Get settings from actor
-    match data.settings_addr.send(GetSettings).await {
-        Ok(Ok(settings)) => {
-            debug!("Settings retrieved successfully");
-            // AppFullSettings now has camelCase serialization built-in
-            Ok(HttpResponse::Ok().json(&settings))
+    // Validate intensity/strength fields
+    for field_name in ["intensity", "strength"] {
+        if let Some(intensity) = glow.get(field_name) {
+            let val = intensity.as_f64().ok_or(format!("glow {} must be a number", field_name))?;
+            if val < 0.0 || val > 10.0 {
+                return Err(format!("glow {} must be between 0.0 and 10.0", field_name));
+            }
         }
-        Ok(Err(e)) => {
-            error!("Failed to retrieve settings: {}", e);
-            Ok(HttpResponse::InternalServerError().json(json!({
-                "error": "Failed to retrieve settings",
-                "message": e
-            })))
+    }
+    
+    // Validate radius field
+    if let Some(radius) = glow.get("radius") {
+        let val = radius.as_f64().ok_or("glow radius must be a number")?;
+        if val < 0.0 || val > 5.0 {
+            return Err("glow radius must be between 0.0 and 5.0".to_string());
         }
-        Err(e) => {
-            error!("Mailbox error when retrieving settings: {}", e);
-            Ok(HttpResponse::InternalServerError().json(json!({
-                "error": "Settings service unavailable",
-                "message": "Failed to communicate with settings service"
-            })))
+    }
+    
+    // Validate threshold field
+    if let Some(threshold) = glow.get("threshold") {
+        let val = threshold.as_f64().ok_or("glow threshold must be a number")?;
+        if val < 0.0 || val > 2.0 {
+            return Err("glow threshold must be between 0.0 and 2.0".to_string());
+        }
+    }
+    
+    // Validate specific glow strength fields
+    for field_name in ["edgeGlowStrength", "environmentGlowStrength", "nodeGlowStrength"] {
+        if let Some(strength) = glow.get(field_name) {
+            let val = strength.as_f64().ok_or(format!("glow {} must be a number", field_name))?;
+            if val < 0.0 || val > 1.0 {
+                return Err(format!("glow {} must be between 0.0 and 1.0", field_name));
+            }
         }
     }
+    
+    Ok(())
 }
 
-/// PUT /api/settings - Updates settings (accepts camelCase input)
-pub async fn update_settings(
-    req: HttpRequest,
-    payload: web::Bytes,
-    data: web::Data<AppState>,
-) -> Result<HttpResponse, Error> {
-    debug!("PUT /api/settings");
-    
-    // Rate limiting
-    let client_id = extract_client_id(&req);
-    if !RATE_LIMITER.is_allowed(&client_id) {
-        warn!("Rate limit exceeded for client {}", client_id);
-        return Ok(HttpResponse::TooManyRequests().json(json!({
-            "error": "Rate limit exceeded",
-            "message": "Too many requests. Please try again later."
-        })));
+fn validate_hologram_settings(hologram: &Value) -> Result<(), String> {
+    // Validate ringCount - MUST be an integer
+    if let Some(ring_count) = hologram.get("ringCount") {
+        // Accept both integer and float values (JavaScript might send 5.0)
+        let val = ring_count.as_f64()
+            .map(|f| f.round() as u64)  // Round float to u64
+            .or_else(|| ring_count.as_u64())  // Also accept direct integer
+            .ok_or("ringCount must be a positive integer")?;
+        
+        if val > 20 {
+            return Err("ringCount must be between 0 and 20".to_string());
+        }
     }
     
-    // Validate payload size
-    if payload.len() > MAX_REQUEST_SIZE {
-        warn!("Request payload too large: {} bytes", payload.len());
-        return Ok(HttpResponse::BadRequest().json(json!({
-            "error": "Request too large",
-            "message": format!("Payload size {} exceeds maximum of {} bytes", payload.len(), MAX_REQUEST_SIZE)
-        })));
+    // Validate ringColor (hex color)
+    if let Some(color) = hologram.get("ringColor") {
+        let color_str = color.as_str().ok_or("ringColor must be a string")?;
+        if !color_str.starts_with('#') || (color_str.len() != 7 && color_str.len() != 4) {
+            return Err("ringColor must be a valid hex color (e.g., #ffffff or #fff)".to_string());
+        }
     }
     
-    // Parse JSON
-    let update_request: SettingsUpdateRequest = match serde_json::from_slice(&payload) {
-        Ok(req) => req,
-        Err(e) => {
-            warn!("Failed to parse settings update request: {}", e);
-            return Ok(HttpResponse::BadRequest().json(json!({
-                "error": "Invalid JSON",
-                "message": format!("Failed to parse request body: {}", e)
-            })));
+    // Validate ringOpacity
+    if let Some(opacity) = hologram.get("ringOpacity") {
+        let val = opacity.as_f64().ok_or("ringOpacity must be a number")?;
+        if !(0.0..=1.0).contains(&val) {
+            return Err("ringOpacity must be between 0.0 and 1.0".to_string());
         }
-    };
+    }
     
-    // Get current settings
-    let current_settings = match data.settings_addr.send(GetSettings).await {
-        Ok(Ok(settings)) => settings,
-        Ok(Err(e)) => {
-            error!("Failed to retrieve current settings: {}", e);
-            return Ok(HttpResponse::InternalServerError().json(json!({
-                "error": "Failed to retrieve current settings",
-                "message": e
-            })));
+    // Validate ringRotationSpeed
+    if let Some(speed) = hologram.get("ringRotationSpeed") {
+        let val = speed.as_f64().ok_or("ringRotationSpeed must be a number")?;
+        if val < 0.0 || val > 1000.0 {
+            return Err("ringRotationSpeed must be between 0.0 and 1000.0".to_string());
         }
-        Err(e) => {
-            error!("Mailbox error when retrieving settings: {}", e);
-            return Ok(HttpResponse::InternalServerError().json(json!({
-                "error": "Settings service unavailable"
-            })));
+    }
+    
+    Ok(())
+}
+
+fn validate_system_settings(system: &Value) -> Result<(), String> {
+    // Handle debug settings
+    if let Some(debug) = system.get("debug") {
+        if let Some(debug_obj) = debug.as_object() {
+            // All debug flags should be booleans - UNIFIED FORMAT ONLY
+            let boolean_fields = [
+                "enabled",  // NOT "enableClientDebugMode" - unified format only!
+                "showFPS", 
+                "showMemory",
+                "enablePerformanceDebug",
+                "enableTelemetry",
+                "enableDataDebug",
+                "enableWebSocketDebug",
+                "enablePhysicsDebug",
+                "enableNodeDebug",
+                "enableShaderDebug",
+                "enableMatrixDebug"
+            ];
+            
+            for field in &boolean_fields {
+                if let Some(val) = debug_obj.get(*field) {
+                    if !val.is_boolean() {
+                        return Err(format!("debug.{} must be a boolean", field));
+                    }
+                }
+            }
+            
+            // logLevel can be a number or string
+            if let Some(log_level) = debug_obj.get("logLevel") {
+                if let Some(val) = log_level.as_f64() {
+                    if val < 0.0 || val > 3.0 {
+                        return Err("debug.logLevel must be between 0 and 3".to_string());
+                    }
+                } else if let Some(val) = log_level.as_u64() {
+                    if val > 3 {
+                        return Err("debug.logLevel must be between 0 and 3".to_string());
+                    }
+                } else if let Some(val) = log_level.as_str() {
+                    // Accept string log levels from client
+                    match val {
+                        "error" | "warn" | "info" | "debug" => {
+                            // Valid string log level
+                        }
+                        _ => {
+                            return Err("debug.logLevel must be 'error', 'warn', 'info', or 'debug'".to_string());
+                        }
+                    }
+                } else {
+                    return Err("debug.logLevel must be a number or string".to_string());
+                }
+            }
         }
-    };
+    }
     
-    // Convert current settings to JSON for merging
-    let mut current_json = match serde_json::to_value(&current_settings) {
-        Ok(json) => json,
-        Err(e) => {
-            error!("Failed to serialize current settings: {}", e);
-            return Ok(HttpResponse::InternalServerError().json(json!({
-                "error": "Internal serialization error"
-            })));
+    // Handle persistSettingsOnServer
+    if let Some(persist) = system.get("persistSettingsOnServer") {
+        if !persist.is_boolean() {
+            return Err("system.persistSettingsOnServer must be a boolean".to_string());
         }
-    };
+    }
+    
+    // Handle customBackendUrl
+    if let Some(url) = system.get("customBackendUrl") {
+        if !url.is_string() && !url.is_null() {
+            return Err("system.customBackendUrl must be a string or null".to_string());
+        }
+    }
+    
+    Ok(())
+}
+
+fn validate_xr_settings(xr: &Value) -> Result<(), String> {
+    // UNIFIED FORMAT: Only accept "enabled", not "enableXrMode"  
+    if let Some(enabled) = xr.get("enabled") {
+        if !enabled.is_boolean() {
+            return Err("XR enabled must be a boolean".to_string());
+        }
+    }
     
-    // Merge updates into current settings
-    if let Some(vis) = update_request.visualisation {
-        if let Some(current_vis) = current_json.get_mut("visualisation") {
-            merge_json_recursive(current_vis, &vis);
+    // Handle quality setting
+    if let Some(quality) = xr.get("quality") {
+        if let Some(q) = quality.as_str() {
+            if !["Low", "Medium", "High", "low", "medium", "high"].contains(&q) {
+                return Err("XR quality must be Low, Medium, or High".to_string());
+            }
+        } else {
+            return Err("XR quality must be a string".to_string());
         }
     }
     
-    if let Some(sys) = update_request.system {
-        if let Some(current_sys) = current_json.get_mut("system") {
-            merge_json_recursive(current_sys, &sys);
+    // UNIFIED FORMAT: Only accept "renderScale"  
+    if let Some(render_scale) = xr.get("renderScale") {
+        let val = render_scale.as_f64().ok_or("renderScale must be a number")?;
+        if val < 0.1 || val > 10.0 {
+            return Err("renderScale must be between 0.1 and 10.0".to_string());
         }
     }
     
-    if let Some(xr) = update_request.xr {
-        if let Some(current_xr) = current_json.get_mut("xr") {
-            merge_json_recursive(current_xr, &xr);
+    // UNIFIED FORMAT: Only accept "roomScale"
+    if let Some(room_scale) = xr.get("roomScale") {
+        let val = room_scale.as_f64().ok_or("roomScale must be a number")?;
+        if val <= 0.0 || val > 100.0 {
+            return Err("roomScale must be between 0.0 and 100.0".to_string());
         }
     }
     
-    if let Some(auth) = update_request.auth {
-        if let Some(current_auth) = current_json.get_mut("auth") {
-            merge_json_recursive(current_auth, &auth);
+    // Handle nested handTracking object
+    if let Some(hand_tracking) = xr.get("handTracking") {
+        if let Some(ht_obj) = hand_tracking.as_object() {
+            if let Some(enabled) = ht_obj.get("enabled") {
+                if !enabled.is_boolean() {
+                    return Err("handTracking.enabled must be a boolean".to_string());
+                }
+            }
         }
     }
     
-    // Handle optional services
-    if let Some(ragflow) = update_request.ragflow {
-        current_json.as_object_mut().unwrap().insert("ragflow".to_string(), ragflow);
+    // Handle nested interactions object
+    if let Some(interactions) = xr.get("interactions") {
+        if let Some(int_obj) = interactions.as_object() {
+            if let Some(haptics) = int_obj.get("enableHaptics") {
+                if !haptics.is_boolean() {
+                    return Err("interactions.enableHaptics must be a boolean".to_string());
+                }
+            }
+        }
     }
     
-    if let Some(perplexity) = update_request.perplexity {
-        current_json.as_object_mut().unwrap().insert("perplexity".to_string(), perplexity);
+    Ok(())
+}
+
+/// Propagate physics settings to GPU compute actor
+async fn propagate_physics_to_gpu(
+    state: &web::Data<AppState>,
+    settings: &AppFullSettings,
+    graph: &str,
+) {
+    let physics = settings.get_physics(graph);
+    
+    // Always log critical physics values with new parameter names
+    info!(
+        "[PHYSICS UPDATE] Propagating {} physics to actors:", graph
+    );
+    info!(
+        "  - repulsion_k: {:.3} (affects node spreading)", 
+        physics.repel_k
+    );
+    info!(
+        "  - spring_k: {:.3} (affects edge tension)",
+        physics.spring_k
+    );
+    info!(
+        "  - attraction_k: {:.3} (affects clustering)",
+        physics.attraction_k
+    );
+    info!(
+        "  - damping: {:.3} (affects settling, 1.0 = no movement)",
+        physics.damping
+    );
+    info!(
+        "  - time_step: {:.3} (simulation speed)",
+        physics.dt
+    );
+    info!(
+        "  - max_velocity: {:.3} (prevents explosions)",
+        physics.max_velocity
+    );
+    info!(
+        "  - temperature: {:.3} (random motion)",
+        physics.temperature
+    );
+    info!(
+        "  - gravity: {:.3} (directional force)",
+        physics.gravity
+    );
+    
+    if crate::utils::logging::is_debug_enabled() {
+        debug!("  - bounds_size: {:.1}", physics.bounds_size);
+        debug!("  - separation_radius: {:.3}", physics.separation_radius);  // Updated name
+        debug!("  - mass_scale: {:.3}", physics.mass_scale);
+        debug!("  - boundary_damping: {:.3}", physics.boundary_damping);
+        debug!("  - update_threshold: {:.3}", physics.update_threshold);
+        debug!("  - iterations: {}", physics.iterations);
+        debug!("  - enabled: {}", physics.enabled);
+        
+        // Log new GPU-aligned parameters
+        debug!("  - min_distance: {:.3}", physics.min_distance);
+        debug!("  - max_repulsion_dist: {:.1}", physics.max_repulsion_dist);
+        debug!("  - boundary_margin: {:.3}", physics.boundary_margin);
+        debug!("  - boundary_force_strength: {:.1}", physics.boundary_force_strength);
+        debug!("  - warmup_iterations: {}", physics.warmup_iterations);
+        debug!("  - warmup_curve: {}", physics.warmup_curve);
+        debug!("  - zero_velocity_iterations: {}", physics.zero_velocity_iterations);
+        debug!("  - cooling_rate: {:.6}", physics.cooling_rate);
+        debug!("  - clustering_algorithm: {}", physics.clustering_algorithm);
+        debug!("  - cluster_count: {}", physics.cluster_count);
+        debug!("  - clustering_resolution: {:.3}", physics.clustering_resolution);
+        debug!("  - clustering_iterations: {}", physics.clustering_iterations);
+        debug!("[GPU Parameters] All new parameters available for GPU processing");
     }
     
-    if let Some(openai) = update_request.openai {
-        current_json.as_object_mut().unwrap().insert("openai".to_string(), openai);
+    let sim_params: crate::models::simulation_params::SimulationParams = physics.into();
+    
+    info!(
+        "[PHYSICS UPDATE] Converted to SimulationParams - repulsion: {}, damping: {:.3}, time_step: {:.3}",
+        sim_params.repel_k, sim_params.damping, sim_params.dt
+    );
+    
+    let update_msg = UpdateSimulationParams { params: sim_params.clone() };
+    
+    // Send to GPU compute actor
+    if let Some(gpu_addr) = &state.gpu_compute_addr {
+        info!("[PHYSICS UPDATE] Sending to GPUComputeActor...");
+        if let Err(e) = gpu_addr.send(update_msg.clone()).await {
+            error!("[PHYSICS UPDATE] FAILED to update GPUComputeActor: {}", e);
+        } else {
+            info!("[PHYSICS UPDATE] GPUComputeActor updated successfully");
+        }
+    } else {
+        warn!("[PHYSICS UPDATE] No GPUComputeActor available");
     }
     
-    if let Some(kokoro) = update_request.kokoro {
-        current_json.as_object_mut().unwrap().insert("kokoro".to_string(), kokoro);
+    // Send to graph service actor
+    info!("[PHYSICS UPDATE] Sending to GraphServiceActor...");
+    if let Err(e) = state.graph_service_addr.send(update_msg).await {
+        error!("[PHYSICS UPDATE] FAILED to update GraphServiceActor: {}", e);
+    } else {
+        info!("[PHYSICS UPDATE] GraphServiceActor updated successfully");
+    }
+}
+
+/// Helper function to get field variants (camelCase or snake_case)
+fn get_field_variant<'a>(obj: &'a Value, variants: &[&str]) -> Option<&'a Value> {
+    for variant in variants {
+        if let Some(val) = obj.get(*variant) {
+            return Some(val);
+        }
+    }
+    None
+}
+
+/// Count the number of fields in a JSON object recursively
+fn count_fields(value: &Value) -> usize {
+    match value {
+        Value::Object(map) => {
+            map.len() + map.values().map(count_fields).sum::<usize>()
+        }
+        Value::Array(arr) => arr.iter().map(count_fields).sum(),
+        _ => 0,
+    }
+}
+
+/// Extract which graphs have physics updates
+fn extract_physics_updates(update: &Value) -> Vec<&str> {
+    update.get("visualisation")
+        .and_then(|v| v.get("graphs"))
+        .and_then(|g| g.as_object())
+        .map(|graphs| {
+            let mut updated = Vec::new();
+            if graphs.contains_key("logseq") && 
+               graphs.get("logseq").and_then(|g| g.get("physics")).is_some() {
+                updated.push("logseq");
+            }
+            if graphs.contains_key("visionflow") && 
+               graphs.get("visionflow").and_then(|g| g.get("physics")).is_some() {
+                updated.push("visionflow");
+            }
+            updated
+        })
+        .unwrap_or_default()
+}
+
+/// Extract the field name that failed validation
+fn extract_failed_field(physics: &Value) -> String {
+    if let Some(obj) = physics.as_object() {
+        obj.keys().next().unwrap_or(&"unknown".to_string()).clone()
+    } else {
+        "unknown".to_string()
     }
+}
+
+/// Create a proper settings update structure for physics parameters
+/// Maps old parameter names to new ones for backward compatibility
+fn create_physics_settings_update(physics_update: Value) -> Value {
+    let mut normalized_physics = physics_update.clone();
     
-    if let Some(whisper) = update_request.whisper {
-        current_json.as_object_mut().unwrap().insert("whisper".to_string(), whisper);
+    // Map old parameter names to new ones if old names are present
+    if let Some(obj) = normalized_physics.as_object_mut() {
+        // Map springStrength -> springK
+        if let Some(spring_strength) = obj.remove("springStrength") {
+            if !obj.contains_key("springK") {
+                obj.insert("springK".to_string(), spring_strength);
+            }
+        }
+        
+        // Map repulsionStrength -> repelK (GPU-aligned name)
+        if let Some(repulsion_strength) = obj.remove("repulsionStrength") {
+            if !obj.contains_key("repelK") {
+                obj.insert("repelK".to_string(), repulsion_strength);
+            }
+        }
+        
+        // Map attractionStrength -> attractionK
+        if let Some(attraction_strength) = obj.remove("attractionStrength") {
+            if !obj.contains_key("attractionK") {
+                obj.insert("attractionK".to_string(), attraction_strength);
+            }
+        }
+        
+        // Map collisionRadius -> separationRadius
+        if let Some(collision_radius) = obj.remove("collisionRadius") {
+            if !obj.contains_key("separationRadius") {
+                obj.insert("separationRadius".to_string(), collision_radius);
+            }
+        }
     }
     
-    // Deserialize back to AppFullSettings (now with camelCase support)
-    let updated_settings: AppFullSettings = match serde_json::from_value(current_json) {
-        Ok(settings) => settings,
+    json!({
+        "visualisation": {
+            "graphs": {
+                "logseq": {
+                    "physics": normalized_physics
+                },
+                "visionflow": {
+                    "physics": normalized_physics.clone()
+                }
+            }
+        }
+    })
+}
+
+/// Update compute mode endpoint
+async fn update_compute_mode(
+    _req: HttpRequest,
+    state: web::Data<AppState>,
+    payload: web::Json<Value>,
+) -> Result<HttpResponse, Error> {
+    let update = payload.into_inner();
+    
+    info!("Compute mode update request received");
+    debug!("Compute mode payload: {}", serde_json::to_string_pretty(&update).unwrap_or_default());
+    
+    // Validate compute mode
+    let compute_mode = update.get("computeMode")
+        .and_then(|v| v.as_u64())
+        .ok_or_else(|| {
+            actix_web::error::ErrorBadRequest("computeMode must be an integer between 0 and 3")
+        })?;
+    
+    if compute_mode > 3 {
+        return Ok(HttpResponse::BadRequest().json(json!({
+            "error": "computeMode must be between 0 and 3"
+        })));
+    }
+    
+    // Create physics update with compute mode
+    let physics_update = json!({
+        "computeMode": compute_mode
+    });
+    
+    let settings_update = create_physics_settings_update(physics_update);
+    
+    // Get and update settings
+    let mut app_settings = match state.settings_addr.send(GetSettings).await {
+        Ok(Ok(s)) => s,
+        Ok(Err(e)) => {
+            error!("Failed to get current settings: {}", e);
+            return Ok(HttpResponse::InternalServerError().json(json!({
+                "error": "Failed to get current settings"
+            })));
+        }
         Err(e) => {
-            error!("Failed to deserialize updated settings: {}", e);
-            return Ok(HttpResponse::BadRequest().json(json!({
-                "error": "Invalid settings structure",
-                "message": format!("Failed to parse merged settings: {}", e)
+            error!("Settings actor error: {}", e);
+            return Ok(HttpResponse::ServiceUnavailable().json(json!({
+                "error": "Settings service unavailable"
             })));
         }
     };
     
-    // Update settings via actor
-    match data.settings_addr.send(UpdateSettings { settings: updated_settings }).await {
-        Ok(Ok(final_settings)) => {
-            info!("Settings updated successfully");
-            Ok(HttpResponse::Ok().json(&final_settings))
+    if let Err(e) = app_settings.merge_update(settings_update) {
+        error!("Failed to merge compute mode settings: {}", e);
+        return Ok(HttpResponse::InternalServerError().json(json!({
+            "error": format!("Failed to update compute mode: {}", e)
+        })));
+    }
+    
+    // Save updated settings
+    match state.settings_addr.send(UpdateSettings { settings: app_settings.clone() }).await {
+        Ok(Ok(())) => {
+            info!("Compute mode updated successfully to: {}", compute_mode);
+            
+            // Propagate to GPU
+            propagate_physics_to_gpu(&state, &app_settings, "logseq").await;
+            propagate_physics_to_gpu(&state, &app_settings, "visionflow").await;
+            
+            Ok(HttpResponse::Ok().json(json!({
+                "status": "Compute mode updated successfully",
+                "computeMode": compute_mode
+            })))
         }
         Ok(Err(e)) => {
-            error!("Failed to update settings: {}", e);
+            error!("Failed to save compute mode settings: {}", e);
             Ok(HttpResponse::InternalServerError().json(json!({
-                "error": "Failed to update settings",
-                "message": e
+                "error": format!("Failed to save compute mode settings: {}", e)
             })))
         }
         Err(e) => {
-            error!("Mailbox error when updating settings: {}", e);
-            Ok(HttpResponse::InternalServerError().json(json!({
+            error!("Settings actor error: {}", e);
+            Ok(HttpResponse::ServiceUnavailable().json(json!({
                 "error": "Settings service unavailable"
             })))
         }
     }
 }
 
-/// PUT /api/settings/simulation - Updates simulation physics parameters
-pub async fn update_simulation_params(
-    req: HttpRequest,
-    payload: web::Bytes,
-    data: web::Data<AppState>,
+/// Update clustering algorithm endpoint
+async fn update_clustering_algorithm(
+    _req: HttpRequest,
+    state: web::Data<AppState>,
+    payload: web::Json<Value>,
 ) -> Result<HttpResponse, Error> {
-    debug!("PUT /api/settings/simulation");
-    
-    // Rate limiting
-    let client_id = extract_client_id(&req);
-    if !RATE_LIMITER.is_allowed(&client_id) {
-        warn!("Rate limit exceeded for client {}", client_id);
-        return Ok(HttpResponse::TooManyRequests().json(json!({
-            "error": "Rate limit exceeded",
-            "message": "Too many requests. Please try again later."
-        })));
-    }
+    let update = payload.into_inner();
     
-    // Validate payload size
-    if payload.len() > MAX_REQUEST_SIZE {
+    info!("Clustering algorithm update request received");
+    debug!("Clustering payload: {}", serde_json::to_string_pretty(&update).unwrap_or_default());
+    
+    // Validate clustering algorithm
+    let algorithm = update.get("algorithm")
+        .and_then(|v| v.as_str())
+        .ok_or_else(|| {
+            actix_web::error::ErrorBadRequest("algorithm must be a string")
+        })?;
+    
+    if !["none", "kmeans", "spectral", "louvain"].contains(&algorithm) {
         return Ok(HttpResponse::BadRequest().json(json!({
-            "error": "Request too large"
+            "error": "algorithm must be 'none', 'kmeans', 'spectral', or 'louvain'"
         })));
     }
     
-    // Parse physics parameters as SimulationParams
-    let params: SimulationParams = match serde_json::from_slice(&payload) {
-        Ok(p) => p,
+    // Extract optional parameters
+    let cluster_count = update.get("clusterCount").and_then(|v| v.as_u64()).unwrap_or(5);
+    let resolution = update.get("resolution").and_then(|v| v.as_f64()).unwrap_or(1.0) as f32;
+    let iterations = update.get("iterations").and_then(|v| v.as_u64()).unwrap_or(30);
+    
+    // Create physics update with clustering parameters
+    let physics_update = json!({
+        "clusteringAlgorithm": algorithm,
+        "clusterCount": cluster_count,
+        "clusteringResolution": resolution,
+        "clusteringIterations": iterations
+    });
+    
+    let settings_update = create_physics_settings_update(physics_update);
+    
+    // Get and update settings
+    let mut app_settings = match state.settings_addr.send(GetSettings).await {
+        Ok(Ok(s)) => s,
+        Ok(Err(e)) => {
+            error!("Failed to get current settings: {}", e);
+            return Ok(HttpResponse::InternalServerError().json(json!({
+                "error": "Failed to get current settings"
+            })));
+        }
         Err(e) => {
-            warn!("Failed to parse simulation parameters: {}", e);
-            return Ok(HttpResponse::BadRequest().json(json!({
-                "error": "Invalid JSON",
-                "message": e.to_string()
+            error!("Settings actor error: {}", e);
+            return Ok(HttpResponse::ServiceUnavailable().json(json!({
+                "error": "Settings service unavailable"
             })));
         }
     };
     
-    // Validate physics parameters
-    if let Err(e) = validate_simulation_params(&params) {
-        return Ok(HttpResponse::BadRequest().json(json!({
-            "error": "Invalid physics parameters",
-            "message": e
+    if let Err(e) = app_settings.merge_update(settings_update) {
+        error!("Failed to merge clustering settings: {}", e);
+        return Ok(HttpResponse::InternalServerError().json(json!({
+            "error": format!("Failed to update clustering algorithm: {}", e)
         })));
     }
     
-    // Update simulation parameters via actor
-    match data.settings_addr.send(UpdateSimulationParams { params }).await {
+    // Save updated settings
+    match state.settings_addr.send(UpdateSettings { settings: app_settings.clone() }).await {
         Ok(Ok(())) => {
-            info!("Simulation parameters updated successfully");
-            // Get the updated settings to return
-            match data.settings_addr.send(GetSettings).await {
-                Ok(Ok(settings)) => Ok(HttpResponse::Ok().json(&settings)),
-                _ => Ok(HttpResponse::Ok().json(json!({
-                    "message": "Simulation parameters updated successfully"
-                })))
-            }
+            info!("Clustering algorithm updated successfully to: {}", algorithm);
+            
+            // Propagate to GPU
+            propagate_physics_to_gpu(&state, &app_settings, "logseq").await;
+            propagate_physics_to_gpu(&state, &app_settings, "visionflow").await;
+            
+            Ok(HttpResponse::Ok().json(json!({
+                "status": "Clustering algorithm updated successfully",
+                "algorithm": algorithm,
+                "clusterCount": cluster_count,
+                "resolution": resolution,
+                "iterations": iterations
+            })))
         }
         Ok(Err(e)) => {
-            error!("Failed to update simulation parameters: {}", e);
+            error!("Failed to save clustering settings: {}", e);
             Ok(HttpResponse::InternalServerError().json(json!({
-                "error": "Failed to update simulation parameters",
-                "message": e
+                "error": format!("Failed to save clustering settings: {}", e)
             })))
         }
         Err(e) => {
-            error!("Mailbox error when updating simulation parameters: {}", e);
-            Ok(HttpResponse::InternalServerError().json(json!({
+            error!("Settings actor error: {}", e);
+            Ok(HttpResponse::ServiceUnavailable().json(json!({
                 "error": "Settings service unavailable"
             })))
         }
     }
 }
 
-/// Helper function to merge JSON values recursively
-fn merge_json_recursive(base: &mut Value, update: &Value) {
-    match (base.as_object_mut(), update.as_object()) {
-        (Some(base_map), Some(update_map)) => {
-            for (key, update_value) in update_map {
-                match base_map.get_mut(key) {
-                    Some(base_value) => merge_json_recursive(base_value, update_value),
-                    None => {
-                        base_map.insert(key.clone(), update_value.clone());
+/// Update constraints endpoint
+async fn update_constraints(
+    _req: HttpRequest,
+    state: web::Data<AppState>,
+    payload: web::Json<Value>,
+) -> Result<HttpResponse, Error> {
+    let update = payload.into_inner();
+    
+    info!("Constraints update request received");
+    debug!("Constraints payload: {}", serde_json::to_string_pretty(&update).unwrap_or_default());
+    
+    // Validate constraint data structure
+    if let Err(e) = validate_constraints(&update) {
+        return Ok(HttpResponse::BadRequest().json(json!({
+            "error": format!("Invalid constraints: {}", e)
+        })));
+    }
+    
+    // For now, store constraints in physics settings
+    // In a real implementation, you'd have a dedicated constraints store
+    let settings_update = json!({
+        "visualisation": {
+            "graphs": {
+                "logseq": {
+                    "physics": {
+                        "computeMode": 2  // Enable constraints mode
+                    }
+                },
+                "visionflow": {
+                    "physics": {
+                        "computeMode": 2
                     }
                 }
             }
         }
-        _ => *base = update.clone(),
+    });
+    
+    // Get and update settings
+    let mut app_settings = match state.settings_addr.send(GetSettings).await {
+        Ok(Ok(s)) => s,
+        Ok(Err(e)) => {
+            error!("Failed to get current settings: {}", e);
+            return Ok(HttpResponse::InternalServerError().json(json!({
+                "error": "Failed to get current settings"
+            })));
+        }
+        Err(e) => {
+            error!("Settings actor error: {}", e);
+            return Ok(HttpResponse::ServiceUnavailable().json(json!({
+                "error": "Settings service unavailable"
+            })));
+        }
+    };
+    
+    if let Err(e) = app_settings.merge_update(settings_update) {
+        error!("Failed to merge constraints settings: {}", e);
+        return Ok(HttpResponse::InternalServerError().json(json!({
+            "error": format!("Failed to update constraints: {}", e)
+        })));
+    }
+    
+    // Save updated settings
+    match state.settings_addr.send(UpdateSettings { settings: app_settings.clone() }).await {
+        Ok(Ok(())) => {
+            info!("Constraints updated successfully");
+            
+            // Propagate to GPU
+            propagate_physics_to_gpu(&state, &app_settings, "logseq").await;
+            propagate_physics_to_gpu(&state, &app_settings, "visionflow").await;
+            
+            Ok(HttpResponse::Ok().json(json!({
+                "status": "Constraints updated successfully"
+            })))
+        }
+        Ok(Err(e)) => {
+            error!("Failed to save constraints settings: {}", e);
+            Ok(HttpResponse::InternalServerError().json(json!({
+                "error": format!("Failed to save constraints settings: {}", e)
+            })))
+        }
+        Err(e) => {
+            error!("Settings actor error: {}", e);
+            Ok(HttpResponse::ServiceUnavailable().json(json!({
+                "error": "Settings service unavailable"
+            })))
+        }
+    }
+}
+
+/// Get cluster analytics endpoint
+async fn get_cluster_analytics(
+    _req: HttpRequest,
+    state: web::Data<AppState>,
+) -> Result<HttpResponse, Error> {
+    info!("Cluster analytics request received");
+    
+    // Check if GPU clustering is available
+    if let Some(gpu_addr) = &state.gpu_compute_addr {
+        // Get cluster data from GPU
+        // This would call a GPU clustering analysis function
+        // For now, return mock data
+        
+        let mock_analytics = json!({
+            "clusters": [
+                {
+                    "id": "cluster_1",
+                    "nodeCount": 25,
+                    "coherence": 0.85,
+                    "centroid": [10.5, 15.2, 8.7],
+                    "keywords": ["semantic", "knowledge", "graph"]
+                },
+                {
+                    "id": "cluster_2",
+                    "nodeCount": 18,
+                    "coherence": 0.72,
+                    "centroid": [-5.3, 12.1, -3.4],
+                    "keywords": ["analytics", "clustering", "gpu"]
+                }
+            ],
+            "totalNodes": 43,
+            "algorithmUsed": "louvain",
+            "modularity": 0.78,
+            "lastUpdated": chrono::Utc::now().to_rfc3339()
+        });
+        
+        Ok(HttpResponse::Ok().json(mock_analytics))
+    } else {
+        // Fallback to CPU-based analytics
+        let fallback_analytics = json!({
+            "clusters": [],
+            "totalNodes": 0,
+            "algorithmUsed": "none",
+            "modularity": 0.0,
+            "lastUpdated": chrono::Utc::now().to_rfc3339(),
+            "note": "GPU clustering not available, using CPU fallback"
+        });
+        
+        Ok(HttpResponse::Ok().json(fallback_analytics))
     }
 }
 
-/// Validate simulation parameters
-fn validate_simulation_params(params: &SimulationParams) -> Result<(), String> {
-    if params.iterations > 1000 {
-        return Err("iterations must be <= 1000".to_string());
+/// Update stress optimization endpoint
+async fn update_stress_optimization(
+    _req: HttpRequest,
+    state: web::Data<AppState>,
+    payload: web::Json<Value>,
+) -> Result<HttpResponse, Error> {
+    let update = payload.into_inner();
+    
+    info!("Stress optimization update request received");
+    debug!("Stress optimization payload: {}", serde_json::to_string_pretty(&update).unwrap_or_default());
+    
+    // Validate stress parameters
+    let stress_weight = update.get("stressWeight")
+        .and_then(|v| v.as_f64())
+        .unwrap_or(0.1) as f32;
+    
+    let stress_alpha = update.get("stressAlpha")
+        .and_then(|v| v.as_f64())
+        .unwrap_or(0.1) as f32;
+    
+    if !(0.0..=1.0).contains(&stress_weight) || !(0.0..=1.0).contains(&stress_alpha) {
+        return Ok(HttpResponse::BadRequest().json(json!({
+            "error": "stressWeight and stressAlpha must be between 0.0 and 1.0"
+        })));
+    }
+    
+    // Create physics update with stress optimization parameters
+    let physics_update = json!({
+        "stressWeight": stress_weight,
+        "stressAlpha": stress_alpha
+    });
+    
+    let settings_update = create_physics_settings_update(physics_update);
+    
+    // Get and update settings
+    let mut app_settings = match state.settings_addr.send(GetSettings).await {
+        Ok(Ok(s)) => s,
+        Ok(Err(e)) => {
+            error!("Failed to get current settings: {}", e);
+            return Ok(HttpResponse::InternalServerError().json(json!({
+                "error": "Failed to get current settings"
+            })));
+        }
+        Err(e) => {
+            error!("Settings actor error: {}", e);
+            return Ok(HttpResponse::ServiceUnavailable().json(json!({
+                "error": "Settings service unavailable"
+            })));
+        }
+    };
+    
+    if let Err(e) = app_settings.merge_update(settings_update) {
+        error!("Failed to merge stress optimization settings: {}", e);
+        return Ok(HttpResponse::InternalServerError().json(json!({
+            "error": format!("Failed to update stress optimization: {}", e)
+        })));
     }
-    if !(0.0..=1.0).contains(&params.damping) {
-        return Err("damping must be 0.0-1.0".to_string());
+    
+    // Save updated settings
+    match state.settings_addr.send(UpdateSettings { settings: app_settings.clone() }).await {
+        Ok(Ok(())) => {
+            info!("Stress optimization updated successfully");
+            
+            // Propagate to GPU
+            propagate_physics_to_gpu(&state, &app_settings, "logseq").await;
+            propagate_physics_to_gpu(&state, &app_settings, "visionflow").await;
+            
+            Ok(HttpResponse::Ok().json(json!({
+                "status": "Stress optimization updated successfully",
+                "stressWeight": stress_weight,
+                "stressAlpha": stress_alpha
+            })))
+        }
+        Ok(Err(e)) => {
+            error!("Failed to save stress optimization settings: {}", e);
+            Ok(HttpResponse::InternalServerError().json(json!({
+                "error": format!("Failed to save stress optimization settings: {}", e)
+            })))
+        }
+        Err(e) => {
+            error!("Settings actor error: {}", e);
+            Ok(HttpResponse::ServiceUnavailable().json(json!({
+                "error": "Settings service unavailable"
+            })))
+        }
     }
-    if params.max_velocity <= 0.0 || params.max_velocity > 100.0 {
-        return Err("maxVelocity must be between 0.0 and 100.0".to_string());
+}
+
+/// Validate constraint data structure
+fn validate_constraints(constraints: &Value) -> Result<(), String> {
+    // Basic validation for constraint structure
+    if let Some(obj) = constraints.as_object() {
+        for (constraint_type, constraint_data) in obj {
+            if !["separation", "boundary", "alignment", "cluster"].contains(&constraint_type.as_str()) {
+                return Err(format!("Unknown constraint type: {}", constraint_type));
+            }
+            
+            if let Some(data) = constraint_data.as_object() {
+                if let Some(strength) = data.get("strength") {
+                    let val = strength.as_f64().ok_or("strength must be a number")?;
+                    if val < 0.0 || val > 100.0 {
+                        return Err("strength must be between 0.0 and 100.0".to_string());
+                    }
+                }
+                
+                if let Some(enabled) = data.get("enabled") {
+                    if !enabled.is_boolean() {
+                        return Err("enabled must be a boolean".to_string());
+                    }
+                }
+            }
+        }
     }
+    
     Ok(())
 }
 
-/// Configuration function for registering routes
-pub fn config(cfg: &mut web::ServiceConfig) {
-    cfg.service(
-        web::scope("/api/settings")
-            .route("", web::get().to(get_settings))
-            .route("", web::put().to(update_settings))
-            .route("/simulation", web::put().to(update_simulation_params))
-    );
-}
\ No newline at end of file
diff --git a/src/lib.rs b/src/lib.rs
index 57839d20..f73b271a 100755
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -7,11 +7,11 @@ pub mod handlers;
 pub mod models;
 pub mod physics;
 pub mod services;
-#[cfg(test)]
-pub mod tests;
 pub mod types;
 pub mod utils;
 
+#[cfg(test)]
+pub mod test_settings_fix;
 
 pub use app_state::AppState;
 pub use actors::{GraphServiceActor, SettingsActor, MetadataActor, ClientManagerActor};
diff --git a/src/state.rs b/src/state.rs
new file mode 100644
index 00000000..28c00a0a
--- /dev/null
+++ b/src/state.rs
@@ -0,0 +1,20 @@
+use std::sync::Arc;
+use tokio::sync::RwLock;
+use crate::config::AppFullSettings;
+
+#[derive(Debug)]  // Only Debug derive, remove Clone
+pub struct AppState {
+    pub settings: Arc<RwLock<AppFullSettings>>,
+}
+
+impl AppState {
+    pub fn new(settings: AppFullSettings) -> Self {
+        Self {
+            settings: Arc::new(RwLock::new(settings)),
+        }
+    }
+
+    pub fn clone_settings(&self) -> Arc<RwLock<AppFullSettings>> {
+        self.settings.clone()
+    }
+} 
\ No newline at end of file
diff --git a/src/tests/mod.rs b/src/tests/mod.rs
deleted file mode 100644
index 82c7c19d..00000000
--- a/src/tests/mod.rs
+++ /dev/null
@@ -1 +0,0 @@
-pub mod settings_serialization;
\ No newline at end of file
diff --git a/src/tests/settings_serialization.rs b/src/tests/settings_serialization.rs
deleted file mode 100644
index a31c2a6a..00000000
--- a/src/tests/settings_serialization.rs
+++ /dev/null
@@ -1,60 +0,0 @@
-#[cfg(test)]
-mod tests {
-    use crate::config::AppFullSettings;
-    use serde_json;
-
-    /// Test to verify settings serialization/deserialization works correctly
-    #[test]
-    fn test_settings_camel_case_serialization() -> Result<(), Box<dyn std::error::Error>> {
-        // Create default settings
-        let settings = AppFullSettings::default();
-        
-        // Test JSON serialization with camelCase
-        let json = serde_json::to_value(&settings)?;
-        
-        // Check that visualisation field is present
-        assert!(json.get("visualisation").is_some(), "visualisation field should be present");
-        
-        // Check that nested structures use camelCase
-        if let Some(vis) = json.get("visualisation") {
-            assert!(vis.get("glow").is_some(), "glow field should be present");
-            if let Some(glow) = vis.get("glow") {
-                assert!(glow.get("edgeGlowStrength").is_some(), "edgeGlowStrength should use camelCase");
-            }
-        }
-        
-        // Test round-trip serialization
-        let json_str = serde_json::to_string(&settings)?;
-        let _deserialized: AppFullSettings = serde_json::from_str(&json_str)?;
-        
-        Ok(())
-    }
-
-    /// Test YAML deserialization using the snake_case field names from config files
-    #[test]
-    fn test_yaml_deserialization() -> Result<(), Box<dyn std::error::Error>> {
-        let test_yaml = r#"
-visualisation:
-  rendering:
-    ambient_light_intensity: 1.2
-    background_color: '#0a0e1a'
-  glow:
-    edge_glow_strength: 0.9
-    enabled: true
-system:
-  network:
-    bind_address: '0.0.0.0'
-    port: 4000
-xr:
-  enabled: false
-auth:
-  enabled: false
-"#;
-
-        let settings: AppFullSettings = serde_yaml::from_str(test_yaml)?;
-        assert_eq!(settings.visualisation.glow.edge_glow_strength, 0.9);
-        assert_eq!(settings.system.network.port, 4000);
-        
-        Ok(())
-    }
-}
\ No newline at end of file
diff --git a/src/tests/validation_tests.rs b/src/tests/validation_tests.rs
deleted file mode 100644
index 525005e8..00000000
--- a/src/tests/validation_tests.rs
+++ /dev/null
@@ -1,390 +0,0 @@
-#[cfg(test)]
-mod validation_tests {
-    use crate::utils::validation::{ValidationError, ValidationContext};
-    use crate::utils::validation::schemas::{ApiSchemas, ValidationSchema, FieldValidator};
-    use crate::utils::validation::sanitization::Sanitizer;
-    use crate::utils::validation::rate_limit::{RateLimiter, RateLimitConfig};
-    use crate::utils::validation::errors::{DetailedValidationError, ValidationErrorCollection};
-    use crate::handlers::validation_handler::ValidationService;
-    use serde_json::json;
-    use std::time::Duration;
-
-    #[test]
-    fn test_string_sanitization() {
-        // Test XSS prevention
-        let malicious_script = "<script>alert('xss')</script>";
-        assert!(Sanitizer::sanitize_string(malicious_script).is_err());
-        
-        let javascript_url = "javascript:alert(1)";
-        assert!(Sanitizer::sanitize_string(javascript_url).is_err());
-        
-        // Test safe string
-        let safe_string = "Hello World!";
-        let sanitized = Sanitizer::sanitize_string(safe_string).unwrap();
-        assert_eq!(sanitized, "Hello World!");
-        
-        // Test HTML escaping
-        let html_content = "<div>Test & content</div>";
-        let sanitized = Sanitizer::sanitize_string(html_content).unwrap();
-        assert!(!sanitized.contains("<div>"));
-        assert!(sanitized.contains("&lt;div&gt;"));
-    }
-
-    #[test]
-    fn test_sql_injection_prevention() {
-        let sql_injection = "'; DROP TABLE users; --";
-        assert!(Sanitizer::sanitize_string(sql_injection).is_err());
-        
-        let union_attack = "' UNION SELECT * FROM passwords --";
-        assert!(Sanitizer::sanitize_string(union_attack).is_err());
-        
-        // Safe database-like string
-        let safe_query = "user_id = 123";
-        let sanitized = Sanitizer::sanitize_string(&safe_query).unwrap();
-        assert_eq!(sanitized, safe_query);
-    }
-
-    #[test]
-    fn test_path_traversal_prevention() {
-        let path_traversal = "../../../etc/passwd";
-        assert!(Sanitizer::sanitize_string(path_traversal).is_err());
-        
-        let encoded_traversal = "%2e%2e%2f%2e%2e%2f";
-        assert!(Sanitizer::sanitize_string(encoded_traversal).is_err());
-        
-        // Safe path
-        let safe_path = "documents/file.txt";
-        let sanitized = Sanitizer::sanitize_string(&safe_path).unwrap();
-        assert_eq!(sanitized, safe_path);
-    }
-
-    #[test]
-    fn test_filename_sanitization() {
-        // Dangerous filenames
-        assert!(Sanitizer::sanitize_filename("").is_err());
-        assert!(Sanitizer::sanitize_filename("con.txt").is_err());
-        assert!(Sanitizer::sanitize_filename(".hidden").is_err());
-        assert!(Sanitizer::sanitize_filename("file<>name").is_err());
-        
-        // Safe filename
-        let safe_filename = "document.pdf";
-        let sanitized = Sanitizer::sanitize_filename(&safe_filename).unwrap();
-        assert_eq!(sanitized, safe_filename);
-    }
-
-    #[test]
-    fn test_email_sanitization() {
-        // Invalid emails
-        assert!(Sanitizer::sanitize_email("not-an-email").is_err());
-        assert!(Sanitizer::sanitize_email("user@@domain.com").is_err());
-        assert!(Sanitizer::sanitize_email("user..name@domain.com").is_err());
-        
-        // Valid email
-        let valid_email = "user@example.com";
-        let sanitized = Sanitizer::sanitize_email(&valid_email).unwrap();
-        assert_eq!(sanitized, valid_email);
-    }
-
-    #[test]
-    fn test_url_sanitization() {
-        // Dangerous URLs
-        assert!(Sanitizer::sanitize_url("javascript:alert(1)").is_err());
-        assert!(Sanitizer::sanitize_url("http://localhost/api").is_err());
-        assert!(Sanitizer::sanitize_url("http://192.168.1.1/").is_err());
-        
-        // Safe URL
-        let safe_url = "https://example.com/api";
-        let sanitized = Sanitizer::sanitize_url(&safe_url).unwrap();
-        assert_eq!(sanitized, safe_url);
-    }
-
-    #[test]
-    fn test_schema_validation() {
-        let mut ctx = ValidationContext::new();
-        
-        // Test valid settings update
-        let valid_settings = json!({
-            "visualisation": {
-                "graphs": {
-                    "logseq": {
-                        "physics": {
-                            "damping": 0.8,
-                            "iterations": 100
-                        }
-                    }
-                }
-            }
-        });
-        
-        let schema = ApiSchemas::settings_update();
-        assert!(schema.validate(&valid_settings, &mut ctx).is_ok());
-    }
-
-    #[test]
-    fn test_physics_validation() {
-        let mut ctx = ValidationContext::new();
-        
-        // Test valid physics params
-        let valid_physics = json!({
-            "damping": 0.8,
-            "iterations": 100,
-            "springK": 0.3,
-            "repelK": 300.0,
-            "maxVelocity": 10.0
-        });
-        
-        let schema = ApiSchemas::physics_params();
-        assert!(schema.validate(&valid_physics, &mut ctx).is_ok());
-        
-        // Test invalid physics params
-        let invalid_physics = json!({
-            "damping": 1.5, // Out of range
-            "iterations": -5 // Negative
-        });
-        
-        ctx = ValidationContext::new();
-        assert!(schema.validate(&invalid_physics, &mut ctx).is_err());
-    }
-
-    #[test]
-    fn test_ragflow_validation() {
-        let mut ctx = ValidationContext::new();
-        
-        // Test valid RAGFlow request
-        let valid_request = json!({
-            "question": "What is the meaning of life?",
-            "session_id": "session-123",
-            "stream": false
-        });
-        
-        let schema = ApiSchemas::ragflow_chat();
-        assert!(schema.validate(&valid_request, &mut ctx).is_ok());
-        
-        // Test invalid RAGFlow request
-        let invalid_request = json!({
-            "question": "", // Empty question
-            "session_id": "x".repeat(300) // Too long
-        });
-        
-        ctx = ValidationContext::new();
-        assert!(schema.validate(&invalid_request, &mut ctx).is_err());
-    }
-
-    #[test]
-    fn test_rate_limiting() {
-        let config = RateLimitConfig {
-            requests_per_minute: 60,
-            burst_size: 5,
-            cleanup_interval: Duration::from_secs(60),
-            ban_duration: Duration::from_secs(300),
-            max_violations: 3,
-        };
-        
-        let limiter = RateLimiter::new(config);
-        let client_id = "test_client";
-        
-        // Should allow burst_size requests
-        for _ in 0..5 {
-            assert!(limiter.is_allowed(client_id));
-        }
-        
-        // Should deny the next request
-        assert!(!limiter.is_allowed(client_id));
-        
-        // Check remaining tokens
-        assert_eq!(limiter.remaining_tokens(client_id), 0);
-    }
-
-    #[test]
-    fn test_validation_service() {
-        let service = ValidationService::new();
-        
-        // Test settings validation
-        let settings = json!({
-            "visualisation": {
-                "graphs": {
-                    "logseq": {
-                        "physics": {"damping": 0.8}
-                    }
-                }
-            }
-        });
-        
-        assert!(service.validate_settings_update(&settings).is_ok());
-        
-        // Test malicious settings
-        let malicious_settings = json!({
-            "visualisation": {
-                "graphs": {
-                    "logseq": {
-                        "physics": {"damping": "<script>alert('xss')</script>"}
-                    }
-                }
-            }
-        });
-        
-        assert!(service.validate_settings_update(&malicious_settings).is_err());
-    }
-
-    #[test]
-    fn test_error_collection() {
-        let mut collection = ValidationErrorCollection::new();
-        assert!(collection.is_empty());
-        
-        let error1 = DetailedValidationError::missing_required_field("field1");
-        let error2 = DetailedValidationError::invalid_type("field2", "string", "number");
-        
-        collection.add_error(error1);
-        collection.add_error(error2);
-        
-        assert_eq!(collection.error_count, 2);
-        assert!(!collection.is_empty());
-        
-        let field_errors = collection.get_field_errors("field1");
-        assert_eq!(field_errors.len(), 1);
-    }
-
-    #[test]
-    fn test_validation_context_nesting() {
-        let mut ctx = ValidationContext::new();
-        
-        assert!(ctx.enter_field("level1").is_ok());
-        assert!(ctx.enter_field("level2").is_ok());
-        assert_eq!(ctx.get_path(), "level1.level2");
-        
-        ctx.exit_field();
-        assert_eq!(ctx.get_path(), "level1");
-        
-        ctx.exit_field();
-        assert_eq!(ctx.get_path(), "root");
-    }
-
-    #[test]
-    fn test_validation_context_max_depth() {
-        let mut ctx = ValidationContext::new();
-        ctx.max_depth = 3;
-        
-        assert!(ctx.enter_field("level1").is_ok());
-        assert!(ctx.enter_field("level2").is_ok());
-        assert!(ctx.enter_field("level3").is_ok());
-        
-        // Should fail at max depth
-        assert!(ctx.enter_field("level4").is_err());
-    }
-
-    #[test]
-    fn test_field_validators() {
-        let mut ctx = ValidationContext::new();
-        
-        // String validator
-        let string_validator = FieldValidator::string().min_length(1).max_length(100);
-        let valid_string = json!("Hello World");
-        let empty_string = json!("");
-        let long_string = json!("x".repeat(200));
-        
-        assert!(string_validator.validate(&valid_string, &mut ctx).is_ok());
-        assert!(string_validator.validate(&empty_string, &mut ctx).is_err());
-        assert!(string_validator.validate(&long_string, &mut ctx).is_err());
-        
-        // Number validator
-        let number_validator = FieldValidator::number().min_value(0.0).max_value(100.0);
-        let valid_number = json!(50.0);
-        let invalid_number = json!(150.0);
-        
-        assert!(number_validator.validate(&valid_number, &mut ctx).is_ok());
-        assert!(number_validator.validate(&invalid_number, &mut ctx).is_err());
-        
-        // Email validator
-        let email_validator = FieldValidator::string().email();
-        let valid_email = json!("test@example.com");
-        let invalid_email = json!("not-an-email");
-        
-        assert!(email_validator.validate(&valid_email, &mut ctx).is_ok());
-        assert!(email_validator.validate(&invalid_email, &mut ctx).is_err());
-    }
-
-    #[test]
-    fn test_swarm_validation() {
-        let service = ValidationService::new();
-        
-        // Valid swarm configuration
-        let valid_swarm = json!({
-            "topology": "mesh",
-            "max_agents": 10,
-            "strategy": "balanced",
-            "enable_neural": true
-        });
-        
-        assert!(service.validate_swarm_init(&valid_swarm).is_ok());
-        
-        // Invalid topology
-        let invalid_swarm = json!({
-            "topology": "invalid_topology",
-            "max_agents": 10,
-            "strategy": "balanced"
-        });
-        
-        assert!(service.validate_swarm_init(&invalid_swarm).is_err());
-    }
-
-    #[test]
-    fn test_comprehensive_json_sanitization() {
-        let mut malicious_json = json!({
-            "user_input": "<script>alert('xss')</script>",
-            "nested": {
-                "sql_injection": "'; DROP TABLE users; --",
-                "path_traversal": "../../../etc/passwd"
-            },
-            "array": [
-                "javascript:alert(1)",
-                "safe_content"
-            ]
-        });
-        
-        // Should detect malicious content
-        assert!(Sanitizer::sanitize_json(&mut malicious_json).is_err());
-        
-        let mut safe_json = json!({
-            "user_input": "Hello, world!",
-            "nested": {
-                "number": 42,
-                "boolean": true
-            },
-            "array": ["item1", "item2"]
-        });
-        
-        // Should pass safe content
-        assert!(Sanitizer::sanitize_json(&mut safe_json).is_ok());
-    }
-
-    #[test]
-    fn test_rate_limit_ban_system() {
-        let config = RateLimitConfig {
-            requests_per_minute: 60,
-            burst_size: 1,
-            max_violations: 2,
-            ban_duration: Duration::from_secs(1),
-            ..Default::default()
-        };
-        
-        let limiter = RateLimiter::new(config);
-        let client_id = "ban_test_client";
-        
-        // Use up the token
-        assert!(limiter.is_allowed(client_id));
-        
-        // Trigger violations
-        assert!(!limiter.is_allowed(client_id)); // Violation 1
-        assert!(!limiter.is_allowed(client_id)); // Violation 2, should trigger ban
-        
-        // Should be banned now
-        assert!(limiter.is_banned(client_id));
-        assert!(!limiter.is_allowed(client_id));
-        
-        // Wait for ban to expire
-        std::thread::sleep(Duration::from_millis(1100));
-        
-        // Should not be banned anymore (in a real scenario with proper time handling)
-        // Note: This test may be flaky due to timing
-    }
-}
\ No newline at end of file
diff --git a/supervisord.dev.conf b/supervisord.dev.conf
index 69f6ebb7..ed2cde7c 100644
--- a/supervisord.dev.conf
+++ b/supervisord.dev.conf
@@ -3,14 +3,6 @@ nodaemon=true
 logfile=/app/logs/supervisord.log
 loglevel=info
 
-[program:nginx-config-gen]
-command=/app/scripts/generate-nginx-config.sh /app/nginx.conf.template /dev/null /etc/nginx/nginx.conf
-autostart=true
-autorestart=false
-priority=1
-stdout_logfile=/app/logs/nginx-config.log
-stderr_logfile=/app/logs/nginx-config-error.log
-
 [program:nginx]
 command=/usr/sbin/nginx -g "daemon off;"
 autostart=true
diff --git a/task.md b/task.md
index f6e33b77..fc484ebd 100644
--- a/task.md
+++ b/task.md
@@ -1,172 +1,268 @@
-# üéâ CODEBASE CLEANUP MISSION COMPLETED BY HIVE MIND COLLECTIVE
-
-## ‚úÖ All Priority Actions Successfully Executed
-
-The Hive Mind swarm has successfully completed the comprehensive codebase cleanup. All identified waste has been eliminated, resulting in a streamlined, maintainable, and performant codebase.
-
-### üèÜ KEY ACHIEVEMENTS:
-- **89% reduction** in settings_handler.rs (from 3,117 to 349 lines!)
-- **4 configuration files** eliminated through consolidation
-- **Multiple redundant components** unified
-- **Build process** optimized and stabilized
-- **Documentation** properly organized
-- **‚úÖ Rust compilation errors** fully resolved - `cargo check` passes successfully!
-
----
-
-## Original Audit Report (Now Resolved)
-
-### Executive Summary
-
-The primary sources of waste have been successfully eliminated:
-
-1.  **‚úÖ Configuration Consolidation**: Merged all Docker/Nginx configs into single sources
-2.  **‚úÖ Component Unification (Client)**: Unified all redundant React components  
-3.  **‚úÖ Code Simplification (Backend)**: Reduced settings_handler.rs by 89% (2,768 lines removed!)
-4.  **‚úÖ Elimination of Dead Code**: All unused files and modules deleted
-
-Addressing these areas will significantly reduce the project's complexity and make it easier for the team to build upon this strong foundation.
-
----
-
-### 1. Configuration & Build Process Waste
-
-The project's configuration for deployment and development is duplicated across multiple files, creating maintenance overhead and potential for inconsistencies.
-
-#### 1.1. Redundant Docker Compose Files - RESOLVED ‚úÖ
-
-~~**Waste**: You have three `docker-compose` files~~
-
-**COMPLETED**:
-- ‚úÖ Consolidated all services into main `docker-compose.yml` with profiles
-- ‚úÖ Deleted `docker-compose.dev.yml` and `docker-compose.production.yml`
-- ‚úÖ Updated README.md with new `docker-compose --profile dev/prod up` commands
-- ‚úÖ Created migration guide at `docs/deployment/MIGRATION_GUIDE.md`
-
-#### 1.2. Redundant Nginx Configuration - RESOLVED ‚úÖ
-
-~~**Waste**: Multiple nginx configuration files~~
-
-**COMPLETED**:
-- ‚úÖ Created `nginx.conf.template` with environment variable placeholders
-- ‚úÖ Deleted all redundant nginx config files
-- ‚úÖ Implemented `scripts/generate-nginx-config.sh` for runtime generation
-- ‚úÖ Created environment-specific configs (`nginx.env.dev`, `nginx.env.prod`)
-
-#### 1.3. Conflicting Environment Variable Templates
-
-*   **Waste**: There are two environment template files: `.env_template` (backend) and `client/.env.example` (frontend).
-*   **Impact**: This splits the environment configuration, making it harder for a new developer to set up the entire project.
-*   **Recommendation**: Merge both files into a single `.env.example` at the project root. Use comments to clearly delineate between backend (`RUST_LOG`, etc.) and frontend (`VITE_...`) variables.
+# WebXR Agent Graph System - Current Status & Future Work
+
+**Date**: 2025-08-30
+**Status**: üü° **MOSTLY COMPLETE** - Core functionality working, architectural improvements pending
+**Environment**: `multi-agent-container` + `visionflow_container`
+
+## üîç MCP TCP Interface Analysis Results - COMPLETE ‚úÖ
+
+### Protocol Implementation
+**Date**: 2025-08-30
+**Status**: ‚úÖ **FULLY ANALYZED AND TESTED**
+**Analysis**: Complete protocol mapping, test suite created and validated
+
+#### Key Protocol Findings:
+1. **Protocol**: JSON-RPC 2.0 over TCP (line-delimited)
+2. **Port**: 9500 (configurable via MCP_TCP_PORT)
+3. **Host**: multi-agent-container (Docker service name)
+4. **Authentication**: None (network-level access control)
+5. **Server**: claude-flow v2.0.0-alpha.101 MCP implementation
+
+#### Critical Protocol Behavior:
+1. **Startup Sequence**: Server sends non-JSON startup message (must be ignored)
+2. **Notifications**: `server.initialized` has no ID field (skip these)
+3. **Responses**: Valid responses contain matching request ID
+4. **Connection**: Must keep connection open briefly (~100ms) to receive full response
+
+#### Message Flow:
+```
+Client ‚Üí Server:
+{"jsonrpc":"2.0","id":"uuid","method":"initialize","params":{...}}
+
+Server ‚Üí Client (3 lines):
+1. ‚úÖ Starting Claude Flow MCP server... (ignore)
+2. {"jsonrpc":"2.0","method":"server.initialized"...} (notification)
+3. {"jsonrpc":"2.0","id":"uuid","result":{...}} (actual response)
+```
+
+#### Critical Tools for VisionFlow:
+- `swarm_init` - Initialize swarm with topology
+- `agent_list` - Get agent statuses  
+- `swarm_destroy` - Terminate swarm
+- `swarm_status` - Get swarm state
+
+#### Test Scripts Created:
+1. **Main Test Suite**: `/workspace/ext/test_mcp_interface_final.sh`
+   - ‚úÖ All 7 tests passing
+   - Features: Full protocol testing, performance mode, interactive mode
+   - Usage: `bash test_mcp_interface_final.sh [HOST] [PORT]`
+
+2. **Diagnostic Tool**: `/workspace/ext/diagnose_mcp_connection.sh`
+   - Network diagnostics and troubleshooting
+   - Usage: `bash diagnose_mcp_connection.sh`
+
+#### VisionFlow Rust Client Considerations:
+- **Connection**: Use `TcpStream` with `set_nodelay(true)`
+- **Reading**: Must handle multiple lines per response
+- **Filtering**: Skip non-JSON lines and notifications
+- **Timeout**: Keep connection open briefly for full response
+- **Parsing**: Match responses by request ID field
+
+## üéØ System Overview
+
+### Two Independent Graph Systems
+1. **Knowledge Graph** - 177+ nodes from markdown/logseq data (‚úÖ Working correctly)
+2. **Agent/Bots Graph** - 3-10 AI agent nodes with MCP integration (‚ö†Ô∏è Needs architectural improvements)
+
+### Architecture
+
+**IMPORTANT**: Development Setup Clarification
+- The VisionFlow code is **mounted** in `/workspace/ext/` for development/editing
+- VisionFlow actually **RUNS** in a separate Docker container (`visionflow_container`)
+- This container (`multi-agent-container`) runs the MCP server with Claude Flow agents
+- The two containers communicate over the Docker network
+
+```
+visionflow_container ‚îÄ‚îÄTCP:9500‚îÄ‚îÄ> multi-agent-container
+     (Rust + React)                  (MCP + Claude Flow)
+           ‚îÇ                               ‚îÇ
+    [WebXR Render] <‚îÄ‚îÄ‚îÄWebSocket‚îÄ‚îÄ> [Agent Swarms]
+```
+
+**Container Responsibilities:**
+- `visionflow_container` (490c211caa2c): Runs Rust backend + React frontend
+- `multi-agent-container` (233024d56830): Runs MCP TCP server on port 9500 with Claude Flow
+- Communication: VisionFlow connects to `multi-agent-container:9500` over Docker network
+
+## ‚úÖ Completed Functionality
+
+### Core Features Working
+- **Graph Rendering**: Nodes and edges display correctly
+- **Real-time Updates**: Positions update from server physics simulation
+- **MCP Integration**: Proper swarm initialization and termination
+- **UI Controls**: Spawn/disconnect agents via control panel
+- **Data Flow**: Complete pipeline from MCP ‚Üí Backend ‚Üí WebSocket ‚Üí Frontend
+- **Token Display**: Shows usage metrics (1000 default)
+- **Agent Colors**: Server-configurable via `dev_config.toml`
+- **Error Handling**: Proper logging instead of silent failures
+
+### Recent Fixes (2025-08-30)
+- ‚úÖ Fixed WebSocket message type mismatch (`bots-graph-update` ‚Üí `botsGraphUpdate`)
+- ‚úÖ Added missing graph update broadcast in `UpdateBotsGraph` handler
+- ‚úÖ Added safety check for undefined data in frontend `updateFromGraphData`
+- ‚úÖ Backend now sends both `bots-full-update` AND `botsGraphUpdate` messages
+- ‚úÖ Added debug logging for WebSocket messages with undefined data
+- ‚úÖ REVERTED incorrect localhost change - VisionFlow correctly connects to `multi-agent-container:9500`
+- ‚úÖ Fixed ClaudeFlowActor initialization - Changed from hardcoded `localhost` to `multi-agent-container`
+- ‚úÖ Fixed WebSocket handler to get bots graph data from GraphServiceActor instead of BotsClient
+- ‚úÖ **CRITICAL FIX**: Added automatic agent spawning after swarm initialization
+  - `swarm_init` only creates swarm structure, doesn't spawn agents
+  - Added `call_agent_spawn` function to MCP connection utilities
+  - Modified both `initialize_swarm` and `initialize_multi_agent` to spawn agents
+  - Spawns 3-4 agents based on topology (hierarchical, mesh, star)
+
+### Technical Fixes Applied
+- ‚úÖ MCP response parsing (removed incorrect `content[0].text` unwrapping)
+- ‚úÖ Position updates (agents now move with server physics)
+- ‚úÖ Data model consistency (removed unsafe 'coordinator' fallback)
+- ‚úÖ Swarm lifecycle management (proper init/destroy flow)
+- ‚úÖ Route registration (all endpoints properly configured)
+- ‚úÖ Type conversions (u32 ‚Üí string for IDs)
+- ‚úÖ Property naming (unified to `swarmId`)
+
+## üî¥ CRITICAL ISSUE - Agent Tracking Not Working
+
+### Root Cause Analysis (2025-08-30 15:18)
+**Priority**: CRITICAL
+**Status**: MCP server not recognizing agent methods
+
+#### Problem Summary:
+- `agent_list` returns empty array instead of spawned agents
+- Agents ARE being created (get valid IDs like `agent_1756564254868_pcgsya`)
+- Agent tracker module exists but agents aren't being tracked
+- The MCP server wrapper is NOT using our modified code
+
+#### Technical Analysis:
+1. **MCP Architecture**:
+   - `/app/core-assets/scripts/mcp-tcp-server.js` - TCP wrapper (spawns MCP per connection)
+   - Each connection spawns: `npx claude-flow@alpha mcp start`
+   - This uses GLOBAL npm package, NOT our local `/workspace/ext/claude-flow` code
+
+2. **Agent Tracking Flow**:
+   - `agent_spawn` creates agent and stores in memory
+   - `global.agentTracker` should track agents in AgentTracker class
+   - `agent_list` checks `global.agentTracker.getAgents(swarmId)`
+   - Returns empty because tracker isn't populated
+
+3. **Code Changes Made**:
+   - ‚úÖ Fixed agent tracker initialization logging
+   - ‚úÖ Added swarmId consistency to agent_spawn
+   - ‚úÖ Removed mock data fallback from agent_list
+   - ‚úÖ Added debug logging throughout
+   - ‚úÖ Modified TCP wrapper to use local code
+   - ‚ùå Changes NOT active (wrapper keeps getting restarted)
+
+#### ‚úÖ SOLUTION IMPLEMENTED (2025-08-30 15:00)
+
+**Final Working Solution:**
+
+1. **Enhanced `/workspace/ext/multi-agent-docker/setup-workspace.sh`**:
+   - Updated `patch_mcp_server()` function to find global installation at `/usr/lib/node_modules/claude-flow`
+   - Added Patch 3: Remove mock data fallback from agent_list
+   - Added Patch 4: Fix agent_spawn to properly track agents with swarmId
+   - Added Patch 5: Enhanced agent tracker initialization with verification
+   - Patches are applied to the INSTALLED claude-flow, not a transient copy
+
+2. **Added agent spawning to VisionFlow handlers**:
+   - Modified `/workspace/ext/src/handlers/bots_handler.rs`
+   - Added `call_agent_spawn` function to `/workspace/ext/src/utils/mcp_connection.rs`
+   - Now automatically spawns 3-4 agents after swarm_init based on topology
+
+**How It Works:**
+1. When container starts, `setup-workspace.sh` runs
+2. It finds the globally installed claude-flow at `/usr/lib/node_modules/claude-flow`
+3. Applies all patches directly to the installed version
+4. Supervisord starts mcp-tcp-server which uses the patched claude-flow
+5. Agent tracking now works correctly with real agents instead of mock data
+
+**To Apply Changes:**
+1. Restart the Docker container to run setup-workspace.sh
+2. The patches will be applied to the installed claude-flow
+3. Supervisord will restart mcp-tcp-server automatically
+4. VisionFlow will spawn agents automatically when creating swarms
+
+## ‚ö†Ô∏è FUTURE WORK REQUIRED
+
+### 1. Backend Data Transformation Consolidation
+**Priority**: HIGH
+**Problem**: Inconsistent positioning logic causes jarring layout changes
+**Details**:
+- REST API uses `position_agents_hierarchically()` for structured layout
+- WebSocket uses simple circular layout in `graph_actor.rs`
+- First WebSocket update can cause nodes to snap to different positions
+
+**Solution Required**:
+```rust
+// In graph_actor.rs UpdateBotsGraph handler
+// Replace circular layout with:
+use crate::handlers::bots_handler::position_agents_hierarchically;
+position_agents_hierarchically(&mut agents);
+```
+
+### 2. WebSocket Message Standardization
+**Priority**: MEDIUM
+**Problem**: Two parallel message types for same data
+**Details**:
+- `bots-graph-update`: Pre-processed graph (preferred)
+- `bots-full-update`: Raw agent data (redundant)
+- Potential for race conditions and state conflicts
+
+**Solution Required**:
+1. Remove `bots-full-update` message type entirely
+2. Standardize on `bots-graph-update` format
+3. Update `BotsDataContext.tsx` to use single handler
+4. Remove `updateFromFullUpdate` method
+
+### 3. Performance Optimizations
+**Priority**: LOW
+**Current State**:
+- Polling every 2000ms (could use WebSocket push)
+- Full graph sent each update (could send deltas)
+- ~3-5KB per update with 3-10 agents
+
+**Improvements Possible**:
+- Server-push updates instead of polling
+- Delta updates for position changes only
+- Binary protocol for position data
+
+### 4. Enhanced MCP Integration
+**Priority**: LOW
+**Opportunities**:
+- Store multiple swarm IDs for multi-swarm support
+- Add swarm configuration persistence
+- Implement swarm state recovery after crashes
+- Add metrics collection and visualization
+
+## üìã Quick Reference
+
+### Testing Steps
+1. Open WebXR visualization
+2. Click "Spawn Hive Mind" in control panel
+3. Verify nodes, edges, and real-time movement
+4. Test disconnect functionality
+5. Check console for any errors
+
+### Key Files
+**Backend**:
+- `/src/handlers/bots_handler.rs` - Main agent handler
+- `/src/actors/graph_actor.rs` - WebSocket updates (needs fix)
+- `/src/utils/mcp_connection.rs` - MCP integration
+
+**Frontend**:
+- `/client/src/features/bots/components/BotsVisualizationFixed.tsx` - 3D rendering
+- `/client/src/features/bots/contexts/BotsDataContext.tsx` - State management
+- `/client/src/features/bots/services/BotsWebSocketIntegration.ts` - WebSocket client
+
+
+```
+
+## üìä Success Metrics
+- ‚úÖ Agents spawn and display correctly
+- ‚úÖ Positions update in real-time
+- ‚úÖ Disconnect properly terminates MCP swarm
+- ‚úÖ No console errors during operation
+- ‚ö†Ô∏è Layout consistency between REST/WebSocket (pending)
+- ‚ö†Ô∏è Single message type for updates (pending)
 
 ---
-
-### 2. Client-Side (Frontend) Waste
-
-The frontend contains several leftover development components, duplicated logic, and organizational inefficiencies.
-
-#### 2.1. Dead and Test Code
-
-The following files appear to be for testing or debugging and are not part of the final application. They should be removed to reduce bundle size and codebase clutter.
-
-*   **`client/public/debug.html`**: A standalone debug page. This is a development artifact.
-*   **`client/src/features/graph/components/GraphCanvasSimple.tsx`**: A simplified test canvas.
-*   **`client/src/features/graph/components/SimpleThreeTest.tsx`**: Another test component.
-*   **`client/src/features/analytics/examples/BasicUsageExample.tsx`**: An example file that should not be in the application source.
-
-#### 2.2. Redundant Components
-
-Several components have overlapping functionality and should be unified.
-
-*   **Performance Monitors**:
-    *   **Files**: `client/src/utils/performanceMonitor.tsx` and `client/src/utils/dualGraphPerformanceMonitor.ts`.
-    *   **Recommendation**: Consolidate into a single, more comprehensive performance monitor. `dualGraphPerformanceMonitor.ts` seems more specialized and should be the basis for the unified version.
-
-*   **Graph Analysis Panels**:
-    *   **Files**: `client/src/features/analytics/components/SSSPAnalysisPanel.tsx` and `client/src/features/analytics/components/ShortestPathControls.tsx`.
-    *   **Recommendation**: `ShortestPathControls.tsx` is newer and integrates with the `analyticsStore`. Remove the older `SSSPAnalysisPanel.tsx` and migrate any unique features if necessary.
-
-*   **Visual Effects Toggles**:
-    *   **Files**: `client/src/features/visualisation/components/VisualEnhancementToggle.tsx` and `client/src/features/graph/components/VisualEffectsPanel.tsx`.
-    *   **Recommendation**: These components control similar visual effects. The `VisualEffectsPanel.tsx` is more comprehensive. Remove `VisualEnhancementToggle.tsx` and integrate its functionality into the main panel.
-
-*   **Dialogs and Modals**:
-    *   **Files**: `client/src/features/design-system/components/Dialog.tsx` and `Modal.tsx`.
-    *   **Recommendation**: Both provide modal dialog functionality. `Modal.tsx` is more feature-rich with animations and positioning. Unify them into a single, enhanced `Dialog.tsx` component based on the `Modal.tsx` implementation to create a consistent dialog experience.
-
-#### 2.3. Duplicated Files
-
-*   **Waste**: The file `iframeCommunication.ts` exists in two locations: `client/src/config/` and `client/src/utils/`.
-*   **Impact**: This is a direct code duplication that will lead to bugs when one is updated and the other is not.
-*   **Recommendation**: The version in `client/src/utils/iframeCommunication.ts` appears more complete. Delete the version in `client/src/config/` and update all imports to point to the `utils` version.
-
-#### 2.4. Dependency and Style Organization
-
-*   **`package.json`**:
-    *   The `wscat` dependency is a command-line tool and should be moved to `devDependencies` or removed if it's not used in any scripts.
-    *   `@types/node` should be in `devDependencies`.
-    *   You are using both `@radix-ui/themes` and individual `@radix-ui/*` primitives. This can lead to larger bundle sizes. Decide on one approach: either use the themed components from `@radix-ui/themes` or build your own styled components from the unstyled primitives. Sticking to one will reduce waste.
-
-*   **CSS Files**:
-    *   The contents of `client/src/styles/tailwind-utilities.css` are minimal and can be merged into `client/src/styles/index.css`.
-    *   `client/src/styles/base.css` contains component-level styles (e.g., `.settings-panel`). These are better defined using Tailwind's `@apply` directive within `index.css` or co-located with their respective components for better maintainability.
-
----
-
-### 3. Server-Side (Backend) Waste
-
-The Rust backend is powerful but contains some legacy files and significant code bloat that can be refactored.
-
-#### ‚úÖ 3.1. Dead and Test Code - **COMPLETED**
-
-*   ‚úÖ **`src/state.rs`**: Already cleaned up - this file was previously superseded by `src/app_state.rs` and has been removed.
-*   ‚úÖ **`src/bin/test_tcp_connection.rs`**: Already cleaned up - this outdated test binary has been removed.
-*   ‚úÖ **`src/test_settings_fix.rs`**: **REMOVED** - This temporary test file has been deleted to clean up the codebase.
-
-#### ‚úÖ 3.2. Code Bloat in DTO Conversions - **COMPLETED**
-
-*   **Previous Waste**: The file `src/handlers/settings_handler.rs` previously contained thousands of lines of highly repetitive boilerplate code for converting between the internal `AppFullSettings` struct and the client-facing `SettingsResponseDTO`.
-*   **SOLUTION IMPLEMENTED**: ‚úÖ **MAJOR REFACTOR COMPLETED**
-    1.  ‚úÖ **Unified the Structs**: Successfully implemented `#[serde(rename_all = "camelCase")]` on the `AppFullSettings` struct and all nested structs.
-    2.  ‚úÖ **Eliminated DTO Boilerplate**: Removed all `From` implementations and separate DTOs entirely.
-    3.  ‚úÖ **Massive Line Reduction**: Reduced from 3,117 lines to 349 lines (89% reduction!).
-    4.  ‚úÖ **Backup Cleaned**: Removed the old bloated `settings_handler_backup.rs` file.
-
-#### ‚úÖ 3.3. Organizational Waste - **COMPLETED**
-
-*   ‚úÖ **Developer Notes**: **MOVED** - The files `owl.md` and `new_cuda.md` have been moved to `docs/research/` directory to clean up the project root.
-*   ‚úÖ **Protocol Complexity**: **REVIEWED** - The file `src/services/agent_visualization_protocol.rs` defines two distinct protocols that serve different purposes:
-    - `AgentVisualizationMessage`: For single swarm/agent visualization (basic use case)
-    - `MultiMcpVisualizationMessage`: For multi-MCP server coordination and discovery (advanced use case)
-    Both protocols are necessary and serve different architectural needs.
-
----
-
-### Conclusion
-
-This codebase has a strong architectural foundation but shows signs of rapid development, resulting in technical debt and waste. By systematically addressing the items in this audit, you can achieve a more efficient, maintainable, and professional-grade application.
-
-**Priority Actions:**
-1.  **Consolidate Configurations**: Merge Docker and Nginx files.
-2.  ‚úÖ **Refactor `settings_handler.rs`**: ‚úÖ **COMPLETED** - Unified the settings structs and eliminated thousands of lines of boilerplate.
-3.  **Delete Unused Frontend Components**: Remove redundant test canvases, performance monitors, and analysis panels.
-4.  ‚úÖ **Clean Up Dead Backend Files**: ‚úÖ **COMPLETED** - Deleted unused backend files and organized documentation.
-
----
-
-## ‚úÖ BACKEND REFACTORING COMPLETED - AUGUST 31, 2025
-
-**MAJOR ACHIEVEMENTS:**
-- ‚úÖ **Eliminated Massive Technical Debt**: Reduced `settings_handler.rs` from 3,117 lines to 349 lines (89% reduction!)
-- ‚úÖ **Unified Settings Architecture**: Implemented camelCase serialization directly on `AppFullSettings`, eliminating all DTO conversion boilerplate
-- ‚úÖ **Cleaned Up Dead Code**: Removed temporary test files and outdated components
-- ‚úÖ **Organized Documentation**: Moved research documents to proper `docs/research/` directory
-- ‚úÖ **Reviewed Protocol Architecture**: Confirmed both visualization protocols serve distinct and necessary purposes
-
-**IMPACT:**
-- **Maintainability**: Adding new settings fields now requires changes in only one location instead of multiple DTOs
-- **Performance**: Eliminated thousands of lines of unnecessary conversion code
-- **Code Quality**: Cleaner, more readable settings handler with proper error handling and rate limiting
-- **Organization**: Better project structure with documentation properly organized
-
-The backend refactoring has successfully eliminated the major sources of waste identified in the audit!
\ No newline at end of file
+*Last Updated: Session 7 - External assessment addressed, core issues fixed, architectural improvements documented*
\ No newline at end of file
diff --git a/tests/test_settings_fix.rs b/tests/test_settings_fix.rs
new file mode 100644
index 00000000..6cbae33d
--- /dev/null
+++ b/tests/test_settings_fix.rs
@@ -0,0 +1,404 @@
+use crate::config::AppFullSettings;
+use crate::handlers::settings_handler::SettingsResponseDTO;
+
+/// Test to verify that the bloom/glow field mapping works correctly
+pub fn test_settings_deserialization() -> Result<(), String> {
+    // Test YAML content that matches the actual settings.yaml structure
+    let test_yaml = r#"
+visualisation:
+  rendering:
+    ambient_light_intensity: 1.2
+    background_color: '#0a0e1a'
+    directional_light_intensity: 1.5
+    enable_ambient_occlusion: false
+    enable_antialiasing: true
+    enable_shadows: true
+    environment_intensity: 0.7
+  animations:
+    enable_motion_blur: false
+    enable_node_animations: true
+    motion_blur_strength: 0.2
+    selection_wave_enabled: true
+    pulse_enabled: true
+    pulse_speed: 1.2
+    pulse_strength: 0.8
+    wave_speed: 0.5
+  bloom:
+    edge_bloom_strength: 0.9
+    enabled: true
+    environment_bloom_strength: 0.96
+    node_bloom_strength: 0.05
+    radius: 0.85
+    strength: 0.95
+    threshold: 0.028
+    diffuse_strength: 1.0
+    atmospheric_density: 0.1
+    volumetric_intensity: 0.1
+    base_color: '#ffffff'
+    emission_color: '#ffffff'
+    opacity: 1.0
+    pulse_speed: 1.0
+    flow_speed: 1.0
+  hologram:
+    ring_count: 5
+    ring_color: '#00ffff'
+    ring_opacity: 0.8
+    sphere_sizes: [40.0, 80.0]
+    ring_rotation_speed: 12.0
+    enable_buckminster: true
+    buckminster_size: 50.0
+    buckminster_opacity: 0.3
+    enable_geodesic: true
+    geodesic_size: 60.0
+    geodesic_opacity: 0.25
+    enable_triangle_sphere: true
+    triangle_sphere_size: 70.0
+    triangle_sphere_opacity: 0.4
+    global_rotation_speed: 0.5
+  graphs:
+    logseq:
+      nodes:
+        base_color: '#00e5ff'
+        metalness: 0.85
+        opacity: 0.95
+        roughness: 0.15
+        node_size: 0.53
+        quality: 'high'
+        enable_instancing: true
+        enable_hologram: true
+        enable_metadata_shape: false
+        enable_metadata_visualisation: true
+      edges:
+        arrow_size: 0.02
+        base_width: 0.5
+        color: '#4fc3f7'
+        enable_arrows: false
+        opacity: 0.45
+        width_range: [0.3, 1.5]
+        quality: 'high'
+      labels:
+        desktop_font_size: 0.5
+        enable_labels: true
+        text_color: '#ffffff'
+        text_outline_color: '#0a0e1a'
+        text_outline_width: 0.005
+        text_resolution: 32
+        text_padding: 0.6
+        billboard_mode: 'camera'
+      physics:
+        auto_balance: false
+        auto_balance_interval_ms: 500
+        auto_balance_config:
+          stability_variance_threshold: 100.0
+          stability_frame_count: 180
+          clustering_distance_threshold: 20.0
+          bouncing_node_percentage: 0.33
+          boundary_min_distance: 90.0
+          boundary_max_distance: 100.0
+          extreme_distance_threshold: 1000.0
+          explosion_distance_threshold: 10000.0
+          spreading_distance_threshold: 500.0
+          oscillation_detection_frames: 10
+          oscillation_change_threshold: 5.0
+          min_oscillation_changes: 5
+          grid_cell_size_min: 1.0
+          grid_cell_size_max: 50.0
+          repulsion_cutoff_min: 5.0
+          repulsion_cutoff_max: 200.0
+          repulsion_softening_min: 0.000001
+          repulsion_softening_max: 1.0
+          center_gravity_min: 0.0
+          center_gravity_max: 0.1
+          spatial_hash_efficiency_threshold: 0.3
+          cluster_density_threshold: 50.0
+          numerical_instability_threshold: 0.001
+        attraction_k: 0.01
+        bounds_size: 1000.0
+        separation_radius: 2.0
+        damping: 0.85
+        enable_bounds: false
+        enabled: true
+        iterations: 50
+        max_velocity: 5.0
+        max_force: 100.0
+        repel_k: 155.0
+        spring_k: 0.1
+        mass_scale: 1.0
+        boundary_damping: 0.95
+        update_threshold: 0.01
+        dt: 0.016
+        temperature: 0.01
+        gravity: 0.0001
+        stress_weight: 0.0001
+        stress_alpha: 0.0001
+        boundary_limit: 1000.0
+        alignment_strength: 0.1
+        cluster_strength: 0.1
+        compute_mode: 1
+        rest_length: 50.0
+        repulsion_cutoff: 50.0
+        repulsion_softening_epsilon: 0.0001
+        center_gravity_k: 0.0
+        grid_cell_size: 50.0
+        warmup_iterations: 100
+        cooling_rate: 0.001
+        boundary_extreme_multiplier: 2.0
+        boundary_extreme_force_multiplier: 5.0
+        boundary_velocity_damping: 0.5
+        min_distance: 1.0
+        max_repulsion_dist: 1000.0
+        boundary_margin: 10.0
+        boundary_force_strength: 1.0
+        warmup_curve: 'exponential'
+        zero_velocity_iterations: 10
+        clustering_algorithm: 'none'
+        cluster_count: 5
+        clustering_resolution: 1.0
+        clustering_iterations: 50
+    visionflow:
+      nodes:
+        base_color: '#40ff00'
+        metalness: 0.85
+        opacity: 0.95
+        roughness: 0.15
+        node_size: 1.2
+        quality: 'high'
+        enable_instancing: true
+        enable_hologram: true
+        enable_metadata_shape: true
+        enable_metadata_visualisation: true
+      edges:
+        arrow_size: 0.02
+        base_width: 0.5
+        color: '#76ff03'
+        enable_arrows: false
+        opacity: 0.45
+        width_range: [0.3, 1.5]
+        quality: 'high'
+      labels:
+        desktop_font_size: 0.5
+        enable_labels: true
+        text_color: '#f0fff0'
+        text_outline_color: '#0a1a0a'
+        text_outline_width: 0.005
+        text_resolution: 32
+        text_padding: 0.6
+        billboard_mode: 'camera'
+      physics:
+        auto_balance: false
+        auto_balance_interval_ms: 500
+        auto_balance_config:
+          stability_variance_threshold: 100.0
+          stability_frame_count: 180
+          clustering_distance_threshold: 20.0
+          bouncing_node_percentage: 0.33
+          boundary_min_distance: 90.0
+          boundary_max_distance: 100.0
+          extreme_distance_threshold: 1000.0
+          explosion_distance_threshold: 10000.0
+          spreading_distance_threshold: 500.0
+          oscillation_detection_frames: 10
+          oscillation_change_threshold: 5.0
+          min_oscillation_changes: 5
+          grid_cell_size_min: 1.0
+          grid_cell_size_max: 50.0
+          repulsion_cutoff_min: 5.0
+          repulsion_cutoff_max: 200.0
+          repulsion_softening_min: 0.000001
+          repulsion_softening_max: 1.0
+          center_gravity_min: 0.0
+          center_gravity_max: 0.1
+          spatial_hash_efficiency_threshold: 0.3
+          cluster_density_threshold: 50.0
+          numerical_instability_threshold: 0.001
+        attraction_k: 0.01
+        bounds_size: 1000.0
+        separation_radius: 2.0
+        damping: 0.85
+        enable_bounds: false
+        enabled: true
+        iterations: 50
+        max_velocity: 5.0
+        max_force: 100.0
+        repel_k: 2.0
+        spring_k: 0.1
+        mass_scale: 1.0
+        boundary_damping: 0.95
+        update_threshold: 0.01
+        dt: 0.016
+        temperature: 0.01
+        gravity: 0.0001
+        stress_weight: 0.0001
+        stress_alpha: 0.0001
+        boundary_limit: 1000.0
+        alignment_strength: 0.1
+        cluster_strength: 0.1
+        compute_mode: 1
+        rest_length: 50.0
+        repulsion_cutoff: 50.0
+        repulsion_softening_epsilon: 0.0001
+        center_gravity_k: 0.0
+        grid_cell_size: 50.0
+        warmup_iterations: 100
+        cooling_rate: 0.001
+        boundary_extreme_multiplier: 2.0
+        boundary_extreme_force_multiplier: 5.0
+        boundary_velocity_damping: 0.5
+        min_distance: 1.0
+        max_repulsion_dist: 1000.0
+        boundary_margin: 10.0
+        boundary_force_strength: 1.0
+        warmup_curve: 'exponential'
+        zero_velocity_iterations: 10
+        clustering_algorithm: 'none'
+        cluster_count: 5
+        clustering_resolution: 1.0
+        clustering_iterations: 50
+system:
+  network:
+    bind_address: '0.0.0.0'
+    domain: 'visionflow.info'
+    enable_http2: false
+    enable_rate_limiting: false
+    enable_tls: false
+    max_request_size: 10485760
+    min_tls_version: '1.2'
+    port: 4000
+    rate_limit_requests: 10000
+    rate_limit_window: 600
+    tunnel_id: 'dummy'
+    api_client_timeout: 30
+    enable_metrics: false
+    max_concurrent_requests: 1
+    max_retries: 3
+    metrics_port: 9090
+    retry_delay: 5
+  websocket:
+    binary_chunk_size: 2048
+    binary_update_rate: 30
+    min_update_rate: 5
+    max_update_rate: 60
+    motion_threshold: 0.05
+    motion_damping: 0.9
+    binary_message_version: 1
+    compression_enabled: false
+    compression_threshold: 512
+    heartbeat_interval: 10000
+    heartbeat_timeout: 600000
+    max_connections: 100
+    max_message_size: 10485760
+    reconnect_attempts: 5
+    reconnect_delay: 1000
+    update_rate: 60
+  security:
+    allowed_origins:
+      - 'https://www.visionflow.info'
+      - 'https://visionflow.info'
+    audit_log_path: '/app/logs/audit.log'
+    cookie_httponly: true
+    cookie_samesite: 'Strict'
+    cookie_secure: true
+    csrf_token_timeout: 3600
+    enable_audit_logging: false
+    enable_request_validation: false
+    session_timeout: 3600
+  debug:
+    enabled: false
+  persist_settings: true
+xr:
+  enabled: false
+  room_scale: 1.0
+  space_type: 'local-floor'
+  quality: 'medium'
+  interaction_distance: 1.5
+  locomotion_method: 'teleport'
+  teleport_ray_color: '#ffffff'
+  controller_ray_color: '#ffffff'
+  enable_hand_tracking: true
+  hand_mesh_enabled: true
+  hand_mesh_color: '#4287f5'
+  hand_mesh_opacity: 0.3
+  hand_point_size: 0.006
+  hand_ray_enabled: true
+  hand_ray_color: '#4287f5'
+  hand_ray_width: 0.003
+  gesture_smoothing: 0.7
+  enable_haptics: true
+  haptic_intensity: 0.3
+  drag_threshold: 0.08
+  pinch_threshold: 0.3
+  rotation_threshold: 0.08
+  interaction_radius: 0.15
+  movement_speed: 1.0
+  dead_zone: 0.12
+  movement_axes:
+    horizontal: 2
+    vertical: 3
+  enable_light_estimation: false
+  enable_plane_detection: false
+  enable_scene_understanding: false
+  plane_color: '#4287f5'
+  plane_opacity: 0.001
+  plane_detection_distance: 3.0
+  show_plane_overlay: false
+  snap_to_floor: false
+  enable_passthrough_portal: false
+  passthrough_opacity: 0.8
+  passthrough_brightness: 1.1
+  passthrough_contrast: 1.2
+  portal_size: 2.5
+  portal_edge_color: '#4287f5'
+  portal_edge_width: 0.02
+auth:
+  enabled: false
+  provider: 'nostr'
+  required: false
+"#;
+
+    // Test direct YAML deserialization
+    println!("Testing direct YAML deserialization...");
+    match serde_yaml::from_str::<AppFullSettings>(test_yaml) {
+        Ok(settings) => {
+            println!("‚úÖ Direct YAML deserialization successful!");
+            println!("   - Glow enabled: {}", settings.visualisation.glow.enabled);
+            println!("   - Glow strength: {}", settings.visualisation.glow.edge_glow_strength);
+            
+            // Test serialization back to ensure bidirectional conversion works
+            match serde_yaml::to_string(&settings) {
+                Ok(serialized) => {
+                    if serialized.contains("bloom:") {
+                        println!("‚úÖ Serialization uses 'bloom' field name correctly");
+                    } else {
+                        println!("‚ö†Ô∏è  Warning: Serialization doesn't use 'bloom' field name");
+                    }
+                }
+                Err(e) => println!("‚ùå Serialization failed: {}", e),
+            }
+        }
+        Err(e) => {
+            println!("‚ùå Direct YAML deserialization failed: {}", e);
+            return Err(format!("Direct YAML deserialization failed: {}", e));
+        }
+    }
+
+    // Test JSON serialization for client compatibility using DTO
+    println!("\nTesting JSON serialization for client using DTO...");
+    let default_settings = AppFullSettings::default();
+    let response_dto: SettingsResponseDTO = (&default_settings).into();
+    
+    match serde_json::to_value(&response_dto) {
+        Ok(json) => {
+            if let Some(vis) = json.get("visualisation") {
+                if vis.get("bloom").is_some() {
+                    println!("‚úÖ Client JSON contains 'bloom' field via DTO");
+                } else {
+                    println!("‚ö†Ô∏è  Warning: Client JSON missing 'bloom' field in DTO");
+                }
+            }
+        }
+        Err(e) => println!("‚ùå JSON serialization failed: {}", e),
+    }
+
+    println!("‚úÖ All tests completed successfully!");
+    Ok(())
+}
\ No newline at end of file
