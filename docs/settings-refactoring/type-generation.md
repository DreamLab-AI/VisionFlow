# Automatic Type Generation Documentation

## Overview

This document explains the automatic type generation system that creates TypeScript definitions directly from Rust structs, eliminating manual synchronisation and ensuring type safety across the entire application.

## Architecture

### Type Generation Flow

```mermaid
graph TD
    A[Rust Structs with #[derive(Type)]] --> B[Build Script (build.rs)]
    B --> C[Specta Type Collection]
    C --> D[TypeScript Generation]
    D --> E[Generated Types File]
    E --> F[Frontend Import]
    F --> G[Type-Safe Frontend Code]
    
    H[Cargo Build] --> B
    I[File Changes] --> B
```

### Dependencies

The type generation system requires these Rust crates:

```toml
# Cargo.toml
[dependencies]
specta = { version = "2.0", features = ["chrono", "uuid", "indexmap"] }
serde = { version = "1.0", features = ["derive"] }

[build-dependencies] 
specta = { version = "2.0", features = ["export"] }
specta-typescript = "0.0.5"
```

## Implementation

### Build Script Configuration

```rust
// build.rs
use specta::{collect_types, Type};
use specta_typescript::{Typescript, ExportConfig, CommentStyle, BigIntExportBehaviour};
use std::path::Path;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo:rerun-if-changed=src/config/mod.rs");
    println!("cargo:rerun-if-changed=src/models/");
    println!("cargo:rerun-if-changed=build.rs");

    // Collect all types marked with #[derive(Type)]
    let types = collect_types![
        // Core settings structures
        crate::config::AppFullSettings,
        crate::config::VisualisationSettings,
        crate::config::PhysicsSettings,
        crate::config::NodeSettings,
        crate::config::EdgeSettings,
        crate::config::RenderingSettings,
        crate::config::AnimationSettings,
        crate::config::GlowSettings,
        crate::config::HologramSettings,
        crate::config::GraphsSettings,
        crate::config::LogseqGraphSettings,
        crate::config::VisionFlowGraphSettings,
        crate::config::SystemSettings,
        crate::config::NetworkSettings,
        crate::config::WebSocketSettings,
        crate::config::SecuritySettings,
        crate::config::DebugSettings,
        crate::config::XRSettings,
        crate::config::AuthSettings,
        
        // Optional service integrations
        crate::config::RagFlowSettings,
        crate::config::PerplexitySettings,
        crate::config::OpenAISettings,
        crate::config::KokoroSettings,
        crate::config::WhisperSettings,
        
        // API types
        crate::handlers::settings_handler::SettingUpdate,
        crate::handlers::settings_handler::SetSettingsRequest,
        crate::handlers::settings_handler::GranularSettingsResponse,
        
        // Validation types
        crate::validation::ValidationError,
        crate::validation::SettingsSchema,
    ];

    // Configure TypeScript export settings
    let config = ExportConfig::default()
        .bigint(BigIntExportBehaviour::Number)  // Convert Rust u64/i64 to TypeScript number
        .comment_style(CommentStyle::JSDoc);     // Use JSDoc-style comments

    // Generate TypeScript with custom header
    let header = r#"// Auto-generated TypeScript definitions from Rust structs
// DO NOT EDIT - This file is automatically generated during build
// 
// To update these types:
// 1. Modify the Rust structs in src/config/mod.rs
// 2. Run `cargo build` to regenerate this file
// 3. The changes will be automatically available in TypeScript

/* eslint-disable */
"#;

    let typescript_content = Typescript::new(config)
        .header(header)
        .export(&types)?;

    // Ensure output directory exists
    let output_path = Path::new("client/src/types/generated/settings.ts");
    if let Some(parent) = output_path.parent() {
        std::fs::create_dir_all(parent)?;
    }

    // Write generated TypeScript to file
    std::fs::write(output_path, typescript_content)?;

    // Also generate a JSON schema file for validation
    let schema_content = serde_json::to_string_pretty(&specta::ts::export(&types, &Default::default()))?;
    std::fs::write("client/src/types/generated/schema.json", schema_content)?;

    println!("✅ Generated TypeScript types: client/src/types/generated/settings.ts");
    println!("✅ Generated JSON schema: client/src/types/generated/schema.json");

    Ok(())
}
```

### Rust Struct Annotations

#### Core Settings Structure

```rust
// src/config/mod.rs
use specta::Type;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize, Clone, Type)]
#[serde(rename_all = "camelCase")]
pub struct AppFullSettings {
    /// Main visualisation configuration
    pub visualisation: VisualisationSettings,
    
    /// System-level configuration  
    pub system: SystemSettings,
    
    /// Virtual/Augmented Reality settings
    pub xr: XRSettings,
    
    /// Authentication and security settings
    pub auth: AuthSettings,
    
    /// Optional RagFlow integration settings
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ragflow: Option<RagFlowSettings>,
    
    /// Optional Perplexity AI integration
    #[serde(skip_serializing_if = "Option::is_none")]
    pub perplexity: Option<PerplexitySettings>,
    
    /// Optional OpenAI integration
    #[serde(skip_serializing_if = "Option::is_none")]
    pub openai: Option<OpenAISettings>,
    
    /// Optional Kokoro voice synthesis
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kokoro: Option<KokoroSettings>,
    
    /// Optional Whisper speech recognition
    #[serde(skip_serializing_if = "Option::is_none")]
    pub whisper: Option<WhisperSettings>,
    
    /// Settings format version for migration
    #[serde(default = "default_version")]
    pub version: String,
    
    /// Last modified timestamp
    #[serde(default = "Utc::now")]
    pub last_modified: DateTime<Utc>,
}

fn default_version() -> String {
    "2.0".to_string()
}

#[derive(Debug, Serialize, Deserialize, Clone, Type)]
#[serde(rename_all = "camelCase")]
pub struct VisualisationSettings {
    /// Rendering configuration
    pub rendering: RenderingSettings,
    
    /// Animation settings
    pub animations: AnimationSettings,
    
    /// Glow effect configuration
    pub glow: GlowSettings,
    
    /// Hologram overlay settings
    pub hologram: HologramSettings,
    
    /// Multi-graph container settings
    pub graphs: GraphsSettings,
}

#[derive(Debug, Serialize, Deserialize, Clone, Type)]
#[serde(rename_all = "camelCase")]
pub struct PhysicsSettings {
    /// Spring force between connected nodes (0.0 - 1.0)
    #[serde(default = "default_spring_strength")]
    pub spring_strength: f64,
    
    /// Repulsive force between all nodes (0.0 - 500.0)
    #[serde(default = "default_repulsion_strength")]
    pub repulsion_strength: f64,
    
    /// Energy dissipation rate (0.0 - 1.0)
    #[serde(default = "default_damping_factor")]
    pub damping_factor: f64,
    
    /// Attraction force towards centre (0.0 - 100.0)
    #[serde(default = "default_central_force")]
    pub central_force: f64,
    
    /// Desired distance between connected nodes (1.0 - 200.0)
    #[serde(default = "default_link_distance")]
    pub link_distance: f64,
    
    /// Strength of link constraints (0.0 - 1.0)
    #[serde(default = "default_link_strength")]
    pub link_strength: f64,
    
    /// Node charge for repulsion (-1000.0 - 0.0)
    #[serde(default = "default_charge_strength")]
    pub charge_strength: f64,
    
    /// Node collision detection radius (0.0 - 50.0)
    #[serde(default = "default_collision_radius")]
    pub collision_radius: f64,
    
    /// Simulation cooling rate (0.0 - 1.0)
    #[serde(default = "default_alpha_decay")]
    pub alpha_decay: f64,
    
    /// Velocity reduction per tick (0.0 - 1.0)
    #[serde(default = "default_velocity_decay")]
    pub velocity_decay: f64,
}

// Default value functions for physics settings
fn default_spring_strength() -> f64 { 0.3 }
fn default_repulsion_strength() -> f64 { 150.0 }
fn default_damping_factor() -> f64 { 0.9 }
fn default_central_force() -> f64 { 10.0 }
fn default_link_distance() -> f64 { 50.0 }
fn default_link_strength() -> f64 { 0.7 }
fn default_charge_strength() -> f64 { -30.0 }
fn default_collision_radius() -> f64 { 5.0 }
fn default_alpha_decay() -> f64 { 0.028 }
fn default_velocity_decay() -> f64 { 0.4 }

#[derive(Debug, Serialize, Deserialize, Clone, Type)]
#[serde(rename_all = "camelCase")]
pub struct RenderingSettings {
    /// Background colour as hex string
    #[serde(default = "default_background_colour")]
    pub background_colour: String,
    
    /// Ambient light intensity (0.0 - 1.0)
    #[serde(default = "default_ambient_light_intensity")]
    pub ambient_light_intensity: f64,
    
    /// Enable anti-aliasing
    #[serde(default = "default_antialiasing")]
    pub antialiasing: bool,
    
    /// Enable shadow rendering
    #[serde(default = "default_shadows")]
    pub shadows: bool,
    
    /// Target frames per second
    #[serde(default = "default_fps")]
    pub fps: u32,
    
    /// Render quality preset
    #[serde(default = "default_quality")]
    pub quality: RenderQuality,
}

#[derive(Debug, Serialize, Deserialize, Clone, Type)]
#[serde(rename_all = "camelCase")]
pub enum RenderQuality {
    Low,
    Medium,
    High,
    Ultra,
}

fn default_background_colour() -> String { "#000000".to_string() }
fn default_ambient_light_intensity() -> f64 { 0.3 }
fn default_antialiasing() -> bool { true }
fn default_shadows() -> bool { true }
fn default_fps() -> u32 { 60 }
fn default_quality() -> RenderQuality { RenderQuality::High }
```

#### API Types

```rust
// src/handlers/settings_handler.rs  
use specta::Type;
use serde::{Deserialize, Serialize};
use serde_json::Value;

#[derive(Debug, Deserialize, Type)]
pub struct SettingUpdate {
    /// Dot-notation path to the setting
    pub path: String,
    
    /// New value for the setting
    pub value: Value,
}

#[derive(Debug, Deserialize, Type)]
pub struct SetSettingsRequest {
    /// Array of setting updates to apply
    pub updates: Vec<SettingUpdate>,
    
    /// Whether to validate settings before applying
    #[serde(default = "default_validate")]
    pub validate: bool,
}

fn default_validate() -> bool { true }

#[derive(Debug, Serialize, Type)]
#[serde(rename_all = "camelCase")]
pub struct GranularSettingsResponse {
    /// Whether the operation succeeded
    pub success: bool,
    
    /// Settings data for GET requests
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<Value>,
    
    /// Updated settings for SET requests
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated: Option<Value>,
    
    /// Paths that were requested (GET)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requested_paths: Option<Vec<String>>,
    
    /// Paths that were affected (SET)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub affected_paths: Option<Vec<String>>,
    
    /// Error information if success is false
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ApiError>,
    
    /// Response timestamp
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Serialize, Type)]
pub struct ApiError {
    /// Error code for programmatic handling
    pub code: String,
    
    /// Human-readable error message
    pub message: String,
    
    /// Additional error details
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<Value>,
}
```

### Generated TypeScript Output

The build process generates comprehensive TypeScript definitions:

```typescript
// client/src/types/generated/settings.ts (AUTO-GENERATED)

// Auto-generated TypeScript definitions from Rust structs
// DO NOT EDIT - This file is automatically generated during build

/* eslint-disable */

/**
 * Main application settings container
 */
export interface AppFullSettings {
  /**
   * Main visualisation configuration
   */
  visualisation: VisualisationSettings;
  /**
   * System-level configuration
   */
  system: SystemSettings;
  /**
   * Virtual/Augmented Reality settings
   */
  xr: XRSettings;
  /**
   * Authentication and security settings
   */
  auth: AuthSettings;
  /**
   * Optional RagFlow integration settings
   */
  ragflow?: RagFlowSettings | null;
  /**
   * Optional Perplexity AI integration
   */
  perplexity?: PerplexitySettings | null;
  /**
   * Optional OpenAI integration
   */
  openai?: OpenAISettings | null;
  /**
   * Optional Kokoro voice synthesis
   */
  kokoro?: KokoroSettings | null;
  /**
   * Optional Whisper speech recognition
   */
  whisper?: WhisperSettings | null;
  /**
   * Settings format version for migration
   */
  version: string;
  /**
   * Last modified timestamp
   */
  lastModified: string;
}

export interface VisualisationSettings {
  /**
   * Rendering configuration
   */
  rendering: RenderingSettings;
  /**
   * Animation settings
   */
  animations: AnimationSettings;
  /**
   * Glow effect configuration
   */
  glow: GlowSettings;
  /**
   * Hologram overlay settings
   */
  hologram: HologramSettings;
  /**
   * Multi-graph container settings
   */
  graphs: GraphsSettings;
}

export interface PhysicsSettings {
  /**
   * Spring force between connected nodes (0.0 - 1.0)
   */
  springStrength: number;
  /**
   * Repulsive force between all nodes (0.0 - 500.0)
   */
  repulsionStrength: number;
  /**
   * Energy dissipation rate (0.0 - 1.0)
   */
  dampingFactor: number;
  /**
   * Attraction force towards centre (0.0 - 100.0)
   */
  centralForce: number;
  /**
   * Desired distance between connected nodes (1.0 - 200.0)
   */
  linkDistance: number;
  /**
   * Strength of link constraints (0.0 - 1.0)
   */
  linkStrength: number;
  /**
   * Node charge for repulsion (-1000.0 - 0.0)
   */
  chargeStrength: number;
  /**
   * Node collision detection radius (0.0 - 50.0)
   */
  collisionRadius: number;
  /**
   * Simulation cooling rate (0.0 - 1.0)
   */
  alphaDecay: number;
  /**
   * Velocity reduction per tick (0.0 - 1.0)
   */
  velocityDecay: number;
}

export interface RenderingSettings {
  /**
   * Background colour as hex string
   */
  backgroundColour: string;
  /**
   * Ambient light intensity (0.0 - 1.0)
   */
  ambientLightIntensity: number;
  /**
   * Enable anti-aliasing
   */
  antialiasing: boolean;
  /**
   * Enable shadow rendering
   */
  shadows: boolean;
  /**
   * Target frames per second
   */
  fps: number;
  /**
   * Render quality preset
   */
  quality: RenderQuality;
}

export type RenderQuality = "Low" | "Medium" | "High" | "Ultra";

export interface SettingUpdate {
  /**
   * Dot-notation path to the setting
   */
  path: string;
  /**
   * New value for the setting
   */
  value: any;
}

export interface SetSettingsRequest {
  /**
   * Array of setting updates to apply
   */
  updates: SettingUpdate[];
  /**
   * Whether to validate settings before applying
   */
  validate: boolean;
}

export interface GranularSettingsResponse {
  /**
   * Whether the operation succeeded
   */
  success: boolean;
  /**
   * Settings data for GET requests
   */
  data?: any;
  /**
   * Updated settings for SET requests
   */
  updated?: any;
  /**
   * Paths that were requested (GET)
   */
  requestedPaths?: string[];
  /**
   * Paths that were affected (SET)
   */
  affectedPaths?: string[];
  /**
   * Error information if success is false
   */
  error?: ApiError;
  /**
   * Response timestamp
   */
  timestamp: string;
}

export interface ApiError {
  /**
   * Error code for programmatic handling
   */
  code: string;
  /**
   * Human-readable error message
   */
  message: string;
  /**
   * Additional error details
   */
  details?: any;
}
```

## Frontend Integration

### Using Generated Types

```typescript
// client/src/components/settings/PhysicsPanel.tsx
import React from 'react';
import { useSettingsStore } from '../../store/settingsStore';
import { PhysicsSettings } from '../../types/generated/settings';

interface PhysicsPanelProps {
  graphName: 'logseq' | 'visionflow';
}

export const PhysicsPanel: React.FC<PhysicsPanelProps> = ({ graphName }) => {
  const { settings, updateSetting } = useSettingsStore();
  
  // Type-safe access to physics settings
  const physics: PhysicsSettings | undefined = 
    settings.visualisation?.graphs?.[graphName]?.physics;

  const handleSliderChange = (field: keyof PhysicsSettings, value: number) => {
    updateSetting(`visualisation.graphs.${graphName}.physics.${field}`, value);
  };

  if (!physics) {
    return <div>Loading physics settings...</div>;
  }

  return (
    <div className="physics-panel">
      <h3>{graphName} Physics Settings</h3>
      
      <div className="setting-group">
        <label>Spring Strength ({physics.springStrength})</label>
        <input
          type="range"
          min="0"
          max="1"
          step="0.01"
          value={physics.springStrength}
          onChange={(e) => handleSliderChange('springStrength', parseFloat(e.target.value))}
        />
      </div>
      
      <div className="setting-group">
        <label>Repulsion Strength ({physics.repulsionStrength})</label>
        <input
          type="range"
          min="0"
          max="500"
          step="1"
          value={physics.repulsionStrength}
          onChange={(e) => handleSliderChange('repulsionStrength', parseFloat(e.target.value))}
        />
      </div>
      
      <div className="setting-group">
        <label>Damping Factor ({physics.dampingFactor})</label>
        <input
          type="range"
          min="0"
          max="1"
          step="0.01"
          value={physics.dampingFactor}
          onChange={(e) => handleSliderChange('dampingFactor', parseFloat(e.target.value))}
        />
      </div>
    </div>
  );
};
```

### Type-Safe API Client

```typescript
// client/src/api/settingsApi.ts
import { 
  AppFullSettings, 
  SettingUpdate, 
  SetSettingsRequest, 
  GranularSettingsResponse 
} from '../types/generated/settings';

export class TypeSafeSettingsApi {
  /**
   * Get settings with full type safety
   */
  async getSettings(paths: string[]): Promise<Partial<AppFullSettings>> {
    const response = await fetch(`/api/settings/get?paths=${paths.join(',')}`);
    const result: GranularSettingsResponse = await response.json();
    
    if (!result.success) {
      throw new Error(result.error?.message || 'Failed to fetch settings');
    }
    
    return result.data as Partial<AppFullSettings>;
  }

  /**
   * Update settings with type-safe validation
   */
  async setSettings(updates: SettingUpdate[]): Promise<Partial<AppFullSettings>> {
    const request: SetSettingsRequest = {
      updates,
      validate: true
    };
    
    const response = await fetch('/api/settings/set', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request)
    });
    
    const result: GranularSettingsResponse = await response.json();
    
    if (!result.success) {
      throw new Error(result.error?.message || 'Failed to update settings');
    }
    
    return result.updated as Partial<AppFullSettings>;
  }

  /**
   * Type-safe setting path validation
   */
  validatePath(path: string, settings: Partial<AppFullSettings>): boolean {
    const parts = path.split('.');
    let current: any = settings;
    
    for (const part of parts) {
      if (current && typeof current === 'object' && part in current) {
        current = current[part];
      } else {
        return false;
      }
    }
    
    return current !== undefined;
  }
}
```

## Advanced Type Generation Features

### Custom Serialisation Attributes

```rust
#[derive(Debug, Serialize, Deserialize, Clone, Type)]
#[serde(rename_all = "camelCase")]
pub struct AdvancedSettings {
    /// Field with custom serialisation name
    #[serde(rename = "customFieldName")]
    pub internal_field_name: String,
    
    /// Field that's skipped during serialisation when None
    #[serde(skip_serializing_if = "Option::is_none")]
    pub optional_field: Option<String>,
    
    /// Field with default value
    #[serde(default = "default_timeout")]
    pub timeout_seconds: u32,
    
    /// Field with custom deserialiser for validation
    #[serde(deserialize_with = "validate_email")]
    pub email: String,
    
    /// Flattened struct (fields appear at parent level)
    #[serde(flatten)]
    pub embedded_config: EmbeddedConfig,
    
    /// Field using custom serialiser for complex types
    #[serde(with = "timestamp_serialiser")]
    pub created_at: chrono::DateTime<chrono::Utc>,
}

fn default_timeout() -> u32 { 30 }

fn validate_email<'de, D>(deserializer: D) -> Result<String, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let email: String = String::deserialize(deserializer)?;
    if !email.contains('@') {
        return Err(serde::de::Error::custom("Invalid email format"));
    }
    Ok(email)
}

mod timestamp_serialiser {
    use chrono::{DateTime, Utc};
    use serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(dt: &DateTime<Utc>, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&dt.to_rfc3339())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<DateTime<Utc>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s: String = String::deserialize(deserializer)?;
        DateTime::parse_from_rfc3339(&s)
            .map(|dt| dt.with_timezone(&Utc))
            .map_err(serde::de::Error::custom)
    }
}
```

### Conditional Type Generation

```rust
// Generate different types based on features
#[derive(Debug, Serialize, Deserialize, Clone, Type)]
pub struct ConditionalSettings {
    /// Always present field
    pub base_setting: String,
    
    /// Only present when "advanced" feature is enabled
    #[cfg(feature = "advanced")]
    pub advanced_setting: AdvancedConfig,
    
    /// Different types based on target
    #[cfg(target_family = "wasm")]
    pub wasm_specific: WasmConfig,
    
    #[cfg(not(target_family = "wasm"))]
    pub native_specific: NativeConfig,
}
```

## Build Process Integration

### Automated CI/CD Integration

```yaml
# .github/workflows/type-generation.yml
name: Type Generation Validation

on:
  pull_request:
    paths:
      - 'src/config/**'
      - 'src/models/**' 
      - 'build.rs'
      - 'Cargo.toml'

jobs:
  validate-types:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          
      - name: Generate types
        run: cargo build
        
      - name: Check for type changes
        run: |
          if ! git diff --quiet client/src/types/generated/settings.ts; then
            echo "Generated types have changed. Please commit the updated types."
            git diff client/src/types/generated/settings.ts
            exit 1
          fi
          
      - name: Validate TypeScript compilation
        working-directory: client
        run: |
          npm ci
          npm run type-check
```

### Development Workflow Integration

```json
// package.json scripts for development
{
  "scripts": {
    "types:generate": "cd .. && cargo build",
    "types:watch": "nodemon --watch ../src/config --ext rs --exec 'npm run types:generate'",
    "dev": "concurrently 'npm run types:watch' 'vite'",
    "type-check": "tsc --noEmit",
    "lint:types": "eslint src/types/generated/ --fix"
  }
}
```

## Troubleshooting

### Common Issues

#### Issue: Build Script Fails
```bash
error: failed to run custom build command for `visionflow v1.0.0`
```
**Solution**: Ensure all referenced types in `collect_types![]` exist and have `#[derive(Type)]`.

#### Issue: TypeScript Compilation Errors
```typescript
error TS2304: Cannot find name 'SomeType'
```
**Solution**: Check that the Rust type is properly exported and the build script completed successfully.

#### Issue: Case Conversion Not Working
```rust
// Wrong - missing rename_all attribute
#[derive(Type)]  
pub struct BadExample {
    pub field_name: String,  // Still snake_case in JSON
}

// Correct - with rename_all
#[derive(Type)]
#[serde(rename_all = "camelCase")]
pub struct GoodExample {
    pub field_name: String,  // Becomes "fieldName" in JSON
}
```

### Debugging Type Generation

```rust
// Add debug output to build script
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let types = collect_types![/* ... */];
    
    // Debug: Print collected type information
    for t in &types {
        println!("Collected type: {} with {} fields", t.name(), t.fields().len());
    }
    
    let typescript_content = Typescript::new(config).export(&types)?;
    
    // Debug: Print generated content length
    println!("Generated {} bytes of TypeScript", typescript_content.len());
    
    Ok(())
}
```

---

**Type Generation Documentation Version**: 1.0  
**Last Updated**: 2025-09-01  
**Maintained By**: Type Safety Team