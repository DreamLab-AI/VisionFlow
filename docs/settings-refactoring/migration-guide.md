# Settings System Migration Guide

## Overview

This guide provides detailed instructions for migrating from the legacy settings system to the new granular, type-safe architecture. The migration eliminates manual DTOs, introduces automatic case conversion, and implements granular API endpoints.

## Migration Timeline

### Phase 1: Preparation (Week 1-2)
- [ ] Add type generation dependencies
- [ ] Set up build script for TypeScript generation
- [ ] Create parallel implementation alongside legacy system
- [ ] Implement feature flags for controlled rollout

### Phase 2: Backend Refactoring (Week 3-4)
- [ ] Add specta annotations to Rust structs
- [ ] Implement automatic case conversion with serde
- [ ] Create granular API endpoints
- [ ] Remove manual DTO layer

### Phase 3: Frontend Migration (Week 5-6)
- [ ] Update frontend to use generated types
- [ ] Implement granular API client
- [ ] Migrate state management to selective loading
- [ ] Update UI components for lazy loading

### Phase 4: Testing & Deployment (Week 7-8)
- [ ] Comprehensive testing of new system
- [ ] Performance validation and optimisation
- [ ] Gradual rollout to production
- [ ] Legacy system deprecation

## Breaking Changes

### API Contract Changes

#### Legacy Endpoints (Deprecated)
```bash
# Will be removed in v3.0
GET /api/settings          # Returns full settings object
POST /api/settings         # Accepts full settings object
```

#### New Endpoints (Current)
```bash
# Granular access with dot-notation paths
GET /api/settings/get?paths=visualisation.rendering.backgroundColour
POST /api/settings/set     # Accepts path-value updates
```

### TypeScript Interface Changes

#### Before (Manual Definitions)
```typescript
// client/src/features/settings/config/settings.ts (REMOVED)
interface PhysicsSettings {
  springStrength: number;
  repulsionStrength: number;
  dampingFactor: number;
}
```

#### After (Auto-Generated)
```typescript
// client/src/types/generated/settings.ts (AUTO-GENERATED)
export interface PhysicsSettings {
  springStrength: number;
  repulsionStrength: number;
  dampingFactor: number;
}
```

### Import Path Changes

#### Before
```typescript
import { AppFullSettings } from '../features/settings/config/settings';
```

#### After  
```typescript
import { AppFullSettings } from '../types/generated/settings';
```

## Step-by-Step Migration

### Backend Migration

#### Step 1: Add Dependencies to Cargo.toml

```toml
[dependencies]
# Existing dependencies...
specta = { version = "2.0", features = ["chrono", "uuid"] }

[build-dependencies]
specta = { version = "2.0", features = ["export"] }
specta-typescript = "0.0.5"
```

#### Step 2: Create Type Generation Build Script

```rust
// build.rs
use specta::{collect_types, Type};
use specta_typescript::{Typescript, ExportConfig};
use std::path::Path;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Collect all types marked with #[derive(Type)]
    let types = collect_types![
        crate::config::AppFullSettings,
        crate::config::VisualisationSettings,
        crate::config::PhysicsSettings,
        crate::config::SystemSettings,
        crate::config::XRSettings,
        crate::config::AuthSettings,
        // Add all settings-related types
    ];

    // Configure TypeScript generation
    let config = ExportConfig::default()
        .bigint(specta_typescript::BigIntExportBehaviour::Number)
        .comment_style(specta_typescript::CommentStyle::JSDoc);

    // Generate TypeScript definitions
    let output = Typescript::new(config)
        .header("// Auto-generated TypeScript definitions from Rust structs\n// DO NOT EDIT - This file is automatically generated during build")
        .export(&types)?;

    // Write to frontend directory
    let output_path = Path::new("client/src/types/generated/settings.ts");
    
    // Create directory if it doesn't exist
    if let Some(parent) = output_path.parent() {
        std::fs::create_dir_all(parent)?;
    }
    
    std::fs::write(output_path, output)?;

    println!("cargo:rerun-if-changed=src/config/mod.rs");
    println!("cargo:rerun-if-changed=build.rs");

    Ok(())
}
```

#### Step 3: Add Type Annotations to Rust Structs

```rust
// src/config/mod.rs
use specta::Type;
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, Clone, Type)]
#[serde(rename_all = "camelCase")]  // Automatic case conversion
pub struct AppFullSettings {
    pub visualisation: VisualisationSettings,
    pub system: SystemSettings,
    pub xr: XRSettings,
    pub auth: AuthSettings,
    
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ragflow: Option<RagFlowSettings>,
    
    #[serde(skip_serializing_if = "Option::is_none")]
    pub perplexity: Option<PerplexitySettings>,
}

#[derive(Debug, Serialize, Deserialize, Clone, Type)]
#[serde(rename_all = "camelCase")]
pub struct PhysicsSettings {
    // snake_case fields automatically become camelCase in JSON
    pub spring_strength: f64,        // -> springStrength
    pub repulsion_strength: f64,     // -> repulsionStrength
    pub damping_factor: f64,         // -> dampingFactor
    pub central_force: f64,          // -> centralForce
    pub link_distance: f64,          // -> linkDistance
    pub link_strength: f64,          // -> linkStrength
    pub charge_strength: f64,        // -> chargeStrength
    pub collision_radius: f64,       // -> collisionRadius
    pub alpha_decay: f64,            // -> alphaDecay
    pub velocity_decay: f64,         // -> velocityDecay
}
```

#### Step 4: Implement Granular API Endpoints

```rust
// src/handlers/settings_handler.rs

use actix_web::{get, post, web, HttpResponse, Result};
use serde_json::Value;

#[derive(Debug, Deserialize)]
struct GetSettingsQuery {
    paths: String,  // Comma-separated paths
    expand: Option<bool>,
}

#[derive(Debug, Deserialize)]
struct SettingUpdate {
    path: String,
    value: Value,
}

#[derive(Debug, Deserialize)]
struct SetSettingsRequest {
    updates: Vec<SettingUpdate>,
    validate: Option<bool>,
}

#[get("/api/settings/get")]
pub async fn get_settings_granular(
    query: web::Query<GetSettingsQuery>,
    settings_actor: web::Data<Addr<SettingsActor>>,
) -> Result<HttpResponse> {
    let paths: Vec<&str> = query.paths.split(',').map(|s| s.trim()).collect();
    
    match settings_actor.send(GetSettingsByPaths { paths }).await {
        Ok(Ok(partial_settings)) => {
            Ok(HttpResponse::Ok().json(json!({
                "success": true,
                "data": partial_settings,
                "requestedPaths": paths,
                "timestamp": chrono::Utc::now()
            })))
        }
        Ok(Err(e)) => {
            Ok(HttpResponse::BadRequest().json(json!({
                "success": false,
                "error": {
                    "code": "INVALID_PATH",
                    "message": e.to_string()
                }
            })))
        }
        Err(e) => {
            Ok(HttpResponse::InternalServerError().json(json!({
                "success": false,
                "error": {
                    "code": "ACTOR_ERROR",
                    "message": e.to_string()
                }
            })))
        }
    }
}

#[post("/api/settings/set")]
pub async fn set_settings_granular(
    request: web::Json<SetSettingsRequest>,
    settings_actor: web::Data<Addr<SettingsActor>>,
) -> Result<HttpResponse> {
    let validate = request.validate.unwrap_or(true);
    
    match settings_actor.send(SetSettingsByPaths {
        updates: request.updates.clone(),
        validate,
    }).await {
        Ok(Ok(updated_settings)) => {
            Ok(HttpResponse::Ok().json(json!({
                "success": true,
                "updated": updated_settings,
                "affectedPaths": request.updates.iter()
                    .map(|u| &u.path)
                    .collect::<Vec<_>>(),
                "timestamp": chrono::Utc::now()
            })))
        }
        Ok(Err(validation_errors)) => {
            Ok(HttpResponse::BadRequest().json(json!({
                "success": false,
                "error": {
                    "code": "VALIDATION_ERROR", 
                    "message": "Multiple validation errors",
                    "details": {
                        "errors": validation_errors
                    }
                }
            })))
        }
        Err(e) => {
            Ok(HttpResponse::InternalServerError().json(json!({
                "success": false,
                "error": {
                    "code": "ACTOR_ERROR",
                    "message": e.to_string()
                }
            })))
        }
    }
}
```

#### Step 5: Remove Manual DTO Layer

```rust
// DELETE: src/models/client_settings_payload.rs
// This file is no longer needed - serde handles case conversion automatically

// BEFORE (Manual DTOs - REMOVE THESE)
#[derive(Debug, Serialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct PhysicsSettingsDTO {
    pub spring_strength: f64,
    pub repulsion_strength: f64,
    // ... manual field mapping
}

// AFTER (Direct serialisation - KEEP THESE)
#[derive(Debug, Serialize, Deserialize, Clone, Type)]
#[serde(rename_all = "camelCase")]
pub struct PhysicsSettings {
    pub spring_strength: f64,    // Automatic camelCase conversion
    pub repulsion_strength: f64, // No manual mapping needed
}
```

### Frontend Migration

#### Step 1: Remove Manual Type Definitions

```bash
# Delete manual settings definitions
rm client/src/features/settings/config/settings.ts
rm client/src/features/settings/config/debugSettingsUIDefinition.ts

# The build process will generate new types automatically
```

#### Step 2: Update Import Statements

```typescript
// Find all files importing settings types
// Replace manual imports with generated types

// BEFORE
import { 
  AppFullSettings, 
  PhysicsSettings, 
  VisualisationSettings 
} from '../features/settings/config/settings';

// AFTER  
import { 
  AppFullSettings, 
  PhysicsSettings, 
  VisualisationSettings 
} from '../types/generated/settings';
```

#### Step 3: Create New Granular API Client

```typescript
// client/src/api/settingsApi.ts

import { apiService } from './apiService';
import { AppFullSettings } from '../types/generated/settings';

export interface SettingUpdate {
  path: string;
  value: any;
}

export interface GranularSettingsResponse {
  success: boolean;
  data?: Partial<AppFullSettings>;
  updated?: Partial<AppFullSettings>;
  requestedPaths?: string[];
  affectedPaths?: string[];
  timestamp: string;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
}

export class GranularSettingsApi {
  /**
   * Get specific settings by dot-notation paths
   * @param paths Array of setting paths like ['visualisation.rendering.backgroundColour']
   */
  async getSettings(paths: string[]): Promise<Partial<AppFullSettings>> {
    const pathsQuery = paths.join(',');
    const response = await apiService.get<GranularSettingsResponse>(
      `/api/settings/get?paths=${encodeURIComponent(pathsQuery)}`
    );
    
    if (!response.success) {
      throw new Error(response.error?.message || 'Failed to fetch settings');
    }
    
    return response.data || {};
  }

  /**
   * Update specific settings with path-value pairs
   * @param updates Array of setting updates
   */
  async setSettings(updates: SettingUpdate[]): Promise<Partial<AppFullSettings>> {
    const response = await apiService.post<GranularSettingsResponse>(
      '/api/settings/set',
      { updates, validate: true }
    );
    
    if (!response.success) {
      throw new Error(response.error?.message || 'Failed to update settings');
    }
    
    return response.updated || {};
  }

  /**
   * Reset specific settings to defaults
   * @param paths Array of setting paths to reset
   */
  async resetSettings(paths: string[]): Promise<Partial<AppFullSettings>> {
    const response = await apiService.post<GranularSettingsResponse>(
      '/api/settings/reset',
      { paths, confirm: true }
    );
    
    if (!response.success) {
      throw new Error(response.error?.message || 'Failed to reset settings');
    }
    
    return response.reset || {};
  }

  /**
   * Validate a setting value without applying it
   * @param path Setting path
   * @param value New value
   */
  async validateSetting(path: string, value: any): Promise<boolean> {
    try {
      await apiService.post<GranularSettingsResponse>(
        '/api/settings/validate',
        { path, value }
      );
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Get available setting paths and their schemas
   */
  async getSchema(path?: string): Promise<any> {
    const query = path ? `?path=${encodeURIComponent(path)}` : '';
    const response = await apiService.get(`/api/settings/schema${query}`);
    return response.data;
  }
}

// Create API instance
export const settingsApi = new GranularSettingsApi();
```

#### Step 4: Update Settings Store

```typescript
// client/src/store/settingsStore.ts

import { create } from 'zustand';
import { subscribeWithSelector, persist } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import { settingsApi, SettingUpdate } from '../api/settingsApi';
import { AppFullSettings } from '../types/generated/settings';

interface SettingsState {
  settings: Partial<AppFullSettings>;
  loading: boolean;
  error: string | null;
  
  // Actions
  loadSettings: (paths: string[]) => Promise<void>;
  updateSetting: (path: string, value: any) => Promise<void>;
  batchUpdate: (updates: SettingUpdate[]) => Promise<void>;
  resetSettings: (paths: string[]) => Promise<void>;
  
  // Utilities  
  getSetting: (path: string) => any;
  hasLoadedPath: (path: string) => boolean;
}

export const useSettingsStore = create<SettingsState>()(
  subscribeWithSelector(
    persist(
      immer((set, get) => ({
        settings: {},
        loading: false,
        error: null,

        loadSettings: async (paths: string[]) => {
          set(state => {
            state.loading = true;
            state.error = null;
          });

          try {
            // Only load paths that haven't been loaded yet
            const unloadedPaths = paths.filter(path => !get().hasLoadedPath(path));
            
            if (unloadedPaths.length === 0) {
              set(state => { state.loading = false; });
              return;
            }

            const partialSettings = await settingsApi.getSettings(unloadedPaths);
            
            set(state => {
              state.settings = mergeDeep(state.settings, partialSettings);
              state.loading = false;
            });
          } catch (error) {
            set(state => {
              state.error = error instanceof Error ? error.message : 'Failed to load settings';
              state.loading = false;
            });
          }
        },

        updateSetting: async (path: string, value: any) => {
          try {
            const updated = await settingsApi.setSettings([{ path, value }]);
            
            set(state => {
              state.settings = mergeDeep(state.settings, updated);
            });
            
            // Notify specific subscribers
            notifyPathSubscribers(path, value);
          } catch (error) {
            set(state => {
              state.error = error instanceof Error ? error.message : 'Failed to update setting';
            });
            throw error;
          }
        },

        batchUpdate: async (updates: SettingUpdate[]) => {
          try {
            const updated = await settingsApi.setSettings(updates);
            
            set(state => {
              state.settings = mergeDeep(state.settings, updated);
            });
            
            // Notify all affected paths
            updates.forEach(update => {
              notifyPathSubscribers(update.path, update.value);
            });
          } catch (error) {
            set(state => {
              state.error = error instanceof Error ? error.message : 'Failed to batch update settings';
            });
            throw error;
          }
        },

        resetSettings: async (paths: string[]) => {
          try {
            const reset = await settingsApi.resetSettings(paths);
            
            set(state => {
              state.settings = mergeDeep(state.settings, reset);
            });
          } catch (error) {
            set(state => {
              state.error = error instanceof Error ? error.message : 'Failed to reset settings';
            });
            throw error;
          }
        },

        getSetting: (path: string) => {
          return getNestedValue(get().settings, path);
        },

        hasLoadedPath: (path: string) => {
          return getNestedValue(get().settings, path) !== undefined;
        }
      })),
      {
        name: 'visionflow-settings',
        partialize: (state) => ({
          settings: state.settings  // Only persist settings, not loading/error state
        })
      }
    )
  )
);

// Utility functions
function mergeDeep(target: any, source: any): any {
  const result = { ...target };
  
  for (const key in source) {
    if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
      result[key] = mergeDeep(result[key] || {}, source[key]);
    } else {
      result[key] = source[key];
    }
  }
  
  return result;
}

function getNestedValue(obj: any, path: string): any {
  return path.split('.').reduce((current, key) => current?.[key], obj);
}

function notifyPathSubscribers(path: string, value: any): void {
  // Notify WebSocket service if available
  const wsService = (window as any).webSocketService;
  if (wsService?.isConnected?.()) {
    wsService.send({
      type: 'settings_changed',
      path,
      value,
      timestamp: new Date().toISOString()
    });
  }
}
```

#### Step 5: Update UI Components for Lazy Loading

```typescript
// client/src/features/settings/components/panels/SettingsPanelRedesign.tsx

import React, { Suspense } from 'react';
import { useSettingsStore } from '../../../../store/settingsStore';

// Lazy-loaded panel components
const PhysicsPanel = React.lazy(() => 
  import('./PhysicsPanel').then(async (module) => {
    // Pre-load required settings when component is imported
    const loadSettings = useSettingsStore.getState().loadSettings;
    await loadSettings([
      'visualisation.graphs.logseq.physics',
      'visualisation.graphs.visionflow.physics'
    ]);
    return module;
  })
);

const RenderingPanel = React.lazy(() => 
  import('./RenderingPanel').then(async (module) => {
    const loadSettings = useSettingsStore.getState().loadSettings;
    await loadSettings([
      'visualisation.rendering',
      'visualisation.animations',
      'visualisation.glow'
    ]);
    return module;
  })
);

export const SettingsPanelRedesign: React.FC = () => {
  const [activeTab, setActiveTab] = React.useState('physics');

  return (
    <div className="settings-panel">
      <div className="settings-tabs">
        <button 
          className={activeTab === 'physics' ? 'active' : ''}
          onClick={() => setActiveTab('physics')}
        >
          Physics
        </button>
        <button 
          className={activeTab === 'rendering' ? 'active' : ''}
          onClick={() => setActiveTab('rendering')}
        >
          Rendering
        </button>
      </div>
      
      <div className="settings-content">
        <Suspense fallback={<div>Loading settings...</div>}>
          {activeTab === 'physics' && <PhysicsPanel />}
          {activeTab === 'rendering' && <RenderingPanel />}
        </Suspense>
      </div>
    </div>
  );
};
```

## Testing Migration

### Backend Testing

```rust
// tests/integration/settings_api_test.rs

#[cfg(test)]
mod granular_settings_tests {
    use super::*;
    use actix_web::{test, web, App};

    #[tokio::test]
    async fn test_get_settings_granular() {
        let app = test::init_service(
            App::new()
                .route("/api/settings/get", web::get().to(get_settings_granular))
        ).await;

        let req = test::TestRequest::get()
            .uri("/api/settings/get?paths=system.network.port,visualisation.rendering.backgroundColour")
            .to_request();
        
        let resp = test::call_service(&app, req).await;
        assert!(resp.status().is_success());

        let body: serde_json::Value = test::read_body_json(resp).await;
        assert!(body["success"].as_bool().unwrap());
        assert!(body["data"]["system"]["network"]["port"].is_number());
        assert!(body["data"]["visualisation"]["rendering"]["backgroundColour"].is_string());
    }

    #[tokio::test]
    async fn test_set_settings_granular() {
        let app = test::init_service(
            App::new()
                .route("/api/settings/set", web::post().to(set_settings_granular))
        ).await;

        let update_data = json!({
            "updates": [
                {
                    "path": "visualisation.rendering.backgroundColour",
                    "value": "#FFFFFF"
                },
                {
                    "path": "system.network.port",
                    "value": 8080
                }
            ]
        });

        let req = test::TestRequest::post()
            .uri("/api/settings/set")
            .set_json(&update_data)
            .to_request();
        
        let resp = test::call_service(&app, req).await;
        assert!(resp.status().is_success());

        let body: serde_json::Value = test::read_body_json(resp).await;
        assert!(body["success"].as_bool().unwrap());
        assert_eq!(body["affectedPaths"].as_array().unwrap().len(), 2);
    }
}
```

### Frontend Testing

```typescript
// client/src/store/__tests__/settingsStore.test.ts

import { renderHook, act } from '@testing-library/react';
import { useSettingsStore } from '../settingsStore';
import { settingsApi } from '../../api/settingsApi';

jest.mock('../../api/settingsApi');

describe('Settings Store (New Granular System)', () => {
  beforeEach(() => {
    useSettingsStore.setState({
      settings: {},
      loading: false,
      error: null
    });
  });

  test('loads specific settings by path', async () => {
    const mockPartialSettings = {
      visualisation: {
        rendering: {
          backgroundColour: '#000000'
        }
      }
    };

    (settingsApi.getSettings as jest.Mock).mockResolvedValue(mockPartialSettings);

    const { result } = renderHook(() => useSettingsStore());

    await act(async () => {
      await result.current.loadSettings(['visualisation.rendering.backgroundColour']);
    });

    expect(result.current.settings.visualisation?.rendering?.backgroundColour).toBe('#000000');
    expect(settingsApi.getSettings).toHaveBeenCalledWith(['visualisation.rendering.backgroundColour']);
  });

  test('updates single setting via granular API', async () => {
    const mockUpdatedSettings = {
      visualisation: {
        rendering: {
          backgroundColour: '#FFFFFF'
        }
      }
    };

    (settingsApi.setSettings as jest.Mock).mockResolvedValue(mockUpdatedSettings);

    const { result } = renderHook(() => useSettingsStore());

    await act(async () => {
      await result.current.updateSetting('visualisation.rendering.backgroundColour', '#FFFFFF');
    });

    expect(result.current.settings.visualisation?.rendering?.backgroundColour).toBe('#FFFFFF');
    expect(settingsApi.setSettings).toHaveBeenCalledWith([{
      path: 'visualisation.rendering.backgroundColour',
      value: '#FFFFFF'
    }]);
  });

  test('batches multiple updates efficiently', async () => {
    const updates = [
      { path: 'visualisation.rendering.backgroundColour', value: '#FFFFFF' },
      { path: 'system.network.port', value: 8080 }
    ];

    const mockUpdatedSettings = {
      visualisation: {
        rendering: {
          backgroundColour: '#FFFFFF'
        }
      },
      system: {
        network: {
          port: 8080
        }
      }
    };

    (settingsApi.setSettings as jest.Mock).mockResolvedValue(mockUpdatedSettings);

    const { result } = renderHook(() => useSettingsStore());

    await act(async () => {
      await result.current.batchUpdate(updates);
    });

    expect(result.current.settings.visualisation?.rendering?.backgroundColour).toBe('#FFFFFF');
    expect(result.current.settings.system?.network?.port).toBe(8080);
    expect(settingsApi.setSettings).toHaveBeenCalledWith(updates);
  });
});
```

## Rollback Plan

### Emergency Rollback Procedure

If critical issues arise during migration:

1. **Feature Flag Rollback** (Immediate)
   ```typescript
   // Set environment variable to revert to legacy system
   REACT_APP_GRANULAR_SETTINGS=false
   ```

2. **API Endpoint Rollback** (5 minutes)
   ```rust
   // Temporarily disable granular endpoints in main.rs
   .service(
       web::scope("/api/settings")
           // .route("/get", web::get().to(get_settings_granular))  // Disabled
           // .route("/set", web::post().to(set_settings_granular)) // Disabled
           .route("", web::get().to(get_settings_legacy))          // Re-enabled
           .route("", web::post().to(update_settings_legacy))      // Re-enabled
   )
   ```

3. **Database Rollback** (If needed)
   ```bash
   # Restore from backup if settings format changed
   cp settings.yaml.backup settings.yaml
   systemctl restart visionflow-server
   ```

### Recovery Testing

Before migration, ensure rollback procedures are tested:

```bash
# Test rollback scenarios
cargo test --test rollback_scenarios
npm run test:rollback
```

## Performance Validation

### Expected Performance Improvements

| Metric | Legacy System | New System | Target Improvement |
|--------|---------------|------------|-------------------|
| Initial Load Time | 2-4 seconds | 0.5-1 seconds | 75% faster |
| Single Setting Update | 200-500ms | 50-100ms | 70% faster |
| Network Payload Size | 50-80KB | 0.1-5KB | 95% reduction |
| Memory Usage | High (full objects) | Low (partial objects) | 60% reduction |
| API Response Time | 100-300ms | 20-80ms | 75% faster |

### Performance Monitoring

```typescript
// Add performance tracking to API calls
const performanceMonitor = {
  trackApiCall: (endpoint: string, startTime: number, payloadSize: number) => {
    const duration = performance.now() - startTime;
    
    // Log to analytics service
    analytics.track('api_performance', {
      endpoint,
      duration,
      payloadSize,
      timestamp: new Date().toISOString()
    });
  }
};
```

## Support and Troubleshooting

### Common Migration Issues

#### Issue 1: Type Generation Fails
```bash
Error: specta failed to generate types
```
**Solution**: Ensure all structs have `#[derive(Type)]` and required dependencies are added.

#### Issue 2: Path Not Found Errors
```bash
Error: Setting path 'visualisation.rendering.backgroundColor' does not exist
```
**Solution**: Check path spelling and ensure the setting exists in the Rust struct.

#### Issue 3: Case Conversion Problems
```bash
Error: Field 'backgroundColour' not found
```
**Solution**: Verify `#[serde(rename_all = "camelCase")]` is applied to structs.

### Migration Validation Checklist

- [ ] All Rust structs have `#[derive(Type)]` annotations
- [ ] Build script generates TypeScript types successfully
- [ ] Granular API endpoints return expected data structure
- [ ] Frontend imports use generated types, not manual definitions
- [ ] Performance improvements meet target benchmarks
- [ ] All existing functionality works with new system
- [ ] Error handling covers granular API edge cases
- [ ] WebSocket integration still functions correctly

---

**Migration Guide Version**: 1.0  
**Last Updated**: 2025-09-01  
**Migration Support**: Settings Migration Team