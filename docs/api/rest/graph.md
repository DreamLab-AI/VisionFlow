# Graph API Reference

The Graph API provides endpoints for managing knowledge graph data, including retrieval, updates, and the Adaptive Balancing system.

## Base URL

```
http://localhost:3002/api/graph
```

## Endpoints

### Get Graph Data

Retrieves the complete graph structure including nodes, edges, and metadata.

```http
GET /api/graph/data
```

#### Response

```json
{
  "nodes": [
    {
      "id": 1,
      "label": "Node Name",
      "metadata_id": "file_123",
      "data": {
        "position": { "x": 10.5, "y": -20.3, "z": 5.1 },
        "velocity": { "x": 0.1, "y": 0.0, "z": -0.05 },
        "mass": 1,
        "flags": 0
      }
    }
  ],
  "edges": [
    {
      "id": "edge_1",
      "source": 1,
      "target": 2,
      "weight": 1.0
    }
  ],
  "metadata": {
    "file_123": {
      "name": "example.md",
      "path": "/notes/example.md",
      "size": 1024,
      "modified": "2024-01-15T10:30:00Z"
    }
  }
}
```

### Get Paginated Graph Data

Retrieves graph data with pagination support for large graphs.

```http
GET /api/graph/data/paginated?page=1&page_size=100&sort=id&filter=active
```

#### Query Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `page` | integer | 1 | Page number (1-indexed) |
| `page_size` | integer | 100 | Items per page |
| `sort` | string | "id" | Sort field |
| `filter` | string | none | Filter expression |

#### Response

```json
{
  "nodes": [...],
  "edges": [...],
  "metadata": {...},
  "total_pages": 5,
  "current_page": 1,
  "total_items": 487,
  "page_size": 100
}
```

### Update Graph

Triggers a graph update, fetching latest data from configured sources.

```http
POST /api/graph/update
```

#### Response

```json
{
  "success": true,
  "message": "Graph updated successfully",
  "nodes_added": 15,
  "edges_added": 23,
  "nodes_removed": 2
}
```

### Refresh Graph

Forces a complete graph rebuild from metadata.

```http
POST /api/graph/refresh
```

#### Response

```json
{
  "success": true,
  "message": "Graph refreshed",
  "total_nodes": 245,
  "total_edges": 412
}
```

## Adaptive Balancing API

### Get Auto-Balance Notifications

Retrieves notifications generated by the Adaptive Balancing system.

```http
GET /api/graph/auto-balance-notifications?since=1705312200000
```

#### Query Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `since` | integer | No | Unix timestamp (ms) to get notifications after |

#### Response

```json
{
  "success": true,
  "notifications": [
    {
      "message": "Adaptive Balancing: Stabilising bouncing nodes",
      "timestamp": 1705312245678,
      "severity": "warning"
    },
    {
      "message": "Adaptive Balancing: Stable configuration found!",
      "timestamp": 1705312267890,
      "severity": "success"
    }
  ]
}
```

#### Notification Severities

- `info` - Routine adjustments (blue toast)
- `warning` - Significant corrections (yellow toast)
- `success` - Stability achieved (green toast)

### Update Physics Settings

Updates physics parameters including Adaptive Balancing configuration.

```http
PUT /api/settings
Content-Type: application/json
```

#### Request Body

```json
{
  "visualisation": {
    "graphs": {
      "logseq": {
        "physics": {
          "autoBalance": true,
          "autoBalanceIntervalMs": 500,
          "damping": 0.95,
          "repelK": 100.0,
          "springK": 0.5,
          "maxVelocity": 2.0,
          "enableBounds": true,
          "boundsSize": 500.0
        }
      }
    }
  }
}
```

#### Response

```json
{
  "success": true,
  "message": "Settings updated successfully"
}
```

## WebSocket Binary Protocol

For real-time position updates, VisionFlow uses a binary WebSocket protocol.

### Connection

```javascript
const ws = new WebSocket('ws://localhost:3002/wss');
ws.binaryType = 'arraybuffer';
```

### Binary Message Format

Each node update is **28 bytes** using the `WireNodeDataItem` structure:

```
Offset | Size | Type    | Description
-------|------|---------|-------------
0      | 4    | u32     | Node ID (with type flags in high bits)
4      | 4    | f32     | Position X
8      | 4    | f32     | Position Y
12     | 4    | f32     | Position Z
16     | 4    | f32     | Velocity X
20     | 4    | f32     | Velocity Y
24     | 4    | f32     | Velocity Z
```

#### Node Type Flags

The Node ID field includes type flags in the high bits:

| Flag | Value | Description |
|------|-------|--------------|
| Agent Node | 0x80000000 | Bit 31 indicates agent node |
| Knowledge Node | 0x40000000 | Bit 30 indicates knowledge graph node |
| Actual ID Mask | 0x3FFFFFFF | Bits 0-29 contain the actual node ID |

### Message Types

```javascript
// Ping
{ "type": "ping", "timestamp": 1705312200000 }

// Enable randomisation
{ "type": "enableRandomization", "enabled": true }
```

## Error Responses

All endpoints return consistent error responses:

```json
{
  "success": false,
  "error": "Error message",
  "details": "Additional error context"
}
```

### HTTP Status Codes

| Code | Description |
|------|-------------|
| 200 | Success |
| 400 | Bad Request - Invalid parameters |
| 401 | Unauthorised - Authentication required |
| 404 | Not Found - Resource doesn't exist |
| 429 | Too Many Requests - Rate limit exceeded |
| 500 | Internal Server Error |

## Rate Limiting

- **Anonymous**: 100 requests per minute
- **Authenticated**: 1000 requests per minute
- **Auto-balance notifications**: No rate limit (polling expected)

## Examples

### JavaScript/TypeScript

```typescript
// Get graph data
const response = await fetch('/api/graph/data');
const graphData = await response.json();

// Poll for auto-balance notifications
async function pollNotifications() {
  let lastTimestamp = Date.now();
  
  setInterval(async () => {
    const response = await fetch(
      `/api/graph/auto-balance-notifications?since=${lastTimestamp}`
    );
    const data = await response.json();
    
    if (data.notifications?.length > 0) {
      data.notifications.forEach(notification => {
        console.log(`[${notification.severity}] ${notification.message}`);
        lastTimestamp = Math.max(lastTimestamp, notification.timestamp);
      });
    }
  }, 2000);
}
```

### Rust

```rust
use reqwest;
use serde_json::Value;

async fn get_graph_data() -> Result<Value, reqwest::Error> {
    let client = reqwest::Client::new();
    let response = client
        .get("http://localhost:3002/api/graph/data")
        .send()
        .await?;
    
    let data = response.json::<Value>().await?;
    Ok(data)
}
```

### Python

```python
import requests
import time

def poll_auto_balance_notifications():
    last_timestamp = int(time.time() * 1000)
    
    while True:
        response = requests.get(
            f'http://localhost:3002/api/graph/auto-balance-notifications',
            params={'since': last_timestamp}
        )
        
        data = response.json()
        if data.get('notifications'):
            for notification in data['notifications']:
                print(f"[{notification['severity']}] {notification['message']}")
                last_timestamp = max(last_timestamp, notification['timestamp'])
        
        time.sleep(2)
```

## Best Practices

1. **Polling Frequency**: For auto-balance notifications, poll every 2-5 seconds
2. **Pagination**: Use paginated endpoints for graphs with >1000 nodes
3. **Caching**: Cache graph data client-side and use update endpoints for changes
4. **Binary Protocol**: Use binary WebSocket for position updates (85% bandwidth saving)
5. **Error Handling**: Implement exponential backoff for failed requests

---

[← Back to API Documentation](index.md) | [WebSocket API →](../websocket/index.md)