# VisionFlow MCP Integration Documentation

*[Api](../index.md) > [Mcp](../api/mcp/index.md)*

## Overview

The Model Context Protocol (MCP) integration enables VisionFlow to communicate seamlessly with Claude-based AI agents, facilitating intelligent graph analysis, automated optimisation, and collaborative development workflows. This integration provides bidirectional communication between VisionFlow's visualisation engine and external AI systems.

## Architecture

### MCP Integration Flow
```mermaid
graph TB
    subgraph "VisionFlow System"
        VF[VisionFlow Core]
        WS[WebSocket Handler]
        MR[MCP Relay Manager]
        GA[Graph Analytics]
    end

    subgraph "MCP Layer"
        MP[MCP Protocol]
        MS[MCP Server]
        MC[MCP Client]
    end

    subgraph "AI Agents"
        CF[Claude Flow]
        CA[Custom Agents]
        AS[Agent Swarms]
    end

    VF < --> WS
    WS < --> MR
    MR < --> MP
    MP < --> MS
    MS < --> CF
    MS < --> CA
    CF < --> AS

    VF --> GA
    GA --> MR
```

### Core Components

#### 1. MCP Relay Manager
**Location**: `//src/services/mcp_relay_manager.rs`

Manages communication between VisionFlow and MCP servers:
- Protocol translation and message routing
- Connection pooling and health monitoring
- Authentication and session management
- Error handling and retry logic

#### 2. WebSocket MCP Bridge
**Location**: `//src/handlers/mcp_relay_handler.rs`

Provides real-time MCP communication:
- WebSocket endpoint for MCP message relay
- Bidirectional message streaming
- Event filtering and subscription management
- Performance monitoring and metrics

#### 3. Graph Analytics Service
**Location**: `//src/services/semantic_analyzer.rs`

Analyses graph data for AI consumption:
- Semantic relationship extraction
- Node clustering and community detection
- Temporal pattern analysis
- Performance bottleneck identification

## MCP Protocol Implementation

### Message Structure
```json
{
  "jsonrpc": "2.0",
  "id": "unique_request_id",
  "method": "visionflow/graph_analysis",
  "params": {
    "graphId": "logseq",
    "analysisType": "semantic_clustering",
    "options": {
      "includeMetrics": true,
      "timeRange": "24h",
      "minClusterSize": 5
    }
  }
}
```

### Supported MCP Methods

#### Graph Analysis Methods
- `visionflow/graph_analysis` - Comprehensive graph analysis
- `visionflow/node_similarity` - Calculate node similarity metrics
- `visionflow/community_detection` - Identify graph communities
- `visionflow/path_analysis` - Analyse connection paths
- `visionflow/anomaly_detection` - Detect unusual patterns

#### Visualisation Control Methods
- `visionflow/update_layout` - Modify graph layout
- `visionflow/apply_filters` - Apply graph filters
- `visionflow/highlight_nodes` - Highlight specific nodes
- `visionflow/animate_path` - Animate connection paths

#### Settings Management Methods
- `visionflow/get_settings` - Retrieve current settings
- `visionflow/update_settings` - Modify settings
- `visionflow/optimise_physics` - Auto-optimise physics parameters
- `visionflow/export_config` - Export configuration

#### System Integration Methods
- `visionflow/health_check` - System health status
- `visionflow/performance_metrics` - Get performance data
- `visionflow/trigger_analysis` - Start analysis workflows
- `visionflow/subscribe_updates` - Subscribe to real-time updates

## Graph Analysis Integration

### Semantic Analysis Request
```json
{
  "jsonrpc": "2.0",
  "method": "visionflow/graph_analysis",
  "params": {
    "graphId": "logseq",
    "analysisType": "semantic_clustering",
    "options": {
      "algorithm": "louvain",
      "resolution": 1.0,
      "includeMetrics": true,
      "exportFormat": "json"
    }
  },
  "id": "analysis_001"
}
```

### Analysis Response
```json
{
  "jsonrpc": "2.0",
  "id": "analysis_001",
  "result": {
    "analysisId": "semantic_analysis_20240115_143000",
    "graphId": "logseq",
    "timestamp": "2024-01-15T14:30:00.000Z",
    "clusters": [
      {
        "id": "cluster_1",
        "label": "Machine Learning Concepts",
        "nodeCount": 47,
        "centrality": 0.82,
        "nodes": ["neural_networks", "deep_learning", "transformers"],
        "keywords": ["ai", "ml", "training", "models"],
        "connections": {
          "internal": 156,
          "external": 23
        }
      },
      {
        "id": "cluster_2",
        "label": "Software Development",
        "nodeCount": 63,
        "centrality": 0.71,
        "nodes": ["react", "typescript", "webgl"],
        "keywords": ["code", "frontend", "javascript"],
        "connections": {
          "internal": 201,
          "external": 45
        }
      }
    ],
    "metrics": {
      "modularity": 0.73,
      "clustering_coefficient": 0.42,
      "average_path_length": 3.2,
      "network_density": 0.15
    },
    "insights": [
      {
        "type": "cluster_overlap",
        "description": "Strong connection between ML and Development clusters",
        "confidence": 0.89,
        "suggestions": ["Create bridge visualisation", "Highlight cross-cluster edges"]
      }
    ]
  }
}
```

### Real-Time Analysis Updates
```json
{
  "jsonrpc": "2.0",
  "method": "visionflow/analysis_update",
  "params": {
    "analysisId": "semantic_analysis_20240115_143000",
    "updateType": "incremental",
    "changes": {
      "new_nodes": ["quantum_computing"],
      "updated_clusters": ["cluster_1"],
      "metrics_delta": {
        "modularity": 0.02,
        "clustering_coefficient": -0.01
      }
    }
  }
}
```

## AI Agent Communication

### Agent Coordination Protocol
```json
{
  "jsonrpc": "2.0",
  "method": "visionflow/agent_coordination",
  "params": {
    "coordinationType": "collaborative_analysis",
    "agents": [
      {
        "id": "researcher_agent",
        "role": "research",
        "capabilities": ["semantic_analysis", "literature_review"],
        "priority": "high"
      },
      {
        "id": "optimiser_agent",
        "role": "optimisation",
        "capabilities": ["physics_tuning", "performance_analysis"],
        "priority": "medium"
      }
    ],
    "task": {
      "description": "Analyse knowledge graph structure and optimise layout",
      "deadline": "2024-01-15T18:00:00.000Z",
      "dependencies": ["graph_data_export", "settings_backup"]
    }
  }
}
```

### Agent Task Distribution
```json
{
  "jsonrpc": "2.0",
  "method": "visionflow/task_assignment",
  "params": {
    "taskId": "collaborative_analysis_001",
    "assignments": [
      {
        "agentId": "researcher_agent",
        "subtask": "semantic_clustering",
        "input": {
          "graphData": "graph_export_url",
          "analysisDepth": "comprehensive"
        },
        "expectedOutput": "cluster_definitions"
      },
      {
        "agentId": "optimiser_agent",
        "subtask": "physics_optimisation",
        "input": {
          "currentSettings": "settings_export_url",
          "targetMetrics": {
            "stability": 0.95,
            "convergence_time": 30
          }
        },
        "expectedOutput": "optimised_settings"
      }
    ]
  }
}
```

## Claude Flow Integration

### Swarm Initialisation
```json
{
  "jsonrpc": "2.0",
  "method": "claude_flow/swarm_init",
  "params": {
    "topology": "hierarchical",
    "maxAgents": 5,
    "specialisations": [
      "graph_analysis",
      "physics_optimisation",
      "user_experience",
      "performance_monitoring",
      "documentation"
    ],
    "visionflowContext": {
      "graphId": "logseq",
      "currentSettings": "/api/settings",
      "realtimeEndpoint": "ws://localhost:3001/ws"
    }
  }
}
```

### Agent Spawning with VisionFlow Context
```json
{
  "jsonrpc": "2.0",
  "method": "claude_flow/agent_spawn",
  "params": {
    "type": "visionflow_analyst",
    "capabilities": [
      "graph_interpretation",
      "layout_optimisation",
      "user_interaction_analysis"
    ],
    "context": {
      "visionflow_api": "http://localhost:3001/api",
      "websocket_endpoint": "ws://localhost:3001/ws",
      "graph_types": ["logseq", "visionflow"],
      "analysis_tools": [
        "semantic_clustering",
        "centrality_measures",
        "community_detection"
      ]
    },
    "permissions": [
      "read_graph_data",
      "analyse_patterns",
      "suggest_optimisations",
      "update_settings"
    ]
  }
}
```

### Task Orchestration
```json
{
  "jsonrpc": "2.0",
  "method": "claude_flow/task_orchestrate",
  "params": {
    "task": "optimise_visionflow_performance",
    "strategy": "adaptive",
    "priority": "high",
    "context": {
      "current_performance": {
        "fps": 45,
        "gpu_utilisation": 23,
        "memory_usage": "2.1GB"
      },
      "target_performance": {
        "fps": 60,
        "gpu_utilisation": 70,
        "memory_usage": "<3.0GB"
      },
      "constraints": {
        "visual_quality": "maintain",
        "user_settings": "preserve_preferences",
        "stability": "ensure_no_regression"
      }
    }
  }
}
```

## Real-Time Data Streaming

### WebSocket MCP Relay
VisionFlow provides a WebSocket endpoint specifically for MCP communication:

```javascript
const mcpWs = new WebSocket('ws://localhost:3001/ws/mcp');

mcpWs.onopen = () => {
  // Subscribe to graph analysis results
  mcpWs.send(JSON.stringify({
    jsonrpc: "2.0",
    method: "subscribe",
    params: {
      topics: ["graph_analysis", "physics_optimisation"],
      realtime: true
    }
  }));
};

mcpWs.onmessage = (event) => {
  const mcpMessage = JSON.parse(event.data);
  handleMCPResponse(mcpMessage);
};
```

### Streaming Analysis Results
```json
{
  "jsonrpc": "2.0",
  "method": "visionflow/stream_analysis",
  "params": {
    "streamId": "realtime_clustering_001",
    "analysisType": "incremental_clustering",
    "bufferSize": 100,
    "updateFrequency": "1s",
    "compression": true
  }
}
```

### Incremental Updates
```json
{
  "jsonrpc": "2.0",
  "method": "visionflow/incremental_update",
  "params": {
    "streamId": "realtime_clustering_001",
    "updateType": "cluster_merge",
    "data": {
      "mergedClusters": ["cluster_3", "cluster_7"],
      "newClusterId": "cluster_3_7_merged",
      "confidence": 0.78,
      "impact": {
        "modularityChange": 0.03,
        "affectedNodes": 23
      }
    },
    "timestamp": "2024-01-15T14:30:15.000Z"
  }
}
```

## Performance Optimisation Integration

### Automated Physics Tuning
```json
{
  "jsonrpc": "2.0",
  "method": "visionflow/auto_optimise",
  "params": {
    "optimisationType": "physics_parameters",
    "constraints": {
      "stability_threshold": 0.95,
      "max_iterations": 1000,
      "convergence_tolerance": 0.001
    },
    "metrics_to_optimise": [
      "simulation_stability",
      "convergence_speed",
      "visual_aesthetics",
      "user_interaction_responsiveness"
    ],
    "learning_from": {
      "user_preferences": true,
      "historical_data": true,
      "similar_graphs": true
    }
  }
}
```

### Optimisation Results
```json
{
  "jsonrpc": "2.0",
  "id": "optimisation_001",
  "result": {
    "optimisationId": "physics_auto_opt_20240115_143000",
    "status": "completed",
    "improvements": {
      "stability": {
        "before": 0.82,
        "after": 0.94,
        "improvement": 14.6
      },
      "convergence_time": {
        "before": 45.2,
        "after": 28.7,
        "improvement": 36.5
      },
      "user_satisfaction": {
        "predicted_score": 8.7,
        "confidence": 0.83
      }
    },
    "recommended_settings": {
      "physics": {
        "springStrength": 0.42,
        "repulsionStrength": 180,
        "dampingFactor": 0.88,
        "centralForce": 12
      }
    },
    "reasoning": [
      "Increased spring strength for better node cohesion",
      "Optimised repulsion for balanced spacing",
      "Enhanced damping for faster convergence"
    ]
  }
}
```

## Error Handling and Recovery

### MCP Error Responses
```json
{
  "jsonrpc": "2.0",
  "id": "request_id",
  "error": {
    "code": -32603,
    "message": "Internal error in graph analysis",
    "data": {
      "errorType": "analysis_failure",
      "component": "semantic_clustering",
      "details": "Insufficient graph data for clustering analysis",
      "suggestions": [
        "Ensure graph has at least 10 nodes",
        "Check graph connectivity",
        "Verify node metadata availability"
      ],
      "retryable": true,
      "retryAfter": 5000
    }
  }
}
```

### Error Recovery Strategies
```javascript
class MCPErrorHandler {
  async handleError(error) {
    switch (error.code) {
      case -32603: // Internal error
        if (error.data.retryable) {
          await this.scheduleRetry(error.data.retryAfter);
        } else {
          await this.fallbackToLocalAnalysis();
        }
        break;

      case -32602: // Invalid params
        await this.validateAndCorrectParams();
        break;

      case -32700: // Parse error
        await this.reconstructMessage();
        break;

      default:
        await this.handleUnknownError(error);
    }
  }

  async fallbackToLocalAnalysis() {
    // Use VisionFlow's built-in analysis capabilities
    const localResult = await this.runLocalGraphAnalysis();
    return this.formatAsLocalResponse(localResult);
  }
}
```

## Security and Authentication

### MCP Authentication
```json
{
  "jsonrpc": "2.0",
  "method": "visionflow/authenticate",
  "params": {
    "authType": "bearer_token",
    "credentials": {
      "token": "vf_token_12345abcdef",
      "refreshToken": "vf_refresh_67890ghijkl"
    },
    "permissions": [
      "read_graph_data",
      "analyse_patterns",
      "update_settings",
      "export_data"
    ],
    "sessionTimeout": 3600
  }
}
```

### Permission Validation
```rust
pub struct MCPPermissionValidator {
    allowed_methods: HashMap<String, Vec<Permission>>,
    user_permissions: HashMap<String, Vec<Permission>>,
}

impl MCPPermissionValidator {
    pub fn validate_request(&self, user_id: &str, method: &str) -> Result<(), PermissionError> {
        let required_perms = self.allowed_methods.get(method)
            .ok_or(PermissionError::UnknownMethod)?;

        let user_perms = self.user_permissions.get(user_id)
            .ok_or(PermissionError::UserNotFound)?;

        for required in required_perms {
            if !user_perms.contains(required) {
                return Err(PermissionError::InsufficientPermissions);
            }
        }

        Ok(())
    }
}
```

## Configuration

### MCP Server Configuration
```yaml
# //config.yml
mcp:
  enabled: true
  server:
    host: "0.0.0.0"
    port: 4001
    protocol: "jsonrpc"

  relay:
    websocket_endpoint: "/ws/mcp"
    max_connections: 100
    message_buffer_size: 1000
    timeout: 30000

  authentication:
    required: false  # Set to true in production
    token_expiry: 3600
    refresh_enabled: true

  analysis:
    cache_results: true
    cache_ttl: 300
    max_concurrent_analyses: 5

  integrations:
    claude_flow:
      enabled: true
      endpoint: "http://localhost:8080"
      timeout: 60000

    custom_agents:
      discovery_enabled: true
      auto_register: false
```

### Runtime Configuration
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MCPConfig {
    pub enabled: bool,
    pub server: MCPServerConfig,
    pub relay: MCPRelayConfig,
    pub authentication: MCPAuthConfig,
    pub analysis: MCPAnalysisConfig,
    pub integrations: MCPIntegrationsConfig,
}

impl MCPConfig {
    pub fn from_file(path: &str) -> Result<Self, ConfigError> {
        let contents = std::fs::read_to_string(path)?;
        let config: MCPConfig = serde_yaml::from_str(&contents)?;
        config.validate()?;
        Ok(config)
    }

    pub fn validate(&self) -> Result<(), ConfigError> {
        if self.server.port < 1024 || self.server.port > 65535 {
            return Err(ConfigError::InvalidPort);
        }

        if self.relay.max_connections > 10000 {
            return Err(ConfigError::ExcessiveConnections);
        }

        Ok(())
    }
}
```

## Monitoring and Diagnostics

### MCP Health Monitoring
```json
{
  "jsonrpc": "2.0",
  "method": "visionflow/health_check",
  "params": {
    "components": ["mcp_relay", "graph_analysis", "websocket_bridge"],
    "include_metrics": true
  },
  "id": "health_001"
}
```

### Health Response
```json
{
  "jsonrpc": "2.0",
  "id": "health_001",
  "result": {
    "status": "healthy",
    "timestamp": "2024-01-15T14:30:00.000Z",
    "components": {
      "mcp_relay": {
        "status": "healthy",
        "uptime": 3600000,
        "active_connections": 5,
        "messages_processed": 1247,
        "error_rate": 0.002
      },
      "graph_analysis": {
        "status": "healthy",
        "active_analyses": 2,
        "queue_size": 0,
        "average_response_time": 145,
        "cache_hit_rate": 0.78
      },
      "websocket_bridge": {
        "status": "healthy",
        "connections": 12,
        "bandwidth_utilisation": 0.34,
        "latency_p95": 25
      }
    },
    "performance_metrics": {
      "cpu_usage": 15.7,
      "memory_usage": 2.1,
      "network_io": {
        "bytes_in": 1048576,
        "bytes_out": 2097152
      }
    }
  }
}
```

### Debug and Profiling
```json
{
  "jsonrpc": "2.0",
  "method": "visionflow/debug_info",
  "params": {
    "level": "verbose",
    "components": ["message_routing", "analysis_pipeline"],
    "include_stack_traces": true,
    "time_range": "1h"
  }
}
```

## Best Practices

### 1. Message Design
```javascript
// Good: Specific, actionable methods
{
  "method": "visionflow/optimise_physics",
  "params": { "graphId": "logseq", "targetFps": 60 }
}

// Avoid: Generic, ambiguous methods
{
  "method": "visionflow/do_something",
  "params": { "type": "optimisation" }
}
```

### 2. Error Handling
```javascript
// Implement comprehensive error handling
async function callMCPMethod(method, params) {
  try {
    const response = await mcpClient.call(method, params);
    return response.result;
  } catch (error) {
    if (error.code === -32603 && error.data.retryable) {
      // Retry with exponential backoff
      await delay(error.data.retryAfter);
      return callMCPMethod(method, params);
    }
    throw new MCPError(error);
  }
}
```

### 3. Performance Optimisation
```javascript
// Batch requests when possible
const batchRequest = {
  "jsonrpc": "2.0",
  "id": "batch_001",
  "method": "batch",
  "params": [
    { "method": "visionflow/get_metrics", "params": {} },
    { "method": "visionflow/get_settings", "params": {} },
    { "method": "visionflow/health_check", "params": {} }
  ]
};
```

### 4. Resource Management
```rust
// Implement proper cleanup
impl Drop for MCPRelayManager {
    fn drop(&mut self) {
        self.shutdown_connections();
        self.cleanup_resources();
    }
}
```

## Testing and Validation

### MCP Integration Tests
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_graph_analysis_request() {
        let mut mcp_relay = MCPRelayManager::new();

        let request = json!({
            "jsonrpc": "2.0",
            "method": "visionflow/graph_analysis",
            "params": {
                "graphId": "test_graph",
                "analysisType": "semantic_clustering"
            },
            "id": "test_001"
        });

        let response = mcp_relay.process_request(request).await.unwrap();

        assert_eq!(response["jsonrpc"], "2.0");
        assert_eq!(response["id"], "test_001");
        assert!(response["result"]["clusters"].is_array());
    }

    #[tokio::test]
    async fn test_settings_update_via_mcp() {
        let mut mcp_relay = MCPRelayManager::new();

        let request = json!({
            "jsonrpc": "2.0",
            "method": "visionflow/update_settings",
            "params": {
                "physics": {
                    "springStrength": 0.7
                }
            },
            "id": "settings_001"
        });

        let response = mcp_relay.process_request(request).await.unwrap();

        assert_eq!(response["result"]["success"], true);

        // Verify settings were actually updated
        let settings = get_current_settings().await;
        assert_eq!(settings.physics.spring_strength, 0.7);
    }
}
```

### End-to-End Testing
```bash
#!/bin/bash
# Test MCP integration end-to-end

# Start VisionFlow with MCP enabled
cargo run --release &
VISIONFLOW_PID=$!

# Wait for startup
sleep 5

# Test basic MCP connectivity
curl -X POST http://localhost:4001 \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "visionflow/health_check",
    "id": "test_001"
  }'

# Test graph analysis
curl -X POST http://localhost:4001 \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "visionflow/graph_analysis",
    "params": {
      "graphId": "logseq",
      "analysisType": "semantic_clustering"
    },
    "id": "test_002"
  }'

# Cleanup
kill $VISIONFLOW_PID
```

## Related Documentation

- [REST API Overview](../rest/index.md)
- [WebSocket Integration](../websocket/index.md)
- [Claude Flow Documentation](https://github.com/ruvnet/claude-flow)
- [Graph Analytics Service](../../server/services.md)
- [Agent Orchestration](../../architecture/managing-claude-flow.md)

## See Also

- [Request Handlers Architecture](../../server/handlers.md) - Server implementation
- [Server Documentation](../../server/index.md) - Server implementation
