# VisionFlow System Architecture Overview

*[Architecture](../index.md)*

## Executive Summary

VisionFlow is a production-ready, GPU-accelerated 3D knowledge graph visualisation platform that combines a unified CUDA compute kernel with an actor-based Rust backend and modern React/TypeScript frontend. The system enables real-time visualisation of parallel knowledge graphs and AI Multi Agents, supporting 100,000+ nodes at 60 FPS with bidirectional synchronisation across all connected clients.

## Core Architecture Principles

### 1. Unified GPU Acceleration
- **Single CUDA Kernel**: `visionflow_unified.cu` handles all physics computation modes
- **Structure of Arrays (SoA)**: Optimal GPU memory layout for maximum performance
- **Four Compute Modes**: Basic, Dual Graph, Constraints, and Visual Analytics
- **Graceful CPU Fallback**: Automatic fallback when GPU unavailable

### 2. Actor-Based Concurrency
- **Message-Passing**: Fault-tolerant communication between system components
- **Supervision Tree**: Automatic actor restart on failure with exponential backoff
- **State Encapsulation**: No shared mutable state between actors
- **Performance**: Handles 100K+ nodes with sub-millisecond message processing

### 3. Real-Time Streaming
- **Binary Protocol**: Efficient WebSocket communication for position updates
- **Differential Updates**: Only changed positions transmitted to clients
- **60 FPS Physics**: Continuous simulation independent of client connections
- **Bidirectional Sync**: Real-time state synchronisation across all clients

### 4. Dual Graph Processing
- **Knowledge Graph**: Markdown files, metadata, and semantic relationships
- **Agent Graph**: Real-time AI Multi Agent telemetry from Claude Flow MCP
- **Parallel Physics**: Independent simulation parameters per graph type
- **Unified Visualisation**: Seamless integration in single 3D viewport

## High-Level System Diagram

```mermaid
graph TB
    subgraph "Frontend Layer"
        subgraph "React Application"
            UI[UI Components]
            Store[State Management]
            Three[Three.js Renderer]
            XR[WebXR Manager]
        end

        subgraph "WebSocket Clients"
            WSFlow[Socket Flow Client]
            WSSpeech[Speech Client]
            WSMCP[MCP Relay Client]
            WSBots[Bots Viz Client]
        end
    end

    subgraph "Backend Layer"
        subgraph "HTTP Server"
            REST[REST API<br/>Actix-Web]
            Static[Static Files]
            Auth[Auth Handler]
        end

        subgraph "WebSocket Server"
            WSHandler[WS Handler]
            Binary[Binary Protocol]
            Stream[Stream Manager]
        end

        subgraph "Actor System"
            CFActor[EnhancedClaudeFlowActor<br/>Direct WebSocket MCP]
            GraphActor[Graph Service Actor<br/>Parallel Graphs]
            GPUActor[GPU Compute Actor<br/>Unified Kernel]
            ClientMgr[Client Manager Actor]
            SettingsActor[Settings Actor]
            MetaActor[Metadata Actor]
            ProtectedActor[Protected Settings]
        end

        subgraph "Services Layer"
            MCPRelay[MCP Relay Manager]
            GitHubSvc[GitHub Service]
            NostrSvc[Nostr Service]
            SpeechSvc[Speech Service]
            BotsClient[Bots Client]
            AgentViz[Agent Viz Processor]
        end
    end

    subgraph "GPU Layer"
        UnifiedKernel[Unified CUDA Kernel<br/>visionflow_unified.cu]
        Physics[Unified Physics Engine]
        ParallelGraphs[Parallel Graph Processing]
        Analytics[Visual Analytics Mode]
    end

    subgraph "External Services"
        ClaudeFlow[Claude Flow<br/>Port 9500 TCP]
        GitHub[GitHub API]
        RAGFlow[RAGFlow Service]
        Perplexity[Perplexity API]
        Nostr[Nostr Network]
    end

    UI --> Store
    Store --> Three
    Three --> XR
    UI --> WSFlow
    UI --> WSSpeech
    UI --> WSMCP
    UI --> WSBots

    WSFlow --> WSHandler
    WSSpeech --> WSHandler
    WSMCP --> WSHandler
    WSBots --> WSHandler

    WSHandler --> Binary
    Binary --> Stream
    Stream --> ClientMgr

    REST --> Auth
    Auth --> NostrSvc
    REST --> GraphActor
    REST --> SettingsActor
    REST --> BotsClient

    ClientMgr --> GraphActor
    GraphActor --> GPUActor
    GPUActor --> UnifiedKernel
    UnifiedKernel --> Physics
    UnifiedKernel --> ParallelGraphs
    UnifiedKernel --> Analytics

    CFActor --> MCPRelay
    MCPRelay --> ClaudeFlow
    GraphActor --> GitHubSvc
    GitHubSvc --> GitHub
    NostrSvc --> Nostr

    BotsClient --> AgentViz
    AgentViz --> GraphActor
```

## Technology Stack

### Backend Technologies
- **Language**: Rust 1.75+
- **Web Framework**: Actix-Web 4.4
- **Actor System**: Actix Actors
- **Async Runtime**: Tokio
- **GPU**: CUDA 11.8+ / PTX Kernels
- **Serialization**: Serde, Bincode
- **WebSocket**: Actix-WS, Tokio-Tungstenite
- **MCP Integration**: Direct TCP Connection

### Frontend Technologies
- **Framework**: React 18
- **Language**: TypeScript 5
- **3D Graphics**: Three.js, React Three Fibre
- **XR**: @react-three/xr
- **State Management**: Zustand
- **Build Tool**: Vite
- **Styling**: Tailwind CSS

### Infrastructure
- **Containerisation**: Docker with Multi-stage builds
- **Proxy**: NGINX with load balancing
- **Process Manager**: Supervisord
- **Logging**: Structured JSON logging
- **Monitoring**: Built-in metrics collection

## Performance Characteristics

### System Performance Metrics
| Component | Target | Actual | Notes |
|-----------|--------|--------|-------|
| REST API Latency | <100ms | 50ms | Average response time |
| WebSocket Latency | <10ms | 5ms | Binary protocol efficiency |
| Unified GPU Kernel | <16ms | 8ms | Physics computation |
| Parallel Graphs FPS | 60 FPS | 60 FPS | Consistent frame rate |
| Memory Usage | <4GB | 2.2GB | Total system memory |
| Agent Update Rate | 10Hz | 10Hz | Claude Flow telemetry |
| Max Concurrent Users | 1000+ | Tested | WebSocket connections |
| Max Graph Nodes | 100K+ | Validated | GPU memory limited |

### GPU Utilisation
- **Before Optimisation**: <30% of GPU features exposed
- **After Integration**: 100% of GPU capabilities available
- **Performance Improvement**: 2-4x faster convergence
- **Quality Enhancement**: Professional-grade layouts with stress majorisation

## Key Features

### 1. GPU-Accelerated Physics
- **Four Compute Modes**:
  - Mode 0: Basic force-directed layout
  - Mode 1: Dual graph forces (Knowledge + Agent)
  - Mode 2: Constraint-enhanced physics
  - Mode 3: Visual analytics with clustering

- **Advanced Algorithms**:
  - Stress majorisation for optimal layouts
  - Progressive warmup system (200 iterations)
  - Adaptive natural length calculation
  - Boundary handling with progressive damping

### 2. Multi-Agent Integration
- **Direct MCP Connection**: Real-time TCP connection to Claude Flow (port 9500)
- **Agent Orchestration**: Spawn and manage 50+ agent types
- **Topology Support**: Mesh, hierarchical, ring, and star configurations
- **Performance Metrics**: Real-time agent telemetry and task tracking

### 3. Clustering & Analytics
- **Three Clustering Algorithms**:
  - K-means clustering
  - Spectral clustering
  - Louvain community detection

- **Visual Analytics**:
  - Node importance weighting
  - Temporal coherence tracking
  - Cluster-aware force scaling
  - Pattern recognition

### 4. Constraint System
- **Four Constraint Types**:
  - Separation constraints (minimum distance)
  - Boundary constraints (viewport limits)
  - Alignment constraints (axis alignment)
  - Cluster constraints (group cohesion)

## Data Flow Architecture

```mermaid
graph TB
    subgraph "Data Sources"
        MD[Markdown Files]
        JSON[JSON Metadata]
        API[External APIs]
        Agents[AI Agents]
    end

    subgraph "Processing Pipeline"
        Parser[Data Parser]
        Semantic[Semantic Analyser]
        Edge[Edge Generator]
        Layout[Layout Engine]
    end

    subgraph "Storage"
        GraphState[Graph State]
        MetaCache[Metadata Cache]
        Settings[Settings Store]
    end

    subgraph "Distribution"
        Binary[Binary Protocol]
        Diff[Differential Updates]
        Stream[Stream Manager]
    end

    MD --> Parser
    JSON --> Parser
    API --> Parser
    Agents --> Parser

    Parser --> Semantic
    Semantic --> Edge
    Edge --> Layout
    Layout --> GraphState

    GraphState --> MetaCache
    GraphState --> Binary
    Binary --> Diff
    Diff --> Stream
    Stream --> Clients[Connected Clients]
```

## Security Architecture

### Authentication Layer
- **Nostr Integration**: Decentralised authentication using NIP-07
- **Event Signing**: Cryptographic verification of user actions
- **Session Management**: Secure token-based sessions

### Authorisation
- **Role-Based Access Control (RBAC)**: Fine-grained permission system
- **Feature Flags**: Dynamic feature enablement per user
- **Protected Settings**: Secure API key and credential management

### Network Security
- **TLS/SSL**: Encrypted communication channels
- **CORS Policy**: Cross-origin request protection
- **Content Security Policy**: XSS and injection prevention

### Data Security
- **Input Validation**: Server-side parameter validation
- **Data Sanitisation**: XSS and SQL injection prevention
- **At-Rest Encryption**: Secure storage of sensitive data

## Deployment Architecture

```mermaid
graph TB
    subgraph "Docker Containers"
        subgraph "Main Container"
            Nginx[NGINX<br/>Port 80/443]
            Rust[Rust Backend<br/>Port 3001]
            Vite[Vite Dev<br/>Port 5173]
        end

        subgraph "Services Container"
            Claude[Claude Flow<br/>Port 9500 TCP]
            RAG[RAGFlow<br/>Port 80]
        end
    end

    subgraph "Host System"
        GPU[NVIDIA GPU]
        CUDA_Host[CUDA Driver]
        Docker[Docker Engine]
    end

    subgraph "Volumes"
        Data[Data Volume]
        Logs[Logs Volume]
        Config[Config Volume]
    end

    Internet[Internet] --> Nginx
    Nginx --> Rust
    Nginx --> Vite
    Rust --> Claude
    Rust --> RAG

    Rust --> GPU
    GPU --> CUDA_Host

    Rust --> Data
    Rust --> Logs
    Rust --> Config
```

## Key Design Decisions

1. **Actor Model**: Provides fault tolerance and concurrent state management
2. **Binary Protocol**: Minimises bandwidth for real-time updates
3. **Unified GPU Kernel**: Single CUDA kernel handles all physics modes
4. **Parallel Graphs**: Independent Logseq and Agent graph processing
5. **WebXR Integration**: Future-proofs for AR/VR interfaces
6. **Direct MCP Integration**: Backend-only WebSocket connection to Claude Flow
7. **Differential Updates**: Optimises network traffic
8. **Structure of Arrays**: GPU memory layout for maximum performance
9. **Modular Architecture**: Allows independent component scaling
10. **Continuous Physics**: Pre-computed node positions independent of client connections
11. **Bidirectional Synchronisation**: Real-time state sync across all connected clients

## Scalability Features

### Horizontal Scaling
- **Stateless Backend**: All state managed through actors and external services
- **Load Balancing**: NGINX reverse proxy with upstream distribution
- **Connection Pooling**: Efficient database and service connections

### Vertical Scaling
- **GPU Acceleration**: Leverages CUDA for compute-intensive physics
- **Memory Optimisation**: Structure of Arrays for cache efficiency
- **Actor Supervision**: Automatic recovery and resource management

### Performance Optimisation
- **Caching Strategy**: Multi-layer caching (metadata, settings, GPU buffers)
- **Message Batching**: Bundled updates for reduced overhead
- **Dead Letter Handling**: Failed message recovery and debugging

## Future Roadmap

### Short Term (Q1 2025)
- Enhanced constraint system with visual feedback
- Advanced clustering algorithms (DBSCAN, Leiden)
- Performance tuning and benchmarking suite

### Medium Term (Q2-Q3 2025)
- Multi-tenant architecture with user isolation
- Advanced analytics dashboard with real-time metrics
- Mobile AR interface using WebXR

### Long Term (Q4 2025+)
- Distributed GPU compute across multiple nodes
- Machine learning integration for layout optimisation
- Collaborative editing with conflict resolution

## Related Documentation

- [Components Architecture](components.md) - Detailed component breakdown
- [Data Flow Architecture](data-flow.md) - Complete data pipeline documentation
- [GPU Compute Integration](gpu-compute.md) - CUDA kernel implementation
- [API Documentation](../api/index.md) - REST and WebSocket APIs
- [Deployment Guide](../deployment/index.md) - Production deployment instructions

---

*Last updated: January 2025*  
*Version: 2.0.0*  
*Status: Production Ready*
## Documents

- [Case Conversion Architecture](./case-conversion.md)
- [Architecture Documentation](./README.md)
- [Bots/VisionFlow System Architecture](./bots-visionflow-system.md)
- [Bots Visualisation Architecture](./bots-visualization.md)
- [ClaudeFlowActor Architecture](./claude-flow-actor.md)
- [VisionFlow Component Architecture](./components.md)
- [Dynamic Agent Architecture (DAA) Setup Guide](./daa-setup-guide.md)
- [VisionFlow Data Flow Architecture](./data-flow.md)
- [GPU Compute Improvements & Troubleshooting Guide](./gpu-compute-improvements.md)
- [VisionFlow GPU Compute Integration](./gpu-compute.md)
- [Managing the Claude-Flow System](./managing-claude-flow.md)
- [MCP Integration Architecture](./mcp-integration.md)
- [MCP WebSocket Relay Architecture](./mcp-websocket-relay.md)
- [MCP Connection Architecture](./mcp-connection.md)
- [Architecture Migration Guide](./migration-guide.md)
- [Parallel Graph Architecture](./parallel-graphs.md)
- [VisionFlow System Architecture](./system-overview.md)
- [VisionFlow GPU Migration Architecture](./visionflow-gpu-migration.md)


## See Also

- [Configuration Architecture](../server/config.md)
- [Feature Access Control](../server/feature-access.md)
- [GPU Compute Architecture](../server/gpu-compute.md)
