// src/ontology/actors/ontology_actor.rs

//! The OntologyActor manages asynchronous validation and reasoning tasks.

use actix::prelude::*;
use crate::ontology::services::owl_validator::OwlValidatorService;
use crate::services::owl_validator::{ValidationReport, PropertyGraph};
use crate::actors::messages::{
    ProcessOntologyData, ValidateGraph, GetValidationReport, GetOntologyHealth, ValidationMode
};
use crate::ontology::parser::parser::LogseqPage;
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use uuid::Uuid;

/// The main actor for ontology processing.
pub struct OntologyActor {
    validator: OwlValidatorService,
    active_jobs: HashMap<String, ValidationJobState>,
    cached_reports: HashMap<String, ValidationReport>,
    ontology_pages: Vec<LogseqPage>,
    loaded_ontology_id: Option<String>,
}

/// State of a validation job
#[derive(Debug, Clone)]
struct ValidationJobState {
    job_id: String,
    status: JobStatus,
    started_at: DateTime<Utc>,
    completed_at: Option<DateTime<Utc>>,
    error_message: Option<String>,
}

#[derive(Debug, Clone, PartialEq)]
enum JobStatus {
    Pending,
    Running,
    Completed,
    Failed,
}

impl OntologyActor {
    /// Creates a new OntologyActor.
    pub fn new() -> Result<Self, String> {
        let validator = OwlValidatorService::new();

        Ok(Self {
            validator,
            active_jobs: HashMap::new(),
            cached_reports: HashMap::new(),
            ontology_pages: Vec::new(),
            loaded_ontology_id: None,
        })
    }

    /// Process loaded ontology data
    fn process_ontology_pages(&mut self, pages: Vec<LogseqPage>) {
        self.ontology_pages = pages;
        log::info!("Processed {} ontology pages", self.ontology_pages.len());
    }

    /// Get health status of the ontology system
    fn get_health(&self) -> String {
        let active_jobs_count = self.active_jobs.values()
            .filter(|job| job.status == JobStatus::Running)
            .count();

        serde_json::json!({
            "loaded_ontologies": if self.loaded_ontology_id.is_some() { 1 } else { 0 },
            "cached_reports": self.cached_reports.len(),
            "validation_queue_size": active_jobs_count,
            "last_validation": self.cached_reports.values()
                .max_by_key(|r| r.timestamp)
                .map(|r| r.timestamp.to_rfc3339()),
            "active_jobs": active_jobs_count,
            "total_ontology_pages": self.ontology_pages.len(),
        }).to_string()
    }
}

/// Implement the Actor trait for OntologyActor.
impl Actor for OntologyActor {
    type Context = Context<Self>;

    fn started(&mut self, _ctx: &mut Self::Context) {
        log::info!("OntologyActor has started.");
    }
}

/// Handler for ProcessOntologyData message
impl Handler<ProcessOntologyData> for OntologyActor {
    type Result = Result<(), String>;

    fn handle(&mut self, msg: ProcessOntologyData, _ctx: &mut Self::Context) -> Self::Result {
        log::info!("Processing ontology data with {} pages", msg.pages.len());
        self.process_ontology_pages(msg.pages);
        Ok(())
    }
}

/// Handler for ValidateGraph message
impl Handler<ValidateGraph> for OntologyActor {
    type Result = ResponseFuture<Result<String, String>>;

    fn handle(&mut self, msg: ValidateGraph, _ctx: &mut Self::Context) -> Self::Result {
        let job_id = Uuid::new_v4().to_string();

        // Create job state
        let job_state = ValidationJobState {
            job_id: job_id.clone(),
            status: JobStatus::Running,
            started_at: Utc::now(),
            completed_at: None,
            error_message: None,
        };

        self.active_jobs.insert(job_id.clone(), job_state);

        // Create a placeholder graph for now
        // In a real implementation, this would come from the graph service
        let graph_data = PropertyGraph {
            nodes: Vec::new(),
            edges: Vec::new(),
            metadata: HashMap::new(),
        };

        let validator = self.validator.clone();
        let ontology_id = self.loaded_ontology_id.clone();
        let job_id_clone = job_id.clone();

        Box::pin(async move {
            match &ontology_id {
                Some(ont_id) => {
                    match validator.validate(ont_id, &graph_data).await {
                        Ok(report) => {
                            log::info!("Validation job {} completed successfully", job_id_clone);
                            Ok(report.id)
                        },
                        Err(e) => {
                            log::error!("Validation job {} failed: {}", job_id_clone, e);
                            Err(format!("Validation failed: {}", e))
                        }
                    }
                },
                None => {
                    log::warn!("No ontology loaded for validation job {}", job_id_clone);
                    Err("No ontology loaded".to_string())
                }
            }
        })
    }
}

/// Handler for GetValidationReport message
impl Handler<GetValidationReport> for OntologyActor {
    type Result = Result<Option<String>, String>;

    fn handle(&mut self, msg: GetValidationReport, _ctx: &mut Self::Context) -> Self::Result {
        match msg.report_id {
            Some(report_id) => {
                // Get specific report
                if let Some(report) = self.cached_reports.get(&report_id) {
                    match serde_json::to_string_pretty(report) {
                        Ok(json) => Ok(Some(json)),
                        Err(e) => Err(format!("Failed to serialize report: {}", e))
                    }
                } else {
                    Ok(None)
                }
            },
            None => {
                // Get latest report
                if let Some(latest) = self.cached_reports.values()
                    .max_by_key(|r| r.timestamp) {
                    match serde_json::to_string_pretty(latest) {
                        Ok(json) => Ok(Some(json)),
                        Err(e) => Err(format!("Failed to serialize report: {}", e))
                    }
                } else {
                    Ok(None)
                }
            }
        }
    }
}

/// Handler for GetOntologyHealth message
impl Handler<GetOntologyHealth> for OntologyActor {
    type Result = Result<crate::actors::messages::OntologyHealth, String>;

    fn handle(&mut self, _msg: GetOntologyHealth, _ctx: &mut Self::Context) -> Self::Result {
        let active_jobs_count = self.active_jobs.values()
            .filter(|job| job.status == JobStatus::Running)
            .count();

        Ok(crate::actors::messages::OntologyHealth {
            loaded_ontologies: if self.loaded_ontology_id.is_some() { 1 } else { 0 },
            cached_reports: self.cached_reports.len() as u32,
            validation_queue_size: active_jobs_count as u32,
            last_validation: self.cached_reports.values()
                .max_by_key(|r| r.timestamp)
                .map(|r| r.timestamp),
            cache_hit_rate: 0.0, // TODO: Implement cache hit rate tracking
            avg_validation_time_ms: 0.0, // TODO: Implement average validation time tracking
            active_jobs: active_jobs_count as u32,
            memory_usage_mb: 0.0, // TODO: Implement memory usage tracking
        })
    }
}
