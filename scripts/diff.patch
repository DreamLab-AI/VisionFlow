diff --git a/client/index.html b/client/index.html
index e441f70c..9e7371f0 100644
--- a/client/index.html
+++ b/client/index.html
@@ -128,10 +128,6 @@
     <div class="control-panel-content">
       <!-- Settings sections will be dynamically populated by ControlPanel.ts -->
     </div>
-    <div class="settings-actions">
-      <button id="reset-settings">Reset</button>
-      <button id="save-settings">Save</button>
-    </div>
   </div>
   <script type="module" src="/index.ts"></script>
 </body>
diff --git a/client/index.ts b/client/index.ts
index 6c2c6ac8..5e8ea08e 100644
--- a/client/index.ts
+++ b/client/index.ts
@@ -7,6 +7,7 @@ import { WebSocketService } from './websocket/websocketService';
 import { SettingsStore } from './state/SettingsStore';
 import { LoggerConfig, createLogger } from './core/logger';
 import { SceneManager } from './rendering/scene';
+import './ui'; // Import UI initialization
 
 const logger = createLogger('GraphVisualization');
 
@@ -49,9 +50,11 @@ export class GraphVisualization {
     constructor(settings: Settings) {
         logger.debug('Initializing GraphVisualization');
         
-        // Create canvas element
-        const canvas = document.createElement('canvas');
-        document.body.appendChild(canvas);
+        // Get existing canvas element
+        const canvas = document.getElementById('main-canvas') as HTMLCanvasElement;
+        if (!canvas) {
+            throw new Error('Could not find #main-canvas element');
+        }
         
         // Initialize SceneManager
         this.sceneManager = SceneManager.getInstance(canvas);
diff --git a/client/platform/platformManager.ts b/client/platform/platformManager.ts
index af79a9ec..81a00080 100644
--- a/client/platform/platformManager.ts
+++ b/client/platform/platformManager.ts
@@ -158,17 +158,30 @@ export class PlatformManager extends BrowserEventEmitter {
     return this.capabilities.websocketSupported;
   }
 
-  async requestXRSession(): Promise<XRSession | null> {
+  async requestXRSession(mode: XRSessionMode = 'immersive-ar'): Promise<XRSession | null> {
     if (!this.capabilities.xrSupported || !('xr' in navigator) || !navigator.xr) {
       logger.warn('WebXR not supported');
       return null;
     }
 
     try {
-      const session = await navigator.xr.requestSession('immersive-ar', {
-        requiredFeatures: ['local-floor', 'hit-test'],
-        optionalFeatures: ['hand-tracking', 'plane-detection']
-      });
+      const requiredFeatures: string[] = ['local-floor'];
+      const optionalFeatures: string[] = ['hand-tracking'];
+
+      // Add mode-specific features
+      if (mode === 'immersive-ar') {
+        requiredFeatures.push('hit-test');
+        optionalFeatures.push('plane-detection');
+      } else if (mode === 'immersive-vr') {
+        optionalFeatures.push('bounded-floor');
+      }
+
+      const features: XRSessionInit = {
+        requiredFeatures,
+        optionalFeatures
+      };
+
+      const session = await navigator.xr.requestSession(mode, features);
 
       // Update capabilities based on session features
       session.addEventListener('end', () => {
@@ -176,7 +189,7 @@ export class PlatformManager extends BrowserEventEmitter {
         this.emit('xrsessionend');
       });
 
-      logger.log('XR session started');
+      logger.log(`XR session started in ${mode} mode`);
       return session;
     } catch (error) {
       logger.error('Failed to start XR session:', error);
@@ -191,7 +204,8 @@ export class PlatformManager extends BrowserEventEmitter {
         if (supported) {
           this.capabilities.webxr = true;
           this.capabilities.handTracking = true;
-          this.capabilities.planeDetection = true;
+          // Only set plane detection for AR mode
+          this.capabilities.planeDetection = mode === 'immersive-ar';
           this.emit('xrdevicechange', true);
           logger.log('WebXR supported for mode:', mode);
           return true;
diff --git a/client/visualization/VisualizationController.ts b/client/rendering/VisualizationController.ts
similarity index 73%
rename from client/visualization/VisualizationController.ts
rename to client/rendering/VisualizationController.ts
index 92eb54b0..e0fee65c 100644
--- a/client/visualization/VisualizationController.ts
+++ b/client/rendering/VisualizationController.ts
@@ -1,8 +1,9 @@
 import * as THREE from 'three';
-import { MetadataVisualizer } from './MetadataVisualizer';
-import { HologramManager } from './HologramManager';
+import { MetadataVisualizer } from '../rendering/MetadataVisualizer';
+import { HologramManager } from '../rendering/HologramManager';
 import { NodeMetadata, HologramSettings } from '../types/metadata';
 import { XRHand } from '../types/xr';
+import { Settings } from '../types/settings';
 
 export class VisualizationController {
     private readonly scene: THREE.Scene;
@@ -13,7 +14,8 @@ export class VisualizationController {
     private clock: THREE.Clock;
     private isXRSession: boolean = false;
 
-    constructor(container: HTMLElement, settings: any) {
+    constructor(container: HTMLElement, settings: Settings) {
+        this.currentSettings = settings;
         // Initialize Three.js basics
         this.scene = new THREE.Scene();
         this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
@@ -28,8 +30,8 @@ export class VisualizationController {
         container.appendChild(this.renderer.domElement);
 
         // Initialize managers
-        this.metadataVisualizer = new MetadataVisualizer(this.scene, this.camera, settings);
-        this.hologramManager = new HologramManager(this.scene, settings.hologram);
+        this.metadataVisualizer = new MetadataVisualizer(this.camera, this.scene, settings);
+        this.hologramManager = new HologramManager(this.scene, this.renderer, settings);
         this.clock = new THREE.Clock();
 
         // Set up XR session change handling
@@ -61,7 +63,7 @@ export class VisualizationController {
 
         // Create new nodes
         nodes.forEach(metadata => {
-            const nodeMesh = this.metadataVisualizer.createNodeVisual(metadata);
+            const nodeMesh = this.metadataVisualizer.createNodeMesh(metadata);
             nodeMesh.userData.isNode = true;
             nodeMesh.position.set(
                 metadata.position.x,
@@ -72,13 +74,28 @@ export class VisualizationController {
         });
     }
 
-    public updateHologramSettings(settings: Partial<HologramSettings>): void {
-        this.hologramManager.updateSettings(settings);
+    private currentSettings: Settings;
+
+    public updateHologramSettings(hologramSettings: Partial<HologramSettings>): void {
+        this.currentSettings = {
+            ...this.currentSettings,
+            visualization: {
+                ...this.currentSettings.visualization,
+                hologram: {
+                    ...this.currentSettings.visualization.hologram,
+                    ...hologramSettings
+                }
+            }
+        };
+        this.hologramManager.updateSettings(this.currentSettings);
     }
 
     public handleHandInput(hand: XRHand): void {
-        if (this.isXRSession) {
-            this.hologramManager.handleHandInteraction(hand);
+        if (this.isXRSession && hand.joints) {
+            const indexTip = hand.joints['index-finger-tip'];
+            if (indexTip) {
+                this.hologramManager.handleInteraction(indexTip.position);
+            }
         }
     }
 
diff --git a/client/services/settingsService.ts b/client/services/settingsService.ts
index 68c44d94..1fb4615f 100644
--- a/client/services/settingsService.ts
+++ b/client/services/settingsService.ts
@@ -26,15 +26,30 @@ export class SettingsService extends EventEmitter<SettingsServiceEvents> {
         return SettingsService.instance;
     }
 
-    async updateSetting(category: string, setting: string, value: any): Promise<void> {
-        const response = await fetch(
-            API_ENDPOINTS.SETTINGS_ITEM(category, setting), 
-            {
-                method: 'PUT',
-                headers: { 'Content-Type': 'application/json' },
-                body: JSON.stringify({ value })
+    async updateSetting(category: keyof Settings, setting: string, value: any): Promise<void> {
+        const currentSettings = await this.getSettings();
+        
+        // Handle nested settings structure
+        const [mainCategory, subCategory] = category.split('.');
+        if (subCategory) {
+            if (!currentSettings[mainCategory as keyof Settings]) {
+                throw new Error(`Invalid category: ${mainCategory}`);
+            }
+            (currentSettings[mainCategory as keyof Settings] as any)[subCategory][setting] = value;
+        } else {
+            if (!(category in currentSettings)) {
+                throw new Error(`Invalid category: ${category}`);
             }
-        );
+            (currentSettings[category] as any)[setting] = value;
+        }
+
+        // Send the full settings object
+        const response = await fetch(API_ENDPOINTS.SETTINGS_ROOT, {
+            method: 'POST',
+            headers: { 'Content-Type': 'application/json' },
+            body: JSON.stringify(currentSettings)
+        });
+
         if (!response.ok) {
             throw new Error('Failed to update setting');
         }
diff --git a/client/services/webSocketService.ts b/client/services/webSocketService.ts
deleted file mode 100644
index 8d3a8f98..00000000
--- a/client/services/webSocketService.ts
+++ /dev/null
@@ -1,97 +0,0 @@
-import { createLogger } from '../utils/logger';
-import { EventEmitter } from '../utils/eventEmitter';
-
-interface WebSocketEvents {
-    connected: boolean;
-    message: any;
-    error: Event;
-}
-
-export class WebSocketService extends EventEmitter<WebSocketEvents> {
-    private static instance: WebSocketService;
-    private ws: WebSocket | null = null;
-    private reconnectAttempts = 0;
-    private readonly maxReconnectAttempts = 5;
-    private readonly logger = createLogger('WebSocketService');
-
-    private constructor() {
-        super();
-    }
-
-    public static getInstance(): WebSocketService {
-        if (!WebSocketService.instance) {
-            WebSocketService.instance = new WebSocketService();
-        }
-        return WebSocketService.instance;
-    }
-
-    public connect(): void {
-        if (this.ws && (this.ws.readyState === WebSocket.CONNECTING || this.ws.readyState === WebSocket.OPEN)) {
-            this.logger.warn('WebSocket already connected or connecting');
-            return;
-        }
-
-        const url = this.getWebSocketUrl();
-        this.ws = new WebSocket(url);
-        this.setupEventHandlers();
-    }
-
-    private getWebSocketUrl(): string {
-        // Always use secure WebSocket when going through Cloudflare
-        const protocol = 'wss:';
-        const host = window.location.host;
-        return `${protocol}//${host}/wss`;
-    }
-
-    private setupEventHandlers(): void {
-        if (!this.ws) return;
-
-        this.ws.onopen = () => {
-            this.logger.info('WebSocket connected');
-            this.reconnectAttempts = 0;
-            this.emit('connected', true);
-        };
-
-        this.ws.onclose = () => {
-            this.logger.warn('WebSocket closed');
-            this.emit('connected', false);
-            this.reconnect();
-        };
-
-        this.ws.onerror = (event: Event) => {
-            this.handleError(event);
-        };
-
-        this.ws.onmessage = (event: MessageEvent) => {
-            this.emit('message', event.data);
-        };
-    }
-
-    private handleError(event: Event): void {
-        this.logger.error('WebSocket error:', event);
-        this.emit('error', event);
-        if (this.ws?.readyState === WebSocket.CLOSED) {
-            this.reconnect();
-        }
-    }
-
-    private reconnect(): void {
-        if (this.reconnectAttempts < this.maxReconnectAttempts) {
-            this.reconnectAttempts++;
-            const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
-            this.logger.info(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
-            setTimeout(() => this.connect(), delay);
-        } else {
-            this.logger.error('Max reconnection attempts reached');
-        }
-    }
-
-    public disconnect(): void {
-        if (this.ws) {
-            this.ws.close();
-            this.ws = null;
-        }
-    }
-}
-
-export const webSocketService = WebSocketService.getInstance(); 
\ No newline at end of file
diff --git a/client/state/SettingsStore.ts b/client/state/SettingsStore.ts
index fbf876fb..fc01ea4d 100644
--- a/client/state/SettingsStore.ts
+++ b/client/state/SettingsStore.ts
@@ -3,6 +3,7 @@ import { createLogger } from '../core/logger';
 import { defaultSettings } from './defaultSettings';
 import { buildApiUrl } from '../core/api';
 import { API_ENDPOINTS } from '../core/constants';
+import { Logger } from '../core/logger';
 
 const logger = createLogger('SettingsStore');
 
@@ -13,13 +14,13 @@ export class SettingsStore {
     private settings: Settings;
     private initialized: boolean = false;
     private initializationPromise: Promise<void> | null = null;
-    private pendingChanges: Set<string> = new Set();
-    private subscribers: Map<string, Set<SettingsChangeCallback>> = new Map();
-    private syncTimer: number | null = null;
+    private subscribers: Map<string, SettingsChangeCallback[]> = new Map();
+    private logger: Logger;
 
     private constructor() {
-        // Initialize with default settings
-        this.settings = { ...defaultSettings };
+        this.settings = {} as Settings;
+        this.subscribers = new Map();
+        this.logger = createLogger('SettingsStore');
     }
 
     public static getInstance(): SettingsStore {
@@ -80,9 +81,6 @@ export class SettingsStore {
 
                 this.initialized = true;
                 logger.info('SettingsStore initialized');
-
-                // Start periodic sync
-                this.startSync();
             } catch (error) {
                 logger.error('Failed to initialize settings:', error);
                 // Use defaults on error but ensure physics is enabled
@@ -108,9 +106,13 @@ export class SettingsStore {
         }
 
         if (!this.subscribers.has(path)) {
-            this.subscribers.set(path, new Set());
+            this.subscribers.set(path, []);
+        }
+        
+        const subscribers = this.subscribers.get(path);
+        if (subscribers) {
+            subscribers.push(callback);
         }
-        this.subscribers.get(path)?.add(callback);
 
         // Immediately call callback with current value
         const value = this.get(path);
@@ -122,8 +124,11 @@ export class SettingsStore {
         return () => {
             const pathSubscribers = this.subscribers.get(path);
             if (pathSubscribers) {
-                pathSubscribers.delete(callback);
-                if (pathSubscribers.size === 0) {
+                const index = pathSubscribers.indexOf(callback);
+                if (index > -1) {
+                    pathSubscribers.splice(index, 1);
+                }
+                if (pathSubscribers.length === 0) {
                     this.subscribers.delete(path);
                 }
             }
@@ -153,31 +158,47 @@ export class SettingsStore {
         }
     }
 
-    public set(path: string, value: unknown): void {
-        if (!this.initialized) {
-            logger.error('Attempting to set settings before initialization');
-            throw new Error('SettingsStore not initialized');
+    public async set(path: string, value: unknown): Promise<void> {
+        try {
+            // Update local state first
+            this.updateSettingValue(path, value);
+            
+            // Immediately sync with server
+            await this.syncWithServer();
+            
+            // Notify subscribers
+            this.notifySubscribers(path, value);
+            
+            this.logger.debug(`Setting updated successfully: ${path}`, value);
+        } catch (error) {
+            this.logger.error(`Failed to update setting: ${path}`, error);
+            // Revert local change
+            const originalValue = this.get(path);
+            this.updateSettingValue(path, originalValue);
+            this.notifySubscribers(path, originalValue);
+            throw error;
         }
+    }
 
+    private async syncWithServer(): Promise<void> {
         try {
-            const parts = path.split('.');
-            const lastKey = parts.pop()!;
-            const target = parts.reduce((obj: any, key) => {
-                if (!(key in obj)) {
-                    obj[key] = {};
-                }
-                return obj[key];
-            }, this.settings);
-
-            if (!target || typeof target !== 'object') {
-                throw new Error(`Invalid settings path: ${path}`);
+            const response = await fetch('/api/settings', {
+                method: 'POST',
+                headers: {
+                    'Content-Type': 'application/json',
+                },
+                body: JSON.stringify(this.settings)
+            });
+            
+            if (!response.ok) {
+                throw new Error(`Server returned ${response.status}: ${await response.text()}`);
             }
-
-            target[lastKey] = value;
-            this.pendingChanges.add(path);
-            this.notifySubscribers(path, value);
+            
+            // Update local settings with server response
+            const serverSettings = await response.json();
+            this.settings = serverSettings;
         } catch (error) {
-            logger.error(`Error setting value at path ${path}:`, error);
+            this.logger.error('Failed to sync settings with server:', error);
             throw error;
         }
     }
@@ -189,7 +210,7 @@ export class SettingsStore {
                 try {
                     callback(path, value);
                 } catch (error) {
-                    logger.error(`Error in settings subscriber for ${path}:`, error);
+                    this.logger.error(`Error in settings subscriber for ${path}:`, error);
                 }
             });
         }
@@ -236,51 +257,31 @@ export class SettingsStore {
         return result;
     }
 
-    private startSync(): void {
-        // Clear any existing sync timer
-        if (this.syncTimer !== null) {
-            window.clearInterval(this.syncTimer);
+    private updateSettingValue(path: string, value: unknown): void {
+        if (!path) {
+            this.settings = value as Settings;
+            return;
         }
+        
+        const parts = path.split('.');
+        const lastKey = parts.pop()!;
+        const target = parts.reduce((obj: any, key) => {
+            if (!(key in obj)) {
+                obj[key] = {};
+            }
+            return obj[key];
+        }, this.settings);
 
-        // Start periodic sync every 30 seconds
-        this.syncTimer = window.setInterval(async () => {
-            try {
-                // Only sync if there are pending changes
-                if (this.pendingChanges.size > 0) {
-                    const changedSettings: Record<string, unknown> = {};
-                    this.pendingChanges.forEach(path => {
-                        changedSettings[path] = this.get(path);
-                    });
-
-                    const response = await fetch(buildApiUrl(API_ENDPOINTS.SETTINGS_ROOT), {
-                        method: 'POST',
-                        headers: {
-                            'Content-Type': 'application/json',
-                        },
-                        body: JSON.stringify(changedSettings),
-                    });
-
-                    if (!response.ok) {
-                        throw new Error(`Failed to sync settings: ${response.statusText}`);
-                    }
+        if (!target || typeof target !== 'object') {
+            throw new Error(`Invalid settings path: ${path}`);
+        }
 
-                    // Clear pending changes after successful sync
-                    this.pendingChanges.clear();
-                    logger.debug('Settings synced with server');
-                }
-            } catch (error) {
-                logger.error('Failed to sync settings:', error);
-            }
-        }, 30000); // 30 seconds
+        target[lastKey] = value;
     }
 
     public dispose(): void {
-        if (this.syncTimer !== null) {
-            window.clearInterval(this.syncTimer);
-            this.syncTimer = null;
-        }
         this.subscribers.clear();
-        this.pendingChanges.clear();
-        this.initialized = false;
+        this.settings = {} as Settings;
+        SettingsStore.instance = null;
     }
 }
diff --git a/client/state/defaultSettings.ts b/client/state/defaultSettings.ts
index 25e5853f..84445395 100644
--- a/client/state/defaultSettings.ts
+++ b/client/state/defaultSettings.ts
@@ -148,6 +148,24 @@ export const defaultSettings: Settings = {
         }
     },
     xr: {
-        quality: 'medium'
+        mode: 'immersive-ar' as const,
+        quality: 'medium',
+        roomScale: true,
+        spaceType: 'local-floor' as XRReferenceSpaceType,
+        enableHandTracking: true,
+        handMeshEnabled: true,
+        handMeshColor: '#ffffff',
+        handMeshOpacity: 0.5,
+        handPointSize: 5,
+        handRayEnabled: true,
+        handRayColor: '#ffffff',
+        handRayWidth: 2,
+        gestureSsmoothing: 0.5,
+        enableHaptics: true,
+        hapticIntensity: 0.5,
+        dragThreshold: 0.1,
+        pinchThreshold: 0.5,
+        rotationThreshold: 0.1,
+        interactionRadius: 0.1
     }
 };
diff --git a/client/types/settings.ts b/client/types/settings.ts
index 7f8280bd..c48e9f90 100644
--- a/client/types/settings.ts
+++ b/client/types/settings.ts
@@ -1,3 +1,5 @@
+import { XRSessionMode } from './xr';
+
 // Core visualization settings
 export interface VisualizationSettings {
     animations: AnimationSettings;
@@ -182,8 +184,25 @@ export interface Settings {
         debug: DebugSettings;
     };
     xr: {
-        mode?: 'ar' | 'vr';
+        mode: XRSessionMode;
         quality: 'low' | 'medium' | 'high';
+        roomScale: boolean;
+        spaceType: 'viewer' | 'local' | 'local-floor' | 'bounded-floor' | 'unbounded';
+        enableHandTracking: boolean;
+        handMeshEnabled: boolean;
+        handMeshColor: string;
+        handMeshOpacity: number;
+        handPointSize: number;
+        handRayEnabled: boolean;
+        handRayColor: string;
+        handRayWidth: number;
+        gestureSsmoothing: number;
+        enableHaptics: boolean;
+        hapticIntensity: number;
+        dragThreshold: number;
+        pinchThreshold: number;
+        rotationThreshold: number;
+        interactionRadius: number;
     };
 }
 
diff --git a/client/types/settings/xr.ts b/client/types/settings/xr.ts
index fa89f8de..4557c5ff 100644
--- a/client/types/settings/xr.ts
+++ b/client/types/settings/xr.ts
@@ -4,7 +4,7 @@ export interface XRSettings {
     // Session Settings
     mode: XRSessionMode;
     roomScale: boolean;
-    spaceType: XRReferenceSpaceType;
+    spaceType: 'viewer' | 'local' | 'local-floor' | 'bounded-floor' | 'unbounded';
     
     // Hand Tracking
     enableHandTracking: boolean;
diff --git a/client/ui/ControlPanel.css b/client/ui/ControlPanel.css
index 5e75b24b..759b612d 100644
--- a/client/ui/ControlPanel.css
+++ b/client/ui/ControlPanel.css
@@ -1,26 +1,56 @@
-/* Control Panel Styles */
-
-.control-panel {
+/* Control Panel Base Styles */
+#control-panel {
     position: fixed;
-    top: 20px;
-    right: 20px;
+    top: 0;
+    right: 0;
     width: 300px;
-    max-height: calc(100vh - 40px);
-    background-color: rgba(30, 30, 30, 0.95);
-    border-radius: 8px;
-    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
+    height: 100vh;
+    background: rgba(33, 33, 33, 0.95);
     color: #ffffff;
     font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
     overflow-y: auto;
     z-index: 1000;
+    border-left: 1px solid rgba(255, 255, 255, 0.1);
+    box-shadow: -2px 0 10px rgba(0, 0, 0, 0.3);
+    padding: 15px;
+    display: block !important;
+}
+
+/* Control Panel Layout */
+.control-panel-content {
+    display: flex;
+    flex-direction: column;
+    gap: 15px;
     padding: 16px;
 }
 
+/* XR Button Styles */
+.xr-button {
+    width: 100%;
+    padding: 8px 16px;
+    background-color: #4CAF50;
+    color: white;
+    border: none;
+    border-radius: 4px;
+    cursor: pointer;
+    font-weight: bold;
+    transition: background-color 0.3s;
+    margin-top: 8px;
+}
+
+.xr-button:hover {
+    background-color: #45a049;
+}
+
+.xr-button:active {
+    background-color: #3d8b40;
+}
+
 .control-panel-header {
     display: flex;
     justify-content: space-between;
     align-items: center;
-    margin-bottom: 16px;
+    margin-bottom: 20px;
     padding-bottom: 8px;
     border-bottom: 1px solid rgba(255, 255, 255, 0.1);
 }
@@ -32,124 +62,98 @@
 }
 
 .connection-status {
+    display: flex;
+    align-items: center;
+    gap: 6px;
     padding: 4px 8px;
     border-radius: 4px;
     font-size: 12px;
 }
 
+.status-indicator {
+    width: 8px;
+    height: 8px;
+    border-radius: 50%;
+    background-color: #F44336;
+}
+
 .connection-status.connected {
     background-color: rgba(39, 174, 96, 0.2);
     color: #2ecc71;
 }
 
+.connection-status.connected .status-indicator {
+    background-color: #2ecc71;
+}
+
 .connection-status.disconnected {
     background-color: rgba(231, 76, 60, 0.2);
     color: #e74c3c;
 }
 
+.connection-status.disconnected .status-indicator {
+    background-color: #e74c3c;
+}
+
+/* Settings Sections */
 .settings-section {
-    margin-bottom: 24px;
+    margin-bottom: 20px;
+    padding-bottom: 15px;
+    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
 }
 
-.settings-section h3 {
+.settings-section h4 {
     margin: 0 0 12px 0;
     font-size: 16px;
     font-weight: 500;
-    color: #bdc3c7;
+    color: #ecf0f1;
 }
 
-.setting-container {
-    margin-bottom: 12px;
+/* Setting Controls */
+.setting-control {
     display: flex;
-    flex-direction: column;
-    gap: 4px;
+    justify-content: space-between;
+    align-items: center;
+    margin: 8px 0;
+    gap: 10px;
 }
 
-.setting-container label {
+.setting-control label {
     font-size: 14px;
     color: #ecf0f1;
+    white-space: nowrap;
 }
 
-.setting-container input[type="text"],
-.setting-container input[type="number"] {
-    background-color: rgba(255, 255, 255, 0.1);
+/* Input Styles */
+input[type="text"],
+input[type="number"] {
+    background: rgba(255, 255, 255, 0.1);
     border: 1px solid rgba(255, 255, 255, 0.2);
     border-radius: 4px;
-    padding: 6px 8px;
+    padding: 4px 8px;
     color: #ffffff;
     font-size: 14px;
-    width: 100%;
+    min-width: 100px;
 }
 
-.setting-container input[type="checkbox"] {
+input[type="checkbox"] {
     width: 16px;
     height: 16px;
+    margin: 0;
 }
 
-.setting-container input[type="color"] {
-    width: 100%;
-    height: 32px;
-    padding: 2px;
-    background-color: rgba(255, 255, 255, 0.1);
+input[type="color"] {
+    width: 50px;
+    height: 24px;
+    padding: 0;
+    background: rgba(255, 255, 255, 0.1);
     border: 1px solid rgba(255, 255, 255, 0.2);
     border-radius: 4px;
 }
 
-.array-input {
-    display: flex;
-    gap: 8px;
-}
-
-.array-input input {
-    flex: 1;
-}
-
-.reset-button {
-    width: 100%;
-    padding: 8px 16px;
-    background-color: rgba(231, 76, 60, 0.2);
-    border: 1px solid rgba(231, 76, 60, 0.4);
-    border-radius: 4px;
-    color: #e74c3c;
-    font-size: 14px;
-    cursor: pointer;
-    transition: all 0.2s ease;
-}
-
-.reset-button:hover {
-    background-color: rgba(231, 76, 60, 0.3);
-    border-color: rgba(231, 76, 60, 0.6);
-}
-
-.randomize-button-container {
-    padding: 16px;
-    margin-bottom: 16px;
-    border-bottom: 1px solid #ccc;
-}
-
-.randomize-button {
-    width: 100%;
-    padding: 12px;
-    font-size: 16px;
-    color: white;
-    background-color: #2196f3;
-    border: none;
-    border-radius: 4px;
-    cursor: pointer;
-    transition: background-color 0.3s ease;
-}
-
-.randomize-button:hover {
-    background-color: #1976d2;
-}
-
-.randomize-button:active {
-    background-color: #0d47a1;
-}
-
 /* Loading and Error states */
 .loading, .error {
-    padding: 20px;
+    padding: 15px;
     text-align: center;
     color: #ffffff;
     font-size: 14px;
@@ -168,22 +172,6 @@
     border: 1px solid rgba(231, 76, 60, 0.4);
 }
 
-.retry-button {
-    margin-top: 10px;
-    padding: 8px 16px;
-    background-color: rgba(52, 152, 219, 0.2);
-    border: 1px solid rgba(52, 152, 219, 0.4);
-    border-radius: 4px;
-    color: #3498db;
-    cursor: pointer;
-    transition: all 0.2s ease;
-}
-
-.retry-button:hover {
-    background-color: rgba(52, 152, 219, 0.3);
-    border-color: rgba(52, 152, 219, 0.6);
-}
-
 @keyframes pulse {
     0% { opacity: 0.6; }
     50% { opacity: 1; }
@@ -191,20 +179,30 @@
 }
 
 /* Scrollbar styles */
-.control-panel::-webkit-scrollbar {
+#control-panel::-webkit-scrollbar {
     width: 8px;
 }
 
-.control-panel::-webkit-scrollbar-track {
+#control-panel::-webkit-scrollbar-track {
     background: rgba(255, 255, 255, 0.1);
     border-radius: 4px;
 }
 
-.control-panel::-webkit-scrollbar-thumb {
+#control-panel::-webkit-scrollbar-thumb {
     background: rgba(255, 255, 255, 0.2);
     border-radius: 4px;
 }
 
-.control-panel::-webkit-scrollbar-thumb:hover {
+#control-panel::-webkit-scrollbar-thumb:hover {
     background: rgba(255, 255, 255, 0.3);
 }
+
+/* Select dropdowns */
+select {
+    background: rgba(255, 255, 255, 0.1);
+    border: 1px solid rgba(255, 255, 255, 0.2);
+    color: white;
+    padding: 4px 8px;
+    border-radius: 4px;
+    min-width: 100px;
+}
diff --git a/client/ui/ControlPanel.ts b/client/ui/ControlPanel.ts
index 215d28dd..5497c56e 100644
--- a/client/ui/ControlPanel.ts
+++ b/client/ui/ControlPanel.ts
@@ -1,27 +1,82 @@
 import { Settings } from '../types/settings';
 import { createLogger } from '../core/logger';
 import { SettingsStore } from '../state/SettingsStore';
+import { WebSocketService } from '../websocket/websocketService';
+import { XRSessionManager } from '../xr/xrSessionManager';
+import { SceneManager } from '../rendering/scene';
 import './ControlPanel.css';
 
 const logger = createLogger('ControlPanel');
 
 export class ControlPanel {
+    private static instance: ControlPanel | null = null;
     private container: HTMLElement;
     private settings: Settings;
     private unsubscribers: Array<() => void> = [];
     private settingsStore: SettingsStore;
+    private webSocketService: WebSocketService;
 
-    constructor(container: HTMLElement) {
+    constructor(container: HTMLElement, settingsStore: SettingsStore) {
+        if (ControlPanel.instance) {
+            throw new Error('ControlPanel is a singleton');
+        }
         this.container = container;
-        this.settingsStore = SettingsStore.getInstance();
+        this.settingsStore = settingsStore;
         this.settings = {} as Settings;
+        this.webSocketService = WebSocketService.getInstance();
+        this.setupConnectionStatus();
         this.initializePanel();
+        ControlPanel.instance = this;
+    }
+
+    public static getInstance(): ControlPanel | null {
+        return ControlPanel.instance;
+    }
+
+    public show(): void {
+        if (this.container) {
+            this.container.style.display = 'block';
+            logger.debug('Control panel shown');
+        }
+    }
+
+    public hide(): void {
+        if (this.container) {
+            this.container.style.display = 'none';
+            logger.debug('Control panel hidden');
+        }
+    }
+
+    private setupConnectionStatus(): void {
+        const statusElement = this.container.querySelector('.connection-status');
+        const statusTextElement = this.container.querySelector('#connection-status');
+        
+        if (!statusElement || !statusTextElement) {
+            logger.error('Connection status elements not found');
+            return;
+        }
+
+        this.webSocketService.onConnectionStatusChange((connected: boolean) => {
+            statusElement.classList.remove('connected', 'disconnected');
+            statusElement.classList.add(connected ? 'connected' : 'disconnected');
+            statusTextElement.textContent = connected ? 'Connected' : 'Disconnected';
+            logger.debug('Connection status updated:', connected);
+        });
     }
 
     private async initializePanel(): Promise<void> {
         try {
-            // Show loading state with more detail
-            this.container.innerHTML = '<div class="loading">Initializing control panel...</div>';
+            logger.debug('Starting panel initialization...');
+            
+            // Get the content container
+            const content = this.container.querySelector('.control-panel-content');
+            if (!content) {
+                throw new Error('Control panel content container not found');
+            }
+            
+            // Show loading state
+            content.innerHTML = '<div class="loading">Initializing control panel...</div>';
+            logger.debug('Container exists:', !!this.container);
             
             // Initialize settings store with timeout
             const initializePromise = this.settingsStore.initialize();
@@ -31,7 +86,7 @@ export class ControlPanel {
             
             // Wait for settings store to initialize or timeout
             await Promise.race([initializePromise, timeoutPromise]);
-            this.container.innerHTML = '<div class="loading">Loading settings...</div>';
+            content.innerHTML = '<div class="loading">Loading settings...</div>';
             
             // Get settings after initialization
             const settings = this.settingsStore.get('');
@@ -40,14 +95,20 @@ export class ControlPanel {
             }
             
             this.settings = settings as Settings;
-            logger.info('Settings loaded:', this.settings);
+            logger.debug('Settings loaded:', {
+                visualization: Object.keys(this.settings.visualization || {}),
+                system: Object.keys(this.settings.system || {}),
+                xr: this.settings.xr
+            });
             
             // Create panel elements
-            this.container.innerHTML = '<div class="loading">Creating control panel...</div>';
+            content.innerHTML = '<div class="loading">Creating control panel...</div>';
             this.createPanelElements();
+            logger.debug('Panel elements created');
             
             // Setup subscriptions
             await this.setupSettingsSubscriptions();
+            logger.debug('Settings subscriptions set up');
             
             logger.info('Control panel initialized successfully');
         } catch (error) {
@@ -63,266 +124,387 @@ export class ControlPanel {
     }
 
     private createPanelElements(): void {
-        // Clear existing content
-        this.container.innerHTML = '';
+        logger.debug('Creating panel elements...');
+        
+        // First check if the container exists
+        if (!this.container) {
+            logger.error('Control panel container is null');
+            return;
+        }
+
+        // Get the content container
+        const content = this.container.querySelector('.control-panel-content');
+        if (!content) {
+            logger.error('Control panel content container not found');
+            return;
+        }
+
+        // Create a temporary container for the new content
+        const tempContainer = document.createElement('div');
 
         // Create settings sections
         const flatSettings = this.flattenSettings(this.settings);
+        logger.debug('Flattened settings:', {
+            count: Object.keys(flatSettings).length,
+            paths: Object.keys(flatSettings)
+        });
+        
         const groupedSettings = this.groupSettingsByCategory(flatSettings);
+        logger.debug('Grouped settings:', {
+            categories: Object.keys(groupedSettings),
+            settingsPerCategory: Object.entries(groupedSettings).map(([cat, settings]) => ({
+                category: cat,
+                count: Object.keys(settings).length
+            }))
+        });
+
+        // Sort categories to ensure consistent order
+        const sortedCategories = Object.entries(groupedSettings).sort(([a], [b]) => a.localeCompare(b));
+        logger.debug('Processing categories:', sortedCategories.map(([cat]) => ({
+            category: cat,
+            settingCount: Object.keys(groupedSettings[cat]).length
+        })));
 
-        for (const [category, settings] of Object.entries(groupedSettings)) {
+        for (const [category, settings] of sortedCategories) {
             const section = this.createSection(category);
             
-            for (const [path, value] of Object.entries(settings)) {
+            // Sort settings within each category
+            const sortedSettings = Object.entries(settings).sort(([a], [b]) => a.localeCompare(b));
+            
+            for (const [path, value] of sortedSettings) {
+                logger.debug(`Creating control for ${path}:`, {
+                    type: typeof value,
+                    value: value
+                });
                 const control = this.createSettingControl(path, value);
                 if (control) {
                     section.appendChild(control);
+                    logger.debug(`Added control for ${path}`);
+                } else {
+                    logger.warn(`Failed to create control for ${path}`);
                 }
             }
             
-            this.container.appendChild(section);
+            if (section.children.length > 1) { // > 1 because section always has a header
+                tempContainer.appendChild(section);
+                logger.debug(`Added section ${category}`, {
+                    totalControls: section.children.length - 1,
+                    paths: Array.from(section.querySelectorAll('[data-path]')).map(el => el.getAttribute('data-path'))
+                });
+            } else {
+                logger.debug(`Skipping empty section ${category}`);
+            }
         }
+
+        // Only update the content once everything is ready
+        content.innerHTML = '';
+        content.appendChild(tempContainer);
+        logger.debug('Panel elements created successfully', {
+            totalSections: tempContainer.children.length,
+            totalControls: tempContainer.querySelectorAll('[data-path]').length
+        });
+
+        logger.debug('Panel elements creation complete');
     }
 
-    private flattenSettings(obj: unknown, prefix: string = ''): Record<string, unknown> {
+    private flattenSettings(settings: Settings): Record<string, unknown> {
         const result: Record<string, unknown> = {};
         
-        if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
-            for (const [key, value] of Object.entries(obj)) {
-                const newKey = prefix ? `${prefix}.${key}` : key;
-                
-                if (value && typeof value === 'object' && !Array.isArray(value)) {
-                    Object.assign(result, this.flattenSettings(value, newKey));
-                } else {
-                    result[newKey] = value;
+        function flatten(obj: unknown, prefix = ''): void {
+            if (typeof obj === 'object' && obj !== null) {
+                for (const [key, value] of Object.entries(obj)) {
+                    const newPrefix = prefix ? `${prefix}.${key}` : key;
+                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
+                        flatten(value, newPrefix);
+                    } else {
+                        result[newPrefix] = value;
+                    }
                 }
             }
         }
         
+        flatten(settings);
         return result;
     }
 
     private groupSettingsByCategory(flatSettings: Record<string, unknown>): Record<string, Record<string, unknown>> {
         const result: Record<string, Record<string, unknown>> = {};
         
+        // Group settings by their category path
         for (const [path, value] of Object.entries(flatSettings)) {
-            const category = path.split('.')[0];
-            if (!result[category]) {
-                result[category] = {};
+            const parts = path.split('.');
+            if (parts.length >= 2) {
+                // For visualization and system settings, use first two parts as category
+                // e.g., 'visualization.nodes' or 'system.network'
+                const category = parts.slice(0, 2).join('.');
+                if (!result[category]) {
+                    result[category] = {};
+                }
+                result[category][path] = value;
+            } else {
+                // For top-level settings like 'xr', use the first part
+                const category = parts[0];
+                if (!result[category]) {
+                    result[category] = {};
+                }
+                result[category][path] = value;
             }
-            result[category][path] = value;
         }
+
+        logger.debug('Grouped settings by category:', {
+            categories: Object.keys(result),
+            settingsPerCategory: Object.entries(result).map(([cat, settings]) => ({
+                category: cat,
+                settingCount: Object.keys(settings).length,
+                example: Object.keys(settings)[0]
+            }))
+        });
         
         return result;
     }
 
     private createSection(category: string): HTMLElement {
         const section = document.createElement('div');
-        section.className = 'settings-section';
+        section.classList.add('settings-section');
         
-        const header = document.createElement('h2');
-        header.textContent = this.formatCategoryName(category);
+        const header = document.createElement('h4');
+        header.textContent = category;
         section.appendChild(header);
         
         return section;
     }
 
-    private createSettingControl(path: string, value: unknown): HTMLElement | null {
-        const container = document.createElement('div');
-        container.className = 'setting-control';
-        
-        const label = document.createElement('label');
-        label.textContent = this.formatSettingName(path.split('.').pop()!);
-        container.appendChild(label);
-        
-        const control = this.createInputElement(path, value);
-        if (!control) {
-            return null;
+    private getSceneManager(): SceneManager {
+        const canvas = document.querySelector('canvas');
+        if (!canvas) {
+            throw new Error('Canvas not found');
         }
-        
-        container.appendChild(control);
-        return container;
+        return SceneManager.getInstance(canvas as HTMLCanvasElement);
     }
 
-    private createInputElement(path: string, value: unknown): HTMLElement | null {
-        const type = this.getInputType(value);
-        if (!type) {
-            return null;
-        }
+    private createXRModeControl(): HTMLElement {
+        const control = document.createElement('div');
+        control.classList.add('setting-control');
 
-        let input: HTMLElement;
-        
-        switch (type) {
-            case 'checkbox':
-                input = document.createElement('input');
-                (input as HTMLInputElement).type = 'checkbox';
-                (input as HTMLInputElement).checked = value as boolean;
-                input.onchange = (e: Event) => {
-                    const target = e.target as HTMLInputElement;
-                    this.settingsStore.set(path, target.checked);
-                };
-                break;
-
-            case 'number':
-                input = document.createElement('input');
-                (input as HTMLInputElement).type = 'number';
-                (input as HTMLInputElement).value = String(value);
-                (input as HTMLInputElement).step = this.getStepValue(path);
-                input.onchange = (e: Event) => {
-                    const target = e.target as HTMLInputElement;
-                    this.settingsStore.set(path, parseFloat(target.value));
-                };
-                break;
-
-            case 'color':
-                input = document.createElement('input');
-                (input as HTMLInputElement).type = 'color';
-                (input as HTMLInputElement).value = value as string;
-                input.onchange = (e: Event) => {
-                    const target = e.target as HTMLInputElement;
-                    this.settingsStore.set(path, target.value);
-                };
-                break;
-
-            case 'select':
-                input = document.createElement('select');
-                if (Array.isArray(value)) {
-                    value.forEach(option => {
-                        const opt = document.createElement('option');
-                        opt.value = String(option);
-                        opt.textContent = String(option);
-                        input.appendChild(opt);
-                    });
+        const button = document.createElement('button');
+        button.textContent = 'Enter Immersive Mode';
+        button.classList.add('xr-button');
+        button.addEventListener('click', async () => {
+            try {
+                const sceneManager = this.getSceneManager();
+                const xrManager = XRSessionManager.getInstance(sceneManager);
+                if (!xrManager.isXRPresenting()) {
+                    await xrManager.initXRSession();
+                    button.textContent = 'Exit Immersive Mode';
+                } else {
+                    await xrManager.endXRSession();
+                    button.textContent = 'Enter Immersive Mode';
                 }
-                input.onchange = (e: Event) => {
-                    const target = e.target as HTMLSelectElement;
-                    this.settingsStore.set(path, target.value);
-                };
-                break;
-
-            default:
-                input = document.createElement('input');
-                (input as HTMLInputElement).type = 'text';
-                (input as HTMLInputElement).value = String(value);
-                input.onchange = (e: Event) => {
-                    const target = e.target as HTMLInputElement;
-                    this.settingsStore.set(path, target.value);
-                };
-        }
+            } catch (error) {
+                logger.error('Failed to toggle XR session:', error);
+            }
+        });
 
-        input.id = `setting-${path}`;
-        return input;
+        control.appendChild(button);
+        return control;
     }
 
-    private getInputType(value: unknown): string | null {
-        switch (typeof value) {
-            case 'boolean':
-                return 'checkbox';
-            case 'number':
-                return 'number';
-            case 'string':
-                if (value.match(/^#[0-9a-f]{6}$/i)) {
-                    return 'color';
-                }
-                return 'text';
-            case 'object':
-                if (Array.isArray(value)) {
-                    return 'select';
-                }
-                return null;
-            default:
-                return null;
+    private createSettingControl(path: string, value: unknown): HTMLElement | null {
+        // Special handling for XR mode
+        if (path === 'xr.mode') {
+            return this.createXRModeControl();
         }
-    }
 
-    private getStepValue(path: string): string {
-        if (path.includes('opacity') || path.includes('strength')) {
-            return '0.1';
-        }
-        return '1';
-    }
+        const label = document.createElement('label');
+        // Use the last part of the path and format it
+        const labelText = path.split('.').pop() || path;
+        label.textContent = `${this.formatSettingLabel(labelText)}:`;  // Use the formatting
+        label.style.whiteSpace = 'nowrap';
 
-    private formatCategoryName(category: string): string {
-        return category
-            .split(/(?=[A-Z])/)
-            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
-            .join(' ');
-    }
+        const control = document.createElement('div');
+        control.classList.add('setting-control');
+        control.appendChild(label);
 
-    private formatSettingName(setting: string): string {
-        return setting
-            .split(/(?=[A-Z])/)
-            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
-            .join(' ');
-    }
+        // Create input element based on value type
+        if (typeof value === 'boolean') {
+            const checkbox = document.createElement('input');
+            checkbox.type = 'checkbox';
+            checkbox.checked = value;
+            checkbox.dataset.path = path;
+            checkbox.addEventListener('change', async () => {
+                try {
+                    await this.settingsStore.set(path, checkbox.checked);
+                    logger.debug(`Setting ${path} updated to:`, checkbox.checked);
+                } catch (error) {
+                    logger.error(`Failed to update setting ${path}:`, error);
+                    // Revert the checkbox if the update failed
+                    checkbox.checked = !checkbox.checked;
+                }
+            });
+            control.appendChild(checkbox);
+        } else if (typeof value === 'number') {
+            const numberInput = document.createElement('input');
+            numberInput.type = 'number';
+            numberInput.value = value.toString();
+            numberInput.dataset.path = path;
+            numberInput.addEventListener('input', async () => {
+                const parsedValue = parseFloat(numberInput.value);
+                if (!isNaN(parsedValue)) {
+                    try {
+                        await this.settingsStore.set(path, parsedValue);
+                        logger.debug(`Setting ${path} updated to:`, parsedValue);
+                    } catch (error) {
+                        logger.error(`Failed to update setting ${path}:`, error);
+                        // Revert the input if the update failed
+                        numberInput.value = value.toString();
+                    }
+                }
+            });
+            control.appendChild(numberInput);
+        } else if (typeof value === 'string' && (path.endsWith('Color') || path.includes('.color'))) {
+            const colorInput = document.createElement('input');
+            colorInput.type = 'color';
+            colorInput.value = value;
+            colorInput.dataset.path = path;
+            colorInput.addEventListener('change', async () => {
+                const newValue = colorInput.value;
+                try {
+                    await this.settingsStore.set(path, newValue);
+                    logger.debug(`Setting ${path} updated to:`, newValue);
+                } catch (error) {
+                    logger.error(`Failed to update setting ${path}:`, error);
+                    // Revert the color if the update failed
+                    colorInput.value = value as string;
+                }
+            });
+            control.appendChild(colorInput);
+        } else if (typeof value === 'string') {
+            const textInput = document.createElement('input');
+            textInput.type = 'text';
+            textInput.value = value;
+            textInput.dataset.path = path;
+            textInput.addEventListener('input', async () => {
+                const newValue = textInput.value;
+                try {
+                    await this.settingsStore.set(path, newValue);
+                    logger.debug(`Setting ${path} updated to:`, newValue);
+                } catch (error) {
+                    logger.error(`Failed to update setting ${path}:`, error);
+                    // Revert the text if the update failed
+                    textInput.value = value as string;
+                }
+            });
+            control.appendChild(textInput);
+        } else if (Array.isArray(value)) {
+            const select = document.createElement('select');
+            select.dataset.path = path;
+            value.forEach(optionValue => {
+                const option = document.createElement('option');
+                option.value = String(optionValue);
+                option.text = String(optionValue);
+                select.appendChild(option);
+            });
+            select.addEventListener('change', async () => {
+                const newValue = select.value;
+                try {
+                    await this.settingsStore.set(path, newValue);
+                    logger.debug(`Setting ${path} updated to:`, newValue);
+                } catch (error) {
+                    logger.error(`Failed to update setting ${path}:`, error);
+                    // Revert the selection if the update failed
+                    select.value = String(value[0]); // Reset to first value in array
+                }
+            });
+            control.appendChild(select);
+        } else {
+            logger.warn(`Unsupported setting type for ${path}:`, typeof value);
+            return null;
+        }
 
-    private setupSettingsSubscriptions(): void {
-        // Clear existing subscriptions
-        this.unsubscribers.forEach(unsub => unsub());
-        this.unsubscribers = [];
+        return control;
+    }
 
-        const settings = this.settingsStore;
-        let unsubscriber: (() => void) | undefined;
+    private async setupSettingsSubscriptions(): Promise<void> {
+        const flatSettings = this.flattenSettings(this.settings);
+        const paths = Object.keys(flatSettings).sort();
 
-        // Subscribe to settings changes
-        settings.subscribe('visualization.labels.enableLabels', (value) => {
-            this.updateLabelVisibility(typeof value === 'boolean' ? value : value === 'true');
-        }).then(unsub => {
-            unsubscriber = unsub;
-            if (unsubscriber) {
-                this.unsubscribers.push(unsubscriber);
-            }
-        });
+        const promises = paths.map(async path => {
+            return new Promise<void>((resolve, reject) => {
+                const timeoutId = setTimeout(() => {
+                    reject(new Error(`Timeout setting up subscription for ${path}`));
+                }, 5000);
 
-        const flatSettings = this.flattenSettings(this.settings);
-        for (const path of Object.keys(flatSettings)) {
-            settings.subscribe(path, (value) => {
-                this.updateSettingValue(path, value);
-            }).then(unsub => {
-                if (unsub) {
+                // Subscribe to each setting path
+                this.settingsStore.subscribe(path, (value: unknown) => {
+                    logger.debug(`Received update for ${path}:`, value);
+                    this.updateSettingControl(path, value);
+                    clearTimeout(timeoutId);
+                    resolve();
+                }).then(unsub => {
                     this.unsubscribers.push(unsub);
-                }
+                }).catch(error => {
+                    logger.error(`Failed to subscribe to ${path}:`, error);
+                    reject(error);
+                });
             });
-        }
-    }
-
-    private updateLabelVisibility(value: boolean): void {
-        // Update label visibility in the UI
-        const labelElements = document.querySelectorAll('.node-label');
-        labelElements.forEach(el => {
-            (el as HTMLElement).style.display = value ? 'block' : 'none';
         });
-    }
 
-    private updateSettingValue(path: string, value: unknown): void {
-        const element = document.getElementById(`setting-${path}`);
-        if (!element) {
-            logger.warn(`No element found for setting: ${path}`);
-            return;
+        try {
+            await Promise.all(promises);
+            logger.info('All settings subscriptions set up successfully.');
+        } catch (error) {
+            logger.error('Failed to set up all settings subscriptions:', error);
         }
+    }
 
-        if (element instanceof HTMLInputElement) {
-            switch (element.type) {
-                case 'checkbox':
-                    element.checked = value as boolean;
-                    break;
-                case 'number':
-                    element.value = String(value);
-                    break;
-                case 'color':
-                    element.value = value as string;
-                    break;
-                default:
-                    element.value = String(value);
+    private updateSettingControl(path: string, value: unknown): void {
+        try {
+            const control = this.container.querySelector(`[data-path="${path}"]`);
+            if (!control) {
+                logger.warn(`Control not found for setting: ${path}`);
+                return;
             }
-        } else if (element instanceof HTMLSelectElement) {
-            element.value = String(value);
+
+            if (control instanceof HTMLInputElement) {
+                const inputType = control.type;
+                switch (inputType) {
+                    case 'checkbox':
+                        control.checked = value as boolean;
+                        logger.debug(`Updated checkbox: ${path}`, { checked: control.checked });
+                        break;
+                    case 'number':
+                        control.value = String(value);
+                        logger.debug(`Updated number: ${path}`, { value: control.value });
+                        break;
+                    case 'color':
+                        control.value = value as string;
+                        logger.debug(`Updated color: ${path}`, { value: control.value });
+                        break;
+                    default:
+                        control.value = String(value);
+                        logger.debug(`Updated text: ${path}`, { value: control.value });
+                }
+            } else if (control instanceof HTMLSelectElement) {
+                control.value = String(value);
+                logger.debug(`Updated select: ${path}`, { value: control.value });
+            }
+        } catch (error) {
+            logger.error(`Failed to update setting value: ${path}`, error);
         }
     }
 
+    private formatSettingLabel(key: string): string {
+        return key
+            .split(/(?=[A-Z])|[_\.]/)
+            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
+            .join(' ');
+    }
+
     public dispose(): void {
         this.unsubscribers.forEach(unsub => unsub());
         this.unsubscribers = [];
+        this.webSocketService.onConnectionStatusChange(() => {}); // Remove connection status handler
         this.container.innerHTML = '';
+        logger.debug('ControlPanel disposed');
     }
 }
diff --git a/client/ui/index.ts b/client/ui/index.ts
index 04ebc6e6..c2bfd442 100644
--- a/client/ui/index.ts
+++ b/client/ui/index.ts
@@ -1,4 +1,45 @@
 import { ControlPanel } from './ControlPanel';
+import { createLogger } from '../core/logger';
+import { SettingsStore } from '../state/SettingsStore';
 import './ControlPanel.css';
 
+const logger = createLogger('UI');
+
+// Initialize UI components
+export async function initializeUI(): Promise<void> {
+    try {
+        logger.debug('Initializing UI components');
+        
+        // Get the singleton instance of SettingsStore
+        const settingsStore = SettingsStore.getInstance();
+        
+        // Initialize settings store
+        await settingsStore.initialize();
+        logger.debug('Settings store initialized');
+        
+        const controlPanelElement = document.getElementById('control-panel');
+        if (controlPanelElement instanceof HTMLElement) {
+            logger.debug('Found control panel element, initializing ControlPanel');
+            new ControlPanel(controlPanelElement, settingsStore);
+        } else {
+            logger.error('Control panel element not found');
+        }
+    } catch (error) {
+        logger.error('Failed to initialize UI:', error);
+    }
+}
+
+// Initialize when DOM is ready
+if (document.readyState === 'loading') {
+    document.addEventListener('DOMContentLoaded', () => {
+        initializeUI().catch(error => {
+            logger.error('Failed to initialize UI on DOMContentLoaded:', error);
+        });
+    });
+} else {
+    initializeUI().catch(error => {
+        logger.error('Failed to initialize UI:', error);
+    });
+}
+
 export { ControlPanel };
diff --git a/client/utils/logger.ts b/client/utils/logger.ts
deleted file mode 100644
index 6200007d..00000000
--- a/client/utils/logger.ts
+++ /dev/null
@@ -1,37 +0,0 @@
-export interface Logger {
-    log: (message: string, ...args: any[]) => void;
-    error: (message: string, ...args: any[]) => void;
-    warn: (message: string, ...args: any[]) => void;
-    info: (message: string, ...args: any[]) => void;
-    debug: (message: string, ...args: any[]) => void;
-}
-
-// Track debug state
-let debugEnabled = true; // Start with debug enabled
-
-export function setDebugEnabled(enabled: boolean): void {
-    debugEnabled = enabled;
-}
-
-export function createLogger(context: string): Logger {
-    const prefix = `[${context}]`;
-
-    return {
-        // Always log errors and warnings
-        log: (message: string, ...args: any[]) => console.log(`${prefix} ${message}`, ...args),
-        error: (message: string, ...args: any[]) => console.error(`${prefix} ${message}`, ...args),
-        warn: (message: string, ...args: any[]) => console.warn(`${prefix} ${message}`, ...args),
-        
-        // Debug and info respect debug state
-        info: (message: string, ...args: any[]) => {
-            if (debugEnabled) {
-                console.info(`${prefix} ${message}`, ...args);
-            }
-        },
-        debug: (message: string, ...args: any[]) => {
-            if (debugEnabled) {
-                console.debug(`${prefix} ${message}`, ...args);
-            }
-        }
-    };
-}
diff --git a/client/websocket/websocketService.ts b/client/websocket/websocketService.ts
index 84514944..8bbc6e20 100644
--- a/client/websocket/websocketService.ts
+++ b/client/websocket/websocketService.ts
@@ -132,7 +132,15 @@ export class WebSocketService {
         this.ws.onerror = (event: Event): void => {
             logger.error('WebSocket error:', event);
             if (this.ws) {
-                logger.debug('WebSocket readyState:', this.ws.readyState);
+                logger.debug('Connection details:', {
+                    readyState: this.ws.readyState,
+                    url: this.url,
+                    connectionState: this.connectionState,
+                    reconnectAttempts: this.reconnectAttempts
+                });
+            }
+            if (this.ws?.readyState === WebSocket.CLOSED) {
+                this.handleReconnect();
             }
         };
 
@@ -149,42 +157,79 @@ export class WebSocketService {
         };
 
         this.ws.onmessage = (event: MessageEvent) => {
-            if (event.data instanceof ArrayBuffer) {
-                logger.debug('Received binary position update');
-                this.handleBinaryMessage(event.data);
-            } else if (typeof event.data === 'string') {
-                try {
-                    const message = JSON.parse(event.data);
-                    logger.debug('Received JSON message:', message);
-                    switch (message.type) {
-                        case 'settings':
-                            this.handleSettingsUpdate(message);
-                            break;
-                        case 'connection_established':
-                        case 'updatesStarted':
-                            logger.info(`WebSocket ${message.type}`);
-                            break;
-                        default:
-                            logger.warn('Unknown message type:', message.type);
+            try {
+                if (event.data instanceof ArrayBuffer) {
+                    logger.debug('Received binary position update');
+                    try {
+                        this.handleBinaryMessage(event.data);
+                    } catch (error) {
+                        logger.error('Failed to process binary message:', {
+                            error,
+                            dataSize: event.data.byteLength,
+                            connectionState: this.connectionState
+                        });
                     }
-                } catch (e) {
-                    logger.error('Failed to parse WebSocket message:', e);
+                } else if (typeof event.data === 'string') {
+                    try {
+                        const message = JSON.parse(event.data);
+                        logger.debug('Received JSON message:', message);
+                        
+                        switch (message.type) {
+                            case 'settings':
+                                try {
+                                    this.handleSettingsUpdate(message);
+                                } catch (error) {
+                                    logger.error('Failed to handle settings update:', {
+                                        error,
+                                        message,
+                                        connectionState: this.connectionState
+                                    });
+                                }
+                                break;
+                            case 'connection_established':
+                            case 'updatesStarted':
+                                logger.info(`WebSocket ${message.type}`);
+                                break;
+                            default:
+                                logger.warn('Unknown message type:', {
+                                    type: message.type,
+                                    message
+                                });
+                        }
+                    } catch (error) {
+                        logger.error('Failed to parse WebSocket message:', {
+                            error,
+                            data: event.data.slice(0, 200), // Log first 200 chars only
+                            connectionState: this.connectionState
+                        });
+                    }
+                } else {
+                    logger.warn('Received unknown message type:', {
+                        type: typeof event.data,
+                        connectionState: this.connectionState
+                    });
                 }
-            } else {
-                logger.warn('Received unknown message type:', typeof event.data);
+            } catch (error) {
+                logger.error('Critical error in message handler:', {
+                    error,
+                    connectionState: this.connectionState,
+                    wsState: this.ws?.readyState
+                });
             }
         };
     }
 
-    // Message types matching server's binary protocol
+    // Message type matching server's binary protocol
     private readonly MessageType = {
-        PositionUpdate: 0x01,
-        VelocityUpdate: 0x02,
-        FullStateUpdate: 0x03
+        PositionVelocityUpdate: 0x01
     } as const;
 
     private handleBinaryMessage(buffer: ArrayBuffer): void {
         try {
+            if (!buffer || buffer.byteLength < 8) {
+                throw new Error(`Invalid buffer size: ${buffer?.byteLength ?? 0} bytes`);
+            }
+
             const dataView = new DataView(buffer);
             let offset = 0;
 
@@ -192,86 +237,183 @@ export class WebSocketService {
             const messageType = dataView.getUint32(offset, true);
             offset += 4;
 
-            if (messageType !== this.MessageType.FullStateUpdate) {
-                logger.warn('Unexpected binary message type:', messageType);
+            if (messageType !== this.MessageType.PositionVelocityUpdate) {
+                logger.warn('Unexpected binary message type:', {
+                    received: messageType,
+                    expected: this.MessageType.PositionVelocityUpdate,
+                    bufferSize: buffer.byteLength
+                });
                 return;
             }
 
-            // Read node count
+            // Read and validate node count
             const nodeCount = dataView.getUint32(offset, true);
             offset += 4;
 
-            logger.debug(`Processing binary update with ${nodeCount} nodes`);
+            // Validate total message size
+            const expectedSize = 8 + (nodeCount * 28); // 8 bytes header + 28 bytes per node
+            if (buffer.byteLength !== expectedSize) {
+                throw new Error(`Invalid buffer size: ${buffer.byteLength} bytes (expected ${expectedSize})`);
+            }
+
+            logger.debug('Processing binary update:', {
+                nodeCount,
+                messageType,
+                bufferSize: buffer.byteLength
+            });
+
             const nodes: NodeData[] = [];
             
             // Read node data
             for (let i = 0; i < nodeCount; i++) {
-                // Read node ID
-                const id = dataView.getUint32(offset, true);
-                offset += 4;
-
-                // Read position vector
-                const position: [number, number, number] = [
-                    dataView.getFloat32(offset, true),
-                    dataView.getFloat32(offset + 4, true),
-                    dataView.getFloat32(offset + 8, true)
-                ];
-                offset += 12;
-
-                // Read velocity vector
-                const velocity: [number, number, number] = [
-                    dataView.getFloat32(offset, true),
-                    dataView.getFloat32(offset + 4, true),
-                    dataView.getFloat32(offset + 8, true)
-                ];
-                offset += 12;
-
-                nodes.push({ id, position, velocity });
+                try {
+                    // Read node ID
+                    const id = dataView.getUint32(offset, true);
+                    offset += 4;
+
+                    // Read position vector
+                    const position: [number, number, number] = [
+                        dataView.getFloat32(offset, true),
+                        dataView.getFloat32(offset + 4, true),
+                        dataView.getFloat32(offset + 8, true)
+                    ];
+                    offset += 12;
+
+                    // Read velocity vector
+                    const velocity: [number, number, number] = [
+                        dataView.getFloat32(offset, true),
+                        dataView.getFloat32(offset + 4, true),
+                        dataView.getFloat32(offset + 8, true)
+                    ];
+                    offset += 12;
+
+                    // Validate node data
+                    if (position.some(isNaN) || velocity.some(isNaN)) {
+                        throw new Error(`Invalid node data at index ${i}: NaN values detected`);
+                    }
+
+                    nodes.push({ id, position, velocity });
+                } catch (nodeError) {
+                    logger.error('Error processing node:', {
+                        error: nodeError,
+                        nodeIndex: i,
+                        offset,
+                        bufferSize: buffer.byteLength
+                    });
+                    // Continue processing other nodes
+                }
             }
 
-            // Notify callback if registered
-            if (this.binaryMessageCallback) {
-                logger.debug('Notifying callback with', nodes.length, 'nodes');
-                this.binaryMessageCallback(nodes);
+            if (nodes.length > 0) {
+                // Notify callback if registered
+                if (this.binaryMessageCallback) {
+                    logger.debug('Notifying callback:', {
+                        nodeCount: nodes.length,
+                        firstNode: nodes[0],
+                        lastNode: nodes[nodes.length - 1]
+                    });
+                    try {
+                        this.binaryMessageCallback(nodes);
+                    } catch (error) {
+                        logger.error('Error in binary message callback:', {
+                            error,
+                            nodeCount: nodes.length,
+                            connectionState: this.connectionState
+                        });
+                    }
+                }
+            } else {
+                logger.warn('No valid nodes processed from binary message');
             }
-        } catch (e) {
-            logger.error('Failed to process binary message:', e);
+        } catch (error) {
+            logger.error('Failed to process binary message:', {
+                error,
+                bufferSize: buffer?.byteLength,
+                connectionState: this.connectionState
+            });
         }
     }
 
     private handleReconnect(): void {
-        const wasConnected = this.connectionState === ConnectionState.CONNECTED;
-        this.connectionState = ConnectionState.DISCONNECTED;
-        this.binaryMessageCallback = null;
-        
-        if (this.reconnectTimeout !== null) {
-            window.clearTimeout(this.reconnectTimeout);
-        }
-        
-        if (this.reconnectAttempts < this._maxReconnectAttempts &&
-            (wasConnected || this.reconnectAttempts === 0)) {
-            
-            this.reconnectAttempts++;
-            const delay = this.getReconnectDelay();
-            
-            logger.info(
-                `WebSocket connection closed, attempt ${this.reconnectAttempts}/${this._maxReconnectAttempts} in ${delay}ms`
-            );
+        try {
+            const wasConnected = this.connectionState === ConnectionState.CONNECTED;
+            const previousState = this.connectionState;
             
-            this.connectionState = ConnectionState.RECONNECTING;
+            logger.debug('Handling reconnect:', {
+                wasConnected,
+                previousState,
+                attempts: this.reconnectAttempts,
+                maxAttempts: this._maxReconnectAttempts,
+                url: this.url
+            });
+
+            this.connectionState = ConnectionState.DISCONNECTED;
+            this.binaryMessageCallback = null;
             
-            this.reconnectTimeout = window.setTimeout(() => {
+            if (this.reconnectTimeout !== null) {
+                window.clearTimeout(this.reconnectTimeout);
                 this.reconnectTimeout = null;
-                this.connect();
-            }, delay);
-        } else if (this.reconnectAttempts >= this._maxReconnectAttempts) {
-            logger.warn('Maximum reconnection attempts reached, WebSocket disabled');
-            this.connectionState = ConnectionState.FAILED;
-            if (this.connectionStatusHandler) {
+            }
+            
+            if (this.reconnectAttempts < this._maxReconnectAttempts &&
+                (wasConnected || this.reconnectAttempts === 0)) {
+                
+                this.reconnectAttempts++;
+                const delay = this.getReconnectDelay();
+                
+                logger.info('Scheduling reconnection:', {
+                    attempt: this.reconnectAttempts,
+                    maxAttempts: this._maxReconnectAttempts,
+                    delay,
+                    url: this.url
+                });
+                
+                this.connectionState = ConnectionState.RECONNECTING;
+                
+                this.reconnectTimeout = window.setTimeout(() => {
+                    try {
+                        this.reconnectTimeout = null;
+                        this.connect();
+                    } catch (error) {
+                        logger.error('Failed to initiate reconnection:', {
+                            error,
+                            attempts: this.reconnectAttempts,
+                            state: this.connectionState
+                        });
+                        this.handleReconnectFailure();
+                    }
+                }, delay);
+            } else if (this.reconnectAttempts >= this._maxReconnectAttempts) {
+                logger.warn('Maximum reconnection attempts reached:', {
+                    attempts: this.reconnectAttempts,
+                    maxAttempts: this._maxReconnectAttempts,
+                    url: this.url
+                });
+                this.handleReconnectFailure();
+            } else {
+                logger.info('WebSocket connection closed without reconnection', {
+                    wasConnected,
+                    attempts: this.reconnectAttempts
+                });
+            }
+        } catch (error) {
+            logger.error('Critical error in reconnect handler:', {
+                error,
+                connectionState: this.connectionState,
+                attempts: this.reconnectAttempts
+            });
+            this.handleReconnectFailure();
+        }
+    }
+
+    private handleReconnectFailure(): void {
+        this.connectionState = ConnectionState.FAILED;
+        if (this.connectionStatusHandler) {
+            try {
                 this.connectionStatusHandler(false);
+            } catch (error) {
+                logger.error('Error in connection status handler during failure:', error);
             }
-        } else {
-            logger.info('WebSocket connection closed');
         }
     }
 
@@ -366,7 +508,7 @@ export class WebSocketService {
         let offset = 0;
 
         // Write message type (PositionUpdate)
-        dataView.setUint32(offset, this.MessageType.PositionUpdate, true);
+        dataView.setUint32(offset, this.MessageType.PositionVelocityUpdate, true);
         offset += 4;
 
         // Write node count
diff --git a/client/xr/xrSessionManager.ts b/client/xr/xrSessionManager.ts
index b9c75028..7976b5c4 100644
--- a/client/xr/xrSessionManager.ts
+++ b/client/xr/xrSessionManager.ts
@@ -20,6 +20,7 @@ import { createLogger } from '../core/utils';
 import { platformManager } from '../platform/platformManager';
 import { SceneManager } from '../rendering/scene';
 import { BACKGROUND_COLOR } from '../core/constants';
+import { ControlPanel } from '../ui/ControlPanel';
 
 const _logger = createLogger('XRSessionManager');
 
@@ -251,6 +252,12 @@ export class XRSessionManager {
             this.isPresenting = true;
             _logger.log('XR session initialized');
 
+            // Hide control panel in XR mode
+            const controlPanel = ControlPanel.getInstance();
+            if (controlPanel) {
+                controlPanel.hide();
+            }
+
             // Notify session start
             if (this.xrSessionStartCallback) {
                 this.xrSessionStartCallback();
@@ -302,6 +309,12 @@ export class XRSessionManager {
 
         _logger.log('XR session ended');
 
+        // Show control panel again
+        const controlPanel = ControlPanel.getInstance();
+        if (controlPanel) {
+            controlPanel.show();
+        }
+
         // Notify session end
         if (this.xrSessionEndCallback) {
             this.xrSessionEndCallback();
diff --git a/docker-compose.yml b/docker-compose.yml
index 351f32c5..12f1f109 100755
--- a/docker-compose.yml
+++ b/docker-compose.yml
@@ -34,6 +34,7 @@ services:
       - NVIDIA_VISIBLE_DEVICES=${NVIDIA_GPU_UUID:-0}  # Use GPU UUID from launch script
       - NVIDIA_DRIVER_CAPABILITIES=compute,utility
       - NODE_ENV=production
+      - SETTINGS_FILE_PATH=/app/settings.toml
     env_file:
       - .env
     volumes:
diff --git a/settings.toml b/settings.toml
index fde0c59f..0ca6d3e6 100644
--- a/settings.toml
+++ b/settings.toml
@@ -135,6 +135,47 @@ enable_websocket_debug = true
 log_binary_headers = true
 log_full_json = true
 
+# XR settings
+[xr]
+mode = "immersive-ar"
+room_scale = true
+space_type = "local-floor"
+
+enable_hand_tracking = true
+hand_mesh_enabled = true
+hand_mesh_color = "#ffffff"
+hand_mesh_opacity = 0.5
+hand_point_size = 5.0
+hand_ray_enabled = true
+hand_ray_color = "#00ff00"
+hand_ray_width = 2.0
+gesture_smoothing = 0.5
+
+enable_haptics = true
+haptic_intensity = 0.5
+drag_threshold = 0.02
+pinch_threshold = 0.7
+rotation_threshold = 0.1
+interaction_radius = 0.5
+
+enable_light_estimation = true
+enable_plane_detection = true
+enable_scene_understanding = true
+plane_color = "#808080"
+plane_opacity = 0.5
+show_plane_overlay = true
+snap_to_floor = true
+
+enable_passthrough_portal = false
+passthrough_opacity = 1.0
+passthrough_brightness = 1.0
+passthrough_contrast = 1.0
+portal_size = 2.0
+portal_edge_color = "#ffffff"
+portal_edge_width = 2.0
+
+quality = "medium"
+
 # Server-only settings
 [github]
 rate_limit = true
diff --git a/src/config.rs b/src/config.rs
index f16ae3ca..50e8e6de 100755
--- a/src/config.rs
+++ b/src/config.rs
@@ -2,6 +2,7 @@ use serde::{Deserialize, Serialize};
 use config::{ConfigBuilder, ConfigError, Environment, File};
 use log::{debug, info};
 use std::path::PathBuf;
+use serde_json::Value;
 
 #[derive(Debug, Serialize, Deserialize, Clone)]
 #[serde(rename_all = "snake_case")]
@@ -24,6 +25,10 @@ pub struct Settings {
     #[serde(default)]
     pub hologram: HologramSettings,
 
+    // XR settings
+    #[serde(default)]
+    pub xr: XRSettings,
+
     // System settings
     #[serde(default)]
     pub network: NetworkSettings,
@@ -622,7 +627,194 @@ impl Default for HologramSettings {
     }
 }
 
+#[derive(Debug, Serialize, Deserialize, Clone)]
+#[serde(rename_all = "snake_case")]
+#[serde(default)]
+pub struct XRSettings {
+    // Session Settings
+    pub mode: String,
+    pub room_scale: bool,
+    pub space_type: String,
+    
+    // Hand Tracking
+    pub enable_hand_tracking: bool,
+    pub hand_mesh_enabled: bool,
+    pub hand_mesh_color: String,
+    pub hand_mesh_opacity: f32,
+    pub hand_point_size: f32,
+    pub hand_ray_enabled: bool,
+    pub hand_ray_color: String,
+    pub hand_ray_width: f32,
+    pub gesture_smoothing: f32,
+    
+    // Interaction
+    pub enable_haptics: bool,
+    pub haptic_intensity: f32,
+    pub drag_threshold: f32,
+    pub pinch_threshold: f32,
+    pub rotation_threshold: f32,
+    pub interaction_radius: f32,
+    
+    // Scene Understanding
+    pub enable_light_estimation: bool,
+    pub enable_plane_detection: bool,
+    pub enable_scene_understanding: bool,
+    pub plane_color: String,
+    pub plane_opacity: f32,
+    pub show_plane_overlay: bool,
+    pub snap_to_floor: bool,
+    
+    // Passthrough
+    pub enable_passthrough_portal: bool,
+    pub passthrough_opacity: f32,
+    pub passthrough_brightness: f32,
+    pub passthrough_contrast: f32,
+    pub portal_size: f32,
+    pub portal_edge_color: String,
+    pub portal_edge_width: f32,
+    
+    // Quality Settings
+    pub quality: String,
+}
+
+impl Default for XRSettings {
+    fn default() -> Self {
+        Self {
+            mode: "immersive-ar".to_string(),
+            room_scale: true,
+            space_type: "local-floor".to_string(),
+            
+            enable_hand_tracking: true,
+            hand_mesh_enabled: true,
+            hand_mesh_color: "#ffffff".to_string(),
+            hand_mesh_opacity: 0.5,
+            hand_point_size: 5.0,
+            hand_ray_enabled: true,
+            hand_ray_color: "#00ff00".to_string(),
+            hand_ray_width: 2.0,
+            gesture_smoothing: 0.5,
+            
+            enable_haptics: true,
+            haptic_intensity: 0.5,
+            drag_threshold: 0.02,
+            pinch_threshold: 0.7,
+            rotation_threshold: 0.1,
+            interaction_radius: 0.5,
+            
+            enable_light_estimation: true,
+            enable_plane_detection: true,
+            enable_scene_understanding: true,
+            plane_color: "#808080".to_string(),
+            plane_opacity: 0.5,
+            show_plane_overlay: true,
+            snap_to_floor: true,
+            
+            enable_passthrough_portal: false,
+            passthrough_opacity: 1.0,
+            passthrough_brightness: 1.0,
+            passthrough_contrast: 1.0,
+            portal_size: 2.0,
+            portal_edge_color: "#ffffff".to_string(),
+            portal_edge_width: 2.0,
+            
+            quality: "medium".to_string(),
+        }
+    }
+}
+
 impl Settings {
+    pub fn merge(&mut self, value: Value) -> Result<(), String> {
+        // Convert incoming JSON value to snake_case
+        let snake_case_value = self.to_snake_case_value(value);
+        
+        // Deserialize the value into a temporary Settings
+        let new_settings: Settings = serde_json::from_value(snake_case_value)
+            .map_err(|e| format!("Failed to deserialize settings: {}", e))?;
+        
+        // Update only the fields that were present in the input
+        // This preserves existing values for fields that weren't included in the update
+        if let Ok(nodes) = serde_json::to_value(&new_settings.nodes) {
+            if !nodes.is_null() {
+                self.nodes = new_settings.nodes;
+            }
+        }
+        if let Ok(edges) = serde_json::to_value(&new_settings.edges) {
+            if !edges.is_null() {
+                self.edges = new_settings.edges;
+            }
+        }
+        if let Ok(physics) = serde_json::to_value(&new_settings.physics) {
+            if !physics.is_null() {
+                self.physics = new_settings.physics;
+            }
+        }
+        if let Ok(rendering) = serde_json::to_value(&new_settings.rendering) {
+            if !rendering.is_null() {
+                self.rendering = new_settings.rendering;
+            }
+        }
+        if let Ok(animations) = serde_json::to_value(&new_settings.animations) {
+            if !animations.is_null() {
+                self.animations = new_settings.animations;
+            }
+        }
+        if let Ok(labels) = serde_json::to_value(&new_settings.labels) {
+            if !labels.is_null() {
+                self.labels = new_settings.labels;
+            }
+        }
+        if let Ok(bloom) = serde_json::to_value(&new_settings.bloom) {
+            if !bloom.is_null() {
+                self.bloom = new_settings.bloom;
+            }
+        }
+        if let Ok(hologram) = serde_json::to_value(&new_settings.hologram) {
+            if !hologram.is_null() {
+                self.hologram = new_settings.hologram;
+            }
+        }
+        if let Ok(xr) = serde_json::to_value(&new_settings.xr) {
+            if !xr.is_null() {
+                self.xr = new_settings.xr;
+            }
+        }
+        
+        Ok(())
+    }
+
+    pub fn save(&self) -> Result<(), String> {
+        let settings_path = std::env::var("SETTINGS_FILE_PATH")
+            .map(PathBuf::from)
+            .unwrap_or_else(|_| PathBuf::from("/app/settings.toml"));
+            
+        // Convert to TOML
+        let toml = toml::to_string(&self)
+            .map_err(|e| format!("Failed to serialize settings to TOML: {}", e))?;
+            
+        // Write to file
+        std::fs::write(&settings_path, toml)
+            .map_err(|e| format!("Failed to write settings file: {}", e))?;
+            
+        Ok(())
+    }
+
+    fn to_snake_case_value(&self, value: Value) -> Value {
+        match value {
+            Value::Object(map) => {
+                let converted: serde_json::Map<String, Value> = map
+                    .into_iter()
+                    .map(|(k, v)| {
+                        let snake_case_key = crate::utils::case_conversion::to_snake_case(&k);
+                        (snake_case_key, self.to_snake_case_value(v))
+                    })
+                    .collect();
+                Value::Object(converted)
+            },
+            Value::Array(arr) => Value::Array(arr.into_iter().map(|v| self.to_snake_case_value(v)).collect()),
+            _ => value,
+        }
+    }
+
     pub fn new() -> Result<Self, ConfigError> {
         debug!("Initializing settings");
         
@@ -708,6 +900,7 @@ impl Default for Settings {
             ragflow: RagFlowSettings::default(),
             perplexity: PerplexitySettings::default(),
             openai: OpenAISettings::default(),
+            xr: XRSettings::default(),
         }
     }
 }
diff --git a/src/handlers/api_handler/mod.rs b/src/handlers/api_handler/mod.rs
index 417f9d9e..6f17e0d6 100644
--- a/src/handlers/api_handler/mod.rs
+++ b/src/handlers/api_handler/mod.rs
@@ -27,6 +27,6 @@ pub fn config(cfg: &mut web::ServiceConfig) {
             .configure(files::config)
             .configure(graph::config)
             .configure(visualization::config)
-            .service(web::scope("/settings").configure(crate::handlers::settings_handler::config))
+            .configure(crate::handlers::settings_handler::config)
     );
 }
diff --git a/src/handlers/settings_handler.rs b/src/handlers/settings_handler.rs
index a486a378..488683f7 100644
--- a/src/handlers/settings_handler.rs
+++ b/src/handlers/settings_handler.rs
@@ -1,13 +1,22 @@
-use actix_web::{web, HttpResponse, Result, Error};
-use crate::AppState;
-use serde_json::json;
+use actix_web::{web, HttpResponse, Error};
+use serde_json::{Value, json};
+use std::sync::Arc;
+
+use crate::app_state::AppState;
 use crate::utils::case_conversion::to_camel_case;
-use serde::{Deserialize, Serialize};
 
-pub async fn get_settings(app_state: web::Data<AppState>) -> Result<HttpResponse> {
-    let settings = app_state.settings.read().await;
+pub fn config(cfg: &mut web::ServiceConfig) {
+    cfg.service(
+        web::resource("/settings")
+            .route(web::get().to(get_settings))
+            .route(web::post().to(update_settings))
+    );
+}
+
+async fn get_settings(state: web::Data<Arc<AppState>>) -> Result<HttpResponse, Error> {
+    let settings = state.settings.read().await;
     
-    // Transform settings using existing case conversion
+    // Transform settings using explicit structure
     let client_settings = json!({
         "visualization": {
             "nodes": convert_struct_to_camel_case(&settings.nodes),
@@ -29,6 +38,43 @@ pub async fn get_settings(app_state: web::Data<AppState>) -> Result<HttpResponse
     Ok(HttpResponse::Ok().json(client_settings))
 }
 
+async fn update_settings(
+    state: web::Data<Arc<AppState>>,
+    payload: web::Json<Value>
+) -> Result<HttpResponse, Error> {
+    // Validate the incoming settings
+    if let Err(e) = validate_settings(&payload) {
+        return Ok(HttpResponse::BadRequest().body(format!("Invalid settings: {}", e)));
+    }
+
+    // Get write lock and dereference to access Settings methods
+    let mut settings_guard = state.settings.write().await;
+    let settings = &mut *settings_guard;
+    
+    // Merge the new settings with existing ones
+    if let Err(e) = settings.merge(payload.into_inner()) {
+        return Ok(HttpResponse::BadRequest().body(format!("Failed to merge settings: {}", e)));
+    }
+    
+    // Save the updated settings
+    if let Err(e) = settings.save() {
+        return Ok(HttpResponse::InternalServerError().body(format!("Failed to save settings: {}", e)));
+    }
+    
+    // Convert settings to camelCase for client response
+    let client_settings = convert_struct_to_camel_case(settings);
+    Ok(HttpResponse::Ok().json(client_settings))
+}
+
+fn validate_settings(settings: &Value) -> Result<(), String> {
+    // Add validation logic here
+    // For now, just ensure it's an object
+    if !settings.is_object() {
+        return Err("Settings must be an object".to_string());
+    }
+    Ok(())
+}
+
 // Helper function to convert struct fields to camelCase
 fn convert_struct_to_camel_case<T: serde::Serialize>(value: &T) -> serde_json::Value {
     let json_value = serde_json::to_value(value).unwrap_or_default();
@@ -44,38 +90,18 @@ fn convert_struct_to_camel_case<T: serde::Serialize>(value: &T) -> serde_json::V
     }
 }
 
-pub async fn get_graph_settings(app_state: web::Data<AppState>) -> Result<HttpResponse> {
+pub async fn get_graph_settings(app_state: web::Data<AppState>) -> Result<HttpResponse, Error> {
     let settings = app_state.settings.read().await;
-    Ok(HttpResponse::Ok().json(json!({
+    
+    // Create visualization settings object and convert to camelCase
+    let visualization = json!({
         "visualization": {
-            "nodes": settings.nodes,
-            "edges": settings.edges,
-            "physics": settings.physics,
-            "labels": settings.labels
+            "nodes": convert_struct_to_camel_case(&settings.nodes),
+            "edges": convert_struct_to_camel_case(&settings.edges),
+            "physics": convert_struct_to_camel_case(&settings.physics),
+            "labels": convert_struct_to_camel_case(&settings.labels)
         }
-    })))
-}
-
-pub fn config(cfg: &mut web::ServiceConfig) {
-    cfg.service(
-        web::resource("")
-            .route(web::get().to(get_settings))
-    ).service(
-        web::resource("/graph")
-            .route(web::get().to(get_graph_settings))
-    );
-}
-
-#[derive(Debug, Serialize, Deserialize)]
-pub struct SettingsUpdate {
-    pub path: String,
-    pub value: serde_json::Value,
-}
-
-pub async fn update_settings(
-    _app_state: web::Data<AppState>,
-    _updates: web::Json<Vec<SettingsUpdate>>,
-) -> Result<HttpResponse, Error> {
-    // Implementation
-    Ok(HttpResponse::Ok().json(json!({ "status": "success" })))
-} 
\ No newline at end of file
+    });
+    
+    Ok(HttpResponse::Ok().json(visualization))
+}
\ No newline at end of file
diff --git a/src/handlers/socket_flow_handler.rs b/src/handlers/socket_flow_handler.rs
index 0f450a25..4756edcf 100644
--- a/src/handlers/socket_flow_handler.rs
+++ b/src/handlers/socket_flow_handler.rs
@@ -146,32 +146,32 @@ impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for SocketFlowServer
                                         // Only process and send updates if we have nodes
                                         if !raw_nodes.is_empty() {
                                             debug!("Processing binary update for {} nodes", raw_nodes.len());
-                                            let nodes: Vec<NodeData> = raw_nodes.into_iter()
-                                                .map(|node| NodeData {
-                                                    id: node.id.parse().unwrap_or(0),
-                                                    position: Vec3::new(
-                                                        node.data.position[0],
-                                                        node.data.position[1],
-                                                        node.data.position[2]
-                                                    ),
-                                                    velocity: Vec3::new(
-                                                        node.data.velocity[0],
-                                                        node.data.velocity[1],
-                                                        node.data.velocity[2]
-                                                    ),
-                                                })
+                                let nodes: Vec<NodeData> = raw_nodes.into_iter()
+                                    .map(|node| NodeData {
+                                        id: node.id.parse().unwrap_or(0),
+                                        position: Vec3::new(
+                                            node.data.position[0],
+                                            node.data.position[1],
+                                            node.data.position[2]
+                                        ),
+                                        velocity: Vec3::new(
+                                            node.data.velocity[0],
+                                            node.data.velocity[1],
+                                            node.data.velocity[2]
+                                        ),
+                                    })
                                                 .collect::<Vec<_>>();
                                             
                                             debug!("Encoding binary update with {} nodes", nodes.len());
-                                            let data = binary_protocol::encode_node_data(&nodes, MessageType::FullStateUpdate);
+                                            let data = binary_protocol::encode_node_data(&nodes, MessageType::PositionVelocityUpdate);
                                             debug!("Binary message size: {} bytes", data.len());
                                             Some(data)
-                                        } else {
+                                } else {
                                             debug!("No nodes to update, skipping binary message");
-                                            None
-                                        }
-                                    };
-                                    
+                                    None
+                                }
+                            };
+                            
                                     let fut = fut.into_actor(actor);
                                     ctx.spawn(fut.map(|maybe_binary_data, actor, ctx| {
                                         if let Some(binary_data) = maybe_binary_data {
@@ -207,34 +207,34 @@ impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for SocketFlowServer
                 match binary_protocol::decode_node_data(&data) {
                     Ok((msg_type, nodes)) => {
                         if nodes.len() <= 2 { // Only allow updates for up to 2 nodes during interaction
-                            match msg_type {
-                                MessageType::PositionUpdate | MessageType::VelocityUpdate => {
+                    match msg_type {
+                                MessageType::PositionVelocityUpdate => {
                                     // Update positions in graph service for interacted nodes
-                                    let app_state = self.app_state.clone();
+                            let app_state = self.app_state.clone();
                                     let nodes_clone = nodes.clone();
                                     
                                     // Spawn a future to update the graph data
-                                    let fut = async move {
-                                        let mut graph = app_state.graph_service.graph_data.write().await;
+                            let fut = async move {
+                                let mut graph = app_state.graph_service.graph_data.write().await;
                                         for node_data in nodes_clone {
-                                            if let Some(node) = graph.nodes.iter_mut().find(|n| n.id.parse::<u32>().unwrap_or(0) == node_data.id) {
+                                    if let Some(node) = graph.nodes.iter_mut().find(|n| n.id.parse::<u32>().unwrap_or(0) == node_data.id) {
                                                 // Update position and velocity from user interaction
-                                                node.data.position = [
-                                                    node_data.position.x,
-                                                    node_data.position.y,
-                                                    node_data.position.z
-                                                ];
-                                                node.data.velocity = [
-                                                    node_data.velocity.x,
-                                                    node_data.velocity.y,
-                                                    node_data.velocity.z
-                                                ];
-                                            }
-                                        }
-                                    };
+                                        node.data.position = [
+                                            node_data.position.x,
+                                            node_data.position.y,
+                                            node_data.position.z
+                                        ];
+                                        node.data.velocity = [
+                                            node_data.velocity.x,
+                                            node_data.velocity.y,
+                                            node_data.velocity.z
+                                        ];
+                                    }
+                                }
+                            };
                                     
-                                    let fut = fut.into_actor(self);
-                                    ctx.spawn(fut.map(|_, _, _| ()));
+                            let fut = fut.into_actor(self);
+                            ctx.spawn(fut.map(|_, _, _| ()));
                                 }
                                 _ => warn!("Unexpected message type")
                             }
diff --git a/src/utils/binary_protocol.rs b/src/utils/binary_protocol.rs
index 80c3d754..827a4841 100644
--- a/src/utils/binary_protocol.rs
+++ b/src/utils/binary_protocol.rs
@@ -1,11 +1,9 @@
 use byteorder::{ByteOrder, LittleEndian};
 use glam::Vec3;
 
-#[derive(Debug)]
+#[derive(Debug, Clone, Copy)]
 pub enum MessageType {
-    PositionUpdate = 0x01,
-    VelocityUpdate = 0x02,
-    FullStateUpdate = 0x03,
+    PositionVelocityUpdate = 0x01,
 }
 
 impl TryFrom<u32> for MessageType {
@@ -13,9 +11,7 @@ impl TryFrom<u32> for MessageType {
 
     fn try_from(value: u32) -> Result<Self, Self::Error> {
         match value {
-            0x01 => Ok(MessageType::PositionUpdate),
-            0x02 => Ok(MessageType::VelocityUpdate),
-            0x03 => Ok(MessageType::FullStateUpdate),
+            0x01 => Ok(MessageType::PositionVelocityUpdate),
             _ => Err(format!("Invalid message type: {}", value)),
         }
     }
@@ -146,10 +142,10 @@ mod tests {
             },
         ];
 
-        let encoded = encode_node_data(&nodes, MessageType::FullStateUpdate);
+        let encoded = encode_node_data(&nodes, MessageType::PositionVelocityUpdate);
         let (msg_type, decoded) = decode_node_data(&encoded).unwrap();
 
-        assert!(matches!(msg_type, MessageType::FullStateUpdate));
+        assert!(matches!(msg_type, MessageType::PositionVelocityUpdate));
         assert_eq!(nodes.len(), decoded.len());
 
         for (original, decoded) in nodes.iter().zip(decoded.iter()) {
