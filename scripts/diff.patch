diff --git a/.env_template b/.env_template
index cb16fb63..077b6c6f 100755
--- a/.env_template
+++ b/.env_template
@@ -44,9 +44,3 @@ OPENAI_BASE_URL=wss://api.openai.com/v1/realtime
 OPENAI_TIMEOUT=30
 OPENAI_RATE_LIMIT=100
 
-# Nostr Authentication Configuration
-NOSTR_POWER_USER_PUBKEYS=           # Comma-separated list of power user pubkeys
-NOSTR_TOKEN_EXPIRY=3600            # Token expiry in seconds (default 1 hour)
-NOSTR_TOKEN_SECRET=                 # Secret for signing auth tokens
-NOSTR_MIN_RELAY_COUNT=2            # Minimum number of relays to verify events
-NOSTR_CHALLENGE_TIMEOUT=300        # Challenge timeout in seconds (default 5 minutes)
diff --git a/Cargo.lock b/Cargo.lock
index 26a5eaa0..ac1eb45f 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -290,17 +290,6 @@ version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "512761e0bb2578dd7380c6baaa0f4ce03e84f95e960231d1dec8bf4d7d6e2627"
 
-[[package]]
-name = "aes"
-version = "0.8.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b169f7a6d4742236a0a00c541b845991d0ac43e546831af1249753ab4c3aa3a0"
-dependencies = [
- "cfg-if",
- "cipher",
- "cpufeatures",
-]
-
 [[package]]
 name = "ahash"
 version = "0.7.8"
@@ -465,29 +454,6 @@ dependencies = [
  "syn 2.0.96",
 ]
 
-[[package]]
-name = "async-utility"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3716c0d3970fe92d79a8f4cda2caf91113574505dff5b18e455e549d4b078e98"
-dependencies = [
- "futures-util",
- "gloo-timers",
- "tokio",
- "wasm-bindgen-futures",
-]
-
-[[package]]
-name = "async_io_stream"
-version = "0.3.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b6d7b9decdf35d8908a7e3ef02f64c5e9b1695e230154c0e8de3969142d9b94c"
-dependencies = [
- "futures",
- "pharos",
- "rustc_version",
-]
-
 [[package]]
 name = "autocfg"
 version = "1.4.0"
@@ -541,23 +507,6 @@ version = "0.22.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"
 
-[[package]]
-name = "bech32"
-version = "0.9.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d86b93f97252c47b41663388e6d155714a9d0c398b99f1005cbc5f978b29f445"
-
-[[package]]
-name = "bip39"
-version = "2.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "33415e24172c1b7d6066f6d999545375ab8e1d95421d6784bdfff9496f292387"
-dependencies = [
- "bitcoin_hashes 0.13.0",
- "serde",
- "unicode-normalization",
-]
-
 [[package]]
 name = "bit-set"
 version = "0.5.3"
@@ -573,52 +522,6 @@ version = "0.6.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "349f9b6a179ed607305526ca489b34ad0a41aed5f7980fa90eb03160b69598fb"
 
-[[package]]
-name = "bitcoin"
-version = "0.30.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1945a5048598e4189e239d3f809b19bdad4845c4b2ba400d304d2dcf26d2c462"
-dependencies = [
- "bech32",
- "bitcoin-private",
- "bitcoin_hashes 0.12.0",
- "hex_lit",
- "secp256k1 0.27.0",
- "serde",
-]
-
-[[package]]
-name = "bitcoin-internals"
-version = "0.2.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9425c3bf7089c983facbae04de54513cce73b41c7f9ff8c845b54e7bc64ebbfb"
-
-[[package]]
-name = "bitcoin-private"
-version = "0.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "73290177011694f38ec25e165d0387ab7ea749a4b81cd4c80dae5988229f7a57"
-
-[[package]]
-name = "bitcoin_hashes"
-version = "0.12.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5d7066118b13d4b20b23645932dfb3a81ce7e29f95726c2036fa33cd7b092501"
-dependencies = [
- "bitcoin-private",
- "serde",
-]
-
-[[package]]
-name = "bitcoin_hashes"
-version = "0.13.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1930a4dabfebb8d7d9992db18ebe3ae2876f0a305fab206fd168df931ede293b"
-dependencies = [
- "bitcoin-internals",
- "hex-conservative",
-]
-
 [[package]]
 name = "bitflags"
 version = "1.3.2"
@@ -646,15 +549,6 @@ dependencies = [
  "generic-array",
 ]
 
-[[package]]
-name = "block-padding"
-version = "0.3.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a8894febbff9f758034a5b8e12d87918f56dfc64a8e1fe757d65e29041538d93"
-dependencies = [
- "generic-array",
-]
-
 [[package]]
 name = "brotli"
 version = "6.0.0"
@@ -723,15 +617,6 @@ dependencies = [
  "bytes",
 ]
 
-[[package]]
-name = "cbc"
-version = "0.1.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "26b52a9543ae338f279b96b0b9fed9c8093744685043739079ce85cd58f289a6"
-dependencies = [
- "cipher",
-]
-
 [[package]]
 name = "cc"
 version = "1.2.8"
@@ -749,17 +634,6 @@ version = "1.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
-[[package]]
-name = "chacha20"
-version = "0.9.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c3613f74bd2eac03dad61bd53dbe620703d4371614fe0bc3b9f04dd36fe4e818"
-dependencies = [
- "cfg-if",
- "cipher",
- "cpufeatures",
-]
-
 [[package]]
 name = "chrono"
 version = "0.4.39"
@@ -775,16 +649,6 @@ dependencies = [
  "windows-targets 0.52.6",
 ]
 
-[[package]]
-name = "cipher"
-version = "0.4.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "773f3b9af64447d2ce9850330c473515014aa235e6a783b02db81ff39e4a3dad"
-dependencies = [
- "crypto-common",
- "inout",
-]
-
 [[package]]
 name = "codespan-reporting"
 version = "0.11.1"
@@ -1327,10 +1191,8 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
 dependencies = [
  "cfg-if",
- "js-sys",
  "libc",
  "wasi",
- "wasm-bindgen",
 ]
 
 [[package]]
@@ -1345,18 +1207,6 @@ version = "0.24.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b5418c17512bdf42730f9032c74e1ae39afc408745ebb2acf72fbc4691c17945"
 
-[[package]]
-name = "gloo-timers"
-version = "0.2.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9b995a66bb87bebce9a0f4a95aed01daca4872c050bfcb21653361c03bc35e5c"
-dependencies = [
- "futures-channel",
- "futures-core",
- "js-sys",
- "wasm-bindgen",
-]
-
 [[package]]
 name = "glow"
 version = "0.12.3"
@@ -1480,24 +1330,6 @@ dependencies = [
  "winapi",
 ]
 
-[[package]]
-name = "hex"
-version = "0.4.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"
-
-[[package]]
-name = "hex-conservative"
-version = "0.1.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "212ab92002354b4819390025006c897e8140934349e8635c9b077f47b4dcbd20"
-
-[[package]]
-name = "hex_lit"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3011d1213f159867b13cfd6ac92d2cd5f1345762c63be3554e84092d85a50bbd"
-
 [[package]]
 name = "hexf-parse"
 version = "0.2.1"
@@ -1753,16 +1585,6 @@ version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39"
 
-[[package]]
-name = "idna"
-version = "0.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "634d9b1461af396cad843f47fdba5597a4f9e6ddd4bfb6ff5d85028c25cb12f6"
-dependencies = [
- "unicode-bidi",
- "unicode-normalization",
-]
-
 [[package]]
 name = "idna"
 version = "1.0.3"
@@ -1804,16 +1626,6 @@ dependencies = [
  "hashbrown 0.15.2",
 ]
 
-[[package]]
-name = "inout"
-version = "0.1.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a0c10553d664a4d0bcff9f4215d0aac67a639cc68ef660840afe309b807bc9f5"
-dependencies = [
- "block-padding",
- "generic-array",
-]
-
 [[package]]
 name = "instant"
 version = "0.1.13"
@@ -1821,9 +1633,6 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e0242819d153cba4b4b05a5a8f2a7e9bbf97b6055b2a002b395c96b5ff3c0222"
 dependencies = [
  "cfg-if",
- "js-sys",
- "wasm-bindgen",
- "web-sys",
 ]
 
 [[package]]
@@ -1877,21 +1686,6 @@ dependencies = [
  "serde",
 ]
 
-[[package]]
-name = "jsonwebtoken"
-version = "9.3.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b9ae10193d25051e74945f1ea2d0b42e03cc3b890f7e4cc5faa44997d808193f"
-dependencies = [
- "base64 0.21.7",
- "js-sys",
- "pem",
- "ring",
- "serde",
- "serde_json",
- "simple_asn1",
-]
-
 [[package]]
 name = "khronos-egl"
 version = "4.1.0"
@@ -2186,70 +1980,6 @@ version = "0.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "61807f77802ff30975e01f4f071c8ba10c022052f98b3294119f3e615d13e5be"
 
-[[package]]
-name = "nostr"
-version = "0.24.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "df0af088a37ea0026bf96dcd66db8bf21ed7ff528b7cbe34b7f32f6af3ae14a0"
-dependencies = [
- "aes",
- "base64 0.21.7",
- "bip39",
- "bitcoin",
- "cbc",
- "chacha20",
- "getrandom",
- "instant",
- "once_cell",
- "reqwest",
- "serde",
- "serde_json",
- "tracing",
- "url-fork",
-]
-
-[[package]]
-name = "nostr-sdk"
-version = "0.24.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5facab78c73baf3853f8c807006e23567dd3825392ef13a3a07122f4ce18b56d"
-dependencies = [
- "async-utility",
- "nostr",
- "nostr-sdk-net",
- "once_cell",
- "thiserror 1.0.69",
- "tokio",
- "tracing",
-]
-
-[[package]]
-name = "nostr-sdk-net"
-version = "0.24.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fa4058b0267a1537c25b4674db9ed7a18152fc4c33df246dd4a88701007084ee"
-dependencies = [
- "futures-util",
- "thiserror 1.0.69",
- "tokio",
- "tokio-rustls",
- "tokio-socks",
- "tokio-tungstenite 0.20.1",
- "url-fork",
- "webpki-roots",
- "ws_stream_wasm",
-]
-
-[[package]]
-name = "num-bigint"
-version = "0.4.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a5e44f723f1133c9deac646763579fdb3ac745e418f2a7af9cd0c431da1f20b9"
-dependencies = [
- "num-integer",
- "num-traits",
-]
-
 [[package]]
 name = "num-complex"
 version = "0.4.6"
@@ -2425,16 +2155,6 @@ version = "0.2.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "df94ce210e5bc13cb6651479fa48d14f601d9858cfe0467f43ae157023b938d3"
 
-[[package]]
-name = "pem"
-version = "3.0.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8e459365e590736a54c3fa561947c84837534b8e9af6fc5bf781307e82658fae"
-dependencies = [
- "base64 0.22.1",
- "serde",
-]
-
 [[package]]
 name = "percent-encoding"
 version = "2.3.1"
@@ -2496,16 +2216,6 @@ dependencies = [
  "indexmap 2.7.0",
 ]
 
-[[package]]
-name = "pharos"
-version = "0.5.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e9567389417feee6ce15dd6527a8a1ecac205ef62c2932bcf3d9f6fc5b78b414"
-dependencies = [
- "futures",
- "rustc_version",
-]
-
 [[package]]
 name = "pin-project-lite"
 version = "0.2.16"
@@ -2744,7 +2454,6 @@ dependencies = [
  "tokio",
  "tokio-native-tls",
  "tokio-rustls",
- "tokio-socks",
  "tokio-util",
  "tower-service",
  "url",
@@ -2752,7 +2461,6 @@ dependencies = [
  "wasm-bindgen-futures",
  "wasm-streams",
  "web-sys",
- "webpki-roots",
  "winreg",
 ]
 
@@ -2925,46 +2633,6 @@ dependencies = [
  "untrusted",
 ]
 
-[[package]]
-name = "secp256k1"
-version = "0.27.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "25996b82292a7a57ed3508f052cfff8640d38d32018784acd714758b43da9c8f"
-dependencies = [
- "bitcoin_hashes 0.12.0",
- "rand",
- "secp256k1-sys 0.8.1",
- "serde",
-]
-
-[[package]]
-name = "secp256k1"
-version = "0.28.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d24b59d129cdadea20aea4fb2352fa053712e5d713eee47d700cd4b2bc002f10"
-dependencies = [
- "rand",
- "secp256k1-sys 0.9.2",
-]
-
-[[package]]
-name = "secp256k1-sys"
-version = "0.8.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "70a129b9e9efbfb223753b9163c4ab3b13cff7fd9c7f010fbac25ab4099fa07e"
-dependencies = [
- "cc",
-]
-
-[[package]]
-name = "secp256k1-sys"
-version = "0.9.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e5d1746aae42c19d583c3c1a8c646bfad910498e2051c551a7f2e3c0c9fbb7eb"
-dependencies = [
- "cc",
-]
-
 [[package]]
 name = "security-framework"
 version = "2.11.1"
@@ -2994,12 +2662,6 @@ version = "1.0.24"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3cb6eb87a131f756572d7fb904f6e7b68633f09cca868c5df1c4b8d1a694bbba"
 
-[[package]]
-name = "send_wrapper"
-version = "0.6.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cd0b0ec5f1c1ca621c432a25813d8d60c88abe6d3e08a3eb9cf37d97a0fe3d73"
-
 [[package]]
 name = "serde"
 version = "1.0.217"
@@ -3125,18 +2787,6 @@ dependencies = [
  "wide",
 ]
 
-[[package]]
-name = "simple_asn1"
-version = "0.6.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "297f631f50729c8c99b84667867963997ec0b50f32b2a7dbcab828ef0541e8bb"
-dependencies = [
- "num-bigint",
- "num-traits",
- "thiserror 2.0.11",
- "time",
-]
-
 [[package]]
 name = "simplelog"
 version = "0.12.2"
@@ -3466,21 +3116,6 @@ dependencies = [
  "zerovec",
 ]
 
-[[package]]
-name = "tinyvec"
-version = "1.8.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "022db8904dfa342efe721985167e9fcd16c29b226db4397ed752a761cfce81e8"
-dependencies = [
- "tinyvec_macros",
-]
-
-[[package]]
-name = "tinyvec_macros"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"
-
 [[package]]
 name = "tokio"
 version = "1.43.0"
@@ -3530,18 +3165,6 @@ dependencies = [
  "tokio",
 ]
 
-[[package]]
-name = "tokio-socks"
-version = "0.5.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0d4770b8024672c1101b3f6733eab95b18007dbe0847a8afe341fcf79e06043f"
-dependencies = [
- "either",
- "futures-util",
- "thiserror 1.0.69",
- "tokio",
-]
-
 [[package]]
 name = "tokio-stream"
 version = "0.1.17"
@@ -3566,21 +3189,6 @@ dependencies = [
  "tokio-stream",
 ]
 
-[[package]]
-name = "tokio-tungstenite"
-version = "0.20.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "212d5dcb2a1ce06d81107c3d0ffa3121fe974b73f068c8282cb1c32328113b6c"
-dependencies = [
- "futures-util",
- "log",
- "rustls",
- "tokio",
- "tokio-rustls",
- "tungstenite 0.20.1",
- "webpki-roots",
-]
-
 [[package]]
 name = "tokio-tungstenite"
 version = "0.21.0"
@@ -3590,7 +3198,7 @@ dependencies = [
  "futures-util",
  "log",
  "tokio",
- "tungstenite 0.21.0",
+ "tungstenite",
 ]
 
 [[package]]
@@ -3693,26 +3301,6 @@ version = "0.2.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e421abadd41a4225275504ea4d6566923418b7f05506fbc9c0fe86ba7396114b"
 
-[[package]]
-name = "tungstenite"
-version = "0.20.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9e3dac10fd62eaf6617d3a904ae222845979aec67c615d1c842b4002c7666fb9"
-dependencies = [
- "byteorder",
- "bytes",
- "data-encoding",
- "http 0.2.12",
- "httparse",
- "log",
- "rand",
- "rustls",
- "sha1",
- "thiserror 1.0.69",
- "url",
- "utf-8",
-]
-
 [[package]]
 name = "tungstenite"
 version = "0.21.0"
@@ -3756,27 +3344,12 @@ version = "2.8.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "75b844d17643ee918803943289730bec8aac480150456169e647ed0b576ba539"
 
-[[package]]
-name = "unicode-bidi"
-version = "0.3.18"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5c1cb5db39152898a79168971543b1cb5020dff7fe43c8dc468b0885f5e29df5"
-
 [[package]]
 name = "unicode-ident"
 version = "1.0.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "adb9e6ca4f869e1180728b7950e35922a7fc6397f7b641499e8f3ef06e50dc83"
 
-[[package]]
-name = "unicode-normalization"
-version = "0.1.22"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5c5713f0fc4b5db668a2ac63cdb7bb4469d8c9fed047b1d0292cc7b0ce2ba921"
-dependencies = [
- "tinyvec",
-]
-
 [[package]]
 name = "unicode-width"
 version = "0.1.14"
@@ -3808,22 +3381,10 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "32f8b686cadd1473f4bd0117a5d28d36b1ade384ea9b5069a1c40aefed7fda60"
 dependencies = [
  "form_urlencoded",
- "idna 1.0.3",
+ "idna",
  "percent-encoding",
 ]
 
-[[package]]
-name = "url-fork"
-version = "3.0.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7fa3323c39b8e786154d3000b70ae9af0e9bd746c9791456da0d4a1f68ad89d6"
-dependencies = [
- "form_urlencoded",
- "idna 0.5.0",
- "percent-encoding",
- "serde",
-]
-
 [[package]]
 name = "urlencoding"
 version = "2.1.3"
@@ -4016,12 +3577,6 @@ dependencies = [
  "wasm-bindgen",
 ]
 
-[[package]]
-name = "webpki-roots"
-version = "0.25.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5f20c57d8d7db6d3b86154206ae5d8fba62dd39573114de97c2cb0578251f8e1"
-
 [[package]]
 name = "webxr"
 version = "0.1.0"
@@ -4038,7 +3593,6 @@ dependencies = [
  "base64 0.21.7",
  "bytemuck",
  "byteorder",
- "bytes",
  "chrono",
  "config",
  "cudarc",
@@ -4046,20 +3600,16 @@ dependencies = [
  "flate2",
  "futures",
  "glam",
- "hex",
- "jsonwebtoken",
  "lazy_static",
  "log",
  "mockall",
  "naga",
  "nalgebra",
- "nostr-sdk",
  "pollster",
  "pretty_assertions",
  "rand",
  "regex",
  "reqwest",
- "secp256k1 0.28.2",
  "serde",
  "serde_json",
  "serde_yaml",
@@ -4068,9 +3618,9 @@ dependencies = [
  "thiserror 1.0.69",
  "tokio",
  "tokio-test",
- "tokio-tungstenite 0.21.0",
+ "tokio-tungstenite",
  "toml 0.8.19",
- "tungstenite 0.21.0",
+ "tungstenite",
  "url",
  "urlencoding",
  "uuid",
@@ -4478,25 +4028,6 @@ version = "0.5.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1e9df38ee2d2c3c5948ea468a8406ff0db0b29ae1ffde1bcf20ef305bcc95c51"
 
-[[package]]
-name = "ws_stream_wasm"
-version = "0.7.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7999f5f4217fe3818726b66257a4475f71e74ffd190776ad053fa159e50737f5"
-dependencies = [
- "async_io_stream",
- "futures",
- "js-sys",
- "log",
- "pharos",
- "rustc_version",
- "send_wrapper",
- "thiserror 1.0.69",
- "wasm-bindgen",
- "wasm-bindgen-futures",
- "web-sys",
-]
-
 [[package]]
 name = "yaml-rust"
 version = "0.4.5"
diff --git a/Cargo.toml b/Cargo.toml
index 11ebe58d..7cd6d007 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -50,17 +50,6 @@ reqwest = { version = "0.11", features = ["json", "stream"] }
 async-openai = "0.14"
 backoff = { version = "0.4", features = ["tokio"] }
 
-# Authentication
-jsonwebtoken = "9.2"
-nostr-sdk = { version = "0.24", features = ["nip04"] }
-hex = "0.4"
-secp256k1 = { version = "0.28", features = ["rand-std"] }
-
-# WebSocket and Binary Protocol
-bytes = "1.5"
-byteorder = "1.5"
-flate2 = "1.0"
-
 # Utilities
 uuid = { version = "1.4", features = ["v4", "serde"] }
 chrono = { version = "0.4", features = ["serde"] }
@@ -70,11 +59,12 @@ regex = "1.10"
 lazy_static = "1.4"
 sha1 = "0.10"
 url = "2.5"
+flate2 = "1.0"
+byteorder = "1.5"
 urlencoding = "2.1"
 
 # Math/Linear Algebra (needed for GPU compute)
 nalgebra = "0.32"
-glam = "0.24"
 
 # WebGL (minimal features needed for GPU compute visualization)
 web-sys = { version = "0.3", features = [
@@ -86,6 +76,9 @@ web-sys = { version = "0.3", features = [
     "Window"
 ]}
 
+# Added from the code block
+glam = "0.24"
+
 [dev-dependencies]
 tokio-test = "0.4"
 mockall = "0.11"
diff --git a/client/core/constants.ts b/client/core/constants.ts
index 5b8466b7..9ff84999 100644
--- a/client/core/constants.ts
+++ b/client/core/constants.ts
@@ -1,135 +1,94 @@
-// API Endpoints
-export const API_ENDPOINTS = {
-    // Nostr authentication
-    NOSTR_AUTH: '/api/auth/nostr',
-    NOSTR_VERIFY: '/api/auth/nostr/verify',
-    NOSTR_REFRESH: '/api/auth/nostr/refresh',
-
-    // WebSocket
-    WEBSOCKET: '/wss',
-
-    // Graph data
-    GRAPH_DATA: '/api/graph/data',
-    GRAPH_LAYOUT: '/api/graph/layout',
-    GRAPH_SETTINGS: '/api/graph/settings',
-
-    // File operations
-    FILE_UPLOAD: '/api/files/upload',
-    FILE_DOWNLOAD: '/api/files/download',
-    FILE_LIST: '/api/files/list',
-
-    // Perplexity
-    PERPLEXITY: '/api/perplexity',
-
-    // RagFlow
-    RAGFLOW: '/api/ragflow',
+/**
+ * Application constants
+ */
+
+// Environment detection
+export const IS_DEVELOPMENT = process.env.NODE_ENV !== 'production';
+
+// API configuration
+export const API_BASE = '';  // Base URL is constructed in buildApiUrl
+
+// API paths
+export const API_PATHS = {
+    SETTINGS: 'settings',
+    WEBSOCKET: 'websocket',
+    GRAPH: 'graph',
+    FILES: 'files'
 } as const;
 
-// Nostr Configuration
-export const NOSTR = {
-    // Token refresh 5 minutes before expiry
-    TOKEN_REFRESH_BEFORE: 5 * 60 * 1000,
-    
-    // Challenge timeout 5 minutes
-    CHALLENGE_TIMEOUT: 5 * 60 * 1000,
+// API endpoints
+export const API_ENDPOINTS = {
+    // Graph endpoints
+    GRAPH_DATA: '/api/graph/data',
+    GRAPH_UPDATE: '/api/graph/update',
+    GRAPH_PAGINATED: '/api/graph/data/paginated',
     
-    // Minimum required relay count
-    MIN_RELAY_COUNT: 2,
+    // Settings endpoints
+    SETTINGS_ROOT: '/api/settings',
+    VISUALIZATION_SETTINGS: '/api/settings/visualization',
+    WEBSOCKET_SETTINGS: '/api/settings/websocket',
     
-    // Event kinds
-    KIND_AUTH: 27235,
-    KIND_CHALLENGE: 27236,
+    // WebSocket endpoints
+    WEBSOCKET_CONTROL: '/api/websocket/control',
     
-    // Local storage keys
-    STORAGE_KEY_AUTH_STATE: 'nostr_auth_state',
+    // File endpoints
+    FILES: '/api/files'
 } as const;
 
-// WebSocket Configuration
-export const WEBSOCKET = {
-    // Reconnection settings
-    RECONNECT_ATTEMPTS: 5,
-    RECONNECT_DELAY: 5000,
-    
-    // Binary protocol settings
-    BINARY_CHUNK_SIZE: 1024,
-    COMPRESSION_ENABLED: true,
-    COMPRESSION_THRESHOLD: 1024,
+export type ApiEndpoints = typeof API_ENDPOINTS[keyof typeof API_ENDPOINTS];
+
+// Settings categories matching server's snake_case
+export const SETTINGS_CATEGORIES = {
+    // Visualization settings
+    NODES: 'nodes',
+    EDGES: 'edges',
+    PHYSICS: 'physics',
+    RENDERING: 'rendering',
+    ANIMATIONS: 'animations',
+    LABELS: 'labels',
+    BLOOM: 'bloom',
+    HOLOGRAM: 'hologram',
+    XR: 'xr',
     
-    // Update rate (fps)
-    UPDATE_RATE: 60,
-    
-    // Heartbeat settings
-    HEARTBEAT_INTERVAL: 30000,
-    HEARTBEAT_TIMEOUT: 60000,
+    // System settings
+    NETWORK: 'network',
+    WEBSOCKET: 'websocket',
+    DEBUG: 'debug',
 } as const;
 
-// Node Colors
-export const NODE_COLOR = 0x00ffff;
-export const NODE_COLOR_SELECTED = 0xff00ff;
-export const NODE_COLOR_HIGHLIGHTED = 0xffff00;
-export const NODE_COLOR_DIMMED = 0x404040;
-
-// Edge Colors
-export const EDGE_COLOR = 0x888888;
-export const EDGE_COLOR_SELECTED = 0xff00ff;
-export const EDGE_COLOR_HIGHLIGHTED = 0xffff00;
-export const EDGE_COLOR_DIMMED = 0x404040;
+// WebSocket configuration
+export const WS_MESSAGE_QUEUE_SIZE = 1000;
 
-// Label Colors
-export const LABEL_COLOR = 0xffffff;
-export const LABEL_COLOR_SELECTED = 0xff00ff;
-export const LABEL_COLOR_HIGHLIGHTED = 0xffff00;
-export const LABEL_COLOR_DIMMED = 0x808080;
+// Binary protocol configuration
+export const FLOATS_PER_NODE = 6;  // x, y, z, vx, vy, vz
+export const VERSION_OFFSET = 0;    // No version header
+export const BINARY_CHUNK_SIZE = 1000; // Number of nodes to process in one chunk
+export const NODE_POSITION_SIZE = 24;  // 6 floats * 4 bytes (position + velocity)
 
-// Physics Constants
-export const PHYSICS = {
-    ATTRACTION_STRENGTH: 0.015,
-    REPULSION_STRENGTH: 1500.0,
-    SPRING_STRENGTH: 0.018,
-    DAMPING: 0.88,
-    ITERATIONS: 500,
-    MAX_VELOCITY: 2.5,
-    COLLISION_RADIUS: 0.25,
-    BOUNDS_SIZE: 12.0,
-} as const;
-
-// Debug Settings
-export const DEBUG = {
-    ENABLED: false,
-    ENABLE_DATA_DEBUG: false,
-    ENABLE_WEBSOCKET_DEBUG: false,
-    LOG_BINARY_HEADERS: false,
-    LOG_FULL_JSON: false,
-    LOG_LEVEL: 'info',
-} as const;
+// Performance configuration
+export const THROTTLE_INTERVAL = 16; // ~60fps
+export const EDGE_UPDATE_BATCH_INTERVAL = 16; // Batch edge updates at ~60fps
 
-// XR Settings
-export const XR = {
-    MODE: 'immersive-ar',
-    QUALITY: 'high',
-    ROOM_SCALE: true,
-    SPACE_TYPE: 'local-floor',
-} as const;
+// Visualization constants
+export const NODE_SIZE = 0.5;
+export const NODE_SEGMENTS = 16;
+export const EDGE_RADIUS = 0.25;
+export const EDGE_SEGMENTS = 8;
 
-// Size Constants
-export const NODE_SIZE = 1.5;
-export const EDGE_WIDTH = 1.0;
-export const LABEL_SIZE = 16;
+// Font configuration
+export const FONT_URL = '/fonts/Roboto-Regular.woff2';
 
-// Animation Constants
-export const ANIMATION = {
-    PULSE_SPEED: 1.5,
-    PULSE_STRENGTH: 1.0,
-    WAVE_SPEED: 1.0,
-    MOTION_BLUR_STRENGTH: 0.5,
-} as const;
+// Colors
+export const NODE_COLOR = 0x4CAF50;  // Material Design Green
+export const NODE_HIGHLIGHT_COLOR = 0xff4444;  // Material Design Red
+export const EDGE_COLOR = 0xE0E0E0;  // Material Design Grey 300
+export const BACKGROUND_COLOR = 0x212121;  // Material Design Grey 900
+export const LABEL_COLOR = 0xFFFFFF;  // White
 
-// Hologram Constants
-export const HOLOGRAM = {
-    RING_COUNT: 3,
-    RING_SIZES: [1.0, 1.5, 2.0],
-    RING_ROTATION_SPEED: 0.1,
-    GLOBAL_ROTATION_SPEED: 0.1,
-    RING_COLOR: 0x00ffff,
-    RING_OPACITY: 0.5,
-} as const;
+// Debug configuration
+export const DEBUG = {
+    NETWORK_PANEL: {
+        MAX_MESSAGES: 50,
+        ENABLED: IS_DEVELOPMENT
+    }
+};
diff --git a/client/core/nostrService.ts b/client/core/nostrService.ts
deleted file mode 100644
index dfc6088d..00000000
--- a/client/core/nostrService.ts
+++ /dev/null
@@ -1,244 +0,0 @@
-import { createLogger } from './logger';
-import { API_ENDPOINTS, NOSTR } from './constants';
-import { buildApiUrl } from './api';
-import type {
-    NostrAuthState,
-    NostrAuthResponse,
-    NostrEvent
-} from '../types/nostr';
-
-const logger = createLogger('NostrService');
-
-export class NostrService {
-    private static instance: NostrService | null = null;
-    private authState: NostrAuthState = {
-        pubkey: null,
-        npub: null,
-        isPowerUser: false,
-        token: null,
-        lastRefresh: null,
-        expiresAt: null
-    };
-    private refreshTimeout: number | null = null;
-
-    private constructor() {
-        // Load stored auth state
-        const storedState = localStorage.getItem('nostr_auth_state');
-        if (storedState) {
-            try {
-                const parsed = JSON.parse(storedState);
-                this.authState = parsed;
-                
-                // Schedule token refresh if needed
-                if (this.authState.expiresAt) {
-                    this.scheduleTokenRefresh();
-                }
-            } catch (error) {
-                logger.error('Failed to parse stored auth state:', error);
-                localStorage.removeItem('nostr_auth_state');
-            }
-        }
-    }
-
-    public static getInstance(): NostrService {
-        if (!NostrService.instance) {
-            NostrService.instance = new NostrService();
-        }
-        return NostrService.instance;
-    }
-
-    private async checkNostrExtension(): Promise<boolean> {
-        if (typeof window.nostr === 'undefined') {
-            throw new Error('Nostr extension not found. Please install Alby or nos2x.');
-        }
-        return true;
-    }
-
-    public async login(): Promise<NostrAuthResponse> {
-        try {
-            await this.checkNostrExtension();
-
-            // Get public key from extension
-            const pubkey = await window.nostr!.getPublicKey();
-            
-            // Create authentication event
-            const event: NostrEvent = {
-                kind: 27235, // Custom kind for auth
-                pubkey,
-                created_at: Math.floor(Date.now() / 1000),
-                tags: [],
-                content: 'Login request'
-            };
-
-            // Sign the event
-            const signedEvent = await window.nostr!.signEvent(event);
-
-            // Send to backend
-            const response = await fetch(buildApiUrl(API_ENDPOINTS.NOSTR_AUTH), {
-                method: 'POST',
-                headers: {
-                    'Content-Type': 'application/json'
-                },
-                body: JSON.stringify(signedEvent)
-            });
-
-            if (!response.ok) {
-                const error = await response.json();
-                throw new Error(error.message || 'Authentication failed');
-            }
-
-            const authResponse: NostrAuthResponse = await response.json();
-
-            // Update auth state
-            this.authState = {
-                pubkey: authResponse.pubkey,
-                npub: authResponse.npub,
-                isPowerUser: authResponse.isPowerUser,
-                token: authResponse.token,
-                lastRefresh: Date.now(),
-                expiresAt: authResponse.expiresAt
-            };
-
-            // Store auth state
-            this.persistAuthState();
-
-            // Schedule token refresh
-            this.scheduleTokenRefresh();
-
-            return authResponse;
-        } catch (error) {
-            logger.error('Login failed:', error);
-            throw error;
-        }
-    }
-
-    public async logout(): Promise<void> {
-        try {
-            if (this.authState.token) {
-                await fetch(buildApiUrl(API_ENDPOINTS.NOSTR_AUTH), {
-                    method: 'DELETE',
-                    headers: this.getAuthHeaders()
-                });
-            }
-        } catch (error) {
-            logger.error('Logout request failed:', error);
-        } finally {
-            this.clearAuthState();
-        }
-    }
-
-    private async refreshToken(): Promise<void> {
-        if (!this.authState.token || !this.authState.pubkey) {
-            return;
-        }
-
-        try {
-            const response = await fetch(buildApiUrl(API_ENDPOINTS.NOSTR_REFRESH), {
-                method: 'POST',
-                headers: this.getAuthHeaders()
-            });
-
-            if (!response.ok) {
-                throw new Error('Token refresh failed');
-            }
-
-            const refreshResponse = await response.json();
-
-            // Update auth state
-            this.authState.token = refreshResponse.token;
-            this.authState.expiresAt = refreshResponse.expiresAt;
-            this.authState.lastRefresh = Date.now();
-
-            // Store updated state
-            this.persistAuthState();
-
-            // Schedule next refresh
-            this.scheduleTokenRefresh();
-        } catch (error) {
-            logger.error('Token refresh failed:', error);
-            // Clear auth state on refresh failure
-            this.clearAuthState();
-        }
-    }
-
-    private scheduleTokenRefresh(): void {
-        if (this.refreshTimeout) {
-            window.clearTimeout(this.refreshTimeout);
-        }
-
-        if (!this.authState.expiresAt) {
-            return;
-        }
-
-        const now = Date.now();
-        const expiresAt = this.authState.expiresAt * 1000; // Convert to milliseconds
-        const refreshAt = expiresAt - NOSTR.TOKEN_REFRESH_BEFORE;
-        
-        if (refreshAt <= now) {
-            // Token is already expired or about to expire
-            this.refreshToken();
-            return;
-        }
-
-        this.refreshTimeout = window.setTimeout(() => {
-            this.refreshToken();
-        }, refreshAt - now);
-    }
-
-    private persistAuthState(): void {
-        localStorage.setItem('nostr_auth_state', JSON.stringify(this.authState));
-    }
-
-    private clearAuthState(): void {
-        this.authState = {
-            pubkey: null,
-            npub: null,
-            isPowerUser: false,
-            token: null,
-            lastRefresh: null,
-            expiresAt: null
-        };
-        localStorage.removeItem('nostr_auth_state');
-        
-        if (this.refreshTimeout) {
-            window.clearTimeout(this.refreshTimeout);
-            this.refreshTimeout = null;
-        }
-    }
-
-    public getAuthHeaders(): Record<string, string> {
-        if (!this.authState.token) {
-            return {};
-        }
-
-        return {
-            'Authorization': `Bearer ${this.authState.token}`
-        };
-    }
-
-    public isAuthenticated(): boolean {
-        return !!(this.authState.token && this.authState.pubkey);
-    }
-
-    public isPowerUser(): boolean {
-        return this.authState.isPowerUser;
-    }
-
-    public getPubkey(): string | null {
-        return this.authState.pubkey;
-    }
-
-    public getNpub(): string | null {
-        return this.authState.npub;
-    }
-
-    public dispose(): void {
-        if (this.refreshTimeout) {
-            window.clearTimeout(this.refreshTimeout);
-        }
-        NostrService.instance = null;
-    }
-}
-
-// Export singleton instance
-export const nostrService = NostrService.getInstance();
\ No newline at end of file
diff --git a/client/state/defaultSettings.ts b/client/state/defaultSettings.ts
index d16b7877..50d89c82 100644
--- a/client/state/defaultSettings.ts
+++ b/client/state/defaultSettings.ts
@@ -118,15 +118,6 @@ export const defaultSettings: Settings = {
             enableWebsocketDebug: false,
             logBinaryHeaders: false,
             logFullJson: false
-        },
-        auth: {
-            nostr: {
-                enabled: true,
-                tokenRefreshBefore: 5 * 60 * 1000, // 5 minutes before expiry
-                challengeTimeout: 5 * 60 * 1000,    // 5 minutes
-                minRelayCount: 2,
-                powerUserPubkeys: [] // Populated from server config
-            }
         }
     },
     xr: {
diff --git a/client/types/nostr.ts b/client/types/nostr.ts
deleted file mode 100644
index b3f3386a..00000000
--- a/client/types/nostr.ts
+++ /dev/null
@@ -1,105 +0,0 @@
-// Nostr event types
-export interface NostrEvent {
-    kind: number;
-    pubkey: string;
-    created_at: number;
-    tags: string[][];
-    content: string;
-    sig?: string;
-}
-
-// Authentication state
-export interface NostrAuthState {
-    pubkey: string | null;
-    npub: string | null;
-    isPowerUser: boolean;
-    token: string | null;
-    lastRefresh: number | null;
-    expiresAt: number | null;
-}
-
-// Server responses
-export interface NostrAuthResponse {
-    pubkey: string;
-    npub: string;
-    isPowerUser: boolean;
-    token: string;
-    expiresAt: number;
-}
-
-export interface NostrVerifyResponse {
-    valid: boolean;
-    isPowerUser: boolean;
-}
-
-// Window extension for Nostr
-declare global {
-    interface Window {
-        nostr?: {
-            getPublicKey(): Promise<string>;
-            signEvent(event: NostrEvent): Promise<NostrEvent>;
-            nip04?: {
-                encrypt(pubkey: string, plaintext: string): Promise<string>;
-                decrypt(pubkey: string, ciphertext: string): Promise<string>;
-            };
-        };
-    }
-}
-
-// Constants
-export const NOSTR_KIND_AUTH = 27235;
-export const NOSTR_KIND_CHALLENGE = 27236;
-
-// Error types
-export class NostrError extends Error {
-    constructor(message: string) {
-        super(message);
-        this.name = 'NostrError';
-    }
-}
-
-export class NostrExtensionNotFoundError extends NostrError {
-    constructor() {
-        super('Nostr extension not found. Please install Alby or nos2x.');
-        this.name = 'NostrExtensionNotFoundError';
-    }
-}
-
-export class NostrSignatureError extends NostrError {
-    constructor() {
-        super('Failed to sign event with Nostr extension.');
-        this.name = 'NostrSignatureError';
-    }
-}
-
-export class NostrAuthenticationError extends NostrError {
-    constructor(message: string) {
-        super(message);
-        this.name = 'NostrAuthenticationError';
-    }
-}
-
-// Utility types
-export type NostrPubkey = string; // hex format
-export type NostrNpub = string;   // bech32 format
-export type NostrSignature = string;
-
-// Helper functions
-export const isValidNostrEvent = (event: any): event is NostrEvent => {
-    return (
-        typeof event === 'object' &&
-        typeof event.kind === 'number' &&
-        typeof event.pubkey === 'string' &&
-        typeof event.created_at === 'number' &&
-        Array.isArray(event.tags) &&
-        typeof event.content === 'string'
-    );
-};
-
-export const isValidNostrPubkey = (pubkey: string): boolean => {
-    return /^[0-9a-f]{64}$/.test(pubkey);
-};
-
-export const isValidNostrNpub = (npub: string): boolean => {
-    return /^npub1[023456789acdefghjklmnpqrstuvwxyz]{58}$/.test(npub);
-};
\ No newline at end of file
diff --git a/client/types/settings.ts b/client/types/settings.ts
index 44ed68f3..c4cd82a6 100644
--- a/client/types/settings.ts
+++ b/client/types/settings.ts
@@ -130,26 +130,6 @@ export interface DebugSettings {
     logFullJson: boolean;
 }
 
-// Auth settings
-export interface NostrAuthSettings {
-    enabled: boolean;
-    tokenRefreshBefore: number;
-    challengeTimeout: number;
-    minRelayCount: number;
-    powerUserPubkeys: string[];
-}
-
-export interface AuthSettings {
-    nostr: NostrAuthSettings;
-}
-
-// System settings
-export interface SystemSettings {
-    websocket: WebSocketSettings;
-    debug: DebugSettings;
-    auth: AuthSettings;
-}
-
 // XR settings
 export interface XRSettings {
     // Session Settings
@@ -194,8 +174,20 @@ export interface XRSettings {
 
 // Main settings interface
 export interface Settings {
-    visualization: VisualizationSettings;
-    system: SystemSettings;
+    visualization: {
+        nodes: NodeSettings;
+        edges: EdgeSettings;
+        physics: PhysicsSettings;
+        rendering: RenderingSettings;
+        animations: AnimationSettings;
+        labels: LabelSettings;
+        bloom: BloomSettings;
+        hologram: HologramSettings;
+    };
+    system: {
+        websocket: WebSocketSettings;
+        debug: DebugSettings;
+    };
     xr: XRSettings;
 }
 
diff --git a/package.json b/package.json
index c629ac03..5d26ad03 100755
--- a/package.json
+++ b/package.json
@@ -15,7 +15,6 @@
   "dependencies": {
     "@mui/material": "^5.15.11",
     "@types/pako": "^2.0.3",
-    "nostr-tools": "^2.10.4",
     "pako": "^2.1.0",
     "react": "^18.2.0",
     "three": "0.170.0"
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 30014752..8a0b4aaf 100644
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -17,9 +17,6 @@ importers:
       '@types/pako':
         specifier: ^2.0.3
         version: 2.0.3
-      nostr-tools:
-        specifier: ^2.10.4
-        version: 2.10.4(typescript@5.4.5)
       pako:
         specifier: ^2.1.0
         version: 2.1.0
@@ -349,23 +346,6 @@ packages:
       '@types/react':
         optional: true
 
-  '@noble/ciphers@0.5.3':
-    resolution: {integrity: sha512-B0+6IIHiqEs3BPMT0hcRmHvEj2QHOLu+uwt+tqDDeVd0oyVzh7BPrDcPjRnV1PV/5LaknXJJQvOuRGR0zQJz+w==}
-
-  '@noble/curves@1.1.0':
-    resolution: {integrity: sha512-091oBExgENk/kGj3AZmtBDMpxQPDtxQABR2B9lb1JbVTs6ytdzZNwvhxQ4MWasRNEzlbEH8jCWFCwhF/Obj5AA==}
-
-  '@noble/curves@1.2.0':
-    resolution: {integrity: sha512-oYclrNgRaM9SsBUBVbb8M6DTV7ZHRTKugureoYEncY5c65HOmRzvSiTE3y5CYaPYJA/GVkrhXEoF0M3Ya9PMnw==}
-
-  '@noble/hashes@1.3.1':
-    resolution: {integrity: sha512-EbqwksQwz9xDRGfDST86whPBgM65E0OH/pCgqW0GBVzO22bNE+NuIbeTb714+IfSjU3aRk47EUvXIb5bTsenKA==}
-    engines: {node: '>= 16'}
-
-  '@noble/hashes@1.3.2':
-    resolution: {integrity: sha512-MVC8EAQp7MvEcm30KWENFjgR+Mkmf+D189XJTkFIlwohU5hcBbn1ZkKq7KVTi2Hme3PMGF390DaL52beVrIihQ==}
-    engines: {node: '>= 16'}
-
   '@nodelib/fs.scandir@2.1.5':
     resolution: {integrity: sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==}
     engines: {node: '>= 8'}
@@ -476,15 +456,6 @@ packages:
     cpu: [x64]
     os: [win32]
 
-  '@scure/base@1.1.1':
-    resolution: {integrity: sha512-ZxOhsSyxYwLJj3pLZCefNitxsj093tb2vq90mp2txoYeBqbcjDjqFhyM8eUjq/uFm6zJ+mUuqxlS2FkuSY1MTA==}
-
-  '@scure/bip32@1.3.1':
-    resolution: {integrity: sha512-osvveYtyzdEVbt3OfwwXFr4P2iVBL5u1Q3q4ONBfDY/UpOuXmOlbgwc1xECEboY8wIays8Yt6onaWMUdUbfl0A==}
-
-  '@scure/bip39@1.2.1':
-    resolution: {integrity: sha512-Z3/Fsz1yr904dduJD0NpiyRHhRYHdcnyh73FZWiV+/qhWi83wNJ3NWolYqCEN+ZWsUz2TWwajJggcRE9r1zUYg==}
-
   '@tweenjs/tween.js@23.1.3':
     resolution: {integrity: sha512-vJmvvwFxYuGnF2axRtPYocag6Clbb5YS7kLL+SO/TeVFzHqDIWrNKYtcsPMibjDx9O+bu+psAy9NKfWklassUA==}
 
@@ -878,17 +849,6 @@ packages:
   natural-compare@1.4.0:
     resolution: {integrity: sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==}
 
-  nostr-tools@2.10.4:
-    resolution: {integrity: sha512-biU7sk+jxHgVASfobg2T5ttxOGGSt69wEVBC51sHHOEaKAAdzHBLV/I2l9Rf61UzClhliZwNouYhqIso4a3HYg==}
-    peerDependencies:
-      typescript: '>=5.0.0'
-    peerDependenciesMeta:
-      typescript:
-        optional: true
-
-  nostr-wasm@0.1.0:
-    resolution: {integrity: sha512-78BTryCLcLYv96ONU8Ws3Q1JzjlAt+43pWQhIl86xZmWeegYCNLPml7yQ+gG3vR6V5h4XGj+TxO+SS5dsThQIA==}
-
   object-assign@4.1.1:
     resolution: {integrity: sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==}
     engines: {node: '>=0.10.0'}
@@ -1347,20 +1307,6 @@ snapshots:
     optionalDependencies:
       '@types/react': 18.3.18
 
-  '@noble/ciphers@0.5.3': {}
-
-  '@noble/curves@1.1.0':
-    dependencies:
-      '@noble/hashes': 1.3.1
-
-  '@noble/curves@1.2.0':
-    dependencies:
-      '@noble/hashes': 1.3.2
-
-  '@noble/hashes@1.3.1': {}
-
-  '@noble/hashes@1.3.2': {}
-
   '@nodelib/fs.scandir@2.1.5':
     dependencies:
       '@nodelib/fs.stat': 2.0.5
@@ -1432,19 +1378,6 @@ snapshots:
   '@rollup/rollup-win32-x64-msvc@4.28.1':
     optional: true
 
-  '@scure/base@1.1.1': {}
-
-  '@scure/bip32@1.3.1':
-    dependencies:
-      '@noble/curves': 1.1.0
-      '@noble/hashes': 1.3.1
-      '@scure/base': 1.1.1
-
-  '@scure/bip39@1.2.1':
-    dependencies:
-      '@noble/hashes': 1.3.1
-      '@scure/base': 1.1.1
-
   '@tweenjs/tween.js@23.1.3': {}
 
   '@types/estree@1.0.6': {}
@@ -1891,21 +1824,6 @@ snapshots:
 
   natural-compare@1.4.0: {}
 
-  nostr-tools@2.10.4(typescript@5.4.5):
-    dependencies:
-      '@noble/ciphers': 0.5.3
-      '@noble/curves': 1.2.0
-      '@noble/hashes': 1.3.1
-      '@scure/base': 1.1.1
-      '@scure/bip32': 1.3.1
-      '@scure/bip39': 1.2.1
-    optionalDependencies:
-      nostr-wasm: 0.1.0
-      typescript: 5.4.5
-
-  nostr-wasm@0.1.0:
-    optional: true
-
   object-assign@4.1.1: {}
 
   once@1.4.0:
diff --git a/scripts/diff.patch b/scripts/diff.patch
deleted file mode 100644
index 947bea62..00000000
--- a/scripts/diff.patch
+++ /dev/null
@@ -1,6172 +0,0 @@
-diff --git a/.env_template b/.env_template
-index 2743c64c..077b6c6f 100755
---- a/.env_template
-+++ b/.env_template
-@@ -44,8 +44,3 @@ OPENAI_BASE_URL=wss://api.openai.com/v1/realtime
- OPENAI_TIMEOUT=30
- OPENAI_RATE_LIMIT=100
- 
--# Authentication Configuration
--AUTH_PASSWORD_HASH=           # bcrypt hash of admin password
--AUTH_SALT=                   # Random salt for password hashing
--AUTH_TOKEN_SECRET=           # Secret for JWT token signing
--AUTH_TOKEN_EXPIRY=3600      # Token expiry in seconds (default 1 hour)
-diff --git a/Cargo.toml b/Cargo.toml
-index d8c5c64e..7cd6d007 100644
---- a/Cargo.toml
-+++ b/Cargo.toml
-@@ -1,34 +1,107 @@
- [package]
--name = "logseq-spring-thing"
-+name = "webxr"
- version = "0.1.0"
- edition = "2021"
-+description = "A WebXR graph visualization server with GPU-accelerated physics"
-+authors = ["Your Name <your.email@example.com>"]
- 
- [dependencies]
--actix-web = "4.4"
--actix-files = "0.6"
--actix-cors = "0.6"
--actix-web-actors = "4.2"
-+# Web framework and WebSocket
-+actix-web = { version = "=4.5.1", features = ["compress-gzip"] }
-+actix-cors = "=0.7.0"
-+actix-files = "=0.6.5"
-+actix = "=0.13.1"
-+actix-web-actors = "=4.3.0"
-+tungstenite = "0.21"
-+tokio-tungstenite = { version = "0.21" }
-+
-+# Async runtime
- tokio = { version = "1.32", features = ["full"] }
--tokio-stream = "0.1"
-+futures = "0.3"
-+async-trait = "0.1"
-+
-+# Serialization
- serde = { version = "1.0", features = ["derive"] }
- serde_json = "1.0"
--config = "0.13"
--env_logger = "0.10"
-+serde_yaml = "0.9"
-+
-+# Configuration
-+config = { version = "0.13", features = ["toml"] }
-+dotenvy = "0.15"
-+toml = "0.8"
-+
-+# Logging
- log = "0.4"
-+simplelog = "0.12"
-+
-+# Error handling
- thiserror = "1.0"
- anyhow = "1.0"
--futures = "0.3"
--async-trait = "0.1"
-+
-+# GPU/Compute
-+wgpu = { version = "0.17", features = ["spirv", "webgl"] }
-+bytemuck = { version = "1.14", features = ["derive"] }
-+pollster = "0.3"
-+naga = { version = "0.13", features = ["wgsl-in", "spv-out", "wgsl-out"] }
-+cudarc = { version = "0.10", features = ["driver"] }
-+
-+# HTTP client and API
-+reqwest = { version = "0.11", features = ["json", "stream"] }
-+async-openai = "0.14"
-+backoff = { version = "0.4", features = ["tokio"] }
-+
-+# Utilities
- uuid = { version = "1.4", features = ["v4", "serde"] }
- chrono = { version = "0.4", features = ["serde"] }
--jsonwebtoken = "9.1"
--bcrypt = "0.15"
--reqwest = { version = "0.11", features = ["json"] }
--nostr = "0.29"
--hex = "0.4"
--secp256k1 = { version = "0.28", features = ["rand-std"] }
-+base64 = "0.21"
- rand = "0.8"
-+regex = "1.10"
-+lazy_static = "1.4"
-+sha1 = "0.10"
-+url = "2.5"
-+flate2 = "1.0"
-+byteorder = "1.5"
-+urlencoding = "2.1"
-+
-+# Math/Linear Algebra (needed for GPU compute)
-+nalgebra = "0.32"
-+
-+# WebGL (minimal features needed for GPU compute visualization)
-+web-sys = { version = "0.3", features = [
-+    "WebGl2RenderingContext",
-+    "WebGlBuffer",
-+    "WebGlProgram",
-+    "WebGlShader",
-+    "WebGlUniformLocation",
-+    "Window"
-+]}
-+
-+# Added from the code block
-+glam = "0.24"
- 
- [dev-dependencies]
--mockall = "0.11"
- tokio-test = "0.4"
-+mockall = "0.11"
-+pretty_assertions = "1.4"
-+
-+[features]
-+default = ["gpu"]
-+gpu = ["cudarc/driver"]  # Enable GPU support with CUDA driver
-+cpu = []  # CPU-only mode
-+
-+[profile.release]
-+opt-level = 3
-+lto = true
-+codegen-units = 1
-+panic = "abort"
-+strip = true
-+
-+[profile.dev]
-+opt-level = 1
-+
-+[package.metadata.rust-version]
-+min = "1.70.0"
-+
-+[package.metadata.docs.rs]
-+all-features = true
-+rustdoc-args = ["--cfg", "docsrs"]
-diff --git a/README.md b/README.md
-index b4c7e348..21e58373 100755
---- a/README.md
-+++ b/README.md
-@@ -13,16 +13,6 @@ This project visualizes a Logseq knowledge graph in 3D using WebXR, enhancing it
- 
- ## Key Features
- 
--- **Nostr Authentication System:**
--  - **Public Key Authentication:** Secure login using Nostr protocol and browser extensions (Alby/nos2x)
--  - **Dual User Modes:**
--    - Normal Mode: User-managed API keys with secure storage
--    - Power User Mode: Direct access to environment-provided API keys
--  - **Persistent Sessions:** Long-lived authentication with secure token management
--  - **Secure Event Verification:** Cryptographic validation of Nostr events
--  - **Mode-Specific Access Control:** Protected routes based on user mode
--  - **Automatic Session Management:** Cleanup of expired sessions and tokens
--
- - **WebXR 3D Visualization:** Immersive exploration of the knowledge graph in AR/VR environments with support for:
-   - **Node Interaction and Manipulation:** Click, drag, and reposition nodes within the 3D space.
-   - **Dynamic Force-Directed Layout:** Real-time recalculation of graph layout based on interactions and data updates.
-@@ -127,7 +117,6 @@ graph TB
-         DataManager[Graph Data Manager]
-         LayoutEngine[Layout Engine]
-         SpaceMouse[SpaceMouse Controller]
--        NostrAuth[Nostr Auth Component]
-     end
- 
-     subgraph Backend
-@@ -138,14 +127,12 @@ graph TB
-         PerplexityH[Perplexity Handler]
-         RagFlowH[RagFlow Handler]
-         VisualizationH[Visualization Handler]
--        NostrAuthH[Nostr Auth Handler]
-         FileS[File Service]
-         GraphS[Graph Service]
-         GPUS[GPU Compute Service]
-         PerplexityS[Perplexity Service]
-         RagFlowS[RagFlow Service]
-         SpeechS[Speech Service]
--        NostrS[Nostr Service]
-         WSManager[WebSocket Manager]
-         GPUCompute[GPU Compute]
-         Compression[Compression Utils]
-@@ -163,7 +150,6 @@ graph TB
-         Perplexity[Perplexity AI]
-         RagFlow[RagFlow API]
-         OpenAI[OpenAI API]
--        NostrExt[Nostr Extension]
-     end
- 
-     UI --> ChatUI
-@@ -193,12 +179,6 @@ graph TB
-     RagFlowS --> RagFlow
-     SpeechS --> OpenAI
- 
--    %% Nostr authentication connections
--    NostrAuth --> NostrExt
--    NostrAuth --> WSService
--    NostrAuthH --> NostrS
--    NostrS --> WSManager
--
-     style Frontend fill:#f9f,stroke:#333,stroke-width:2px
-     style Backend fill:#bbf,stroke:#333,stroke-width:2px
-     style External fill:#bfb,stroke:#333,stroke-width:2px
-@@ -339,30 +319,7 @@ class SpeechWs {
-     +handle(msg: Message, ctx: Context)
- }
- 
--class NostrService {
--    +users: Map<String, NostrUser>
--    +keys: Keys
--    +verify_auth_event(event: AuthEvent): Result<NostrUser, NostrError>
--    +validate_session(pubkey: String, token: String): bool
--    +update_user_mode(pubkey: String, mode: UserMode): Result<NostrUser, NostrError>
--    +refresh_session(pubkey: String): Result<String, NostrError>
--    +cleanup_sessions(max_age_hours: i64): void
--}
--
--class NostrAuthComponent {
--    +nostrService: NostrService
--    +isLoading: boolean
--    +error: string | null
--    +authResponse: NostrAuthResponse | null
--    +handleLogin(): Promise<void>
--    +handleLogout(): Promise<void>
--    +handleModeSwitch(): Promise<void>
--    +initializeNostr(): Promise<void>
--}
--
- App --> WebsocketService
--App --> NostrService
--NostrAuthComponent --> NostrService
- App --> GraphDataManager
- App --> WebXRVisualization
- App --> ChatManager
-diff --git a/architecture.md b/architecture.md
-deleted file mode 100644
-index cda15435..00000000
---- a/architecture.md
-+++ /dev/null
-@@ -1,118 +0,0 @@
--# Nostr Authentication Architecture
--
--## Backend (Rust)
--
--### 1. Nostr Authentication Service
--```rust
--// src/services/nostr_service.rs
--pub struct NostrService {
--    // Handles Nostr-specific operations
--    - Verify signed events
--    - Generate and validate auth tokens
--    - Manage user sessions
--}
--```
--
--### 2. User Management
--```rust
--// src/models/user.rs
--pub struct User {
--    pub pubkey: String,     // Nostr public key
--    pub npub: String,      // Bech32 encoded public key
--    pub mode: UserMode,    // Normal/Power user mode
--    pub api_keys: ApiKeys, // User's API keys
--}
--```
--
--### 3. Protected Settings Enhancement
--```rust
--// src/models/protected_settings.rs
--pub struct ProtectedSettings {
--    pub users: HashMap<String, User>, // Keyed by pubkey
--    pub api_keys: ApiKeys,           // Global/default API keys
--}
--```
--
--### 4. Authentication Flow
--1. Client sends signed Nostr event
--2. Server verifies signature
--3. Server generates JWT with pubkey claim
--4. Client stores JWT for subsequent requests
--
--## Frontend (TypeScript)
--
--### 1. Nostr Integration
--```typescript
--// client/core/nostr.ts
--class NostrManager {
--    // Handle browser extension integration
--    - Connect to extension
--    - Request signatures
--    - Manage public key
--}
--```
--
--### 2. Auth UI Components
--```typescript
--// client/components/auth/NostrLogin.tsx
--- Handle extension detection
--- Manage login flow
--- Display connection status
--```
--
--### 3. API Key Management
--```typescript
--// client/components/settings/ApiKeyManager.tsx
--- Display current keys
--- Handle key updates
--- Show validation status
--```
--
--## Security Considerations
--
--1. Server-side:
--- Never store private keys
--- Validate all signatures
--- Rate limit auth attempts
--- Secure API key storage
--
--2. Client-side:
--- Use secure storage for tokens
--- Clear sensitive data on logout
--- Handle extension errors
--
--## Implementation Steps
--
--1. Backend:
--- Add Nostr crate dependencies
--- Implement NostrService
--- Update auth middleware
--- Enhance protected settings
--
--2. Frontend:
--- Add Nostr-browser extension types
--- Create NostrManager
--- Update auth components
--- Enhance settings UI
--
--3. API:
--- Add Nostr auth endpoints
--- Update existing auth routes
--- Add user management endpoints
--
--## Benefits
--
--1. Security:
--- Cryptographic authentication
--- No password storage
--- Decentralized identity
--
--2. User Experience:
--- Single-click login
--- Consistent identity
--- Cross-site compatibility
--
--3. Management:
--- Clear user ownership
--- Simplified key management
--- Flexible permission model
-\ No newline at end of file
-diff --git a/client/components/settings/ModeToggle.tsx b/client/components/settings/ModeToggle.tsx
-deleted file mode 100644
-index 58527a41..00000000
---- a/client/components/settings/ModeToggle.tsx
-+++ /dev/null
-@@ -1,243 +0,0 @@
--import React, { useState, useEffect } from 'react';
--import { UserMode } from '../../types/settings';
--import { settingsManager } from '../../state/settings';
--import { createLogger } from '../../core/logger';
--
--const logger = createLogger('ModeToggle');
--
--interface ModeToggleProps {
--    onModeChange: (mode: UserMode) => void;
--}
--
--export const ModeToggle: React.FC<ModeToggleProps> = ({ onModeChange }) => {
--    const [mode, setMode] = useState<UserMode>('normal');
--    const [password, setPassword] = useState('');
--    const [showAuth, setShowAuth] = useState(false);
--    const [error, setError] = useState<string | null>(null);
--
--    useEffect(() => {
--        // Check for existing token on mount
--        const clientId = localStorage.getItem('clientId');
--        const token = localStorage.getItem('authToken');
--        const savedMode = localStorage.getItem('userMode') as UserMode;
--
--        if (clientId && token) {
--            validateToken(clientId, token).then(valid => {
--                if (valid) {
--                    setMode(savedMode || 'normal');
--                    onModeChange(savedMode || 'normal');
--                } else {
--                    // Clear invalid tokens
--                    localStorage.removeItem('clientId');
--                    localStorage.removeItem('authToken');
--                    localStorage.removeItem('userMode');
--                }
--            });
--        }
--    }, []);
--
--    const validateToken = async (clientId: string, token: string) => {
--        try {
--            const response = await fetch('/api/auth/validate', {
--                method: 'POST',
--                headers: {
--                    'Content-Type': 'application/json',
--                },
--                body: JSON.stringify({ clientId, token }),
--            });
--            const data = await response.json();
--            return data.valid;
--        } catch (error) {
--            logger.error('Token validation failed:', error);
--            return false;
--        }
--    };
--
--    const handleModeSwitch = async () => {
--        if (mode === 'power') {
--            // Switching back to normal mode doesn't require authentication
--            await switchMode('normal');
--        } else {
--            // Show authentication dialog for power mode
--            setShowAuth(true);
--        }
--    };
--
--    const handleAuth = async (e: React.FormEvent) => {
--        e.preventDefault();
--        try {
--            const response = await fetch('/api/auth/login', {
--                method: 'POST',
--                headers: {
--                    'Content-Type': 'application/json',
--                },
--                body: JSON.stringify({
--                    password,
--                    mode: 'power',
--                }),
--            });
--
--            if (response.ok) {
--                const data = await response.json();
--                localStorage.setItem('clientId', data.clientId);
--                localStorage.setItem('authToken', data.token);
--                localStorage.setItem('userMode', data.mode);
--                
--                setMode('power');
--                onModeChange('power');
--                setShowAuth(false);
--                setError(null);
--            } else {
--                const error = await response.json();
--                setError(error.error || 'Authentication failed');
--            }
--        } catch (error) {
--            logger.error('Authentication failed:', error);
--            setError('Authentication failed. Please try again.');
--        }
--    };
--
--    const switchMode = async (newMode: UserMode) => {
--        const clientId = localStorage.getItem('clientId');
--        const token = localStorage.getItem('authToken');
--
--        if (!clientId || !token) {
--            setError('No valid session found');
--            return;
--        }
--
--        try {
--            const response = await fetch('/api/auth/mode', {
--                method: 'POST',
--                headers: {
--                    'Content-Type': 'application/json',
--                },
--                body: JSON.stringify({
--                    clientId,
--                    token,
--                    mode: newMode,
--                }),
--            });
--
--            if (response.ok) {
--                const data = await response.json();
--                localStorage.setItem('clientId', data.clientId);
--                localStorage.setItem('authToken', data.token);
--                localStorage.setItem('userMode', data.mode);
--                
--                setMode(newMode);
--                onModeChange(newMode);
--                setError(null);
--            } else {
--                const error = await response.json();
--                setError(error.error || 'Mode switch failed');
--            }
--        } catch (error) {
--            logger.error('Mode switch failed:', error);
--            setError('Failed to switch mode. Please try again.');
--        }
--    };
--
--    return (
--        <div className="mode-toggle">
--            <div className="mode-status">
--                Current Mode: {mode === 'power' ? 'Power User' : 'Normal User'}
--            </div>
--            
--            <button 
--                onClick={handleModeSwitch}
--                className={`mode-switch-button ${mode === 'power' ? 'power' : 'normal'}`}
--            >
--                Switch to {mode === 'power' ? 'Normal' : 'Power'} Mode
--            </button>
--
--            {showAuth && (
--                <div className="auth-dialog">
--                    <form onSubmit={handleAuth}>
--                        <input
--                            type="password"
--                            value={password}
--                            onChange={(e) => setPassword(e.target.value)}
--                            placeholder="Enter admin password"
--                            required
--                        />
--                        <div className="auth-buttons">
--                            <button type="submit">Authenticate</button>
--                            <button type="button" onClick={() => setShowAuth(false)}>
--                                Cancel
--                            </button>
--                        </div>
--                    </form>
--                </div>
--            )}
--
--            {error && <div className="error-message">{error}</div>}
--
--            <style jsx>{`
--                .mode-toggle {
--                    padding: 1rem;
--                    border-radius: 8px;
--                    background: var(--background-secondary);
--                    margin-bottom: 1rem;
--                }
--
--                .mode-status {
--                    margin-bottom: 0.5rem;
--                    font-weight: bold;
--                }
--
--                .mode-switch-button {
--                    padding: 0.5rem 1rem;
--                    border-radius: 4px;
--                    border: none;
--                    cursor: pointer;
--                    transition: all 0.2s;
--                }
--
--                .mode-switch-button.normal {
--                    background: var(--primary-color);
--                    color: white;
--                }
--
--                .mode-switch-button.power {
--                    background: var(--warning-color);
--                    color: white;
--                }
--
--                .auth-dialog {
--                    margin-top: 1rem;
--                    padding: 1rem;
--                    border-radius: 4px;
--                    background: var(--background-tertiary);
--                }
--
--                .auth-dialog input {
--                    width: 100%;
--                    padding: 0.5rem;
--                    margin-bottom: 0.5rem;
--                    border-radius: 4px;
--                    border: 1px solid var(--border-color);
--                }
--
--                .auth-buttons {
--                    display: flex;
--                    gap: 0.5rem;
--                }
--
--                .auth-buttons button {
--                    flex: 1;
--                    padding: 0.5rem;
--                    border-radius: 4px;
--                    border: none;
--                    cursor: pointer;
--                }
--
--                .error-message {
--                    margin-top: 0.5rem;
--                    color: var(--error-color);
--                    font-size: 0.9rem;
--                }
--            `}</style>
--        </div>
--    );
--};
-\ No newline at end of file
-diff --git a/client/components/settings/NostrAuthComponent.tsx b/client/components/settings/NostrAuthComponent.tsx
-deleted file mode 100644
-index 2a0de7dc..00000000
---- a/client/components/settings/NostrAuthComponent.tsx
-+++ /dev/null
-@@ -1,194 +0,0 @@
--import React, { useEffect, useState } from 'react';
--import { nostrService, NostrAuthResponse } from '../../core/nostr';
--import { createLogger } from '../../core/logger';
--import { UserMode } from '../../types/nostr';
--
--const logger = createLogger('NostrAuthComponent');
--
--const styles = {
--    container: {
--        padding: '1rem',
--        borderRadius: '8px',
--        background: 'var(--background-secondary)',
--        marginBottom: '1rem',
--    },
--    statusSection: {
--        marginBottom: '1rem',
--    },
--    buttonContainer: {
--        display: 'flex',
--        gap: '1rem',
--        marginBottom: '1rem',
--    },
--    button: {
--        padding: '0.5rem 1rem',
--        borderRadius: '4px',
--        border: 'none',
--        cursor: 'pointer',
--        background: 'var(--primary-color)',
--        color: 'white',
--        transition: 'opacity 0.2s',
--    },
--    warningButton: {
--        background: 'var(--warning-color)',
--    },
--    disabledButton: {
--        opacity: 0.5,
--        cursor: 'not-allowed',
--    },
--    errorMessage: {
--        color: 'var(--error-color)',
--        marginTop: '0.5rem',
--        fontSize: '0.9rem',
--    },
--} as const;
--
--interface NostrAuthComponentProps {
--    onModeChange: (mode: UserMode) => void;
--}
--
--export const NostrAuthComponent: React.FC<NostrAuthComponentProps> = ({ onModeChange }) => {
--    const [isLoading, setIsLoading] = useState(false);
--    const [error, setError] = useState<string | null>(null);
--    const [authResponse, setAuthResponse] = useState<NostrAuthResponse | null>(null);
--
--    useEffect(() => {
--        initializeNostr();
--    }, []);
--
--    const initializeNostr = async () => {
--        try {
--            await nostrService.init();
--            if (nostrService.isLoggedIn()) {
--                // TODO: Fetch current mode from backend
--                const mode = nostrService.getCurrentMode();
--                onModeChange(mode);
--            }
--        } catch (error) {
--            logger.error('Failed to initialize Nostr:', error);
--            setError('Failed to initialize Nostr connection');
--        }
--    };
--
--    const handleLogin = async () => {
--        setIsLoading(true);
--        setError(null);
--        try {
--            const response = await nostrService.login();
--            setAuthResponse(response);
--            onModeChange(response.user.mode);
--        } catch (error) {
--            logger.error('Login failed:', error);
--            setError(error instanceof Error ? error.message : 'Login failed');
--        } finally {
--            setIsLoading(false);
--        }
--    };
--
--    const handleLogout = async () => {
--        setIsLoading(true);
--        try {
--            await nostrService.logout();
--            setAuthResponse(null);
--            onModeChange('normal');
--        } catch (error) {
--            logger.error('Logout failed:', error);
--            setError(error instanceof Error ? error.message : 'Logout failed');
--        } finally {
--            setIsLoading(false);
--        }
--    };
--
--    const handleModeSwitch = async () => {
--        if (!authResponse) return;
--
--        const newMode = authResponse.user.mode === 'normal' ? 'power' : 'normal';
--        setIsLoading(true);
--        setError(null);
--
--        try {
--            const response = await fetch('/api/auth/nostr/mode', {
--                method: 'POST',
--                headers: {
--                    'Content-Type': 'application/json',
--                    ...nostrService.getAuthHeaders(),
--                },
--                body: JSON.stringify({
--                    mode: newMode,
--                }),
--            });
--
--            if (!response.ok) {
--                throw new Error('Failed to switch mode');
--            }
--
--            const updatedAuth = await response.json();
--            setAuthResponse(updatedAuth);
--            onModeChange(updatedAuth.user.mode);
--        } catch (error) {
--            logger.error('Mode switch failed:', error);
--            setError(error instanceof Error ? error.message : 'Failed to switch mode');
--        } finally {
--            setIsLoading(false);
--        }
--    };
--
--    const npub = nostrService.getNpub();
--    const currentMode = nostrService.getCurrentMode();
--
--    return (
--        <div style={styles.container}>
--            <div style={styles.statusSection}>
--                {npub ? (
--                    <>
--                        <div>Logged in as: {npub}</div>
--                        <div>Mode: {currentMode === 'power' ? 'Power User' : 'Normal User'}</div>
--                    </>
--                ) : (
--                    <div>Not logged in</div>
--                )}
--            </div>
--
--            <div style={styles.buttonContainer}>
--                {!npub ? (
--                    <button
--                        onClick={handleLogin}
--                        disabled={isLoading}
--                        style={{
--                            ...styles.button,
--                            ...(isLoading ? styles.disabledButton : {}),
--                        }}
--                    >
--                        {isLoading ? 'Connecting...' : 'Login with Nostr'}
--                    </button>
--                ) : (
--                    <>
--                        <button
--                            onClick={handleModeSwitch}
--                            disabled={isLoading}
--                            style={{
--                                ...styles.button,
--                                ...(isLoading ? styles.disabledButton : {}),
--                            }}
--                        >
--                            Switch to {currentMode === 'power' ? 'Normal' : 'Power'} Mode
--                        </button>
--                        <button
--                            onClick={handleLogout}
--                            disabled={isLoading}
--                            style={{
--                                ...styles.button,
--                                ...styles.warningButton,
--                                ...(isLoading ? styles.disabledButton : {}),
--                            }}
--                        >
--                            Logout
--                        </button>
--                    </>
--                )}
--            </div>
--
--            {error && <div style={styles.errorMessage}>{error}</div>}
--        </div>
--    );
--};
-\ No newline at end of file
-diff --git a/client/core/debugState.ts b/client/core/debugState.ts
-new file mode 100644
-index 00000000..543a9a04
---- /dev/null
-+++ b/client/core/debugState.ts
-@@ -0,0 +1,96 @@
-+import { SettingsStore } from '../state/SettingsStore';
-+
-+export interface DebugState {
-+    enabled: boolean;
-+    logFullJson: boolean;
-+    enableDataDebug: boolean;
-+    enableWebsocketDebug: boolean;
-+    logBinaryHeaders: boolean;
-+}
-+
-+class DebugStateManager {
-+    private static instance: DebugStateManager | null = null;
-+    private state: DebugState = {
-+        enabled: false,
-+        logFullJson: false,
-+        enableDataDebug: false,
-+        enableWebsocketDebug: false,
-+        logBinaryHeaders: false
-+    };
-+
-+    private constructor() {}
-+
-+    public static getInstance(): DebugStateManager {
-+        if (!DebugStateManager.instance) {
-+            DebugStateManager.instance = new DebugStateManager();
-+        }
-+        return DebugStateManager.instance;
-+    }
-+
-+    public async initialize(): Promise<void> {
-+        const settingsStore = SettingsStore.getInstance();
-+        await settingsStore.initialize();
-+
-+        // Load initial debug settings
-+        this.state = {
-+            enabled: settingsStore.get('system.debug.enabled') as boolean ?? false,
-+            logFullJson: settingsStore.get('system.debug.log_full_json') as boolean ?? false,
-+            enableDataDebug: settingsStore.get('system.debug.enable_data_debug') as boolean ?? false,
-+            enableWebsocketDebug: settingsStore.get('system.debug.enable_websocket_debug') as boolean ?? false,
-+            logBinaryHeaders: settingsStore.get('system.debug.log_binary_headers') as boolean ?? false
-+        };
-+
-+        // Subscribe to debug setting changes
-+        settingsStore.subscribe('system.debug.enabled', (_, value) => {
-+            this.state.enabled = value as boolean;
-+            this.updateLoggerConfig();
-+        });
-+
-+        settingsStore.subscribe('system.debug.log_full_json', (_, value) => {
-+            this.state.logFullJson = value as boolean;
-+            this.updateLoggerConfig();
-+        });
-+
-+        settingsStore.subscribe('system.debug.enable_data_debug', (_, value) => {
-+            this.state.enableDataDebug = value as boolean;
-+        });
-+
-+        settingsStore.subscribe('system.debug.enable_websocket_debug', (_, value) => {
-+            this.state.enableWebsocketDebug = value as boolean;
-+        });
-+
-+        settingsStore.subscribe('system.debug.log_binary_headers', (_, value) => {
-+            this.state.logBinaryHeaders = value as boolean;
-+        });
-+
-+        this.updateLoggerConfig();
-+    }
-+
-+    private updateLoggerConfig(): void {
-+        const { LoggerConfig } = require('./logger');
-+        LoggerConfig.setGlobalDebug(this.state.enabled);
-+        LoggerConfig.setFullJson(this.state.logFullJson);
-+    }
-+
-+    public isEnabled(): boolean {
-+        return this.state.enabled;
-+    }
-+
-+    public isWebsocketDebugEnabled(): boolean {
-+        return this.state.enabled && this.state.enableWebsocketDebug;
-+    }
-+
-+    public isDataDebugEnabled(): boolean {
-+        return this.state.enabled && this.state.enableDataDebug;
-+    }
-+
-+    public shouldLogBinaryHeaders(): boolean {
-+        return this.state.enabled && this.state.logBinaryHeaders;
-+    }
-+
-+    public getState(): DebugState {
-+        return { ...this.state };
-+    }
-+}
-+
-+export const debugState = DebugStateManager.getInstance();
-\ No newline at end of file
-diff --git a/client/core/nostr.ts b/client/core/nostr.ts
-deleted file mode 100644
-index 0d021c52..00000000
---- a/client/core/nostr.ts
-+++ /dev/null
-@@ -1,194 +0,0 @@
--import { getPublicKey, nip19, Event as NostrEvent, UnsignedEvent } from 'nostr-tools';
--import { createLogger } from './logger';
--import { NostrAuthResponse, UserMode } from '../types/nostr';
--
--const logger = createLogger('NostrService');
--
--export type { NostrAuthResponse };
--
--export class NostrService {
--    private pubkey: string | null = null;
--    private token: string | null = null;
--    private mode: UserMode = 'normal';
--
--    async init(): Promise<void> {
--        try {
--            // Check for existing session
--            const storedPubkey = localStorage.getItem('nostr_pubkey');
--            const storedToken = localStorage.getItem('nostr_token');
--            
--            if (storedPubkey && storedToken) {
--                const isValid = await this.validateSession(storedPubkey, storedToken);
--                if (isValid) {
--                    this.pubkey = storedPubkey;
--                    this.token = storedToken;
--                    logger.info('Restored existing Nostr session');
--                } else {
--                    this.clearSession();
--                }
--            }
--        } catch (error) {
--            logger.error('Failed to initialize Nostr:', error);
--            throw error;
--        }
--    }
--
--    async login(): Promise<NostrAuthResponse> {
--        try {
--            // Check if we have a browser extension (e.g., Alby, nos2x)
--            if (typeof window.nostr === 'undefined') {
--                throw new Error('No Nostr extension found. Please install Alby or nos2x.');
--            }
--
--            // Request public key
--            const pubkey = await window.nostr.getPublicKey();
--            
--            // Create authentication event
--            const event: UnsignedEvent = {
--                kind: 27235,
--                pubkey,
--                created_at: Math.floor(Date.now() / 1000),
--                tags: [],
--                content: 'Login request',
--            };
--
--            // Sign the event using the extension
--            const signedEvent = await window.nostr.signEvent(event);
--
--            // Send to our backend
--            const response = await fetch('/api/auth/nostr/login', {
--                method: 'POST',
--                headers: {
--                    'Content-Type': 'application/json',
--                },
--                body: JSON.stringify(signedEvent),
--            });
--
--            if (!response.ok) {
--                throw new Error('Login failed');
--            }
--
--            const authResponse: NostrAuthResponse = await response.json();
--
--            // Store session
--            this.pubkey = authResponse.user.pubkey;
--            this.token = authResponse.token;
--            this.mode = authResponse.user.mode;
--
--            localStorage.setItem('nostr_pubkey', authResponse.user.pubkey);
--            localStorage.setItem('nostr_token', authResponse.token);
--
--            return authResponse;
--        } catch (error) {
--            logger.error('Login failed:', error);
--            throw error;
--        }
--    }
--
--    async logout(): Promise<void> {
--        if (!this.pubkey) {
--            return;
--        }
--
--        try {
--            await fetch('/api/auth/nostr/logout', {
--                method: 'POST',
--                headers: {
--                    'Content-Type': 'application/json',
--                },
--                body: JSON.stringify({ pubkey: this.pubkey }),
--            });
--        } finally {
--            this.clearSession();
--        }
--    }
--
--    private async validateSession(pubkey: string, token: string): Promise<boolean> {
--        try {
--            const response = await fetch('/api/auth/nostr/validate', {
--                method: 'POST',
--                headers: {
--                    'Content-Type': 'application/json',
--                },
--                body: JSON.stringify({ pubkey, token }),
--            });
--
--            const data = await response.json();
--            return data.valid;
--        } catch (error) {
--            logger.error('Session validation failed:', error);
--            return false;
--        }
--    }
--
--    async refreshSession(): Promise<string | null> {
--        if (!this.pubkey || !this.token) {
--            return null;
--        }
--
--        try {
--            const response = await fetch('/api/auth/nostr/refresh', {
--                method: 'POST',
--                headers: {
--                    'Content-Type': 'application/json',
--                },
--                body: JSON.stringify({
--                    pubkey: this.pubkey,
--                    token: this.token,
--                }),
--            });
--
--            if (!response.ok) {
--                throw new Error('Session refresh failed');
--            }
--
--            const data = await response.json();
--            this.token = data.token;
--            localStorage.setItem('nostr_token', data.token);
--            
--            return data.token;
--        } catch (error) {
--            logger.error('Failed to refresh session:', error);
--            this.clearSession();
--            return null;
--        }
--    }
--
--    private clearSession(): void {
--        this.pubkey = null;
--        this.token = null;
--        this.mode = 'normal';
--        localStorage.removeItem('nostr_pubkey');
--        localStorage.removeItem('nostr_token');
--    }
--
--    isLoggedIn(): boolean {
--        return !!(this.pubkey && this.token);
--    }
--
--    getCurrentMode(): UserMode {
--        return this.mode;
--    }
--
--    getAuthHeaders(): Record<string, string> {
--        if (!this.pubkey || !this.token) {
--            return {};
--        }
--
--        return {
--            'X-Nostr-Pubkey': this.pubkey,
--            'X-Nostr-Auth': this.token,
--        };
--    }
--
--    getPubkey(): string | null {
--        return this.pubkey;
--    }
--
--    getNpub(): string | null {
--        return this.pubkey ? nip19.npubEncode(this.pubkey) : null;
--    }
--}
--
--// Export singleton instance
--export const nostrService = new NostrService();
-\ No newline at end of file
-diff --git a/client/index.html b/client/index.html
-index 9e7371f0..1a7a73f2 100644
---- a/client/index.html
-+++ b/client/index.html
-@@ -3,6 +3,8 @@
- <head>
-   <meta charset="UTF-8">
-   <meta name="viewport" content="width=device-width, initial-scale=1.0">
-+  <meta name="immersive-ar" content="true">
-+  <meta name="oculus-hand-tracking" content="true">
-   <title>LogseqXR Graph Visualization</title>
-   <style>
-     body {
-@@ -33,6 +35,37 @@
-       min-width: 300px;
-       overflow-y: auto;
-       box-shadow: -2px 0 10px rgba(0, 0, 0, 0.3);
-+      transition: opacity 0.3s ease;
-+    }
-+
-+    #control-panel.hidden {
-+      opacity: 0;
-+      pointer-events: none;
-+    }
-+
-+    #xr-button {
-+      position: fixed;
-+      bottom: 20px;
-+      left: 50%;
-+      transform: translateX(-50%);
-+      padding: 12px 24px;
-+      background: rgba(255, 255, 255, 0.2);
-+      border: 1px solid rgba(255, 255, 255, 0.3);
-+      border-radius: 20px;
-+      color: white;
-+      font-size: 16px;
-+      cursor: pointer;
-+      z-index: 1000;
-+      transition: all 0.3s ease;
-+    }
-+
-+    #xr-button:hover {
-+      background: rgba(255, 255, 255, 0.3);
-+    }
-+
-+    #xr-button.hidden {
-+      opacity: 0;
-+      pointer-events: none;
-     }
- 
-     .control-panel-header {
-diff --git a/client/index.ts b/client/index.ts
-index 66b9bd33..8941c68f 100644
---- a/client/index.ts
-+++ b/client/index.ts
-@@ -6,12 +6,23 @@ import { TextRenderer } from './rendering/textRenderer';
- import { WebSocketService } from './websocket/websocketService';
- import { SettingsStore } from './state/SettingsStore';
- import { LoggerConfig, createLogger } from './core/logger';
-+import { platformManager } from './platform/platformManager';
-+import { XRSessionManager } from './xr/xrSessionManager';
-+import { XRInitializer } from './xr/xrInitializer';
- import { SceneManager } from './rendering/scene';
- import { graphDataManager } from './state/graphData';
-+import { debugState } from './core/debugState';
- import './ui'; // Import UI initialization
- 
- const logger = createLogger('GraphVisualization');
- 
-+// Helper for conditional debug logging
-+function debugLog(message: string, ...args: any[]) {
-+    if (debugState.isDataDebugEnabled()) {
-+        logger.debug(message, ...args);
-+    }
-+}
-+
- export class GraphVisualization {
-     private sceneManager: SceneManager;
-     private nodeManager: EnhancedNodeManager;
-@@ -21,21 +32,17 @@ export class GraphVisualization {
-     private websocketService!: WebSocketService;
- 
-     private async initializeWebSocket(): Promise<void> {
--        logger.debug('Initializing WebSocket connection');
--        // Initialize settings first
--        const settingsStore = SettingsStore.getInstance();
--        await settingsStore.initialize();
--        logger.debug('Settings store initialized');
--
-+        debugLog('Initializing WebSocket connection');
-+        
-         // Load initial graph data
--        logger.debug('Loading initial graph data');
-+        debugLog('Loading initial graph data');
-         try {
-             await graphDataManager.fetchInitialData();
-             // Update visualization with initial data
-             const graphData = graphDataManager.getGraphData();
-             this.nodeManager.updateNodes(graphData.nodes);
-             this.edgeManager.updateEdges(graphData.edges);
--            logger.debug('Initial graph data loaded and visualization updated');
-+            debugLog('Initial graph data loaded and visualization updated');
-         } catch (error) {
-             logger.error('Failed to load initial graph data:', error);
-         }
-@@ -43,26 +50,26 @@ export class GraphVisualization {
-         // Then initialize WebSocket for position updates
-         this.websocketService = WebSocketService.getInstance();
-         this.websocketService.onBinaryMessage((nodes) => {
--            logger.debug('Received binary node update', { nodeCount: nodes.length });
-+            debugLog('Received binary node update', { nodeCount: nodes.length });
-             this.nodeManager.updateNodePositions(nodes);
-         });
-         this.websocketService.onSettingsUpdate((updatedSettings) => {
--            logger.debug('Received settings update');
-+            debugLog('Received settings update');
-             this.handleSettingsUpdate(updatedSettings);
-         });
-         this.websocketService.onConnectionStatusChange((connected) => {
-             logger.info(`WebSocket connection status changed: ${connected}`);
-             if (connected) {
--                logger.debug('Requesting position updates');
-+                debugLog('Requesting position updates');
-                 this.websocketService.sendMessage({ type: 'requestInitialData' });
-             }
-         });
-         this.websocketService.connect();
--        logger.debug('WebSocket initialization complete');
-+        debugLog('WebSocket initialization complete');
-     }
- 
-     constructor(settings: Settings) {
--        logger.debug('Initializing GraphVisualization');
-+        debugLog('Initializing GraphVisualization');
-         
-         // Get existing canvas element
-         const canvas = document.getElementById('main-canvas') as HTMLCanvasElement;
-@@ -88,12 +95,12 @@ export class GraphVisualization {
-         
-         // Start rendering
-         this.sceneManager.start();
--        logger.debug('GraphVisualization initialization complete');
-+        debugLog('GraphVisualization initialization complete');
-     }
- 
- 
-     public handleSettingsUpdate(settings: Settings) {
--        logger.debug('Handling settings update');
-+        debugLog('Handling settings update');
-         this.nodeManager.handleSettingsUpdate(settings);
-         this.edgeManager.handleSettingsUpdate(settings);
-         this.hologramManager.updateSettings(settings);
-@@ -102,23 +109,76 @@ export class GraphVisualization {
-     }
- 
-     public dispose() {
--        logger.debug('Disposing GraphVisualization');
-+        debugLog('Disposing GraphVisualization');
-         this.nodeManager.dispose();
-         this.edgeManager.dispose();
-         this.hologramManager.dispose();
-         this.textRenderer.dispose();
-         this.websocketService.close();
-         SceneManager.cleanup();
--        logger.debug('GraphVisualization disposed');
-+        debugLog('GraphVisualization disposed');
-     }
- }
- 
- // Import default settings
- import { defaultSettings } from './state/defaultSettings';
- 
--// Enable debug logging
--LoggerConfig.setGlobalDebug(true);
--LoggerConfig.setFullJson(true);
-+// Initialize settings and logging
-+async function init() {
-+    // Initialize settings first
-+    const settingsStore = SettingsStore.getInstance();
-+    await settingsStore.initialize();
-+    
-+    // Configure logging based on settings
-+    const debugEnabled = settingsStore.get('system.debug.enabled') as boolean;
-+    const logFullJson = settingsStore.get('system.debug.log_full_json') as boolean;
-+    LoggerConfig.setGlobalDebug(debugEnabled);
-+    LoggerConfig.setFullJson(logFullJson);
-+    
-+    // Subscribe to debug setting changes
-+    settingsStore.subscribe('system.debug.enabled', (_, value) => {
-+        LoggerConfig.setGlobalDebug(value as boolean);
-+    });
-+    settingsStore.subscribe('system.debug.log_full_json', (_, value) => {
-+        LoggerConfig.setFullJson(value as boolean);
-+    });
-+    
-+    logger.log('Starting application...');
-+    
-+    try {
-+        // Initialize settings first
-+        const settingsStore = SettingsStore.getInstance();
-+        await settingsStore.initialize();
-+
-+        // Initialize UI with settings
-+        const { initializeUI } = await import('./ui');
-+        await initializeUI();
-+        
-+        // Initialize main visualization and store globally
-+        const viz = new GraphVisualization(defaultSettings);
-+        (window as any).visualization = viz;
-+        
-+        // Initialize platform and XR components
-+        await platformManager.initialize(defaultSettings);
-+        
-+        // Get canvas and scene manager
-+        const canvas = document.getElementById('main-canvas') as HTMLCanvasElement;
-+        if (!canvas) {
-+            throw new Error('Could not find #main-canvas element');
-+        }
-+        const sceneManager = SceneManager.getInstance(canvas);
-+        
-+        // Initialize XR components
-+        const xrSessionManager = XRSessionManager.getInstance(sceneManager);
-+        XRInitializer.getInstance(xrSessionManager);
-+        
-+        logger.info('Application initialized successfully');
-+    } catch (error) {
-+        logger.error('Failed to initialize application components:', error);
-+        throw error;
-+    }
-+}
- 
--logger.log('Starting application...');
--new GraphVisualization(defaultSettings);
-+init().catch(error => {
-+    console.error('Failed to initialize application:', error);
-+});
-diff --git a/client/platform/platformManager.ts b/client/platform/platformManager.ts
-index 81a00080..2d067466 100644
---- a/client/platform/platformManager.ts
-+++ b/client/platform/platformManager.ts
-@@ -68,8 +68,15 @@ export class PlatformManager extends BrowserEventEmitter {
-     this.detectPlatform();
-     await this.detectCapabilities();
-     
--    // Initialize platform with settings
--    if (settings.xr?.mode) {
-+    // Auto-enable XR mode for Quest devices unless explicitly disabled in settings
-+    if (this.isQuest()) {
-+      this._isXRMode = settings.xr?.mode !== 'inline';
-+      if (this._isXRMode) {
-+        this.capabilities.xrSupported = await this.checkXRSupport('immersive-ar');
-+      }
-+    }
-+    // For other platforms, initialize based on settings
-+    else if (settings.xr?.mode) {
-       this._isXRMode = true;
-       this.capabilities.xrSupported = await this.checkXRSupport(
-         settings.xr?.mode as XRSessionMode
-@@ -77,15 +84,37 @@ export class PlatformManager extends BrowserEventEmitter {
-     }
-     
-     this.initialized = true;
--    logger.log('Platform manager initialized');
-+    logger.log('Platform manager initialized:', {
-+      platform: this.platform,
-+      isXRMode: this._isXRMode,
-+      capabilities: this.capabilities
-+    });
-   }
- 
-   private detectPlatform(): void {
-+    // Try modern User-Agent Client Hints API first
-+    if ('userAgentData' in navigator) {
-+      const brands = (navigator as any).userAgentData.brands;
-+      const isOculusDevice = brands.some((b: any) =>
-+        /oculus|meta|quest/i.test(b.brand)
-+      );
-+      if (isOculusDevice) {
-+        this.platform = 'quest';
-+        logger.log('Quest platform detected via userAgentData');
-+        return;
-+      }
-+    }
-+
-+    // Fallback to traditional user agent detection
-     const userAgent = navigator.userAgent.toLowerCase();
--    const isQuest = userAgent.includes('quest');
-+    const isQuest = userAgent.includes('quest') ||
-+                    userAgent.includes('oculus') ||
-+                    userAgent.includes('oculusbrowser') ||
-+                    userAgent.includes('meta');
-     
-     if (isQuest) {
-       this.platform = 'quest';
-+      logger.log('Quest platform detected via userAgent');
-     } else if (userAgent.includes('chrome') || userAgent.includes('firefox') || userAgent.includes('safari')) {
-       this.platform = 'browser';
-     } else {
-@@ -97,7 +126,16 @@ export class PlatformManager extends BrowserEventEmitter {
-     // WebXR support
-     if ('xr' in navigator && navigator.xr) {
-       try {
--        this.capabilities.xrSupported = await navigator.xr.isSessionSupported('immersive-ar');
-+        // For Quest devices, prioritize checking immersive-ar support
-+        if (this.isQuest()) {
-+          this.capabilities.xrSupported = await navigator.xr.isSessionSupported('immersive-ar');
-+        } else {
-+          // For other platforms, check both VR and AR
-+          this.capabilities.xrSupported = 
-+            await navigator.xr.isSessionSupported('immersive-ar') ||
-+            await navigator.xr.isSessionSupported('immersive-vr');
-+        }
-+        
-         this.capabilities.webxr = this.capabilities.xrSupported;
-         this.capabilities.handTracking = this.capabilities.xrSupported;
-         this.capabilities.planeDetection = this.capabilities.xrSupported;
-@@ -183,7 +221,6 @@ export class PlatformManager extends BrowserEventEmitter {
- 
-       const session = await navigator.xr.requestSession(mode, features);
- 
--      // Update capabilities based on session features
-       session.addEventListener('end', () => {
-         logger.log('XR session ended');
-         this.emit('xrsessionend');
-@@ -204,7 +241,6 @@ export class PlatformManager extends BrowserEventEmitter {
-         if (supported) {
-           this.capabilities.webxr = true;
-           this.capabilities.handTracking = true;
--          // Only set plane detection for AR mode
-           this.capabilities.planeDetection = mode === 'immersive-ar';
-           this.emit('xrdevicechange', true);
-           logger.log('WebXR supported for mode:', mode);
-diff --git a/client/rendering/EdgeManager.ts b/client/rendering/EdgeManager.ts
-index 9a3560d0..2cc41528 100644
---- a/client/rendering/EdgeManager.ts
-+++ b/client/rendering/EdgeManager.ts
-@@ -19,7 +19,7 @@ export class EdgeManager {
-     private instancedMesh: InstancedMesh | null = null;
-     private geometryFactory: GeometryFactory;
-     private materialFactory: MaterialFactory;
--    private quaternion = new Quaternion();
-+    private static UP = new Vector3(0, 1, 0);
- 
-     constructor(scene: Scene, settings: Settings) {
-         this.scene = scene;
-@@ -63,14 +63,27 @@ export class EdgeManager {
-             // Calculate edge direction and length
-             const direction = endPos.clone().sub(startPos);
-             const length = direction.length();
-+            direction.normalize();
-             
-             // Position the edge at the midpoint between source and target
--            const position = startPos.clone().add(direction.multiplyScalar(0.5));
-+            const position = startPos.clone().add(direction.clone().multiplyScalar(length * 0.5));
-             
--            // Calculate rotation
--            const matrix = new Matrix4();
-+            // Create transformation components
-             const scale = new Vector3(1, length, 1);
--            matrix.compose(position, this.quaternion, scale);
-+            
-+            // Calculate rotation from UP vector to edge direction
-+            const upDot = EdgeManager.UP.dot(direction);
-+            const rotationAxis = new Vector3().crossVectors(EdgeManager.UP, direction).normalize();
-+            const rotationAngle = Math.acos(upDot);
-+            
-+            // Create matrix from components
-+            const matrix = new Matrix4().compose(
-+                position,
-+                Math.abs(Math.abs(upDot) - 1) > 0.001
-+                    ? new Quaternion().setFromAxisAngle(rotationAxis, rotationAngle)
-+                    : new Quaternion(),
-+                scale
-+            );
- 
-             mesh.setMatrixAt(index, matrix);
-         });
-diff --git a/client/rendering/scene.ts b/client/rendering/scene.ts
-index b07e9042..82e87d22 100644
---- a/client/rendering/scene.ts
-+++ b/client/rendering/scene.ts
-@@ -50,12 +50,15 @@ export class SceneManager {
-     this.camera.position.set(0, 10, 50); // Position for better overview
-     this.camera.lookAt(0, 0, 0);
- 
--    // Create renderer
-+    // Create renderer with WebXR support
-     this.renderer = new WebGLRenderer({
-       canvas,
-       antialias: true,
-       alpha: true,
--      powerPreference: 'high-performance'
-+      powerPreference: 'high-performance',
-+      xr: {
-+        enabled: true
-+      }
-     });
-     this.renderer.setSize(window.innerWidth, window.innerHeight);
-     this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
-@@ -155,29 +158,50 @@ export class SceneManager {
- 
-   stop(): void {
-     this.isRunning = false;
-+    
-+    // Clean up animation loops
-+    if (this.renderer.xr.enabled) {
-+      this.renderer.setAnimationLoop(null);
-+    }
-     if (this.animationFrameId !== null) {
-       cancelAnimationFrame(this.animationFrameId);
-       this.animationFrameId = null;
-     }
-+    
-     logger.log('Scene rendering stopped');
-   }
- 
-   private animate = (): void => {
-     if (!this.isRunning) return;
- 
--    // Request next frame first to ensure smooth animation
--    this.animationFrameId = requestAnimationFrame(this.animate);
--    
--    // Update controls with damping
--    this.controls.update();
--
--    // Only use composer when bloom is actually enabled and has non-zero values
--    if (this.bloomPass.enabled &&
--        (this.bloomPass.strength > 0 ||
--         this.bloomPass.radius > 0 ||
--         (this.bloomPass as any).edgeStrength > 0 ||
--         (this.bloomPass as any).nodeStrength > 0 ||
--         (this.bloomPass as any).environmentStrength > 0)) {
-+    // Set up animation loop
-+    if (this.renderer.xr.enabled) {
-+      // For XR, use the built-in animation loop
-+      this.renderer.setAnimationLoop(this.render);
-+    } else {
-+      // For non-XR, use requestAnimationFrame
-+      this.animationFrameId = requestAnimationFrame(this.animate);
-+      this.render();
-+    }
-+  }
-+
-+  private render = (): void => {
-+    // Update controls only in non-XR mode
-+    if (!this.renderer.xr.enabled) {
-+      this.controls.update();
-+    }
-+
-+    // Determine if we should use post-processing
-+    const usePostProcessing = !this.renderer.xr.enabled &&
-+                            this.bloomPass.enabled &&
-+                            (this.bloomPass.strength > 0 ||
-+                             this.bloomPass.radius > 0 ||
-+                             (this.bloomPass as any).edgeStrength > 0 ||
-+                             (this.bloomPass as any).nodeStrength > 0 ||
-+                             (this.bloomPass as any).environmentStrength > 0);
-+
-+    // Render scene
-+    if (usePostProcessing) {
-       this.composer.render();
-     } else {
-       this.renderer.render(this.scene, this.camera);
-diff --git a/client/state/defaultSettings.ts b/client/state/defaultSettings.ts
-index 84445395..50d89c82 100644
---- a/client/state/defaultSettings.ts
-+++ b/client/state/defaultSettings.ts
-@@ -1,5 +1,5 @@
- import { Settings, VisualizationSettings } from '../types/settings';
--import { NODE_COLOR, NODE_SIZE, LABEL_COLOR } from '../core/constants';
-+import { LABEL_COLOR } from '../core/constants';
- 
- // Helper function to convert number to hex color
- function toHexColor(num: number): string {
-@@ -8,74 +8,83 @@ function toHexColor(num: number): string {
- 
- // Export visualization defaults separately for reuse
- export const defaultVisualizationSettings: VisualizationSettings = {
--    animations: {
--        enableMotionBlur: false,
--        enableNodeAnimations: false,
--        motionBlurStrength: 0.0,
--        selectionWaveEnabled: false,
--        pulseEnabled: false,
--        pulseSpeed: 0.0,
--        pulseStrength: 0.0,
--        waveSpeed: 0.0
--    },
--    bloom: {
--        enabled: false,
--        strength: 0.0,
--        radius: 0.0,
--        threshold: 1.0,
--        edgeBloomStrength: 0.0,
--        nodeBloomStrength: 0.0,
--        environmentBloomStrength: 0.0
-+    nodes: {
-+        quality: 'high',
-+        enableInstancing: true,
-+        enableMetadataShape: true,
-+        enableMetadataVisualization: true,
-+        baseSize: 1.5,
-+        sizeRange: [1.0, 3.0],
-+        baseColor: toHexColor(0x00ffff),
-+        opacity: 1,
-+        colorRangeAge: [toHexColor(0x00ffff), toHexColor(0xff00ff)],
-+        colorRangeLinks: [toHexColor(0x00ffff), toHexColor(0xff00ff)],
-+        metalness: 0.8,
-+        roughness: 0.2,
-+        enableHologram: false
-     },
-     edges: {
--        arrowSize: 0.15,
--        baseWidth: 2.0,
--        color: '#917f18',
--        enableArrows: false,
-+        color: toHexColor(0x888888),
-         opacity: 0.6,
--        widthRange: [1.0, 3.0]
-+        arrowSize: 0,
-+        baseWidth: 1,
-+        enableArrows: false,
-+        widthRange: [1, 2]
-     },
--    hologram: {
--        ringCount: 0,
--        ringColor: '#00ff00',
--        ringOpacity: 0.0,
--        ringSizes: [1.0, 1.2, 1.5],
--        ringRotationSpeed: 0.0,
--        enableBuckminster: false,
--        buckminsterScale: 1.0,
--        buckminsterOpacity: 0.0,
--        enableGeodesic: false,
--        geodesicScale: 1.0,
--        geodesicOpacity: 0.0,
--        enableTriangleSphere: false,
--        triangleSphereScale: 1.0,
--        triangleSphereOpacity: 0.0,
--        globalRotationSpeed: 0.0
-+    animations: {
-+        enableNodeAnimations: true,
-+        enableMotionBlur: false,
-+        motionBlurStrength: 0.5,
-+        selectionWaveEnabled: true,
-+        pulseEnabled: true,
-+        pulseSpeed: 1.5,
-+        pulseStrength: 1,
-+        waveSpeed: 1
-     },
-     labels: {
-         enableLabels: true,
-+        desktopFontSize: 16,
-         textColor: toHexColor(LABEL_COLOR),
--        textOutlineColor: '#000000',
--        textOutlineWidth: 0.1,
--        textResolution: 512,
--        textPadding: 16,
--        desktopFontSize: 48,
-+        textOutlineColor: toHexColor(0x000000),
-+        textOutlineWidth: 2,
-+        textResolution: 256,
-+        textPadding: 4,
-         billboardMode: true
-     },
--    nodes: {
--        baseColor: toHexColor(NODE_COLOR),
--        baseSize: NODE_SIZE,
--        sizeRange: [0.5, 1.0],
--        enableMetadataShape: false,
--        colorRangeAge: ['#ffffff', '#ffffff'],
--        colorRangeLinks: ['#ffffff', '#ffffff'],
--        metalness: 0.0,
--        roughness: 0.5,
--        opacity: 1.0,
--        enableMetadataVisualization: false,
--        enableHologram: false,
--        enableInstancing: false,
--        quality: 'low'
-+    rendering: {
-+        ambientLightIntensity: 0.5,
-+        directionalLightIntensity: 1.5,
-+        environmentIntensity: 1,
-+        backgroundColor: toHexColor(0x121212),
-+        enableAmbientOcclusion: true,
-+        enableAntialiasing: true,
-+        enableShadows: true
-+    },
-+    bloom: {
-+        enabled: true,
-+        strength: 1.5,
-+        radius: 0.8,
-+        threshold: 0.3,
-+        edgeBloomStrength: 0.5,
-+        nodeBloomStrength: 2,
-+        environmentBloomStrength: 1
-+    },
-+    hologram: {
-+        ringCount: 3,
-+        ringSizes: [1, 1.5, 2],
-+        ringRotationSpeed: 0.1,
-+        globalRotationSpeed: 0.1,
-+        ringColor: toHexColor(0x00ffff),
-+        ringOpacity: 0.5,
-+        enableBuckminster: false,
-+        buckminsterScale: 1,
-+        buckminsterOpacity: 0.5,
-+        enableGeodesic: false,
-+        geodesicScale: 1,
-+        geodesicOpacity: 0.5,
-+        enableTriangleSphere: false,
-+        triangleSphereScale: 1,
-+        triangleSphereOpacity: 0.5
-     },
-     physics: {
-         enabled: true,
-@@ -88,15 +97,6 @@ export const defaultVisualizationSettings: VisualizationSettings = {
-         collisionRadius: 0.25,
-         enableBounds: true,
-         boundsSize: 12.0
--    },
--    rendering: {
--        ambientLightIntensity: 0.3,
--        directionalLightIntensity: 1.0,
--        environmentIntensity: 0.6,
--        backgroundColor: '#000000',
--        enableAmbientOcclusion: false,
--        enableAntialiasing: false,
--        enableShadows: false
-     }
- };
- 
-@@ -104,61 +104,34 @@ export const defaultVisualizationSettings: VisualizationSettings = {
- export const defaultSettings: Settings = {
-     visualization: defaultVisualizationSettings,
-     system: {
--        network: {
--            bindAddress: '127.0.0.1',
--            domain: 'localhost',
--            port: 3000,
--            enableHttp2: true,
--            enableTls: false,
--            minTlsVersion: 'TLS1.2',
--            maxRequestSize: 10485760,
--            enableRateLimiting: true,
--            rateLimitRequests: 100,
--            rateLimitWindow: 60,
--            tunnelId: ''
--        },
-         websocket: {
--            url: '',
-             reconnectAttempts: 5,
-             reconnectDelay: 5000,
--            binaryChunkSize: 65536,
-+            binaryChunkSize: 1024,
-             compressionEnabled: true,
-             compressionThreshold: 1024,
--            maxConnections: 100,
--            maxMessageSize: 32 * 1024 * 1024,
-             updateRate: 60
-         },
--        security: {
--            allowedOrigins: ['http://localhost:3000'],
--            auditLogPath: './audit.log',
--            cookieHttponly: true,
--            cookieSamesite: 'Lax',
--            cookieSecure: false,
--            csrfTokenTimeout: 3600,
--            enableAuditLogging: true,
--            enableRequestValidation: true,
--            sessionTimeout: 86400
--        },
-         debug: {
--            enabled: true,
--            enableDataDebug: true,
--            enableWebsocketDebug: true,
--            logBinaryHeaders: true,
--            logFullJson: true
-+            enabled: false,
-+            enableDataDebug: false,
-+            enableWebsocketDebug: false,
-+            logBinaryHeaders: false,
-+            logFullJson: false
-         }
-     },
-     xr: {
-         mode: 'immersive-ar' as const,
--        quality: 'medium',
-+        quality: 'high',
-         roomScale: true,
--        spaceType: 'local-floor' as XRReferenceSpaceType,
-+        spaceType: 'local-floor',
-         enableHandTracking: true,
-         handMeshEnabled: true,
--        handMeshColor: '#ffffff',
-+        handMeshColor: toHexColor(0xffffff),
-         handMeshOpacity: 0.5,
-         handPointSize: 5,
-         handRayEnabled: true,
--        handRayColor: '#ffffff',
-+        handRayColor: toHexColor(0xffffff),
-         handRayWidth: 2,
-         gestureSsmoothing: 0.5,
-         enableHaptics: true,
-@@ -166,6 +139,18 @@ export const defaultSettings: Settings = {
-         dragThreshold: 0.1,
-         pinchThreshold: 0.5,
-         rotationThreshold: 0.1,
--        interactionRadius: 0.1
-+        interactionRadius: 0.1,
-+        // Platform settings
-+        autoEnterAR: true,
-+        hideControlPanel: true,
-+        preferredMode: 'immersive-ar',
-+        // Scene understanding
-+        enableLightEstimation: true,
-+        enablePlaneDetection: true,
-+        enableSceneUnderstanding: true,
-+        planeColor: toHexColor(0x808080),
-+        planeOpacity: 0.5,
-+        showPlaneOverlay: true,
-+        snapToFloor: true
-     }
--};
-+}
-diff --git a/client/types/nostr.ts b/client/types/nostr.ts
-deleted file mode 100644
-index 419de96c..00000000
---- a/client/types/nostr.ts
-+++ /dev/null
-@@ -1,29 +0,0 @@
--import { Event as NostrToolsEvent, UnsignedEvent } from 'nostr-tools';
--
--export type UserMode = 'normal' | 'power';
--
--export interface NostrAuthResponse {
--    user: {
--        pubkey: string;
--        npub: string;
--        mode: UserMode;
--        created_at: number;
--        last_seen: number;
--    };
--    token: string;
--}
--
--export interface NostrWindow {
--    nostr?: {
--        getPublicKey(): Promise<string>;
--        signEvent(event: UnsignedEvent): Promise<NostrToolsEvent>;
--        nip04?: {
--            encrypt(pubkey: string, plaintext: string): Promise<string>;
--            decrypt(pubkey: string, ciphertext: string): Promise<string>;
--        };
--    };
--}
--
--declare global {
--    interface Window extends NostrWindow {}
--}
-\ No newline at end of file
-diff --git a/client/types/settings.ts b/client/types/settings.ts
-index 4b7522b0..c4cd82a6 100644
---- a/client/types/settings.ts
-+++ b/client/types/settings.ts
-@@ -1,37 +1,195 @@
--import { z } from 'zod';
-+import { XRSessionMode } from './xr';
- 
--export type UserMode = 'normal' | 'power';
-+// Core visualization settings
-+export interface VisualizationSettings {
-+    animations: AnimationSettings;
-+    bloom: BloomSettings;
-+    edges: EdgeSettings;
-+    hologram: HologramSettings;
-+    labels: LabelSettings;
-+    nodes: NodeSettings;
-+    physics: PhysicsSettings;
-+    rendering: RenderingSettings;
-+}
- 
--export interface ApiKeys {
--    perplexity?: string;
--    openai?: string;
-+// Component settings interfaces
-+export interface AnimationSettings {
-+    enableNodeAnimations: boolean;
-+    enableMotionBlur: boolean;
-+    motionBlurStrength: number;
-+    selectionWaveEnabled: boolean;
-+    pulseEnabled: boolean;
-+    pulseSpeed: number;
-+    pulseStrength: number;
-+    waveSpeed: number;
- }
- 
--export interface Settings {
--    mode: UserMode;
--    apiKeys: ApiKeys;
-+export interface BloomSettings {
-+    enabled: boolean;
-+    strength: number;
-+    radius: number;
-+    threshold: number;
-+    edgeBloomStrength: number;
-+    nodeBloomStrength: number;
-+    environmentBloomStrength: number;
-+}
-+
-+export interface EdgeSettings {
-+    color: string;
-+    opacity: number;
-+    arrowSize: number;
-+    baseWidth: number;
-+    enableArrows: boolean;
-+    widthRange: [number, number];
-+}
-+
-+export interface HologramSettings {
-+    ringCount: number;
-+    ringSizes: number[];
-+    ringRotationSpeed: number;
-+    globalRotationSpeed: number;
-+    ringColor: string;
-+    ringOpacity: number;
-+    enableBuckminster: boolean;
-+    buckminsterScale: number;
-+    buckminsterOpacity: number;
-+    enableGeodesic: boolean;
-+    geodesicScale: number;
-+    geodesicOpacity: number;
-+    enableTriangleSphere: boolean;
-+    triangleSphereScale: number;
-+    triangleSphereOpacity: number;
- }
- 
--// Validation schemas
--export const apiKeysSchema = z.object({
--    perplexity: z.string().optional(),
--    openai: z.string().optional(),
--});
-+export interface LabelSettings {
-+    enableLabels: boolean;
-+    desktopFontSize: number;
-+    textColor: string;
-+    textOutlineColor: string;
-+    textOutlineWidth: number;
-+    textResolution: number;
-+    textPadding: number;
-+    billboardMode: boolean;
-+}
- 
--export const settingsSchema = z.object({
--    mode: z.enum(['normal', 'power']),
--    apiKeys: apiKeysSchema,
--});
-+export interface NodeSettings {
-+    quality: 'low' | 'medium' | 'high';
-+    enableInstancing: boolean;
-+    enableHologram: boolean;
-+    enableMetadataShape: boolean;
-+    enableMetadataVisualization: boolean;
-+    baseSize: number;
-+    sizeRange: [number, number];
-+    baseColor: string;
-+    opacity: number;
-+    colorRangeAge: [string, string];
-+    colorRangeLinks: [string, string];
-+    metalness: number;
-+    roughness: number;
-+}
- 
--// Type guards
--export const isValidUserMode = (mode: string): mode is UserMode => {
--    return mode === 'normal' || mode === 'power';
--};
-+export interface PhysicsSettings {
-+    enabled: boolean;
-+    attractionStrength: number;
-+    repulsionStrength: number;
-+    springStrength: number;
-+    damping: number;
-+    iterations: number;
-+    maxVelocity: number;
-+    collisionRadius: number;
-+    enableBounds: boolean;
-+    boundsSize: number;
-+}
- 
--export const isValidApiKeys = (keys: unknown): keys is ApiKeys => {
--    return apiKeysSchema.safeParse(keys).success;
--};
-+export interface RenderingSettings {
-+    ambientLightIntensity: number;
-+    directionalLightIntensity: number;
-+    environmentIntensity: number;
-+    backgroundColor: string;
-+    enableAmbientOcclusion: boolean;
-+    enableAntialiasing: boolean;
-+    enableShadows: boolean;
-+}
-+
-+// Client-side WebSocket settings (non-sensitive)
-+export interface WebSocketSettings {
-+    reconnectAttempts: number;
-+    reconnectDelay: number;
-+    binaryChunkSize: number;
-+    compressionEnabled: boolean;
-+    compressionThreshold: number;
-+    updateRate: number;
-+}
-+
-+// Debug settings (UI-only)
-+export interface DebugSettings {
-+    enabled: boolean;
-+    enableDataDebug: boolean;
-+    enableWebsocketDebug: boolean;
-+    logBinaryHeaders: boolean;
-+    logFullJson: boolean;
-+}
-+
-+// XR settings
-+export interface XRSettings {
-+    // Session Settings
-+    mode: XRSessionMode;
-+    quality: 'low' | 'medium' | 'high';
-+    roomScale: boolean;
-+    spaceType: 'viewer' | 'local' | 'local-floor' | 'bounded-floor' | 'unbounded';
-+    
-+    // Platform Settings
-+    autoEnterAR?: boolean;
-+    hideControlPanel?: boolean;
-+    preferredMode?: XRSessionMode;
-+    
-+    // Hand Tracking
-+    enableHandTracking: boolean;
-+    handMeshEnabled: boolean;
-+    handMeshColor: string;
-+    handMeshOpacity: number;
-+    handPointSize: number;
-+    handRayEnabled: boolean;
-+    handRayColor: string;
-+    handRayWidth: number;
-+    gestureSsmoothing: number;
-+    
-+    // Interaction
-+    enableHaptics: boolean;
-+    hapticIntensity: number;
-+    dragThreshold: number;
-+    pinchThreshold: number;
-+    rotationThreshold: number;
-+    interactionRadius: number;
-+    
-+    // Scene Understanding
-+    enableLightEstimation?: boolean;
-+    enablePlaneDetection?: boolean;
-+    enableSceneUnderstanding?: boolean;
-+    planeColor?: string;
-+    planeOpacity?: number;
-+    showPlaneOverlay?: boolean;
-+    snapToFloor?: boolean;
-+}
-+
-+// Main settings interface
-+export interface Settings {
-+    visualization: {
-+        nodes: NodeSettings;
-+        edges: EdgeSettings;
-+        physics: PhysicsSettings;
-+        rendering: RenderingSettings;
-+        animations: AnimationSettings;
-+        labels: LabelSettings;
-+        bloom: BloomSettings;
-+        hologram: HologramSettings;
-+    };
-+    system: {
-+        websocket: WebSocketSettings;
-+        debug: DebugSettings;
-+    };
-+    xr: XRSettings;
-+}
- 
--export const isValidSettings = (settings: unknown): settings is Settings => {
--    return settingsSchema.safeParse(settings).success;
--};
-+export * from './settings/base';
-+export * from './settings/utils';
-diff --git a/client/types/settings/validation.ts b/client/types/settings/validation.ts
-index 2294c07c..05bdbb7a 100644
---- a/client/types/settings/validation.ts
-+++ b/client/types/settings/validation.ts
-@@ -74,26 +74,13 @@ function validateVisualizationSettings(visualization: Settings['visualization'],
- }
- 
- function validateSystemSettings(system: Settings['system'], errors: ValidationError[]): void {
--    // Validate network settings
--    if (system.network) {
--        validateNumericRange('system.network.port', system.network.port, 1, 65535, errors);
--        if (system.network.enableRateLimiting && system.network.rateLimitRequests <= 0) {
--            errors.push({
--                path: 'system.network.rateLimitRequests',
--                message: 'Rate limit requests must be greater than 0'
--            });
--        }
--    }
--
-     // Validate websocket settings
-     if (system.websocket) {
-         validateNumericRange('system.websocket.updateRate', system.websocket.updateRate, 1, 120, errors);
--        if (system.websocket.maxMessageSize > 100 * 1024 * 1024) { // 100MB limit
--            errors.push({
--                path: 'system.websocket.maxMessageSize',
--                message: 'Max message size cannot exceed 100MB'
--            });
--        }
-+        validateNumericRange('system.websocket.reconnectAttempts', system.websocket.reconnectAttempts, 1, 10, errors);
-+        validateNumericRange('system.websocket.reconnectDelay', system.websocket.reconnectDelay, 1000, 30000, errors);
-+        validateNumericRange('system.websocket.binaryChunkSize', system.websocket.binaryChunkSize, 1024, 1048576, errors);
-+        validateNumericRange('system.websocket.compressionThreshold', system.websocket.compressionThreshold, 512, 1048576, errors);
-     }
- }
- 
-diff --git a/client/types/settings/xr.ts b/client/types/settings/xr.ts
-index 4557c5ff..50ecf1dc 100644
---- a/client/types/settings/xr.ts
-+++ b/client/types/settings/xr.ts
-@@ -6,6 +6,11 @@ export interface XRSettings {
-     roomScale: boolean;
-     spaceType: 'viewer' | 'local' | 'local-floor' | 'bounded-floor' | 'unbounded';
-     
-+    // Platform Settings
-+    autoEnterAR?: boolean;
-+    hideControlPanel?: boolean;
-+    preferredMode?: XRSessionMode;
-+    
-     // Hand Tracking
-     enableHandTracking: boolean;
-     handMeshEnabled: boolean;
-@@ -62,10 +67,17 @@ export interface WebXRSettings extends XRSettings {
- 
- // Default XR settings
- export const defaultXRSettings: XRSettings = {
-+    // Session Settings
-     mode: 'immersive-ar',
-     roomScale: true,
-     spaceType: 'local-floor',
-     
-+    // Platform Settings
-+    autoEnterAR: true,
-+    hideControlPanel: true,
-+    preferredMode: 'immersive-ar',
-+    
-+    // Hand Tracking
-     enableHandTracking: true,
-     handMeshEnabled: true,
-     handMeshColor: '#ffffff',
-@@ -76,6 +88,7 @@ export const defaultXRSettings: XRSettings = {
-     handRayWidth: 2,
-     gestureSsmoothing: 0.5,
-     
-+    // Interaction
-     enableHaptics: true,
-     hapticIntensity: 0.5,
-     dragThreshold: 0.02,
-@@ -83,6 +96,7 @@ export const defaultXRSettings: XRSettings = {
-     rotationThreshold: 0.1,
-     interactionRadius: 0.5,
-     
-+    // Scene Understanding
-     enableLightEstimation: true,
-     enablePlaneDetection: true,
-     enableSceneUnderstanding: true,
-@@ -91,6 +105,7 @@ export const defaultXRSettings: XRSettings = {
-     showPlaneOverlay: true,
-     snapToFloor: true,
-     
-+    // Passthrough
-     enablePassthroughPortal: false,
-     passthroughOpacity: 1,
-     passthroughBrightness: 1,
-@@ -99,5 +114,6 @@ export const defaultXRSettings: XRSettings = {
-     portalEdgeColor: '#ffffff',
-     portalEdgeWidth: 2,
-     
--    quality: 'medium'
-+    // Quality
-+    quality: 'high'
- };
-diff --git a/client/ui/ControlPanel.ts b/client/ui/ControlPanel.ts
-index 22f675af..53c9bbb7 100644
---- a/client/ui/ControlPanel.ts
-+++ b/client/ui/ControlPanel.ts
-@@ -21,6 +21,12 @@ export class ControlPanel {
-         // Initialize validation error display
-         this.validationDisplay = new ValidationErrorDisplay(this.container);
- 
-+        // Check platform and settings before showing panel
-+        const { platformManager } = require('../platform/platformManager');
-+        if (platformManager.isQuest()) {
-+            this.container.style.display = 'none';
-+        }
-+
-         this.initializePanel();
-     }
- 
-@@ -358,11 +364,11 @@ export class ControlPanel {
-     }
- 
-     public show(): void {
--        this.container.style.display = 'block';
-+        this.container.classList.remove('hidden');
-     }
- 
-     public hide(): void {
--        this.container.style.display = 'none';
-+        this.container.classList.add('hidden');
-     }
- 
-     public dispose(): void {
-diff --git a/client/ui/index.ts b/client/ui/index.ts
-index 145dedcb..03fad108 100644
---- a/client/ui/index.ts
-+++ b/client/ui/index.ts
-@@ -4,6 +4,9 @@ import './ControlPanel.css';
- 
- const logger = createLogger('UI');
- 
-+import { SettingsStore } from '../state/SettingsStore';
-+import { platformManager } from '../platform/platformManager';
-+
- // Initialize UI components
- export async function initializeUI(): Promise<void> {
-     try {
-@@ -12,7 +15,24 @@ export async function initializeUI(): Promise<void> {
-         const controlPanelElement = document.getElementById('control-panel');
-         if (controlPanelElement instanceof HTMLElement) {
-             logger.debug('Found control panel element, initializing ControlPanel');
--            ControlPanel.initialize(controlPanelElement);
-+            const controlPanel = ControlPanel.initialize(controlPanelElement);
-+            
-+            // Check if we should hide control panel based on platform
-+            if (platformManager.isQuest()) {
-+                controlPanel.hide();
-+            }
-+            
-+            // Initialize with current settings
-+            const settingsStore = SettingsStore.getInstance();
-+            if (settingsStore.isInitialized()) {
-+                const settings = settingsStore.get('');
-+                if (settings) {
-+                    logger.debug('Applying initial settings to control panel');
-+                    // Settings will be handled by ControlPanel's internal subscription
-+                }
-+            } else {
-+                logger.warn('Settings not initialized when initializing UI');
-+            }
-         } else {
-             logger.error('Control panel element not found');
-         }
-diff --git a/client/websocket/websocketService.ts b/client/websocket/websocketService.ts
-index 8bbc6e20..6d94a089 100644
---- a/client/websocket/websocketService.ts
-+++ b/client/websocket/websocketService.ts
-@@ -1,8 +1,20 @@
- import { createLogger } from '../core/logger';
- import { buildWsUrl } from '../core/api';
-+import { debugState } from '../core/debugState';
-+import pako from 'pako';
- 
- const logger = createLogger('WebSocketService');
- 
-+// Helper for conditional debug logging
-+function debugLog(message: string, ...args: any[]) {
-+    if (debugState.isWebsocketDebugEnabled()) {
-+        logger.debug(message, ...args);
-+    }
-+}
-+
-+// Compression settings
-+const COMPRESSION_THRESHOLD = 1024; // Only compress messages larger than 1KB
-+
- enum ConnectionState {
-     DISCONNECTED = 'disconnected',
-     CONNECTING = 'connecting',
-@@ -121,23 +133,25 @@ export class WebSocketService {
-             // Notify connection status change
-             if (this.connectionStatusHandler) {
-                 this.connectionStatusHandler(true);
--                logger.debug('Connection status handler notified: connected');
-+                debugLog('Connection status handler notified: connected');
-             }
- 
-             // Send request for position updates after connection
--            logger.debug('Requesting position updates');
-+            debugLog('Requesting position updates');
-             this.sendMessage({ type: 'requestInitialData' });
-         };
- 
-         this.ws.onerror = (event: Event): void => {
-             logger.error('WebSocket error:', event);
-             if (this.ws) {
--                logger.debug('Connection details:', {
--                    readyState: this.ws.readyState,
--                    url: this.url,
--                    connectionState: this.connectionState,
--                    reconnectAttempts: this.reconnectAttempts
--                });
-+                if (debugState.isWebsocketDebugEnabled()) {
-+                    debugLog('Connection details:', {
-+                        readyState: this.ws.readyState,
-+                        url: this.url,
-+                        connectionState: this.connectionState,
-+                        reconnectAttempts: this.reconnectAttempts
-+                    });
-+                }
-             }
-             if (this.ws?.readyState === WebSocket.CLOSED) {
-                 this.handleReconnect();
-@@ -150,7 +164,9 @@ export class WebSocketService {
-             // Notify connection status change
-             if (this.connectionStatusHandler) {
-                 this.connectionStatusHandler(false);
--                logger.debug('Connection status handler notified: disconnected');
-+                if (debugState.isWebsocketDebugEnabled()) {
-+                    debugLog('Connection status handler notified: disconnected');
-+                }
-             }
-             
-             this.handleReconnect();
-@@ -159,7 +175,7 @@ export class WebSocketService {
-         this.ws.onmessage = (event: MessageEvent) => {
-             try {
-                 if (event.data instanceof ArrayBuffer) {
--                    logger.debug('Received binary position update');
-+                    debugLog('Received binary position update');
-                     try {
-                         this.handleBinaryMessage(event.data);
-                     } catch (error) {
-@@ -172,7 +188,9 @@ export class WebSocketService {
-                 } else if (typeof event.data === 'string') {
-                     try {
-                         const message = JSON.parse(event.data);
--                        logger.debug('Received JSON message:', message);
-+                        if (debugState.isWebsocketDebugEnabled()) {
-+                            debugLog('Received JSON message:', message);
-+                        }
-                         
-                         switch (message.type) {
-                             case 'settings':
-@@ -224,13 +242,63 @@ export class WebSocketService {
-         PositionVelocityUpdate: 0x01
-     } as const;
- 
-+    private tryDecompress(buffer: ArrayBuffer): ArrayBuffer {
-+        try {
-+            // Try to decompress using pako
-+            const decompressed = pako.inflate(new Uint8Array(buffer));
-+            // Check if decompressed data has a valid structure (at least 8 bytes and aligned to 4 bytes)
-+            if (decompressed.length < 8 || decompressed.length % 4 !== 0) {
-+                logger.warn('Decompressed data does not align properly; using original buffer.', {
-+                    originalSize: buffer.byteLength,
-+                    decompressedSize: decompressed.length
-+                });
-+                return buffer;
-+            }
-+            if (debugState.shouldLogBinaryHeaders()) {
-+                debugLog('Successfully decompressed binary data:', {
-+                    originalSize: buffer.byteLength,
-+                    decompressedSize: decompressed.length
-+                });
-+            }
-+            return decompressed.buffer.slice(decompressed.byteOffset, decompressed.byteOffset + decompressed.byteLength);
-+        } catch (error) {
-+            // If decompression fails, assume the data wasn't compressed
-+            if (debugState.isWebsocketDebugEnabled()) {
-+                debugLog('Data appears to be uncompressed:', error);
-+            }
-+            return buffer;
-+        }
-+    }
-+
-+    private compressIfNeeded(buffer: ArrayBuffer): ArrayBuffer {
-+        if (buffer.byteLength > COMPRESSION_THRESHOLD) {
-+            try {
-+                const compressed = pako.deflate(new Uint8Array(buffer));
-+                if (debugState.shouldLogBinaryHeaders()) {
-+                    debugLog('Successfully compressed binary data:', {
-+                        originalSize: buffer.byteLength,
-+                        compressedSize: compressed.length
-+                    });
-+                }
-+                return compressed.buffer;
-+            } catch (error) {
-+                logger.warn('Compression failed, using original data:', error);
-+                return buffer;
-+            }
-+        }
-+        return buffer;
-+    }
-+
-     private handleBinaryMessage(buffer: ArrayBuffer): void {
-         try {
--            if (!buffer || buffer.byteLength < 8) {
--                throw new Error(`Invalid buffer size: ${buffer?.byteLength ?? 0} bytes`);
-+            // Try to decompress the buffer first
-+            const decompressedBuffer = this.tryDecompress(buffer);
-+            
-+            if (!decompressedBuffer || decompressedBuffer.byteLength < 8) {
-+                throw new Error(`Invalid buffer size: ${decompressedBuffer?.byteLength ?? 0} bytes`);
-             }
- 
--            const dataView = new DataView(buffer);
-+            const dataView = new DataView(decompressedBuffer);
-             let offset = 0;
- 
-             // Read and validate message type
-@@ -249,18 +317,25 @@ export class WebSocketService {
-             // Read and validate node count
-             const nodeCount = dataView.getUint32(offset, true);
-             offset += 4;
-+            if (nodeCount === 0) {
-+                logger.warn('Received binary update with zero nodes');
-+                return;
-+            }
- 
-             // Validate total message size
-             const expectedSize = 8 + (nodeCount * 28); // 8 bytes header + 28 bytes per node
--            if (buffer.byteLength !== expectedSize) {
--                throw new Error(`Invalid buffer size: ${buffer.byteLength} bytes (expected ${expectedSize})`);
-+            if (decompressedBuffer.byteLength !== expectedSize) {
-+                throw new Error(`Invalid buffer size: ${decompressedBuffer.byteLength} bytes (expected ${expectedSize})`);
-             }
- 
--            logger.debug('Processing binary update:', {
--                nodeCount,
--                messageType,
--                bufferSize: buffer.byteLength
--            });
-+            if (debugState.shouldLogBinaryHeaders()) {
-+                debugLog('Processing binary update:', {
-+                    nodeCount,
-+                    messageType,
-+                    originalSize: buffer.byteLength,
-+                    decompressedSize: decompressedBuffer.byteLength
-+                });
-+            }
- 
-             const nodes: NodeData[] = [];
-             
-@@ -287,18 +362,21 @@ export class WebSocketService {
-                     ];
-                     offset += 12;
- 
--                    // Validate node data
-+                    // Sanitize node data: replace any NaN value with 0
-+                    const sanitizedPosition = position.map(v => isNaN(v) ? 0 : v) as [number, number, number];
-+                    const sanitizedVelocity = velocity.map(v => isNaN(v) ? 0 : v) as [number, number, number];
-                     if (position.some(isNaN) || velocity.some(isNaN)) {
--                        throw new Error(`Invalid node data at index ${i}: NaN values detected`);
-+                        logger.warn(`Sanitized node data at index ${i}: replaced NaN values with 0`);
-                     }
--
--                    nodes.push({ id, position, velocity });
-+                    nodes.push({ id, position: sanitizedPosition, velocity: sanitizedVelocity });
-                 } catch (nodeError) {
-                     logger.error('Error processing node:', {
--                        error: nodeError,
-+                        error: (typeof nodeError === 'object' && nodeError !== null && 'message' in nodeError)
-+                            ? (nodeError as Error).message
-+                            : nodeError,
-                         nodeIndex: i,
-                         offset,
--                        bufferSize: buffer.byteLength
-+                        bufferSize: decompressedBuffer.byteLength
-                     });
-                     // Continue processing other nodes
-                 }
-@@ -307,11 +385,13 @@ export class WebSocketService {
-             if (nodes.length > 0) {
-                 // Notify callback if registered
-                 if (this.binaryMessageCallback) {
--                    logger.debug('Notifying callback:', {
--                        nodeCount: nodes.length,
--                        firstNode: nodes[0],
--                        lastNode: nodes[nodes.length - 1]
--                    });
-+                    if (debugState.isWebsocketDebugEnabled()) {
-+                        debugLog('Notifying callback:', {
-+                            nodeCount: nodes.length,
-+                            firstNode: nodes[0],
-+                            lastNode: nodes[nodes.length - 1]
-+                        });
-+                    }
-                     try {
-                         this.binaryMessageCallback(nodes);
-                     } catch (error) {
-@@ -328,7 +408,7 @@ export class WebSocketService {
-         } catch (error) {
-             logger.error('Failed to process binary message:', {
-                 error,
--                bufferSize: buffer?.byteLength,
-+                originalSize: buffer?.byteLength,
-                 connectionState: this.connectionState
-             });
-         }
-@@ -339,13 +419,15 @@ export class WebSocketService {
-             const wasConnected = this.connectionState === ConnectionState.CONNECTED;
-             const previousState = this.connectionState;
-             
--            logger.debug('Handling reconnect:', {
--                wasConnected,
--                previousState,
--                attempts: this.reconnectAttempts,
--                maxAttempts: this._maxReconnectAttempts,
--                url: this.url
--            });
-+            if (debugState.isWebsocketDebugEnabled()) {
-+                debugLog('Handling reconnect:', {
-+                    wasConnected,
-+                    previousState,
-+                    attempts: this.reconnectAttempts,
-+                    maxAttempts: this._maxReconnectAttempts,
-+                    url: this.url
-+                });
-+            }
- 
-             this.connectionState = ConnectionState.DISCONNECTED;
-             this.binaryMessageCallback = null;
-@@ -431,7 +513,9 @@ export class WebSocketService {
-                 this.settingsUpdateHandler(settings);
-             }
- 
--            logger.debug(`Updated setting ${settingsKey}:`, value);
-+            if (debugState.isWebsocketDebugEnabled()) {
-+                debugLog(`Updated setting ${settingsKey}:`, value);
-+            }
-         } catch (e) {
-             logger.error('Failed to handle settings update:', e);
-         }
-@@ -538,7 +622,9 @@ export class WebSocketService {
-             offset += 12;
-         });
- 
--        this.ws.send(buffer);
-+        // Compress the buffer if it's large enough
-+        const finalBuffer = this.compressIfNeeded(buffer);
-+        this.ws.send(finalBuffer);
-     }
- 
-     public onConnectionStatusChange(handler: (status: boolean) => void): void {
-diff --git a/client/xr/xrInitializer.ts b/client/xr/xrInitializer.ts
-new file mode 100644
-index 00000000..ffb22bc6
---- /dev/null
-+++ b/client/xr/xrInitializer.ts
-@@ -0,0 +1,84 @@
-+import { platformManager } from '../platform/platformManager';
-+import { XRSessionManager } from './xrSessionManager';
-+import { createLogger } from '../core/logger';
-+
-+const logger = createLogger('XRInitializer');
-+
-+export class XRInitializer {
-+    private static instance: XRInitializer | null = null;
-+    private xrButton: HTMLButtonElement;
-+    private xrSessionManager: XRSessionManager;
-+
-+    private constructor(xrSessionManager: XRSessionManager) {
-+        this.xrSessionManager = xrSessionManager;
-+        this.xrButton = document.getElementById('xr-button') as HTMLButtonElement;
-+        if (!this.xrButton) {
-+            throw new Error('XR button not found');
-+        }
-+        this.setupEventListeners();
-+    }
-+
-+    public static getInstance(xrSessionManager: XRSessionManager): XRInitializer {
-+        if (!XRInitializer.instance) {
-+            XRInitializer.instance = new XRInitializer(xrSessionManager);
-+        }
-+        return XRInitializer.instance;
-+    }
-+
-+    private setupEventListeners(): void {
-+        // Button click handler
-+        this.xrButton.addEventListener('click', () => this.onXRButtonClick());
-+
-+        // Keyboard shortcut (Ctrl + Shift + A)
-+        document.addEventListener('keydown', (event) => {
-+            if (event.ctrlKey && event.shiftKey && event.key.toLowerCase() === 'a') {
-+                this.onXRButtonClick();
-+            }
-+        });
-+
-+        // Update button visibility based on XR session state
-+        this.xrSessionManager.setSessionCallbacks(
-+            () => this.xrButton.classList.add('hidden'),    // onStart
-+            () => this.xrButton.classList.remove('hidden'), // onEnd
-+            () => {}                                        // onFrame
-+        );
-+
-+        // Initial button state
-+        this.updateButtonState();
-+    }
-+
-+    private async updateButtonState(): Promise<void> {
-+        const isQuest = platformManager.isQuest();
-+        const xrSupported = platformManager.isXRSupported();
-+
-+        if (!xrSupported) {
-+            this.xrButton.style.display = 'none';
-+            return;
-+        }
-+
-+        if (isQuest) {
-+            this.xrButton.textContent = 'Enter AR';
-+            this.xrButton.classList.remove('hidden');
-+        } else {
-+            this.xrButton.textContent = 'Enter VR';
-+            this.xrButton.classList.remove('hidden');
-+        }
-+    }
-+
-+    private async onXRButtonClick(): Promise<void> {
-+        try {
-+            if (this.xrSessionManager.isXRPresenting()) {
-+                await this.xrSessionManager.endXRSession();
-+            } else {
-+                await this.xrSessionManager.initXRSession();
-+            }
-+        } catch (error) {
-+            logger.error('Failed to toggle XR session:', error);
-+        }
-+    }
-+
-+    public dispose(): void {
-+        // Clean up event listeners if needed
-+        XRInitializer.instance = null;
-+    }
-+}
-\ No newline at end of file
-diff --git a/client/xr/xrInteraction.ts b/client/xr/xrInteraction.ts
-index 9399c7cd..0eafdb38 100644
---- a/client/xr/xrInteraction.ts
-+++ b/client/xr/xrInteraction.ts
-@@ -3,6 +3,7 @@ import { NodeManager } from '../rendering/nodes';
- import { SettingsStore } from '../state/SettingsStore';
- import { createLogger } from '../core/logger';
- import { WebSocketService } from '../websocket/websocketService';
-+import { XRSettings } from '../types/settings/xr';
- import * as THREE from 'three';
- 
- const logger = createLogger('XRInteraction');
-@@ -16,10 +17,28 @@ export class XRInteraction {
-     private interactionEnabled: boolean = false;
-     private websocketService: WebSocketService;
- 
--    private constructor(_: XRSessionManager, __: NodeManager) {
-+    private xrManager: XRSessionManager;
-+    private constructor(xrManager: XRSessionManager, _: NodeManager) {
-+        this.xrManager = xrManager;
-         this.settingsStore = SettingsStore.getInstance();
-         this.websocketService = WebSocketService.getInstance();
-         this.initializeSettings();
-+        this.initializeXRSession();
-+    }
-+
-+    private async initializeXRSession(): Promise<void> {
-+        try {
-+            const { platformManager } = require('../platform/platformManager');
-+            const settings = this.settingsStore.get('xr') as XRSettings;
-+            
-+            // Auto-enter AR for Quest devices if enabled in settings
-+            if (platformManager.isQuest() && settings && settings.autoEnterAR) {
-+                logger.info('Auto-entering AR mode for Quest device');
-+                await this.xrManager.initXRSession();
-+            }
-+        } catch (error) {
-+            logger.error('Failed to initialize XR session:', error);
-+        }
-     }
- 
-     private initializeSettings(): void {
-diff --git a/client/xr/xrSessionManager.ts b/client/xr/xrSessionManager.ts
-index 7976b5c4..fcb6b9db 100644
---- a/client/xr/xrSessionManager.ts
-+++ b/client/xr/xrSessionManager.ts
-@@ -206,10 +206,44 @@ export class XRSessionManager {
-         }
- 
-         try {
--            const session = await navigator.xr.requestSession('immersive-ar', {
--                requiredFeatures: ['local-floor', 'hit-test'],
--                optionalFeatures: ['hand-tracking', 'layers', 'light-estimation']
-+            // Check if session mode is supported
-+            const mode = platformManager.isQuest() ? 'immersive-ar' : 'immersive-vr';
-+            const isSupported = await navigator.xr.isSessionSupported(mode);
-+            
-+            if (!isSupported) {
-+                throw new Error(`${mode} not supported on this device`);
-+            }
-+            
-+            // Configure features based on mode and platform
-+            const requiredFeatures = ['local-floor'];
-+            const optionalFeatures = ['hand-tracking', 'layers'];
-+            
-+            // Add mode-specific features for Quest
-+            if (platformManager.isQuest()) {
-+                // For Quest AR, require hit-test and make plane detection optional
-+                requiredFeatures.push('hit-test');
-+                optionalFeatures.push(
-+                    'light-estimation',
-+                    'plane-detection',
-+                    'anchors',
-+                    'depth-sensing',
-+                    'dom-overlay'
-+                );
-+            }
-+            
-+            // Request session with configured features
-+            const sessionInit: XRSessionInit = {
-+                requiredFeatures,
-+                optionalFeatures,
-+                domOverlay: platformManager.isQuest() ? { root: document.body } : undefined
-+            };
-+            
-+            _logger.info('Requesting XR session with config:', {
-+                mode,
-+                features: sessionInit
-             });
-+            
-+            const session = await navigator.xr.requestSession(mode, sessionInit);
- 
-             if (!session) {
-                 throw new Error('Failed to create XR session');
-@@ -224,12 +258,19 @@ export class XRSessionManager {
-             // Configure renderer for AR
-             renderer.xr.enabled = true;
-             
--            // Clear background for AR passthrough
-+            // Set up scene for XR mode
-             const scene = this.sceneManager.getScene();
--            scene.background = null;
-+            if (platformManager.isQuest()) {
-+                // Clear background for AR passthrough
-+                scene.background = null;
-+            } else {
-+                // Keep background for VR mode
-+                scene.background = new Color(BACKGROUND_COLOR);
-+            }
-             
--            // Get reference space
--            this.referenceSpace = await this.session.requestReferenceSpace('local-floor');
-+            // Get reference space based on platform
-+            const spaceType = platformManager.isQuest() ? 'local-floor' : 'bounded-floor';
-+            this.referenceSpace = await this.session.requestReferenceSpace(spaceType);
-             
-             // Setup session event handlers
-             this.session.addEventListener('end', this.onXRSessionEnd);
-@@ -275,23 +316,27 @@ export class XRSessionManager {
-     }
- 
-     private onXRSessionEnd = (): void => {
-+        // Clean up hit test source
-         if (this.hitTestSource) {
-             this.hitTestSource.cancel();
-             this.hitTestSource = null;
-         }
-         
-+        // Reset session state
-         this.session = null;
-         this.referenceSpace = null;
-         this.hitTestSourceRequested = false;
-         this.isPresenting = false;
- 
--        // Hide AR visualization elements
--        this.gridHelper.visible = false;
--        this.groundPlane.visible = false;
--        this.hitTestMarker.visible = false;
--        this.arLight.visible = false;
-+        // Hide AR visualization elements if in Quest mode
-+        if (platformManager.isQuest()) {
-+            this.gridHelper.visible = false;
-+            this.groundPlane.visible = false;
-+            this.hitTestMarker.visible = false;
-+            this.arLight.visible = false;
-+        }
- 
--        // Reset camera rig
-+        // Reset camera and scene
-         this.cameraRig.position.set(0, 0, 0);
-         this.cameraRig.quaternion.identity();
- 
-@@ -299,16 +344,22 @@ export class XRSessionManager {
-         const scene = this.sceneManager.getScene();
-         scene.background = new Color(BACKGROUND_COLOR);
- 
--        // Disable AR layer for camera
-+        // Reset camera layers
-         const camera = this.sceneManager.getCamera();
--        camera.layers.disable(1);
-+        camera.layers.disable(1); // AR layer
- 
--        // Reset renderer settings
-+        // Reset renderer
-         const renderer = this.sceneManager.getRenderer();
-         renderer.xr.enabled = false;
- 
-         _logger.log('XR session ended');
- 
-+        // Show control panel again and notify session end
-+        ControlPanel.getInstance()?.show();
-+        this.xrSessionEndCallback?.();
-+
-+        _logger.log('XR session ended');
-+
-         // Show control panel again
-         const controlPanel = ControlPanel.getInstance();
-         if (controlPanel) {
-diff --git a/package.json b/package.json
-index 0f9b0622..5d26ad03 100755
---- a/package.json
-+++ b/package.json
-@@ -14,10 +14,8 @@
-   },
-   "dependencies": {
-     "@mui/material": "^5.15.11",
--    "@noble/curves": "^1.8.1",
--    "@noble/hashes": "^1.7.1",
--    "@nostr-dev-kit/ndk": "^2.11.0",
--    "nostr-tools": "^2.10.4",
-+    "@types/pako": "^2.0.3",
-+    "pako": "^2.1.0",
-     "react": "^18.2.0",
-     "three": "0.170.0"
-   },
-diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
-index 516ca240..8a0b4aaf 100644
---- a/pnpm-lock.yaml
-+++ b/pnpm-lock.yaml
-@@ -14,18 +14,12 @@ importers:
-       '@mui/material':
-         specifier: ^5.15.11
-         version: 5.16.14(@types/react@18.3.18)(react-dom@19.0.0(react@18.3.1))(react@18.3.1)
--      '@noble/curves':
--        specifier: ^1.8.1
--        version: 1.8.1
--      '@noble/hashes':
--        specifier: ^1.7.1
--        version: 1.7.1
--      '@nostr-dev-kit/ndk':
--        specifier: ^2.11.0
--        version: 2.11.0(typescript@5.4.5)
--      nostr-tools:
--        specifier: ^2.10.4
--        version: 2.10.4(typescript@5.4.5)
-+      '@types/pako':
-+        specifier: ^2.0.3
-+        version: 2.0.3
-+      pako:
-+        specifier: ^2.1.0
-+        version: 2.1.0
-       react:
-         specifier: ^18.2.0
-         version: 18.3.1
-@@ -352,34 +346,6 @@ packages:
-       '@types/react':
-         optional: true
- 
--  '@noble/ciphers@0.5.3':
--    resolution: {integrity: sha512-B0+6IIHiqEs3BPMT0hcRmHvEj2QHOLu+uwt+tqDDeVd0oyVzh7BPrDcPjRnV1PV/5LaknXJJQvOuRGR0zQJz+w==}
--
--  '@noble/curves@1.1.0':
--    resolution: {integrity: sha512-091oBExgENk/kGj3AZmtBDMpxQPDtxQABR2B9lb1JbVTs6ytdzZNwvhxQ4MWasRNEzlbEH8jCWFCwhF/Obj5AA==}
--
--  '@noble/curves@1.2.0':
--    resolution: {integrity: sha512-oYclrNgRaM9SsBUBVbb8M6DTV7ZHRTKugureoYEncY5c65HOmRzvSiTE3y5CYaPYJA/GVkrhXEoF0M3Ya9PMnw==}
--
--  '@noble/curves@1.8.1':
--    resolution: {integrity: sha512-warwspo+UYUPep0Q+vtdVB4Ugn8GGQj8iyB3gnRWsztmUHTI3S1nhdiWNsPUGL0vud7JlRRk1XEu7Lq1KGTnMQ==}
--    engines: {node: ^14.21.3 || >=16}
--
--  '@noble/hashes@1.3.1':
--    resolution: {integrity: sha512-EbqwksQwz9xDRGfDST86whPBgM65E0OH/pCgqW0GBVzO22bNE+NuIbeTb714+IfSjU3aRk47EUvXIb5bTsenKA==}
--    engines: {node: '>= 16'}
--
--  '@noble/hashes@1.3.2':
--    resolution: {integrity: sha512-MVC8EAQp7MvEcm30KWENFjgR+Mkmf+D189XJTkFIlwohU5hcBbn1ZkKq7KVTi2Hme3PMGF390DaL52beVrIihQ==}
--    engines: {node: '>= 16'}
--
--  '@noble/hashes@1.7.1':
--    resolution: {integrity: sha512-B8XBPsn4vT/KJAGqDzbwztd+6Yte3P4V7iafm24bxgDe/mlRuK6xmWPuCNrKt2vDafZ8MfJLlchDG/vYafQEjQ==}
--    engines: {node: ^14.21.3 || >=16}
--
--  '@noble/secp256k1@2.2.3':
--    resolution: {integrity: sha512-l7r5oEQym9Us7EAigzg30/PQAvynhMt2uoYtT3t26eGDVm9Yii5mZ5jWSWmZ/oSIR2Et0xfc6DXrG0bZ787V3w==}
--
-   '@nodelib/fs.scandir@2.1.5':
-     resolution: {integrity: sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==}
-     engines: {node: '>= 8'}
-@@ -392,10 +358,6 @@ packages:
-     resolution: {integrity: sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==}
-     engines: {node: '>= 8'}
- 
--  '@nostr-dev-kit/ndk@2.11.0':
--    resolution: {integrity: sha512-FKIMtcVsVcquzrC+yir9lOXHCIHmQ3IKEVCMohqEB7N96HjP2qrI9s5utbjI3lkavFNF5tXg1Gp9ODEo7XCfLA==}
--    engines: {node: '>=16'}
--
-   '@popperjs/core@2.11.8':
-     resolution: {integrity: sha512-P1st0aksCrn9sGZhp8GMYwBnQsbvAWsZAX44oXNNvLHGqAOcoVxmjZiohstwQ7SqKnbR47akdNi+uleWD8+g6A==}
- 
-@@ -494,18 +456,6 @@ packages:
-     cpu: [x64]
-     os: [win32]
- 
--  '@scure/base@1.1.1':
--    resolution: {integrity: sha512-ZxOhsSyxYwLJj3pLZCefNitxsj093tb2vq90mp2txoYeBqbcjDjqFhyM8eUjq/uFm6zJ+mUuqxlS2FkuSY1MTA==}
--
--  '@scure/base@1.2.4':
--    resolution: {integrity: sha512-5Yy9czTO47mqz+/J8GM6GIId4umdCk1wc1q8rKERQulIoc8VP9pzDcghv10Tl2E7R96ZUx/PhND3ESYUQX8NuQ==}
--
--  '@scure/bip32@1.3.1':
--    resolution: {integrity: sha512-osvveYtyzdEVbt3OfwwXFr4P2iVBL5u1Q3q4ONBfDY/UpOuXmOlbgwc1xECEboY8wIays8Yt6onaWMUdUbfl0A==}
--
--  '@scure/bip39@1.2.1':
--    resolution: {integrity: sha512-Z3/Fsz1yr904dduJD0NpiyRHhRYHdcnyh73FZWiV+/qhWi83wNJ3NWolYqCEN+ZWsUz2TWwajJggcRE9r1zUYg==}
--
-   '@tweenjs/tween.js@23.1.3':
-     resolution: {integrity: sha512-vJmvvwFxYuGnF2axRtPYocag6Clbb5YS7kLL+SO/TeVFzHqDIWrNKYtcsPMibjDx9O+bu+psAy9NKfWklassUA==}
- 
-@@ -515,6 +465,9 @@ packages:
-   '@types/node@22.10.2':
-     resolution: {integrity: sha512-Xxr6BBRCAOQixvonOye19wnzyDiUtTeqldOOmj3CkeblonbccA12PFwlufvRdrpjXxqnmUaeiU5EOA+7s5diUQ==}
- 
-+  '@types/pako@2.0.3':
-+    resolution: {integrity: sha512-bq0hMV9opAcrmE0Byyo0fY3Ew4tgOevJmQ9grUhpXQhYfyLJ1Kqg3P33JT5fdbT2AjeAjR51zqqVjAL/HMkx7Q==}
-+
-   '@types/prop-types@15.7.14':
-     resolution: {integrity: sha512-gNMvNH49DJ7OJYv+KAKn0Xp45p8PLl6zo2YnvDIbTd4J6MER2BmWN49TG7n9LvkyihINxeKW8+3bfS2yDC9dzQ==}
- 
-@@ -628,10 +581,6 @@ packages:
-   buffer-from@1.1.2:
-     resolution: {integrity: sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==}
- 
--  bufferutil@4.0.9:
--    resolution: {integrity: sha512-WDtdLmJvAuNNPzByAYpRo2rF1Mmradw6gvWsQKf63476DDXmomT9zUiGypLcG4ibIM67vhAj8jJRdbmEws2Aqw==}
--    engines: {node: '>=6.14.2'}
--
-   callsites@3.1.0:
-     resolution: {integrity: sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==}
-     engines: {node: '>=6'}
-@@ -664,18 +613,6 @@ packages:
-   csstype@3.1.3:
-     resolution: {integrity: sha512-M1uQkMl8rQK/szD0LNhtqxIPLpimGm8sOBwU7lLnCpSbTyY3yeU1Vc7l4KT5zT4s/yOxHH5O7tIuuLOCnLADRw==}
- 
--  d@1.0.2:
--    resolution: {integrity: sha512-MOqHvMWF9/9MX6nza0KgvFH4HpMU0EF5uUDXqX/BtxtU8NfB0QzRtJ8Oe/6SuS4kbhyzVJwjd97EA4PKrzJ8bw==}
--    engines: {node: '>=0.12'}
--
--  debug@2.6.9:
--    resolution: {integrity: sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==}
--    peerDependencies:
--      supports-color: '*'
--    peerDependenciesMeta:
--      supports-color:
--        optional: true
--
-   debug@4.4.0:
-     resolution: {integrity: sha512-6WTZ/IxCY/T6BALoZHaE4ctp9xm+Z5kY/pzYaCHRFeyVhojxlrm+46y68HA6hr0TcwEssoxNiDEUJQjfPZ/RYA==}
-     engines: {node: '>=6.0'}
-@@ -695,17 +632,6 @@ packages:
-   dom-helpers@5.2.1:
-     resolution: {integrity: sha512-nRCa7CK3VTrM2NmGkIy4cbK7IZlgBE/PYMn55rrXefr5xXDP0LdtfPnblFDoVdcAfslJ7or6iqAUnx0CCGIWQA==}
- 
--  es5-ext@0.10.64:
--    resolution: {integrity: sha512-p2snDhiLaXe6dahss1LddxqEm+SkuDvV8dnIQG0MWjyHpcMNfXKPE+/Cc0y+PhxJX3A4xGNeFCj5oc0BUh6deg==}
--    engines: {node: '>=0.10'}
--
--  es6-iterator@2.0.3:
--    resolution: {integrity: sha512-zw4SRzoUkd+cl+ZoE15A9o1oQd920Bb0iOJMQkQhl3jNc03YqVjAhG7scf9C5KWRU/R13Orf588uCC6525o02g==}
--
--  es6-symbol@3.1.4:
--    resolution: {integrity: sha512-U9bFFjX8tFiATgtkJ1zg25+KviIXpgRvRHS8sau3GfhVzThRQrOeksPeT0BWW2MNZs1OEWJ1DPXOQMn0KKRkvg==}
--    engines: {node: '>=0.12'}
--
-   esbuild@0.21.5:
-     resolution: {integrity: sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==}
-     engines: {node: '>=12'}
-@@ -733,10 +659,6 @@ packages:
-     deprecated: This version is no longer supported. Please see https://eslint.org/version-support for other options.
-     hasBin: true
- 
--  esniff@2.0.1:
--    resolution: {integrity: sha512-kTUIGKQ/mDPFoJ0oVfcmyJn4iBDRptjNVIzwIFR7tqWXdVI9xfA2RMwY/gbSpJG3lkdWNEjLap/NqVHZiJsdfg==}
--    engines: {node: '>=0.10'}
--
-   espree@9.6.1:
-     resolution: {integrity: sha512-oruZaFkjorTpF32kDSI5/75ViwGeZginGGy2NoOSg3Q9bnwlnmDm4HLnkl0RE3n+njDXR037aY1+x58Z/zFdwQ==}
-     engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}
-@@ -757,12 +679,6 @@ packages:
-     resolution: {integrity: sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==}
-     engines: {node: '>=0.10.0'}
- 
--  event-emitter@0.3.5:
--    resolution: {integrity: sha512-D9rRn9y7kLPnJ+hMq7S/nhvoKwwvVJahBi2BPmx3bvbsEdK3W9ii8cBSGjP+72/LnM4n6fo3+dkCX5FeTQruXA==}
--
--  ext@1.7.0:
--    resolution: {integrity: sha512-6hxeJYaL110a9b5TEJSj0gojyHQAmA2ch5Os+ySCiA1QGdS697XWY1pzsrSjqA9LDEEgdB/KypIlR59RcLuHYw==}
--
-   fast-deep-equal@3.1.3:
-     resolution: {integrity: sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==}
- 
-@@ -867,9 +783,6 @@ packages:
-     resolution: {integrity: sha512-Fd4gABb+ycGAmKou8eMftCupSir5lRxqf4aD/vd0cD2qc4HL07OjCeuHMr8Ro4CoMaeCKDB0/ECBOVWjTwUvPQ==}
-     engines: {node: '>=8'}
- 
--  is-typedarray@1.0.0:
--    resolution: {integrity: sha512-cyA56iCMHAh5CdzjJIa4aohJyeO1YbwLi3Jc35MmRU6poroFjIGZzUzupGiRPOjgHg9TLu43xbpwXk523fMxKA==}
--
-   isexe@2.0.0:
-     resolution: {integrity: sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==}
- 
-@@ -896,9 +809,6 @@ packages:
-     resolution: {integrity: sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==}
-     engines: {node: '>= 0.8.0'}
- 
--  light-bolt11-decoder@3.2.0:
--    resolution: {integrity: sha512-3QEofgiBOP4Ehs9BI+RkZdXZNtSys0nsJ6fyGeSiAGCBsMwHGUDS/JQlY/sTnWs91A2Nh0S9XXfA8Sy9g6QpuQ==}
--
-   locate-path@6.0.0:
-     resolution: {integrity: sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==}
-     engines: {node: '>=10'}
-@@ -928,9 +838,6 @@ packages:
-     resolution: {integrity: sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==}
-     engines: {node: '>=16 || 14 >=14.17'}
- 
--  ms@2.0.0:
--    resolution: {integrity: sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==}
--
-   ms@2.1.3:
-     resolution: {integrity: sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==}
- 
-@@ -942,24 +849,6 @@ packages:
-   natural-compare@1.4.0:
-     resolution: {integrity: sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==}
- 
--  next-tick@1.1.0:
--    resolution: {integrity: sha512-CXdUiJembsNjuToQvxayPZF9Vqht7hewsvy2sOWafLvi2awflj9mOC6bHIg50orX8IJvWKY9wYQ/zB2kogPslQ==}
--
--  node-gyp-build@4.8.4:
--    resolution: {integrity: sha512-LA4ZjwlnUblHVgq0oBF3Jl/6h/Nvs5fzBLwdEF4nuxnFdsfajde4WfxtJr3CaiH+F6ewcIB/q4jQ4UzPyid+CQ==}
--    hasBin: true
--
--  nostr-tools@2.10.4:
--    resolution: {integrity: sha512-biU7sk+jxHgVASfobg2T5ttxOGGSt69wEVBC51sHHOEaKAAdzHBLV/I2l9Rf61UzClhliZwNouYhqIso4a3HYg==}
--    peerDependencies:
--      typescript: '>=5.0.0'
--    peerDependenciesMeta:
--      typescript:
--        optional: true
--
--  nostr-wasm@0.1.0:
--    resolution: {integrity: sha512-78BTryCLcLYv96ONU8Ws3Q1JzjlAt+43pWQhIl86xZmWeegYCNLPml7yQ+gG3vR6V5h4XGj+TxO+SS5dsThQIA==}
--
-   object-assign@4.1.1:
-     resolution: {integrity: sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==}
-     engines: {node: '>=0.10.0'}
-@@ -979,6 +868,9 @@ packages:
-     resolution: {integrity: sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==}
-     engines: {node: '>=10'}
- 
-+  pako@2.1.0:
-+    resolution: {integrity: sha512-w+eufiZ1WuJYgPXbV/PO3NCMEc3xqylkKHzp8bxp1uW4qaSNQUkwmLLEc3kKsfz8lpV1F8Ht3U1Cm+9Srog2ug==}
-+
-   parent-module@1.0.1:
-     resolution: {integrity: sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==}
-     engines: {node: '>=6'}
-@@ -1133,12 +1025,6 @@ packages:
-     peerDependencies:
-       typescript: '>=4.2.0'
- 
--  tseep@1.3.1:
--    resolution: {integrity: sha512-ZPtfk1tQnZVyr7BPtbJ93qaAh2lZuIOpTMjhrYa4XctT8xe7t4SAW9LIxrySDuYMsfNNayE51E/WNGrNVgVicQ==}
--
--  tstl@2.5.16:
--    resolution: {integrity: sha512-+O2ybLVLKcBwKm4HymCEwZIT0PpwS3gCYnxfSDEjJEKADvIFruaQjd3m7CAKNU1c7N3X3WjVz87re7TA2A5FUw==}
--
-   type-check@0.4.0:
-     resolution: {integrity: sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==}
-     engines: {node: '>= 0.8.0'}
-@@ -1147,15 +1033,6 @@ packages:
-     resolution: {integrity: sha512-Ne+eE4r0/iWnpAxD852z3A+N0Bt5RN//NjJwRd2VFHEmrywxf5vsZlh4R6lixl6B+wz/8d+maTSAkN1FIkI3LQ==}
-     engines: {node: '>=10'}
- 
--  type@2.7.3:
--    resolution: {integrity: sha512-8j+1QmAbPvLZow5Qpi6NCaN8FB60p/6x8/vfNqOk/hC+HuvFZhL4+WfekuhQLiqFZXOgQdrs3B+XxEmCc6b3FQ==}
--
--  typedarray-to-buffer@3.1.5:
--    resolution: {integrity: sha512-zdu8XMNEDepKKR+XYOXAVPtWui0ly0NtohUscw+UmaHiAWT8hrV1rr//H6V+0DvJ3OQ19S979M0laLfX8rm82Q==}
--
--  typescript-lru-cache@2.0.0:
--    resolution: {integrity: sha512-Jp57Qyy8wXeMkdNuZiglE6v2Cypg13eDA1chHwDG6kq51X7gk4K7P7HaDdzZKCxkegXkVHNcPD0n5aW6OZH3aA==}
--
-   typescript@5.4.5:
-     resolution: {integrity: sha512-vcI4UpRgg81oIRUFwR0WSIHKt11nJ7SAVlYNIu+QpqeyXP+gpQJy/Z4+F0aGxSE4MqwjyXvW/TzgkLAx2AGHwQ==}
-     engines: {node: '>=14.17'}
-@@ -1167,14 +1044,6 @@ packages:
-   uri-js@4.4.1:
-     resolution: {integrity: sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==}
- 
--  utf-8-validate@5.0.10:
--    resolution: {integrity: sha512-Z6czzLq4u8fPOyx7TU6X3dvUZVvoJmxSQ+IcrlmagKhilxlhZgxPK6C5Jqbkw1IDUmFTM+cz9QDnnLTwDz/2gQ==}
--    engines: {node: '>=6.14.2'}
--
--  utf8-buffer@1.0.0:
--    resolution: {integrity: sha512-ueuhzvWnp5JU5CiGSY4WdKbiN/PO2AZ/lpeLiz2l38qwdLy/cW40XobgyuIWucNyum0B33bVB0owjFCeGBSLqg==}
--    engines: {node: '>=8'}
--
-   vite@5.4.14:
-     resolution: {integrity: sha512-EK5cY7Q1D8JNhSaPKVK4pwBFvaTmZxEnoKXLG/U9gmdDcihQGNzFlgIvaxezFR4glP1LsuiedwMBqCXH3wZccA==}
-     engines: {node: ^18.0.0 || >=20.0.0}
-@@ -1206,13 +1075,6 @@ packages:
-       terser:
-         optional: true
- 
--  websocket-polyfill@0.0.3:
--    resolution: {integrity: sha512-pF3kR8Uaoau78MpUmFfzbIRxXj9PeQrCuPepGE6JIsfsJ/o/iXr07Q2iQNzKSSblQJ0FiGWlS64N4pVSm+O3Dg==}
--
--  websocket@1.0.35:
--    resolution: {integrity: sha512-/REy6amwPZl44DDzvRCkaI1q1bIiQB0mEFQLUrhz3z2EK91cp3n72rAjUlrTP0zV22HJIUOVHQGPxhFRjxjt+Q==}
--    engines: {node: '>=4.0.0'}
--
-   which@2.0.2:
-     resolution: {integrity: sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==}
-     engines: {node: '>= 8'}
-@@ -1225,10 +1087,6 @@ packages:
-   wrappy@1.0.2:
-     resolution: {integrity: sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==}
- 
--  yaeti@0.0.6:
--    resolution: {integrity: sha512-MvQa//+KcZCUkBTIC9blM+CU9J2GzuTytsOUwf2lidtvkx/6gnEp1QvJv34t9vdjhFmha/mUiNDbN0D0mJWdug==}
--    engines: {node: '>=0.10.32'}
--
-   yocto-queue@0.1.0:
-     resolution: {integrity: sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==}
-     engines: {node: '>=10'}
-@@ -1449,28 +1307,6 @@ snapshots:
-     optionalDependencies:
-       '@types/react': 18.3.18
- 
--  '@noble/ciphers@0.5.3': {}
--
--  '@noble/curves@1.1.0':
--    dependencies:
--      '@noble/hashes': 1.3.1
--
--  '@noble/curves@1.2.0':
--    dependencies:
--      '@noble/hashes': 1.3.2
--
--  '@noble/curves@1.8.1':
--    dependencies:
--      '@noble/hashes': 1.7.1
--
--  '@noble/hashes@1.3.1': {}
--
--  '@noble/hashes@1.3.2': {}
--
--  '@noble/hashes@1.7.1': {}
--
--  '@noble/secp256k1@2.2.3': {}
--
-   '@nodelib/fs.scandir@2.1.5':
-     dependencies:
-       '@nodelib/fs.stat': 2.0.5
-@@ -1483,23 +1319,6 @@ snapshots:
-       '@nodelib/fs.scandir': 2.1.5
-       fastq: 1.17.1
- 
--  '@nostr-dev-kit/ndk@2.11.0(typescript@5.4.5)':
--    dependencies:
--      '@noble/curves': 1.8.1
--      '@noble/hashes': 1.7.1
--      '@noble/secp256k1': 2.2.3
--      '@scure/base': 1.2.4
--      debug: 4.4.0
--      light-bolt11-decoder: 3.2.0
--      nostr-tools: 2.10.4(typescript@5.4.5)
--      tseep: 1.3.1
--      typescript-lru-cache: 2.0.0
--      utf8-buffer: 1.0.0
--      websocket-polyfill: 0.0.3
--    transitivePeerDependencies:
--      - supports-color
--      - typescript
--
-   '@popperjs/core@2.11.8': {}
- 
-   '@rollup/rollup-android-arm-eabi@4.28.1':
-@@ -1559,21 +1378,6 @@ snapshots:
-   '@rollup/rollup-win32-x64-msvc@4.28.1':
-     optional: true
- 
--  '@scure/base@1.1.1': {}
--
--  '@scure/base@1.2.4': {}
--
--  '@scure/bip32@1.3.1':
--    dependencies:
--      '@noble/curves': 1.1.0
--      '@noble/hashes': 1.3.2
--      '@scure/base': 1.1.1
--
--  '@scure/bip39@1.2.1':
--    dependencies:
--      '@noble/hashes': 1.3.2
--      '@scure/base': 1.1.1
--
-   '@tweenjs/tween.js@23.1.3': {}
- 
-   '@types/estree@1.0.6': {}
-@@ -1582,6 +1386,8 @@ snapshots:
-     dependencies:
-       undici-types: 6.20.0
- 
-+  '@types/pako@2.0.3': {}
-+
-   '@types/prop-types@15.7.14': {}
- 
-   '@types/react-transition-group@4.4.12(@types/react@18.3.18)':
-@@ -1725,10 +1531,6 @@ snapshots:
- 
-   buffer-from@1.1.2: {}
- 
--  bufferutil@4.0.9:
--    dependencies:
--      node-gyp-build: 4.8.4
--
-   callsites@3.1.0: {}
- 
-   chalk@4.1.2:
-@@ -1756,15 +1558,6 @@ snapshots:
- 
-   csstype@3.1.3: {}
- 
--  d@1.0.2:
--    dependencies:
--      es5-ext: 0.10.64
--      type: 2.7.3
--
--  debug@2.6.9:
--    dependencies:
--      ms: 2.0.0
--
-   debug@4.4.0:
-     dependencies:
-       ms: 2.1.3
-@@ -1780,24 +1573,6 @@ snapshots:
-       '@babel/runtime': 7.26.0
-       csstype: 3.1.3
- 
--  es5-ext@0.10.64:
--    dependencies:
--      es6-iterator: 2.0.3
--      es6-symbol: 3.1.4
--      esniff: 2.0.1
--      next-tick: 1.1.0
--
--  es6-iterator@2.0.3:
--    dependencies:
--      d: 1.0.2
--      es5-ext: 0.10.64
--      es6-symbol: 3.1.4
--
--  es6-symbol@3.1.4:
--    dependencies:
--      d: 1.0.2
--      ext: 1.7.0
--
-   esbuild@0.21.5:
-     optionalDependencies:
-       '@esbuild/aix-ppc64': 0.21.5
-@@ -1878,13 +1653,6 @@ snapshots:
-     transitivePeerDependencies:
-       - supports-color
- 
--  esniff@2.0.1:
--    dependencies:
--      d: 1.0.2
--      es5-ext: 0.10.64
--      event-emitter: 0.3.5
--      type: 2.7.3
--
-   espree@9.6.1:
-     dependencies:
-       acorn: 8.14.0
-@@ -1903,15 +1671,6 @@ snapshots:
- 
-   esutils@2.0.3: {}
- 
--  event-emitter@0.3.5:
--    dependencies:
--      d: 1.0.2
--      es5-ext: 0.10.64
--
--  ext@1.7.0:
--    dependencies:
--      type: 2.7.3
--
-   fast-deep-equal@3.1.3: {}
- 
-   fast-glob@3.3.2:
-@@ -2009,8 +1768,6 @@ snapshots:
- 
-   is-path-inside@3.0.3: {}
- 
--  is-typedarray@1.0.0: {}
--
-   isexe@2.0.0: {}
- 
-   js-tokens@4.0.0: {}
-@@ -2034,10 +1791,6 @@ snapshots:
-       prelude-ls: 1.2.1
-       type-check: 0.4.0
- 
--  light-bolt11-decoder@3.2.0:
--    dependencies:
--      '@scure/base': 1.1.1
--
-   locate-path@6.0.0:
-     dependencies:
-       p-locate: 5.0.0
-@@ -2065,33 +1818,12 @@ snapshots:
-     dependencies:
-       brace-expansion: 2.0.1
- 
--  ms@2.0.0: {}
--
-   ms@2.1.3: {}
- 
-   nanoid@3.3.8: {}
- 
-   natural-compare@1.4.0: {}
- 
--  next-tick@1.1.0: {}
--
--  node-gyp-build@4.8.4: {}
--
--  nostr-tools@2.10.4(typescript@5.4.5):
--    dependencies:
--      '@noble/ciphers': 0.5.3
--      '@noble/curves': 1.2.0
--      '@noble/hashes': 1.3.1
--      '@scure/base': 1.1.1
--      '@scure/bip32': 1.3.1
--      '@scure/bip39': 1.2.1
--    optionalDependencies:
--      nostr-wasm: 0.1.0
--      typescript: 5.4.5
--
--  nostr-wasm@0.1.0:
--    optional: true
--
-   object-assign@4.1.1: {}
- 
-   once@1.4.0:
-@@ -2115,6 +1847,8 @@ snapshots:
-     dependencies:
-       p-limit: 3.1.0
- 
-+  pako@2.1.0: {}
-+
-   parent-module@1.0.1:
-     dependencies:
-       callsites: 3.1.0
-@@ -2260,24 +1994,12 @@ snapshots:
-     dependencies:
-       typescript: 5.4.5
- 
--  tseep@1.3.1: {}
--
--  tstl@2.5.16: {}
--
-   type-check@0.4.0:
-     dependencies:
-       prelude-ls: 1.2.1
- 
-   type-fest@0.20.2: {}
- 
--  type@2.7.3: {}
--
--  typedarray-to-buffer@3.1.5:
--    dependencies:
--      is-typedarray: 1.0.0
--
--  typescript-lru-cache@2.0.0: {}
--
-   typescript@5.4.5: {}
- 
-   undici-types@6.20.0: {}
-@@ -2286,12 +2008,6 @@ snapshots:
-     dependencies:
-       punycode: 2.3.1
- 
--  utf-8-validate@5.0.10:
--    dependencies:
--      node-gyp-build: 4.8.4
--
--  utf8-buffer@1.0.0: {}
--
-   vite@5.4.14(@types/node@22.10.2)(terser@5.37.0):
-     dependencies:
-       esbuild: 0.21.5
-@@ -2302,24 +2018,6 @@ snapshots:
-       fsevents: 2.3.3
-       terser: 5.37.0
- 
--  websocket-polyfill@0.0.3:
--    dependencies:
--      tstl: 2.5.16
--      websocket: 1.0.35
--    transitivePeerDependencies:
--      - supports-color
--
--  websocket@1.0.35:
--    dependencies:
--      bufferutil: 4.0.9
--      debug: 2.6.9
--      es5-ext: 0.10.64
--      typedarray-to-buffer: 3.1.5
--      utf-8-validate: 5.0.10
--      yaeti: 0.0.6
--    transitivePeerDependencies:
--      - supports-color
--
-   which@2.0.2:
-     dependencies:
-       isexe: 2.0.0
-@@ -2328,6 +2026,4 @@ snapshots:
- 
-   wrappy@1.0.2: {}
- 
--  yaeti@0.0.6: {}
--
-   yocto-queue@0.1.0: {}
-diff --git a/scripts/large_files_output.txt b/scripts/large_files_output.txt
-new file mode 100644
-index 00000000..18366a3b
---- /dev/null
-+++ b/scripts/large_files_output.txt
-@@ -0,0 +1,41 @@
-+index.ts
-+index.html
-+platform/platformManager.ts
-+types/three-ext.d.ts
-+types/three.d.ts
-+types/webxr.d.ts
-+types/settings.ts
-+types/settings/base.ts
-+types/settings/utils.ts
-+types/settings/xr.ts
-+types/settings/validation.ts
-+visualization/HologramManager.ts
-+visualization/MetadataVisualizer.ts
-+websocket/websocketService.ts
-+xr/xrInteraction.ts
-+xr/xrSessionManager.ts
-+xr/xrInitializer.ts
-+components/settings/ValidationErrorDisplay.ts
-+core/constants.ts
-+core/types.ts
-+core/utils.ts
-+core/debugState.ts
-+public/fonts/Roboto-Regular.woff2
-+public/fonts/helvetiker_regular.typeface.json
-+rendering/EdgeManager.ts
-+rendering/EnhancedNodeManager.ts
-+rendering/HologramManager.ts
-+rendering/MetadataVisualizer.ts
-+rendering/VisualizationController.ts
-+rendering/nodes.ts
-+rendering/scene.ts
-+rendering/textRenderer.ts
-+rendering/factories/GeometryFactory.ts
-+rendering/factories/MaterialFactory.ts
-+rendering/materials/HologramShaderMaterial.ts
-+state/SettingsStore.ts
-+state/graphData.ts
-+state/settings.ts
-+state/defaultSettings.ts
-+ui/ControlPanel.css
-+ui/ControlPanel.ts
-diff --git a/scripts/test_endpoints.sh b/scripts/test_endpoints.sh
-index 1b50f5a3..2db60534 100755
---- a/scripts/test_endpoints.sh
-+++ b/scripts/test_endpoints.sh
-@@ -130,6 +130,25 @@ check_settings_endpoint() {
-     log_message "Settings: domain=${domain}, port=${port}, tunnel_id=${tunnel_id}"
- }
- 
-+# Function to check WebSocket Endpoint with verbose output for detailed diagnostics
-+check_websocket_endpoint() {
-+    log_section "Checking WebSocket Endpoint"
-+    log_message "Attempting WebSocket upgrade test with verbose output..."
-+    ws_response=$(docker exec ${CONTAINER_NAME} curl -v -i -N -s \
-+        -H "Connection: Upgrade" \
-+        -H "Upgrade: websocket" \
-+        -H "Sec-WebSocket-Version: 13" \
-+        -H "Sec-WebSocket-Key: testkey" \
-+        "http://localhost:${NGINX_PORT}/wss" || true)
-+    log_message "WebSocket test response (verbose):"
-+    if [ -z "$ws_response" ]; then
-+        log_error "No response received from WebSocket upgrade test."
-+    else
-+        echo "$ws_response" | tee -a "$LOG_FILE"
-+        log_message "WebSocket response length: $(echo "$ws_response" | wc -c) characters"
-+    fi
-+}
-+
- # Function to test GitHub API endpoints
- check_github_endpoints() {
-     log_section "Testing GitHub API Endpoints"
-diff --git a/scripts/test_nostr_auth.sh b/scripts/test_nostr_auth.sh
-deleted file mode 100755
-index c8343a2c..00000000
---- a/scripts/test_nostr_auth.sh
-+++ /dev/null
-@@ -1,89 +0,0 @@
--#!/bin/bash
--
--# Colors for output
--GREEN='\033[0;32m'
--RED='\033[0;31m'
--NC='\033[0m'
--
--echo "Testing Nostr Authentication System"
--echo "================================="
--
--# Test 1: Backend Health Check
--echo -e "\n${GREEN}Test 1: Backend Health Check${NC}"
--response=$(curl -s -w "\n%{http_code}" http://localhost:4000/api/health)
--status_code=$(echo "$response" | tail -n1)
--if [ "$status_code" -eq 200 ]; then
--    echo "✓ Backend is running"
--else
--    echo -e "${RED}✗ Backend is not running (Status: $status_code)${NC}"
--    exit 1
--fi
--
--# Test 2: Nostr Login Endpoint
--echo -e "\n${GREEN}Test 2: Nostr Login Endpoint${NC}"
--test_event='{
--    "id": "test_id",
--    "pubkey": "test_pubkey",
--    "content": "Login request",
--    "sig": "test_sig",
--    "created_at": '$(date +%s)',
--    "kind": 27235,
--    "tags": []
--}'
--
--response=$(curl -s -w "\n%{http_code}" -X POST \
--    -H "Content-Type: application/json" \
--    -d "$test_event" \
--    http://localhost:4000/api/auth/nostr/login)
--status_code=$(echo "$response" | tail -n1)
--if [ "$status_code" -eq 401 ]; then
--    echo "✓ Login endpoint correctly rejects invalid signature"
--else
--    echo -e "${RED}✗ Unexpected response from login endpoint (Status: $status_code)${NC}"
--fi
--
--# Test 3: Session Validation
--echo -e "\n${GREEN}Test 3: Session Validation${NC}"
--response=$(curl -s -w "\n%{http_code}" -X POST \
--    -H "Content-Type: application/json" \
--    -d '{"pubkey": "test_pubkey", "token": "invalid_token"}' \
--    http://localhost:4000/api/auth/nostr/validate)
--status_code=$(echo "$response" | tail -n1)
--if [ "$status_code" -eq 200 ]; then
--    valid=$(echo "$response" | head -n1 | jq -r '.valid')
--    if [ "$valid" = "false" ]; then
--        echo "✓ Session validation correctly identifies invalid token"
--    else
--        echo -e "${RED}✗ Session validation incorrectly accepts invalid token${NC}"
--    fi
--else
--    echo -e "${RED}✗ Unexpected response from validation endpoint (Status: $status_code)${NC}"
--fi
--
--# Test 4: Mode Switch Protection
--echo -e "\n${GREEN}Test 4: Mode Switch Protection${NC}"
--response=$(curl -s -w "\n%{http_code}" -X POST \
--    -H "Content-Type: application/json" \
--    -d '{"mode": "power", "pubkey": "test_pubkey", "token": "invalid_token"}' \
--    http://localhost:4000/api/auth/nostr/mode)
--status_code=$(echo "$response" | tail -n1)
--if [ "$status_code" -eq 401 ]; then
--    echo "✓ Mode switch correctly requires authentication"
--else
--    echo -e "${RED}✗ Mode switch does not properly check authentication (Status: $status_code)${NC}"
--fi
--
--# Test 5: Protected Settings Access
--echo -e "\n${GREEN}Test 5: Protected Settings Access${NC}"
--response=$(curl -s -w "\n%{http_code}" -X GET \
--    -H "X-Nostr-Pubkey: test_pubkey" \
--    -H "X-Nostr-Auth: invalid_token" \
--    http://localhost:4000/api/settings/protected)
--status_code=$(echo "$response" | tail -n1)
--if [ "$status_code" -eq 401 ]; then
--    echo "✓ Protected settings correctly requires authentication"
--else
--    echo -e "${RED}✗ Protected settings does not properly check authentication (Status: $status_code)${NC}"
--fi
--
--echo -e "\n${GREEN}Tests completed!${NC}"
-\ No newline at end of file
-diff --git a/settings.yaml b/settings.yaml
-index 6366b091..8fa3a43b 100644
---- a/settings.yaml
-+++ b/settings.yaml
-@@ -1,25 +1,25 @@
- # Core visualization settings
- visualization:
-   nodes:
--    base_color: "#c3ab6f"
--    base_size: 0.5
--    metalness: 0.3
--    opacity: 0.4
--    roughness: 0.35
--    size_range: [0.5, 1.0]
--    quality: "medium"
--    enable_instancing: false
-+    base_color: "#00ffff"
-+    base_size: 1.5
-+    metalness: 0.8
-+    opacity: 1.0
-+    roughness: 0.2
-+    size_range: [1.0, 3.0]
-+    quality: "high"
-+    enable_instancing: true
-     enable_hologram: false
--    enable_metadata_shape: false
--    enable_metadata_visualization: false
-+    enable_metadata_shape: true
-+    enable_metadata_visualization: true
- 
-   edges:
--    arrow_size: 0.15
--    base_width: 2.0
--    color: "#917f18"
-+    arrow_size: 0
-+    base_width: 1.0
-+    color: "#888888"
-     enable_arrows: false
-     opacity: 0.6
--    width_range: [1.0, 3.0]
-+    width_range: [1.0, 2.0]
- 
-   physics:
-     attraction_strength: 0.015
-@@ -27,60 +27,66 @@ visualization:
-     collision_radius: 0.25
-     damping: 0.88
-     enable_bounds: true
--    enabled: false
-+    enabled: true
-     iterations: 500
-     max_velocity: 2.5
-     repulsion_strength: 1500.0
-     spring_strength: 0.018
- 
-   rendering:
--    ambient_light_intensity: 0.3
--    background_color: "#000000"
--    directional_light_intensity: 1.0
--    enable_ambient_occlusion: false
--    enable_antialiasing: false
--    enable_shadows: false
--    environment_intensity: 0.6
-+    ambient_light_intensity: 0.5
-+    background_color: "#121212"
-+    directional_light_intensity: 1.5
-+    enable_ambient_occlusion: true
-+    enable_antialiasing: true
-+    enable_shadows: true
-+    environment_intensity: 1.0
- 
-   animations:
-     enable_motion_blur: false
--    enable_node_animations: false
--    motion_blur_strength: 0.4
--    selection_wave_enabled: false
--    pulse_enabled: false
--    pulse_speed: 1.0
-+    enable_node_animations: true
-+    motion_blur_strength: 0.5
-+    selection_wave_enabled: true
-+    pulse_enabled: true
-+    pulse_speed: 1.5
-     pulse_strength: 1.0
-     wave_speed: 1.0
- 
-   labels:
--    desktop_font_size: 48
-+    desktop_font_size: 16
-     enable_labels: true
-     text_color: "#FFFFFF"
-+    text_outline_color: "#000000"
-+    text_outline_width: 2
-+    text_resolution: 256
-+    text_padding: 4
-+    billboard_mode: true
- 
-   bloom:
--    edge_bloom_strength: 0.3
--    enabled: false
--    environment_bloom_strength: 0.5
--    node_bloom_strength: 0.2
--    radius: 0.5
--    strength: 1.8
-+    edge_bloom_strength: 0.5
-+    enabled: true
-+    environment_bloom_strength: 1.0
-+    node_bloom_strength: 2.0
-+    radius: 0.8
-+    strength: 1.5
-+    threshold: 0.3
- 
-   hologram:
-     ring_count: 3
--    ring_color: "#00ff00"
-+    ring_color: "#00ffff"
-     ring_opacity: 0.5
--    ring_sizes: [1.0, 1.2, 1.5]
--    ring_rotation_speed: 0.001
-+    ring_sizes: [1.0, 1.5, 2.0]
-+    ring_rotation_speed: 0.1
-     enable_buckminster: false
-     buckminster_scale: 1.0
--    buckminster_opacity: 0.3
-+    buckminster_opacity: 0.5
-     enable_geodesic: false
-     geodesic_scale: 1.0
--    geodesic_opacity: 0.3
-+    geodesic_opacity: 0.5
-     enable_triangle_sphere: false
-     triangle_sphere_scale: 1.0
--    triangle_sphere_opacity: 0.3
--    global_rotation_speed: 0.0005
-+    triangle_sphere_opacity: 0.5
-+    global_rotation_speed: 0.1
- 
- # System settings
- system:
-@@ -104,7 +110,7 @@ system:
-     retry_delay: 5
- 
-   websocket:
--    binary_chunk_size: 65536
-+    binary_chunk_size: 1024
-     binary_update_rate: 30
-     binary_message_version: 1
-     compression_enabled: true
-@@ -113,9 +119,9 @@ system:
-     heartbeat_timeout: 60000
-     max_connections: 1000
-     max_message_size: 100485760
--    reconnect_attempts: 3
-+    reconnect_attempts: 5
-     reconnect_delay: 5000
--    update_rate: 90
-+    update_rate: 60
- 
-   security:
-     allowed_origins: []
-@@ -142,7 +148,8 @@ xr:
-   mode: "immersive-ar"
-   room_scale: true
-   space_type: "local-floor"
--  quality: "medium"
-+  quality: "high"
-+  hide_control_panel: false
- 
-   # Hand tracking settings
-   enable_hand_tracking: true
-@@ -151,17 +158,17 @@ xr:
-   hand_mesh_opacity: 0.5
-   hand_point_size: 5.0
-   hand_ray_enabled: true
--  hand_ray_color: "#00ff00"
-+  hand_ray_color: "#ffffff"
-   hand_ray_width: 2.0
-   gesture_smoothing: 0.5
- 
-   # Haptics and interaction settings
-   enable_haptics: true
-   haptic_intensity: 0.5
--  drag_threshold: 0.02
--  pinch_threshold: 0.7
-+  drag_threshold: 0.1
-+  pinch_threshold: 0.5
-   rotation_threshold: 0.1
--  interaction_radius: 0.5
-+  interaction_radius: 0.1
- 
-   # Environment settings
-   enable_light_estimation: true
-diff --git a/src/app_state.rs b/src/app_state.rs
-index e203607a..ec09d64f 100755
---- a/src/app_state.rs
-+++ b/src/app_state.rs
-@@ -1,32 +1,57 @@
--use crate::models::protected_settings::ProtectedSettings;
--use crate::services::NostrService;
--use actix_web::web;
--use std::sync::Arc;
-+use std::sync::{Arc, atomic::{AtomicUsize, Ordering}};
- use tokio::sync::RwLock;
--use serde_json::Value;
- 
-+use crate::config::Settings;
-+use crate::models::metadata::MetadataStore;
-+use crate::services::graph_service::GraphService;
-+use crate::services::github::{GitHubClient, ContentAPI};
-+use crate::services::perplexity_service::PerplexityService;
-+use crate::services::ragflow_service::RAGFlowService;
-+use crate::utils::gpu_compute::GPUCompute;
-+
-+#[derive(Clone)]
- pub struct AppState {
--    pub settings: Arc<RwLock<Value>>,
--    pub protected_settings: Arc<RwLock<ProtectedSettings>>,
--    pub nostr_service: Option<web::Data<NostrService>>,
-+    pub graph_service: GraphService,
-+    pub gpu_compute: Option<Arc<RwLock<GPUCompute>>>,
-+    pub settings: Arc<RwLock<Settings>>,
-+    pub metadata: Arc<RwLock<MetadataStore>>,
-+    pub github_client: Arc<GitHubClient>,
-+    pub content_api: Arc<ContentAPI>,
-+    pub perplexity_service: Option<Arc<PerplexityService>>,
-+    pub ragflow_service: Option<Arc<RAGFlowService>>,
-+    pub ragflow_conversation_id: String,
-+    pub active_connections: Arc<AtomicUsize>,
- }
- 
- impl AppState {
--    pub fn new() -> Self {
-+    pub fn new(
-+        settings: Arc<RwLock<Settings>>,
-+        github_client: Arc<GitHubClient>,
-+        content_api: Arc<ContentAPI>,
-+        perplexity_service: Option<Arc<PerplexityService>>,
-+        ragflow_service: Option<Arc<RAGFlowService>>,
-+        gpu_compute: Option<Arc<RwLock<GPUCompute>>>,
-+        ragflow_conversation_id: String,
-+    ) -> Self {
-         Self {
--            settings: Arc::new(RwLock::new(serde_json::json!({}))),
--            protected_settings: Arc::new(RwLock::new(ProtectedSettings::default())),
--            nostr_service: None,
-+            graph_service: GraphService::new(),
-+            gpu_compute,
-+            settings,
-+            metadata: Arc::new(RwLock::new(MetadataStore::new())),
-+            github_client,
-+            content_api,
-+            perplexity_service,
-+            ragflow_service,
-+            ragflow_conversation_id,
-+            active_connections: Arc::new(AtomicUsize::new(0)),
-         }
-     }
- 
--    pub fn get_nostr_service(&self) -> Option<&web::Data<NostrService>> {
--        self.nostr_service.as_ref()
-+    pub fn increment_connections(&self) -> usize {
-+        self.active_connections.fetch_add(1, Ordering::SeqCst)
-     }
--}
- 
--impl Default for AppState {
--    fn default() -> Self {
--        Self::new()
-+    pub fn decrement_connections(&self) -> usize {
-+        self.active_connections.fetch_sub(1, Ordering::SeqCst)
-     }
- }
-diff --git a/src/auth/mod.rs b/src/auth/mod.rs
-deleted file mode 100644
-index 8e208763..00000000
---- a/src/auth/mod.rs
-+++ /dev/null
-@@ -1,136 +0,0 @@
--use bcrypt::{hash, verify, DEFAULT_COST};
--use jsonwebtoken::{encode, decode, EncodingKey, DecodingKey, Header, Validation};
--use serde::{Deserialize, Serialize};
--use std::env;
--use std::time::{SystemTime, UNIX_EPOCH};
--use thiserror::Error;
--use uuid::Uuid;
--use crate::models::protected_settings::UserMode;
--
--#[derive(Debug, Error)]
--pub enum AuthError {
--    #[error("Invalid credentials")]
--    InvalidCredentials,
--    #[error("Token creation failed: {0}")]
--    TokenCreation(String),
--    #[error("Token validation failed: {0}")]
--    TokenValidation(String),
--    #[error("Environment error: {0}")]
--    Environment(String),
--    #[error("Bcrypt error: {0}")]
--    BcryptError(#[from] bcrypt::BcryptError),
--}
--
--#[derive(Debug, Serialize, Deserialize)]
--pub struct Claims {
--    pub sub: String,      // Subject (user ID)
--    pub exp: usize,       // Expiration time
--    pub iat: usize,       // Issued at
--    pub mode: UserMode,   // User mode
--    pub client_id: String, // Client identifier
--}
--
--pub struct Auth {
--    password_hash: String,
--    token_secret: String,
--    token_expiry: u64,
--}
--
--impl Auth {
--    pub fn new() -> Result<Self, AuthError> {
--        let password_hash = env::var("AUTH_PASSWORD_HASH")
--            .map_err(|_| AuthError::Environment("AUTH_PASSWORD_HASH not set".to_string()))?;
--        
--        let token_secret = env::var("AUTH_TOKEN_SECRET")
--            .map_err(|_| AuthError::Environment("AUTH_TOKEN_SECRET not set".to_string()))?;
--        
--        let token_expiry = env::var("AUTH_TOKEN_EXPIRY")
--            .unwrap_or_else(|_| "3600".to_string())
--            .parse()
--            .unwrap_or(3600);
--
--        Ok(Auth {
--            password_hash,
--            token_secret,
--            token_expiry,
--        })
--    }
--
--    pub fn validate_password(&self, password: &str) -> Result<bool, AuthError> {
--        Ok(verify(password, &self.password_hash)?)
--    }
--
--    pub fn create_token(&self, mode: UserMode) -> Result<(String, String), AuthError> {
--        let now = SystemTime::now()
--            .duration_since(UNIX_EPOCH)
--            .unwrap()
--            .as_secs() as usize;
--
--        let client_id = Uuid::new_v4().to_string();
--        
--        let claims = Claims {
--            sub: "user".to_string(),
--            exp: now + self.token_expiry as usize,
--            iat: now,
--            mode,
--            client_id: client_id.clone(),
--        };
--
--        let token = encode(
--            &Header::default(),
--            &claims,
--            &EncodingKey::from_secret(self.token_secret.as_bytes()),
--        )
--        .map_err(|e| AuthError::TokenCreation(e.to_string()))?;
--
--        Ok((token, client_id))
--    }
--
--    pub fn verify_token(&self, token: &str) -> Result<Claims, AuthError> {
--        let validation = Validation::default();
--        
--        decode::<Claims>(
--            token,
--            &DecodingKey::from_secret(self.token_secret.as_bytes()),
--            &validation,
--        )
--        .map(|token_data| token_data.claims)
--        .map_err(|e| AuthError::TokenValidation(e.to_string()))
--    }
--
--    pub fn hash_password(password: &str) -> Result<String, AuthError> {
--        Ok(hash(password, DEFAULT_COST)?)
--    }
--}
--
--#[cfg(test)]
--mod tests {
--    use super::*;
--    use std::env;
--
--    #[test]
--    fn test_password_validation() {
--        let test_password = "test_password";
--        let hashed = Auth::hash_password(test_password).unwrap();
--        
--        env::set_var("AUTH_PASSWORD_HASH", &hashed);
--        env::set_var("AUTH_TOKEN_SECRET", "test_secret");
--        
--        let auth = Auth::new().unwrap();
--        assert!(auth.validate_password(test_password).unwrap());
--        assert!(!auth.validate_password("wrong_password").unwrap());
--    }
--
--    #[test]
--    fn test_token_creation_and_verification() {
--        env::set_var("AUTH_PASSWORD_HASH", "dummy_hash");
--        env::set_var("AUTH_TOKEN_SECRET", "test_secret");
--        
--        let auth = Auth::new().unwrap();
--        let (token, client_id) = auth.create_token(UserMode::Normal).unwrap();
--        
--        let claims = auth.verify_token(&token).unwrap();
--        assert_eq!(claims.client_id, client_id);
--        assert!(matches!(claims.mode, UserMode::Normal));
--    }
--}
-\ No newline at end of file
-diff --git a/src/handlers/auth_handler.rs b/src/handlers/auth_handler.rs
-deleted file mode 100644
-index 4d4d6364..00000000
---- a/src/handlers/auth_handler.rs
-+++ /dev/null
-@@ -1,113 +0,0 @@
--use crate::app_state::AppState;
--use crate::auth::{Auth, AuthError};
--use crate::models::protected_settings::UserMode;
--use actix_web::{web, Error, HttpResponse};
--use serde::{Deserialize, Serialize};
--use serde_json::json;
--use std::sync::Arc;
--
--#[derive(Debug, Deserialize)]
--pub struct LoginRequest {
--    password: String,
--    mode: Option<UserMode>,
--}
--
--#[derive(Debug, Serialize)]
--pub struct LoginResponse {
--    token: String,
--    client_id: String,
--    mode: UserMode,
--}
--
--#[derive(Debug, Deserialize)]
--pub struct SwitchModeRequest {
--    client_id: String,
--    token: String,
--    mode: UserMode,
--}
--
--pub fn config(cfg: &mut web::ServiceConfig) {
--    cfg.service(
--        web::scope("/auth")
--            .route("/login", web::post().to(login))
--            .route("/mode", web::post().to(switch_mode))
--            .route("/validate", web::post().to(validate_token)),
--    );
--}
--
--async fn login(
--    req: web::Json<LoginRequest>,
--    state: web::Data<AppState>,
--    auth: web::Data<Arc<Auth>>,
--) -> Result<HttpResponse, Error> {
--    match auth.validate_password(&req.password) {
--        Ok(true) => {
--            let mode = req.mode.clone().unwrap_or(UserMode::Normal);
--            let (token, client_id) = auth.create_token(mode.clone())?;
--
--            // Store the client token
--            let mut protected_settings = state.protected_settings.write().await;
--            protected_settings.store_client_token(client_id.clone(), token.clone(), mode.clone());
--
--            Ok(HttpResponse::Ok().json(LoginResponse {
--                token,
--                client_id,
--                mode,
--            }))
--        }
--        Ok(false) => Ok(HttpResponse::Unauthorized().json(json!({
--            "error": "Invalid credentials"
--        }))),
--        Err(e) => Ok(HttpResponse::InternalServerError().json(json!({
--            "error": format!("Authentication error: {}", e)
--        }))),
--    }
--}
--
--async fn switch_mode(
--    req: web::Json<SwitchModeRequest>,
--    state: web::Data<AppState>,
--    auth: web::Data<Arc<Auth>>,
--) -> Result<HttpResponse, Error> {
--    // First validate the existing token
--    let mut protected_settings = state.protected_settings.write().await;
--    
--    if let Some(_current_mode) = protected_settings.validate_client_token(&req.client_id, &req.token) {
--        // Create new token for the new mode
--        let (new_token, client_id) = auth.create_token(req.mode.clone())?;
--        
--        // Store the new client token
--        protected_settings.store_client_token(client_id.clone(), new_token.clone(), req.mode.clone());
--        
--        // Clean up expired tokens
--        protected_settings.cleanup_expired_tokens(30); // Clean up tokens older than 30 days
--
--        Ok(HttpResponse::Ok().json(LoginResponse {
--            token: new_token,
--            client_id,
--            mode: req.mode.clone(),
--        }))
--    } else {
--        Ok(HttpResponse::Unauthorized().json(json!({
--            "error": "Invalid token"
--        })))
--    }
--}
--
--async fn validate_token(
--    req: web::Json<SwitchModeRequest>,
--    state: web::Data<AppState>,
--) -> Result<HttpResponse, Error> {
--    let mut protected_settings = state.protected_settings.write().await;
--    
--    if let Some(mode) = protected_settings.validate_client_token(&req.client_id, &req.token) {
--        Ok(HttpResponse::Ok().json(json!({
--            "valid": true,
--            "mode": mode
--        })))
--    } else {
--        Ok(HttpResponse::Ok().json(json!({
--            "valid": false
--        })))
--    }
--}
-\ No newline at end of file
-diff --git a/src/handlers/mod.rs b/src/handlers/mod.rs
-index 41cc7357..5d6237e7 100755
---- a/src/handlers/mod.rs
-+++ b/src/handlers/mod.rs
-@@ -1,22 +1,7 @@
--pub mod auth_handler;
--pub mod file_handler;
--pub mod graph_handler;
-+pub mod api_handler;
- pub mod health_handler;
- pub mod pages_handler;
- pub mod perplexity_handler;
- pub mod ragflow_handler;
- pub mod settings_handler;
- pub mod socket_flow_handler;
--pub mod visualization_handler;
--pub mod nostr_auth_handler;
--
--pub mod api_handler {
--    pub mod files;
--    pub mod graph;
--    pub mod visualization;
--}
--
--// Re-export commonly used handlers
--pub use auth_handler::config as auth_config;
--pub use nostr_auth_handler::config as nostr_auth_config;
--pub use settings_handler::config as settings_config;
-diff --git a/src/handlers/nostr_auth_handler.rs b/src/handlers/nostr_auth_handler.rs
-deleted file mode 100644
-index 9d3a2c32..00000000
---- a/src/handlers/nostr_auth_handler.rs
-+++ /dev/null
-@@ -1,158 +0,0 @@
--use crate::app_state::AppState;
--use crate::models::protected_settings::UserMode;
--use crate::services::nostr_service::{NostrService, NostrUser, AuthEvent, NostrError};
--use actix_web::{web, Error, HttpResponse};
--use serde::{Deserialize, Serialize};
--use serde_json::json;
--
--#[derive(Debug, Serialize)]
--pub struct AuthResponse {
--    pub user: NostrUser,
--    pub token: String,
--}
--
--#[derive(Debug, Deserialize)]
--pub struct ModeRequest {
--    pub mode: UserMode,
--}
--
--#[derive(Debug, Deserialize)]
--pub struct ValidateRequest {
--    pub pubkey: String,
--    pub token: String,
--}
--
--pub fn config(cfg: &mut web::ServiceConfig) {
--    cfg.service(
--        web::scope("/auth/nostr")
--            .route("/login", web::post().to(login))
--            .route("/logout", web::post().to(logout))
--            .route("/mode", web::post().to(switch_mode))
--            .route("/validate", web::post().to(validate_session))
--            .route("/refresh", web::post().to(refresh_session)),
--    );
--}
--
--async fn login(
--    event: web::Json<AuthEvent>,
--    nostr_service: web::Data<NostrService>,
--) -> Result<HttpResponse, Error> {
--    match nostr_service.verify_auth_event(event.into_inner()).await {
--        Ok(user) => {
--            let token = user.session_token.clone().unwrap_or_default();
--            Ok(HttpResponse::Ok().json(AuthResponse { user, token }))
--        }
--        Err(NostrError::InvalidSignature) => {
--            Ok(HttpResponse::Unauthorized().json(json!({
--                "error": "Invalid signature"
--            })))
--        }
--        Err(e) => {
--            Ok(HttpResponse::InternalServerError().json(json!({
--                "error": format!("Authentication error: {}", e)
--            })))
--        }
--    }
--}
--
--async fn logout(
--    req: web::Json<ValidateRequest>,
--    nostr_service: web::Data<NostrService>,
--) -> Result<HttpResponse, Error> {
--    // Validate session before logout
--    if !nostr_service.validate_session(&req.pubkey, &req.token).await {
--        return Ok(HttpResponse::Unauthorized().json(json!({
--            "error": "Invalid session"
--        })));
--    }
--
--    match nostr_service.logout(&req.pubkey).await {
--        Ok(_) => Ok(HttpResponse::Ok().json(json!({
--            "message": "Logged out successfully"
--        }))),
--        Err(e) => Ok(HttpResponse::InternalServerError().json(json!({
--            "error": format!("Logout error: {}", e)
--        }))),
--    }
--}
--
--async fn switch_mode(
--    req: web::Json<ModeRequest>,
--    validate: web::Json<ValidateRequest>,
--    nostr_service: web::Data<NostrService>,
--) -> Result<HttpResponse, Error> {
--    // Validate session before mode switch
--    if !nostr_service.validate_session(&validate.pubkey, &validate.token).await {
--        return Ok(HttpResponse::Unauthorized().json(json!({
--            "error": "Invalid session"
--        })));
--    }
--
--    match nostr_service.update_user_mode(&validate.pubkey, req.mode.clone()).await {
--        Ok(user) => {
--            let token = user.session_token.clone().unwrap_or_default();
--            Ok(HttpResponse::Ok().json(AuthResponse { user, token }))
--        }
--        Err(e) => Ok(HttpResponse::InternalServerError().json(json!({
--            "error": format!("Mode switch error: {}", e)
--        }))),
--    }
--}
--
--async fn validate_session(
--    req: web::Json<ValidateRequest>,
--    nostr_service: web::Data<NostrService>,
--) -> Result<HttpResponse, Error> {
--    let is_valid = nostr_service.validate_session(&req.pubkey, &req.token).await;
--
--    Ok(HttpResponse::Ok().json(json!({
--        "valid": is_valid
--    })))
--}
--
--async fn refresh_session(
--    req: web::Json<ValidateRequest>,
--    nostr_service: web::Data<NostrService>,
--) -> Result<HttpResponse, Error> {
--    // First validate the current session
--    if !nostr_service.validate_session(&req.pubkey, &req.token).await {
--        return Ok(HttpResponse::Unauthorized().json(json!({
--            "error": "Invalid session"
--        })));
--    }
--
--    match nostr_service.refresh_session(&req.pubkey).await {
--        Ok(new_token) => {
--            if let Some(user) = nostr_service.get_user(&req.pubkey).await {
--                Ok(HttpResponse::Ok().json(AuthResponse {
--                    user,
--                    token: new_token,
--                }))
--            } else {
--                Ok(HttpResponse::InternalServerError().json(json!({
--                    "error": "User not found after refresh"
--                })))
--            }
--        }
--        Err(e) => Ok(HttpResponse::InternalServerError().json(json!({
--            "error": format!("Session refresh error: {}", e)
--        }))),
--    }
--}
--
--// Add Nostr service to app state during startup
--pub fn init_nostr_service(app_state: &mut AppState) {
--    let nostr_service = NostrService::new();
--    
--    // Start session cleanup task
--    let service_clone = nostr_service.clone();
--    tokio::spawn(async move {
--        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(3600)); // Every hour
--        loop {
--            interval.tick().await;
--            service_clone.cleanup_sessions(24).await; // Clean up sessions older than 24 hours
--        }
--    });
--
--    app_state.nostr_service = Some(web::Data::new(nostr_service));
--}
-\ No newline at end of file
-diff --git a/src/handlers/perplexity_handler.rs b/src/handlers/perplexity_handler.rs
-index 4c47acc0..0ad75858 100755
---- a/src/handlers/perplexity_handler.rs
-+++ b/src/handlers/perplexity_handler.rs
-@@ -1,5 +1,5 @@
- use crate::AppState;
--use actix_web::{post, web, HttpMessage, HttpResponse, Responder};
-+use actix_web::{post, web, HttpResponse, Responder};
- use serde::{Deserialize, Serialize};
- use serde_json::json;
- use log::{error, info};
-@@ -8,7 +8,6 @@ use log::{error, info};
- pub struct PerplexityRequest {
-     pub query: String,
-     pub conversation_id: Option<String>,
--    pub api_key: Option<String>,  // Optional API key in request body
- }
- 
- #[derive(Debug, Serialize)]
-@@ -19,30 +18,11 @@ pub struct PerplexityResponse {
- 
- #[post("")]
- pub async fn handle_perplexity(
--    req: web::HttpRequest,
-     state: web::Data<AppState>,
-     request: web::Json<PerplexityRequest>,
- ) -> impl Responder {
-     info!("Received perplexity request: {:?}", request);
- 
--    // Try to get API key in this order:
--    // 1. From request header (set by middleware)
--    // 2. From request body
--    // 3. From server configuration
--    let api_key = req
--        .extensions()
--        .get::<String>()
--        .map(|s| s.to_string())
--        .or_else(|| request.api_key.clone())
--        .or_else(|| std::env::var("PERPLEXITY_API_KEY").ok());
--
--    let api_key = match api_key {
--        Some(key) => key,
--        None => return HttpResponse::Unauthorized().json(json!({
--            "error": "No API key provided and no server-side key configured"
--        }))
--    };
--
-     let perplexity_service = match &state.perplexity_service {
-         Some(service) => service,
-         None => return HttpResponse::ServiceUnavailable().json(json!({
-@@ -50,9 +30,6 @@ pub async fn handle_perplexity(
-         }))
-     };
- 
--    // Use the determined API key
--    perplexity_service.set_api_key(&api_key);
--
-     let conversation_id = state.ragflow_conversation_id.clone();
-     match perplexity_service.query(&request.query, &conversation_id).await {
-         Ok(answer) => {
-diff --git a/src/handlers/settings_handler.rs b/src/handlers/settings_handler.rs
-index 54375b6f..71a667e7 100644
---- a/src/handlers/settings_handler.rs
-+++ b/src/handlers/settings_handler.rs
-@@ -1,456 +1,51 @@
- use crate::app_state::AppState;
--use crate::auth::{Auth, AuthError};
--use crate::models::protected_settings::{ProtectedSettings, UserMode};
--use crate::utils::case_conversion::to_camel_case;
--use actix_web::{web, Error, HttpRequest, HttpResponse};
-+use crate::models::UISettings;
-+use actix_web::{web, Error, HttpResponse};
- use serde_json::{json, Value};
--use std::sync::Arc;
- 
- pub fn config(cfg: &mut web::ServiceConfig) {
-     cfg.service(
--        web::scope("/settings")
--            .route("", web::get().to(get_settings))
--            .route("", web::post().to(update_settings))
--            .route("/protected", web::get().to(get_protected_settings))
--            .route("/protected", web::post().to(update_protected_settings)),
-+        web::resource("/settings")
-+            .route(web::get().to(get_settings))
-+            .route(web::post().to(update_settings)),
-     );
- }
- 
--// Helper to extract and validate client auth
--async fn validate_client_auth(
--    req: &HttpRequest,
--    state: &web::Data<AppState>,
--) -> Result<(String, UserMode), HttpResponse> {
--    let client_id = req
--        .headers()
--        .get("X-Client-ID")
--        .and_then(|h| h.to_str().ok())
--        .ok_or_else(|| {
--            HttpResponse::Unauthorized().json(json!({
--                "error": "Missing client ID"
--            }))
--        })?;
--
--    let token = req
--        .headers()
--        .get("Authorization")
--        .and_then(|h| h.to_str().ok())
--        .and_then(|s| s.strip_prefix("Bearer "))
--        .ok_or_else(|| {
--            HttpResponse::Unauthorized().json(json!({
--                "error": "Missing or invalid authorization header"
--            }))
--        })?;
--
--    let protected_settings = state.protected_settings.read().await;
--    if let Some(mode) = protected_settings.validate_client_token(client_id, token) {
--        Ok((client_id.to_string(), mode))
--    } else {
--        Err(HttpResponse::Unauthorized().json(json!({
--            "error": "Invalid or expired token"
--        })))
--    }
--}
--
- async fn get_settings(state: web::Data<AppState>) -> Result<HttpResponse, Error> {
-     let settings_guard = state.settings.read().await;
--    let settings_json = convert_struct_to_camel_case(&*settings_guard);
--    Ok(HttpResponse::Ok().json(settings_json))
-+    
-+    // Convert to UI settings
-+    let ui_settings = UISettings::from(&*settings_guard);
-+    
-+    Ok(HttpResponse::Ok().json(ui_settings))
- }
- 
- async fn update_settings(
-     state: web::Data<AppState>,
-     payload: web::Json<Value>,
- ) -> Result<HttpResponse, Error> {
--    if let Err(e) = validate_settings(&payload) {
--        return Ok(HttpResponse::BadRequest().body(format!("Invalid settings: {}", e)));
--    }
-+    // Parse and validate the incoming settings as UISettings
-+    let ui_settings: UISettings = match serde_json::from_value(payload.into_inner()) {
-+        Ok(settings) => settings,
-+        Err(e) => {
-+            return Ok(HttpResponse::BadRequest().body(format!("Invalid settings format: {}", e)));
-+        }
-+    };
- 
-+    // Update the main settings with UI settings
-     let mut settings_guard = state.settings.write().await;
-+    ui_settings.merge_into_settings(&mut settings_guard);
- 
--    if let Err(e) = settings_guard.merge(payload.into_inner()) {
--        return Ok(HttpResponse::BadRequest().body(format!("Failed to merge settings: {}", e)));
--    }
--
-+    // Save the updated settings
-     if let Err(e) = settings_guard.save() {
-         return Ok(
-             HttpResponse::InternalServerError().body(format!("Failed to save settings: {}", e))
-         );
-     }
- 
--    let settings_json = convert_struct_to_camel_case(&*settings_guard);
--    Ok(HttpResponse::Ok().json(settings_json))
--}
--
--async fn get_protected_settings(
--    req: HttpRequest,
--    state: web::Data<AppState>,
--) -> Result<HttpResponse, Error> {
--    let (_, mode) = validate_client_auth(&req, &state).await?;
--    let protected_settings = state.protected_settings.read().await;
--
--    let response = match mode {
--        UserMode::Power => {
--            // In power user mode, return env-based keys
--            json!({
--                "mode": "power",
--                "api_keys": protected_settings.get_active_keys()
--            })
--        }
--        UserMode::Normal => {
--            // In normal mode, return user-configured keys
--            json!({
--                "mode": "normal",
--                "api_keys": protected_settings.api_keys
--            })
--        }
--    };
--
--    Ok(HttpResponse::Ok().json(response))
--}
--
--async fn update_protected_settings(
--    req: HttpRequest,
--    payload: web::Json<ProtectedSettings>,
--    state: web::Data<AppState>,
--) -> Result<HttpResponse, Error> {
--    let (_, mode) = validate_client_auth(&req, &state).await?;
--
--    match mode {
--        UserMode::Power => {
--            Ok(HttpResponse::Forbidden().json(json!({
--                "error": "Cannot update settings in power user mode",
--                "message": "Power user mode uses environment variables"
--            })))
--        }
--        UserMode::Normal => {
--            let mut protected_settings = state.protected_settings.write().await;
--            protected_settings.api_keys = payload.api_keys.clone();
--            
--            Ok(HttpResponse::Ok().json(json!({
--                "message": "Settings updated successfully",
--                "api_keys": protected_settings.api_keys
--            })))
--        }
--    }
--}
--
--// Validation functions remain unchanged
--fn validate_settings(settings: &Value) -> Result<(), String> {
--    if !settings.is_object() {
--        return Err("Settings must be an object".to_string());
--    }
--
--    let obj = settings.as_object().unwrap();
--
--    // Validate visualization settings
--    if let Some(visualization) = obj.get("visualization") {
--        validate_visualization_settings(visualization)?;
--    }
--
--    // Validate system settings
--    if let Some(system) = obj.get("system") {
--        validate_system_settings(system)?;
--    }
--
--    // Validate XR settings
--    if let Some(xr) = obj.get("xr") {
--        validate_xr_settings(xr)?;
--    }
--
--    Ok(())
--}
--
--fn validate_visualization_settings(settings: &Value) -> Result<(), String> {
--    let obj = settings
--        .as_object()
--        .ok_or("Visualization settings must be an object")?;
--
--    // Validate bloom settings
--    if let Some(bloom) = obj.get("bloom") {
--        validate_bloom_settings(bloom)?;
--    }
--
--    // Validate hologram settings
--    if let Some(hologram) = obj.get("hologram") {
--        validate_hologram_settings(hologram)?;
--    }
--
--    // Validate physics settings
--    if let Some(physics) = obj.get("physics") {
--        validate_physics_settings(physics)?;
--    }
--
--    // Validate node settings
--    if let Some(nodes) = obj.get("nodes") {
--        validate_node_settings(nodes)?;
--    }
--
--    Ok(())
--}
--
--// Rest of the validation functions remain unchanged...
--fn validate_bloom_settings(settings: &Value) -> Result<(), String> {
--    let obj = settings
--        .as_object()
--        .ok_or("Bloom settings must be an object")?;
--
--    // If bloom is enabled, validate required settings
--    if let Some(enabled) = obj.get("enabled") {
--        if enabled.as_bool().unwrap_or(false) {
--            // Validate strength (0.0 - 2.0)
--            if let Some(strength) = obj.get("strength") {
--                let strength_val = strength.as_f64().ok_or("Bloom strength must be a number")?;
--                if !(0.0..=2.0).contains(&strength_val) {
--                    return Err("Bloom strength must be between 0.0 and 2.0".to_string());
--                }
--            }
--
--            // Validate radius (0.0 - 1.0)
--            if let Some(radius) = obj.get("radius") {
--                let radius_val = radius.as_f64().ok_or("Bloom radius must be a number")?;
--                if !(0.0..=1.0).contains(&radius_val) {
--                    return Err("Bloom radius must be between 0.0 and 1.0".to_string());
--                }
--            }
--        }
--    }
--
--    Ok(())
--}
--
--fn validate_hologram_settings(settings: &Value) -> Result<(), String> {
--    let obj = settings
--        .as_object()
--        .ok_or("Hologram settings must be an object")?;
--
--    // If hologram features are enabled, validate their settings
--    if let Some(enable_buckminster) = obj.get("enableBuckminster") {
--        if enable_buckminster.as_bool().unwrap_or(false) {
--            validate_range_f64(obj, "buckminsterScale", 0.1, 50.0, "Buckminster scale")?;
--            validate_range_f64(obj, "buckminsterOpacity", 0.0, 1.0, "Buckminster opacity")?;
--        }
--    }
--
--    if let Some(enable_geodesic) = obj.get("enableGeodesic") {
--        if enable_geodesic.as_bool().unwrap_or(false) {
--            validate_range_f64(obj, "geodesicScale", 0.1, 50.0, "Geodesic scale")?;
--            validate_range_f64(obj, "geodesicOpacity", 0.0, 1.0, "Geodesic opacity")?;
--        }
--    }
--
--    Ok(())
--}
--
--fn validate_physics_settings(settings: &Value) -> Result<(), String> {
--    let obj = settings
--        .as_object()
--        .ok_or("Physics settings must be an object")?;
--
--    if let Some(enabled) = obj.get("enabled") {
--        if enabled.as_bool().unwrap_or(false) {
--            // Validate required physics parameters when enabled
--            validate_range_f64(obj, "attractionStrength", 0.0, 1.0, "Attraction strength")?;
--            validate_range_f64(obj, "repulsionStrength", 0.0, 5000.0, "Repulsion strength")?;
--            validate_range_f64(obj, "springStrength", 0.0, 1.0, "Spring strength")?;
--            validate_range_f64(obj, "damping", 0.0, 1.0, "Damping")?;
--
--            if let Some(iterations) = obj.get("iterations") {
--                let iter_val = iterations
--                    .as_u64()
--                    .ok_or("Iterations must be a positive integer")?;
--                if !(100..=1000).contains(&iter_val) {
--                    return Err("Iterations must be between 100 and 1000".to_string());
--                }
--            }
--        }
--    }
--
--    Ok(())
--}
--
--fn validate_node_settings(settings: &Value) -> Result<(), String> {
--    let obj = settings
--        .as_object()
--        .ok_or("Node settings must be an object")?;
--
--    // Validate quality enum
--    if let Some(quality) = obj.get("quality") {
--        let quality_str = quality.as_str().ok_or("Quality must be a string")?;
--        if !["low", "medium", "high"].contains(&quality_str) {
--            return Err("Quality must be one of: low, medium, high".to_string());
--        }
--    }
--
--    // Validate numeric ranges
--    validate_range_f64(obj, "baseSize", 0.1, 10.0, "Base size")?;
--    validate_range_f64(obj, "opacity", 0.0, 1.0, "Opacity")?;
--    validate_range_f64(obj, "metalness", 0.0, 1.0, "Metalness")?;
--    validate_range_f64(obj, "roughness", 0.0, 1.0, "Roughness")?;
--
--    Ok(())
--}
--
--fn validate_system_settings(settings: &Value) -> Result<(), String> {
--    let obj = settings
--        .as_object()
--        .ok_or("System settings must be an object")?;
--
--    // Validate network settings
--    if let Some(network) = obj.get("network") {
--        validate_network_settings(network)?;
--    }
--
--    // Validate websocket settings
--    if let Some(websocket) = obj.get("websocket") {
--        validate_websocket_settings(websocket)?;
--    }
--
--    Ok(())
--}
--
--fn validate_network_settings(settings: &Value) -> Result<(), String> {
--    let obj = settings
--        .as_object()
--        .ok_or("Network settings must be an object")?;
--
--    // Validate port range
--    if let Some(port) = obj.get("port") {
--        let port_val = port.as_u64().ok_or("Port must be a positive integer")?;
--        if !(1..=65535).contains(&port_val) {
--            return Err("Port must be between 1 and 65535".to_string());
--        }
--    }
--
--    // Validate rate limiting settings
--    if let Some(enable_rate_limiting) = obj.get("enableRateLimiting") {
--        if enable_rate_limiting.as_bool().unwrap_or(false) {
--            if let Some(rate_limit_requests) = obj.get("rateLimitRequests") {
--                let requests = rate_limit_requests
--                    .as_u64()
--                    .ok_or("Rate limit requests must be a positive integer")?;
--                if requests == 0 {
--                    return Err("Rate limit requests must be greater than 0".to_string());
--                }
--            }
--        }
--    }
--
--    Ok(())
--}
--
--fn validate_websocket_settings(settings: &Value) -> Result<(), String> {
--    let obj = settings
--        .as_object()
--        .ok_or("WebSocket settings must be an object")?;
--
--    // Validate update rate
--    if let Some(update_rate) = obj.get("updateRate") {
--        let rate = update_rate
--            .as_u64()
--            .ok_or("Update rate must be a positive integer")?;
--        if !(1..=120).contains(&rate) {
--            return Err("Update rate must be between 1 and 120".to_string());
--        }
--    }
--
--    // Validate message size
--    if let Some(max_message_size) = obj.get("maxMessageSize") {
--        let size = max_message_size
--            .as_u64()
--            .ok_or("Max message size must be a positive integer")?;
--        if size > 100 * 1024 * 1024 {
--            // 100MB limit
--            return Err("Max message size cannot exceed 100MB".to_string());
--        }
--    }
--
--    Ok(())
--}
--
--fn validate_xr_settings(settings: &Value) -> Result<(), String> {
--    let obj = settings
--        .as_object()
--        .ok_or("XR settings must be an object")?;
--
--    // Validate mode enum
--    if let Some(mode) = obj.get("mode") {
--        let mode_str = mode.as_str().ok_or("XR mode must be a string")?;
--        if !["immersive-ar", "immersive-vr"].contains(&mode_str) {
--            return Err("XR mode must be one of: immersive-ar, immersive-vr".to_string());
--        }
--    }
--
--    // Validate space type enum
--    if let Some(space_type) = obj.get("spaceType") {
--        let space_str = space_type.as_str().ok_or("Space type must be a string")?;
--        if ![
--            "viewer",
--            "local",
--            "local-floor",
--            "bounded-floor",
--            "unbounded",
--        ]
--        .contains(&space_str)
--        {
--            return Err("Invalid space type".to_string());
--        }
--    }
--
--    // Validate numeric ranges
--    validate_range_f64(obj, "handMeshOpacity", 0.0, 1.0, "Hand mesh opacity")?;
--    validate_range_f64(obj, "handPointSize", 0.1, 20.0, "Hand point size")?;
--    validate_range_f64(obj, "handRayWidth", 0.1, 10.0, "Hand ray width")?;
--    validate_range_f64(obj, "hapticIntensity", 0.0, 1.0, "Haptic intensity")?;
--
--    Ok(())
--}
--
--fn validate_range_f64(
--    obj: &serde_json::Map<String, Value>,
--    key: &str,
--    min: f64,
--    max: f64,
--    name: &str,
--) -> Result<(), String> {
--    if let Some(value) = obj.get(key) {
--        let val = value.as_f64().ok_or(format!("{} must be a number", name))?;
--        if !(min..=max).contains(&val) {
--            return Err(format!("{} must be between {} and {}", name, min, max));
--        }
--    }
--    Ok(())
--}
--
--fn convert_struct_to_camel_case<T: serde::Serialize>(value: &T) -> serde_json::Value {
--    let json_value = serde_json::to_value(value).unwrap_or_default();
--
--    match json_value {
--        serde_json::Value::Object(map) => {
--            let converted: serde_json::Map<String, serde_json::Value> = map
--                .into_iter()
--                .map(|(k, v)| (to_camel_case(&k), convert_struct_to_camel_case_value(&v)))
--                .collect();
--            serde_json::Value::Object(converted)
--        }
--        _ => json_value,
--    }
--}
--
--fn convert_struct_to_camel_case_value(value: &serde_json::Value) -> serde_json::Value {
--    match value {
--        serde_json::Value::Object(map) => {
--            let converted: serde_json::Map<String, serde_json::Value> = map
--                .into_iter()
--                .map(|(k, v)| (to_camel_case(&k), convert_struct_to_camel_case_value(v)))
--                .collect();
--            serde_json::Value::Object(converted)
--        }
--        serde_json::Value::Array(arr) => {
--            serde_json::Value::Array(arr.iter().map(convert_struct_to_camel_case_value).collect())
--        }
--        _ => value.clone(),
--    }
-+    // Return the updated UI settings
-+    let updated_ui_settings = UISettings::from(&*settings_guard);
-+    Ok(HttpResponse::Ok().json(updated_ui_settings))
- }
- 
- pub async fn get_graph_settings(app_state: web::Data<AppState>) -> Result<HttpResponse, Error> {
-diff --git a/src/main.rs b/src/main.rs
-index b40ba7f9..43666224 100755
---- a/src/main.rs
-+++ b/src/main.rs
-@@ -1,62 +1,197 @@
-+use webxr::{
-+    AppState, Settings,
-+    handlers::{
-+        api_handler,
-+        health_handler,
-+        pages_handler,
-+        socket_flow_handler::socket_flow_handler,
-+    },
-+    GPUCompute, GraphData,
-+    services::{
-+        file_service::FileService,
-+        graph_service::GraphService,
-+        github::{GitHubClient, ContentAPI},
-+    },
-+};
-+
-+use actix_web::{web, App, HttpServer, middleware};
- use actix_cors::Cors;
--use actix_web::{middleware, web, App, HttpServer};
-+use actix_files::Files;
- use std::sync::Arc;
--
--mod app_state;
--mod auth;
--mod config;
--mod handlers;
--mod models;
--mod services;
--mod utils;
--
--use app_state::AppState;
--use auth::Auth;
--use config::Config;
--use handlers::nostr_auth_handler;
-+use tokio::sync::RwLock;
-+use dotenvy::dotenv;
-+use log::{error, warn, info, debug};
-+use webxr::utils::logging::{init_logging_with_config, LogConfig};
- 
- #[actix_web::main]
- async fn main() -> std::io::Result<()> {
--    env_logger::init();
-+    dotenv().ok();
-+
-+    // Load settings first to get the log level
-+    let settings = match Settings::new() {
-+        Ok(s) => {
-+            info!("Settings loaded successfully from: {}", 
-+                std::env::var("SETTINGS_FILE_PATH").unwrap_or_default());
-+            Arc::new(RwLock::new(s))
-+        },
-+        Err(e) => {
-+            error!("Failed to load settings: {:?}", e);
-+            return Err(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to initialize settings: {:?}", e)));
-+        }
-+    };
-+
-+    // Initialize logging with settings-based configuration
-+    let log_config = {
-+        let settings_read = settings.read().await;
-+        let file_level = if settings_read.system.debug.enabled {
-+            "debug"
-+        } else {
-+            &settings_read.system.debug.log_level
-+        };
-+        
-+        let console_level = if settings_read.system.debug.enable_websocket_debug {
-+            "debug"
-+        } else {
-+            &settings_read.system.debug.log_level
-+        };
-+        
-+        LogConfig::new(
-+            file_level,
-+            console_level,
-+        )
-+    };
- 
--    // Load configuration
--    let config = Config::new().expect("Failed to load configuration");
-+    init_logging_with_config(log_config)?;
-+
-+    debug!("Successfully loaded settings");
-+
-+    info!("Starting WebXR application...");
-+    
-+    // Replace log_data! and log_warn! with standard log macros
-+    info!("Initializing GPU compute...");
-     
--    // Initialize auth
--    let auth = Arc::new(Auth::new().expect("Failed to initialize auth"));
-+    let gpu_compute = if cfg!(feature = "gpu") {
-+        match GPUCompute::new(&GraphData::default()).await {
-+            Ok(gpu) => {
-+                info!("GPU initialization successful");
-+                Some(gpu)
-+            }
-+            Err(e) => {
-+                warn!("Failed to initialize GPU: {}. Falling back to CPU computations.", e);
-+                debug!("GPU initialization error details: {:?}", e);
-+                None
-+            }
-+        }
-+    } else {
-+        info!("GPU feature disabled, using CPU computations");
-+        None
-+    };
-+
-+    // Create web::Data instances first
-+    let settings_data = web::Data::new(settings.clone());
-+
-+    // Initialize services
-+    let settings_read = settings.read().await;
-+    let github_client = match GitHubClient::new(
-+        settings_read.github.token.clone(),
-+        settings_read.github.owner.clone(),
-+        settings_read.github.repo.clone(),
-+        settings_read.github.base_path.clone(),
-+        settings.clone(),
-+    ).await {
-+        Ok(client) => Arc::new(client),
-+        Err(e) => return Err(std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))
-+    };
-+
-+    let content_api = Arc::new(ContentAPI::new(github_client.clone()));
-+    drop(settings_read);
- 
-     // Initialize app state
--    let mut app_state = AppState::new();
--    
--    // Initialize Nostr service
--    nostr_auth_handler::init_nostr_service(&mut app_state);
-+    let app_state = web::Data::new(AppState::new(
-+        settings.clone(),
-+        github_client.clone(),
-+        content_api.clone(),
-+        None,
-+        None,
-+        gpu_compute,
-+        "default_conversation".to_string(),
-+    ));
-+
-+    // Initialize local storage and fetch initial data
-+    info!("Initializing local storage and fetching initial data");
-+    if let Err(e) = FileService::initialize_local_storage(settings.clone()).await {
-+        error!("Failed to initialize local storage: {}", e);
-+        return Err(std::io::Error::new(std::io::ErrorKind::Other, e.to_string()));
-+    }
-+
-+    // Load metadata and build initial graph
-+    info!("Building initial graph from metadata");
-+    let metadata_store = FileService::load_or_create_metadata()
-+        .map_err(|e| {
-+            error!("Failed to load metadata: {}", e);
-+            std::io::Error::new(std::io::ErrorKind::Other, e.to_string())
-+        })?;
-+
-+    info!("Loaded {} items from metadata store", metadata_store.len());
- 
--    // Create app state data
--    let app_state = web::Data::new(app_state);
--    let auth = web::Data::new(auth);
-+    // Update metadata in app state
-+    {
-+        let mut app_metadata = app_state.metadata.write().await;
-+        *app_metadata = metadata_store.clone();
-+        info!("Loaded metadata into app state");
-+    }
-+
-+    // Build initial graph from metadata
-+    match GraphService::build_graph_from_metadata(&metadata_store).await {
-+        Ok(graph_data) => {
-+            let mut graph = app_state.graph_service.graph_data.write().await;
-+            *graph = graph_data;
-+            info!("Built initial graph from metadata");
-+        },
-+        Err(e) => {
-+            error!("Failed to build initial graph: {}", e);
-+            return Err(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to build initial graph: {}", e)));
-+        }
-+    }
-+
-+    // Start the server
-+    let bind_address = {
-+        let settings_read = settings.read().await;
-+        format!("{}:{}", (*settings_read).system.network.bind_address, (*settings_read).system.network.port)
-+    };
-+
-+    info!("Starting HTTP server on {}", bind_address);
- 
-     HttpServer::new(move || {
-+        // Configure CORS
-         let cors = Cors::default()
-             .allow_any_origin()
-             .allow_any_method()
-             .allow_any_header()
--            .max_age(3600);
-+            .max_age(3600)
-+            .supports_credentials();
- 
-         App::new()
-             .wrap(middleware::Logger::default())
-             .wrap(cors)
-+            .wrap(middleware::Compress::default())
-+            .app_data(settings_data.clone())
-             .app_data(app_state.clone())
--            .app_data(auth.clone())
--            // Register handlers
-+            .app_data(web::Data::new(github_client.clone()))
-+            .app_data(web::Data::new(content_api.clone()))
-+            .route("/wss", web::get().to(socket_flow_handler))
-             .service(
--                web::scope("/api")
--                    .configure(handlers::auth_handler::config)
--                    .configure(nostr_auth_handler::config)
--                    .configure(handlers::settings_handler::config)
--                    // Add other handlers here
-+                web::scope("")
-+                    .configure(api_handler::config)
-+                    .service(web::scope("/health").configure(health_handler::config))
-+                    .service(web::scope("/pages").configure(pages_handler::config))
-             )
-+            .service(Files::new("/", "/app/client").index_file("index.html"))
-     })
--    .bind(("0.0.0.0", config.server.port))?
-+    .bind(&bind_address)?
-     .run()
--    .await
-+    .await?;
-+
-+    info!("HTTP server stopped");
-+    Ok(())
- }
-diff --git a/src/middleware/auth.rs b/src/middleware/auth.rs
-deleted file mode 100644
-index b5d47e8f..00000000
---- a/src/middleware/auth.rs
-+++ /dev/null
-@@ -1,104 +0,0 @@
--use crate::app_state::AppState;
--use crate::models::protected_settings::UserMode;
--use actix_web::dev::{Service, ServiceRequest, ServiceResponse, Transform};
--use actix_web::Error;
--use actix_web::error::ErrorUnauthorized;
--use futures::future::{ok, Ready};
--use futures::Future;
--use std::pin::Pin;
--use std::task::{Context, Poll};
--
--pub struct Auth;
--
--impl Auth {
--    pub fn new() -> Self {
--        Auth
--    }
--}
--
--impl<S, B> Transform<S, ServiceRequest> for Auth
--where
--    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error>,
--    S::Future: 'static,
--    B: 'static,
--{
--    type Response = ServiceResponse<B>;
--    type Error = Error;
--    type InitError = ();
--    type Transform = AuthMiddleware<S>;
--    type Future = Ready<Result<Self::Transform, Self::InitError>>;
--
--    fn new_transform(&self, service: S) -> Self::Future {
--        ok(AuthMiddleware { service })
--    }
--}
--
--pub struct AuthMiddleware<S> {
--    service: S,
--}
--
--impl<S, B> Service<ServiceRequest> for AuthMiddleware<S>
--where
--    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error>,
--    S::Future: 'static,
--    B: 'static,
--{
--    type Response = ServiceResponse<B>;
--    type Error = Error;
--    type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>>>>;
--
--    fn poll_ready(&self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
--        self.service.poll_ready(cx)
--    }
--
--    fn call(&self, req: ServiceRequest) -> Self::Future {
--        let app_state = req.app_data::<actix_web::web::Data<AppState>>().cloned();
--        
--        // Skip auth for non-protected routes
--        if !req.path().starts_with("/api/protected") {
--            let fut = self.service.call(req);
--            return Box::pin(async move {
--                let res = fut.await?;
--                Ok(res)
--            });
--        }
--
--        let client_id = req.headers().get("X-Client-ID").and_then(|h| h.to_str().ok());
--        let token = req
--            .headers()
--            .get("Authorization")
--            .and_then(|h| h.to_str().ok())
--            .and_then(|s| s.strip_prefix("Bearer "));
--
--        if client_id.is_none() || token.is_none() {
--            return Box::pin(async move {
--                Err(ErrorUnauthorized("Missing authentication credentials"))
--            });
--        }
--
--        let client_id = client_id.unwrap();
--        let token = token.unwrap();
--
--        let fut = self.service.call(req);
--        
--        Box::pin(async move {
--            if let Some(state) = app_state {
--                let protected_settings = state.protected_settings.read().await;
--                
--                if let Some(mode) = protected_settings.validate_client_token(client_id, token) {
--                    // For power-user-only routes, check if user is in power mode
--                    if req.path().starts_with("/api/protected/power") && mode != UserMode::Power {
--                        return Err(ErrorUnauthorized("Power user access required"));
--                    }
--                    
--                    let res = fut.await?;
--                    Ok(res)
--                } else {
--                    Err(ErrorUnauthorized("Invalid or expired token"))
--                }
--            } else {
--                Err(ErrorUnauthorized("Server configuration error"))
--            }
--        })
--    }
--}
-\ No newline at end of file
-diff --git a/src/middleware/mod.rs b/src/middleware/mod.rs
-deleted file mode 100644
-index f7a092a1..00000000
---- a/src/middleware/mod.rs
-+++ /dev/null
-@@ -1,3 +0,0 @@
--pub mod auth;
--
--pub use auth::AuthMiddleware;
-\ No newline at end of file
-diff --git a/src/models/mod.rs b/src/models/mod.rs
-index bd14d6bc..051dfe70 100755
---- a/src/models/mod.rs
-+++ b/src/models/mod.rs
-@@ -6,3 +6,11 @@ pub mod pagination;
- pub mod position_update;
- pub mod protected_settings;
- pub mod simulation_params;
-+pub mod ui_settings;
-+
-+pub use metadata::MetadataStore;
-+pub use pagination::PaginationParams;
-+pub use position_update::PositionUpdate;
-+pub use protected_settings::ProtectedSettings;
-+pub use simulation_params::SimulationParams;
-+pub use ui_settings::UISettings;
-diff --git a/src/models/protected_settings.rs b/src/models/protected_settings.rs
-index dafa8fcf..7ea3ebae 100644
---- a/src/models/protected_settings.rs
-+++ b/src/models/protected_settings.rs
-@@ -1,102 +1,119 @@
- use serde::{Deserialize, Serialize};
--use std::collections::HashMap;
- 
--#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
--pub enum UserMode {
--    Normal,
--    Power,
-+#[derive(Debug, Clone, Serialize, Deserialize)]
-+pub struct ProtectedSettings {
-+    pub network: NetworkSettings,
-+    pub security: SecuritySettings,
-+    pub websocket_server: WebSocketServerSettings,
- }
- 
- #[derive(Debug, Clone, Serialize, Deserialize)]
--pub struct ApiKeys {
--    pub perplexity: Option<String>,
--    pub openai: Option<String>,
-+pub struct NetworkSettings {
-+    pub bind_address: String,
-+    pub domain: String,
-+    pub port: u16,
-+    pub enable_http2: bool,
-+    pub enable_tls: bool,
-+    pub min_tls_version: String,
-+    pub max_request_size: usize,
-+    pub enable_rate_limiting: bool,
-+    pub rate_limit_requests: u32,
-+    pub rate_limit_window: u32,
-+    pub tunnel_id: String,
- }
- 
- #[derive(Debug, Clone, Serialize, Deserialize)]
--pub struct UserSettings {
--    pub mode: UserMode,
--    pub api_keys: ApiKeys,
--    pub last_active: i64,
-+pub struct SecuritySettings {
-+    pub allowed_origins: Vec<String>,
-+    pub audit_log_path: String,
-+    pub cookie_httponly: bool,
-+    pub cookie_samesite: String,
-+    pub cookie_secure: bool,
-+    pub csrf_token_timeout: u32,
-+    pub enable_audit_logging: bool,
-+    pub enable_request_validation: bool,
-+    pub session_timeout: u32,
- }
- 
- #[derive(Debug, Clone, Serialize, Deserialize)]
--pub struct ProtectedSettings {
--    pub users: HashMap<String, UserSettings>,
--    pub default_api_keys: ApiKeys,
-+pub struct WebSocketServerSettings {
-+    pub max_connections: usize,
-+    pub max_message_size: usize,
-+    pub url: String,
- }
- 
- impl Default for ProtectedSettings {
-     fn default() -> Self {
-         Self {
--            users: HashMap::new(),
--            default_api_keys: ApiKeys {
--                perplexity: None,
--                openai: None,
-+            network: NetworkSettings {
-+                bind_address: "127.0.0.1".to_string(),
-+                domain: "localhost".to_string(),
-+                port: 3000,
-+                enable_http2: true,
-+                enable_tls: false,
-+                min_tls_version: "TLS1.2".to_string(),
-+                max_request_size: 10 * 1024 * 1024, // 10MB
-+                enable_rate_limiting: true,
-+                rate_limit_requests: 100,
-+                rate_limit_window: 60,
-+                tunnel_id: String::new(),
-+            },
-+            security: SecuritySettings {
-+                allowed_origins: vec!["http://localhost:3000".to_string()],
-+                audit_log_path: "./audit.log".to_string(),
-+                cookie_httponly: true,
-+                cookie_samesite: "Lax".to_string(),
-+                cookie_secure: false,
-+                csrf_token_timeout: 3600,
-+                enable_audit_logging: true,
-+                enable_request_validation: true,
-+                session_timeout: 86400,
-+            },
-+            websocket_server: WebSocketServerSettings {
-+                max_connections: 100,
-+                max_message_size: 32 * 1024 * 1024, // 32MB
-+                url: String::new(),
-             },
-         }
-     }
- }
- 
- impl ProtectedSettings {
--    pub fn from_env() -> Self {
--        Self {
--            users: HashMap::new(),
--            default_api_keys: ApiKeys {
--                perplexity: std::env::var("PERPLEXITY_API_KEY").ok(),
--                openai: std::env::var("OPENAI_API_KEY").ok(),
--            },
-+    pub fn merge(&mut self, other: serde_json::Value) -> Result<(), String> {
-+        if let Some(network) = other.get("network") {
-+            if let Ok(network_settings) = serde_json::from_value(network.clone()) {
-+                self.network = network_settings;
-+            }
-         }
--    }
- 
--    pub fn get_user_settings(&self, pubkey: &str) -> Option<&UserSettings> {
--        self.users.get(pubkey)
--    }
--
--    pub fn get_active_keys(&self, pubkey: &str) -> ApiKeys {
--        if let Some(user_settings) = self.users.get(pubkey) {
--            match user_settings.mode {
--                UserMode::Power => ApiKeys {
--                    perplexity: std::env::var("PERPLEXITY_API_KEY").ok(),
--                    openai: std::env::var("OPENAI_API_KEY").ok(),
--                },
--                UserMode::Normal => user_settings.api_keys.clone(),
-+        if let Some(security) = other.get("security") {
-+            if let Ok(security_settings) = serde_json::from_value(security.clone()) {
-+                self.security = security_settings;
-             }
--        } else {
--            self.default_api_keys.clone()
-         }
--    }
--
--    pub fn update_user_settings(
--        &mut self,
--        pubkey: String,
--        mode: UserMode,
--        api_keys: Option<ApiKeys>,
--    ) -> UserSettings {
--        let now = chrono::Utc::now().timestamp();
--        let settings = self.users.entry(pubkey).or_insert(UserSettings {
--            mode: UserMode::Normal,
--            api_keys: ApiKeys {
--                perplexity: None,
--                openai: None,
--            },
--            last_active: now,
--        });
- 
--        settings.mode = mode;
--        if let Some(keys) = api_keys {
--            settings.api_keys = keys;
-+        if let Some(websocket) = other.get("websocketServer") {
-+            if let Ok(websocket_settings) = serde_json::from_value(websocket.clone()) {
-+                self.websocket_server = websocket_settings;
-+            }
-         }
--        settings.last_active = now;
- 
--        settings.clone()
-+        Ok(())
-+    }
-+
-+    pub fn load(path: &str) -> Result<Self, String> {
-+        let content = std::fs::read_to_string(path)
-+            .map_err(|e| format!("Failed to read protected settings: {}", e))?;
-+        
-+        serde_json::from_str(&content)
-+            .map_err(|e| format!("Failed to parse protected settings: {}", e))
-     }
- 
--    pub fn cleanup_inactive_users(&mut self, max_age_hours: i64) {
--        let now = chrono::Utc::now().timestamp();
--        let max_age_secs = max_age_hours * 3600;
--        self.users.retain(|_, settings| {
--            now - settings.last_active < max_age_secs
--        });
-+    pub fn save(&self, path: &str) -> Result<(), String> {
-+        let content = serde_json::to_string_pretty(self)
-+            .map_err(|e| format!("Failed to serialize protected settings: {}", e))?;
-+        
-+        std::fs::write(path, content)
-+            .map_err(|e| format!("Failed to write protected settings: {}", e))
-     }
- }
-\ No newline at end of file
-diff --git a/src/models/ui_settings.rs b/src/models/ui_settings.rs
-new file mode 100644
-index 00000000..79494e46
---- /dev/null
-+++ b/src/models/ui_settings.rs
-@@ -0,0 +1,63 @@
-+use serde::{Deserialize, Serialize};
-+use crate::config::{
-+    AnimationSettings, BloomSettings, DebugSettings, EdgeSettings,
-+    HologramSettings, LabelSettings, NodeSettings, PhysicsSettings,
-+    RenderingSettings, VisualizationSettings, XRSettings, Settings,
-+};
-+
-+#[derive(Debug, Clone, Serialize, Deserialize)]
-+pub struct UISettings {
-+    pub visualization: VisualizationSettings,
-+    pub system: UISystemSettings,
-+    pub xr: XRSettings,
-+}
-+
-+#[derive(Debug, Clone, Serialize, Deserialize)]
-+pub struct UISystemSettings {
-+    pub websocket: WebSocketClientSettings,
-+    pub debug: DebugSettings,
-+}
-+
-+#[derive(Debug, Clone, Serialize, Deserialize)]
-+pub struct WebSocketClientSettings {
-+    pub reconnect_attempts: u32,
-+    pub reconnect_delay: u64,
-+    pub binary_chunk_size: usize,
-+    pub compression_enabled: bool,
-+    pub compression_threshold: usize,
-+    pub update_rate: u32,
-+}
-+
-+impl From<&Settings> for UISettings {
-+    fn from(settings: &Settings) -> Self {
-+        Self {
-+            visualization: settings.visualization.clone(),
-+            system: UISystemSettings {
-+                websocket: WebSocketClientSettings {
-+                    reconnect_attempts: settings.system.websocket.reconnect_attempts,
-+                    reconnect_delay: settings.system.websocket.reconnect_delay,
-+                    binary_chunk_size: settings.system.websocket.binary_chunk_size,
-+                    compression_enabled: settings.system.websocket.compression_enabled,
-+                    compression_threshold: settings.system.websocket.compression_threshold,
-+                    update_rate: settings.system.websocket.update_rate,
-+                },
-+                debug: settings.system.debug.clone(),
-+            },
-+            xr: settings.xr.clone(),
-+        }
-+    }
-+}
-+
-+impl UISettings {
-+    pub fn merge_into_settings(&self, settings: &mut Settings) {
-+        settings.visualization = self.visualization.clone();
-+        settings.system.websocket.reconnect_attempts = self.system.websocket.reconnect_attempts;
-+        settings.system.websocket.reconnect_delay = self.system.websocket.reconnect_delay;
-+        settings.system.websocket.binary_chunk_size = self.system.websocket.binary_chunk_size;
-+        settings.system.websocket.compression_enabled = self.system.websocket.compression_enabled;
-+        settings.system.websocket.compression_threshold = self.system.websocket.compression_threshold;
-+        settings.system.websocket.update_rate = self.system.websocket.update_rate;
-+        settings.system.debug = self.system.debug.clone();
-+        settings.xr = self.xr.clone();
-+    }
-+}
-\ No newline at end of file
-diff --git a/src/services/graph_service.rs b/src/services/graph_service.rs
-index f2eda292..67a305fe 100755
---- a/src/services/graph_service.rs
-+++ b/src/services/graph_service.rs
-@@ -31,12 +31,12 @@ impl GraphService {
-         tokio::spawn(async move {
-             let params = SimulationParams {
-                 iterations: 1,  // One iteration per frame
--                spring_length: 100.0,  // Default spring length
--                spring_strength: 0.1,  // Gentler forces for continuous updates
--                repulsion: 50.0,  // Reduced repulsion
--                attraction: 0.5,  // Reduced attraction
--                damping: 0.8,  // More damping for stability
--                time_step: 0.016,  // 60fps
-+                spring_length: 50.0,  // Match ideal_length in CPU layout
-+                spring_strength: 0.05,  // Reduced for stability
-+                repulsion: 10.0,  // Significantly reduced repulsion
-+                attraction: 0.2,  // Reduced attraction
-+                damping: 0.95,  // Higher damping for more stability
-+                time_step: 0.1,  // Match dt in CPU layout
-                 phase: SimulationPhase::Dynamic,
-                 mode: SimulationMode::Local,  // Use CPU for continuous updates
-             };
-@@ -206,16 +206,26 @@ impl GraphService {
- 
-     fn initialize_random_positions(graph: &mut GraphData) {
-         let mut rng = rand::thread_rng();
--        let initial_radius = 30.0;
-+        let node_count = graph.nodes.len() as f32;
-+        let initial_radius = 100.0; // Larger initial radius
-+        let golden_ratio = (1.0 + 5.0_f32.sqrt()) / 2.0;
-         
--        for node in &mut graph.nodes {
--            let theta = rng.gen_range(0.0..std::f32::consts::PI * 2.0);
--            let phi = rng.gen_range(0.0..std::f32::consts::PI);
--            let r = rng.gen_range(0.0..initial_radius);
-+        // Use Fibonacci sphere distribution for more uniform initial positions
-+        for (i, node) in graph.nodes.iter_mut().enumerate() {
-+            let i = i as f32;
-             
--            node.set_x(r * theta.cos() * phi.sin());
--            node.set_y(r * theta.sin() * phi.sin());
-+            // Calculate Fibonacci sphere coordinates
-+            let theta = 2.0 * std::f32::consts::PI * i / golden_ratio;
-+            let phi = (1.0 - 2.0 * (i + 0.5) / node_count).acos();
-+            
-+            // Add slight randomness to prevent exact overlaps
-+            let r = initial_radius * (0.9 + rng.gen_range(0.0..0.2));
-+            
-+            node.set_x(r * phi.sin() * theta.cos());
-+            node.set_y(r * phi.sin() * theta.sin());
-             node.set_z(r * phi.cos());
-+            
-+            // Initialize with zero velocity
-             node.set_vx(0.0);
-             node.set_vy(0.0);
-             node.set_vz(0.0);
-@@ -262,7 +272,8 @@ impl GraphService {
-     }
- 
-     fn calculate_layout_cpu(graph: &mut GraphData, iterations: u32, spring_strength: f32, damping: f32) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
--        let repulsion_strength = spring_strength * 10000.0;
-+        let repulsion_strength = spring_strength * 1000.0; // Reduced repulsion strength
-+        let min_distance = 0.1; // Minimum distance to prevent division by zero
-         
-         for _ in 0..iterations {
-             // Calculate forces between nodes
-@@ -275,26 +286,31 @@ impl GraphService {
-                     let dy = graph.nodes[j].y() - graph.nodes[i].y();
-                     let dz = graph.nodes[j].z() - graph.nodes[i].z();
-                     
--                    let distance = (dx * dx + dy * dy + dz * dz).sqrt();
--                    if distance > 0.0 {
--                        let force = repulsion_strength / (distance * distance);
--                        
--                        let fx = dx * force / distance;
--                        let fy = dy * force / distance;
--                        let fz = dz * force / distance;
--                        
--                        forces[i].0 -= fx;
--                        forces[i].1 -= fy;
--                        forces[i].2 -= fz;
--                        
--                        forces[j].0 += fx;
--                        forces[j].1 += fy;
--                        forces[j].2 += fz;
--                    }
-+                    let distance_squared = dx * dx + dy * dy + dz * dz;
-+                    let distance = distance_squared.sqrt().max(min_distance);
-+                    
-+                    // Use inverse square law with clamped maximum force
-+                    let force = (repulsion_strength / distance_squared).min(100.0);
-+                    
-+                    // Normalize direction vector
-+                    let fx = (dx / distance) * force;
-+                    let fy = (dy / distance) * force;
-+                    let fz = (dz / distance) * force;
-+                    
-+                    forces[i].0 -= fx;
-+                    forces[i].1 -= fy;
-+                    forces[i].2 -= fz;
-+                    
-+                    forces[j].0 += fx;
-+                    forces[j].1 += fy;
-+                    forces[j].2 += fz;
-                 }
-             }
- 
-             // Calculate spring forces along edges
-+            let ideal_length = 50.0; // Ideal spring length
-+            let max_spring_force = 10.0; // Maximum spring force
-+            
-             for edge in &graph.edges {
-                 // Find indices of source and target nodes
-                 let source_idx = graph.nodes.iter().position(|n| n.id == edge.source);
-@@ -308,40 +324,62 @@ impl GraphService {
-                     let dy = target.y() - source.y();
-                     let dz = target.z() - source.z();
-                     
--                    let distance = (dx * dx + dy * dy + dz * dz).sqrt();
--                    if distance > 0.0 {
--                        // Scale force by edge weight
--                        let force = spring_strength * (distance - 30.0) * edge.weight;
--                        
--                        let fx = dx * force / distance;
--                        let fy = dy * force / distance;
--                        let fz = dz * force / distance;
--                        
--                        forces[si].0 += fx;
--                        forces[si].1 += fy;
--                        forces[si].2 += fz;
--                        
--                        forces[ti].0 -= fx;
--                        forces[ti].1 -= fy;
--                        forces[ti].2 -= fz;
--                    }
-+                    let distance_squared = dx * dx + dy * dy + dz * dz;
-+                    let distance = distance_squared.sqrt().max(0.1); // Prevent division by zero
-+                    
-+                    // Calculate spring force with ideal length and weight
-+                    let displacement = distance - ideal_length;
-+                    let force = (spring_strength * displacement * edge.weight)
-+                        .clamp(-max_spring_force, max_spring_force);
-+                    
-+                    // Normalize direction vector and apply force
-+                    let fx = (dx / distance) * force;
-+                    let fy = (dy / distance) * force;
-+                    let fz = (dz / distance) * force;
-+                    
-+                    forces[si].0 += fx;
-+                    forces[si].1 += fy;
-+                    forces[si].2 += fz;
-+                    
-+                    forces[ti].0 -= fx;
-+                    forces[ti].1 -= fy;
-+                    forces[ti].2 -= fz;
-                 }
-             }
-             
--            // Apply forces and update positions
-+            // Apply forces and update positions with stability constraints
-+            let max_velocity = 5.0; // Maximum allowed velocity
-+            let dt = 0.1; // Time step for integration
-+            
-             for (i, node) in graph.nodes.iter_mut().enumerate() {
--                let vx = node.vx() + forces[i].0;
--                let vy = node.vy() + forces[i].1;
--                let vz = node.vz() + forces[i].2;
-+                // Update velocity with damping and clamping
-+                let mut vx = node.vx() + forces[i].0 * dt;
-+                let mut vy = node.vy() + forces[i].1 * dt;
-+                let mut vz = node.vz() + forces[i].2 * dt;
-                 
--                let x = node.x() + vx;
--                let y = node.y() + vy;
--                let z = node.z() + vz;
-+                // Apply damping
-+                vx *= damping;
-+                vy *= damping;
-+                vz *= damping;
-+                
-+                // Clamp velocity magnitude
-+                let v_mag = (vx * vx + vy * vy + vz * vz).sqrt();
-+                if v_mag > max_velocity {
-+                    let scale = max_velocity / v_mag;
-+                    vx *= scale;
-+                    vy *= scale;
-+                    vz *= scale;
-+                }
-                 
--                node.set_vx(vx * damping);
--                node.set_vy(vy * damping);
--                node.set_vz(vz * damping);
-+                // Update position using clamped velocity
-+                let x = node.x() + vx * dt;
-+                let y = node.y() + vy * dt;
-+                let z = node.z() + vz * dt;
-                 
-+                // Store updated values
-+                node.set_vx(vx);
-+                node.set_vy(vy);
-+                node.set_vz(vz);
-                 node.set_x(x);
-                 node.set_y(y);
-                 node.set_z(z);
-diff --git a/src/services/mod.rs b/src/services/mod.rs
-index 8c94d99f..657be730 100755
---- a/src/services/mod.rs
-+++ b/src/services/mod.rs
-@@ -1,21 +1,6 @@
-+pub mod github;
- pub mod file_service;
- pub mod graph_service;
- pub mod perplexity_service;
- pub mod ragflow_service;
- pub mod speech_service;
--pub mod nostr_service;
--
--pub mod github {
--    pub mod api;
--    pub mod content;
--    pub mod pr;
--    pub mod types;
--}
--
--// Re-export commonly used services
--pub use file_service::FileService;
--pub use graph_service::GraphService;
--pub use nostr_service::NostrService;
--pub use perplexity_service::PerplexityService;
--pub use ragflow_service::RagflowService;
--pub use speech_service::SpeechService;
-diff --git a/src/services/nostr_service.rs b/src/services/nostr_service.rs
-deleted file mode 100644
-index b338186c..00000000
---- a/src/services/nostr_service.rs
-+++ /dev/null
-@@ -1,180 +0,0 @@
--use crate::models::protected_settings::UserMode;
--use chrono::{DateTime, Utc};
--use nostr::prelude::*;
--use serde::{Deserialize, Serialize};
--use std::collections::HashMap;
--use std::sync::Arc;
--use thiserror::Error;
--use tokio::sync::RwLock;
--use uuid::Uuid;
--
--#[derive(Debug, Error)]
--pub enum NostrError {
--    #[error("Invalid event: {0}")]
--    InvalidEvent(String),
--    #[error("Invalid signature")]
--    InvalidSignature,
--    #[error("User not found")]
--    UserNotFound,
--    #[error("Nostr error: {0}")]
--    NostrError(#[from] nostr::Error),
--}
--
--#[derive(Debug, Clone, Serialize, Deserialize)]
--pub struct NostrUser {
--    pub pubkey: String,
--    pub npub: String,
--    pub mode: UserMode,
--    pub created_at: DateTime<Utc>,
--    pub last_seen: DateTime<Utc>,
--    pub session_token: Option<String>,
--}
--
--#[derive(Debug, Clone, Serialize, Deserialize)]
--pub struct AuthEvent {
--    pub id: String,
--    pub pubkey: String,
--    pub content: String,
--    pub sig: String,
--    pub created_at: i64,
--    pub kind: i32,
--    pub tags: Vec<Vec<String>>,
--}
--
--impl TryFrom<AuthEvent> for Event {
--    type Error = NostrError;
--
--    fn try_from(auth: AuthEvent) -> Result<Self, Self::Error> {
--        let pubkey = XOnlyPublicKey::from_str(&auth.pubkey)
--            .map_err(|e| NostrError::InvalidEvent(e.to_string()))?;
--        
--        let tags = auth.tags
--            .iter()
--            .map(|t| Tag::parse(t))
--            .collect::<Result<Vec<Tag>, _>>()
--            .map_err(|e| NostrError::InvalidEvent(e.to_string()))?;
--
--        Ok(Event {
--            id: EventId::from_str(&auth.id)
--                .map_err(|e| NostrError::InvalidEvent(e.to_string()))?,
--            pubkey,
--            created_at: Timestamp::from(auth.created_at as u64),
--            kind: Kind::from(auth.kind),
--            tags,
--            content: auth.content,
--            sig: Signature::from_str(&auth.sig)
--                .map_err(|e| NostrError::InvalidEvent(e.to_string()))?,
--        })
--    }
--}
--
--#[derive(Clone)]
--pub struct NostrService {
--    users: Arc<RwLock<HashMap<String, NostrUser>>>,
--    keys: Arc<Keys>,
--}
--
--impl NostrService {
--    pub fn new() -> Self {
--        let secret_key = SecretKey::generate();
--        let keys = Keys::new(secret_key);
--        
--        Self {
--            users: Arc::new(RwLock::new(HashMap::new())),
--            keys: Arc::new(keys),
--        }
--    }
--
--    pub async fn verify_auth_event(&self, event: AuthEvent) -> Result<NostrUser, NostrError> {
--        // Convert to Nostr Event
--        let nostr_event: Event = event.try_into()?;
--
--        // Verify the event
--        if !nostr_event.verify() {
--            return Err(NostrError::InvalidSignature);
--        }
--
--        let now = Utc::now();
--        let user = NostrUser {
--            pubkey: nostr_event.pubkey.to_string(),
--            npub: nostr_event.pubkey.to_bech32()
--                .map_err(|e| NostrError::InvalidEvent(e.to_string()))?,
--            mode: UserMode::Normal, // Default to normal mode
--            created_at: now,
--            last_seen: now,
--            session_token: Some(Uuid::new_v4().to_string()),
--        };
--
--        // Store or update user
--        let mut users = self.users.write().await;
--        users.insert(user.pubkey.clone(), user.clone());
--
--        Ok(user)
--    }
--
--    pub async fn get_user(&self, pubkey: &str) -> Option<NostrUser> {
--        let users = self.users.read().await;
--        users.get(pubkey).cloned()
--    }
--
--    pub async fn update_user_mode(&self, pubkey: &str, mode: UserMode) -> Result<NostrUser, NostrError> {
--        let mut users = self.users.write().await;
--        
--        if let Some(user) = users.get_mut(pubkey) {
--            user.mode = mode;
--            user.last_seen = Utc::now();
--            Ok(user.clone())
--        } else {
--            Err(NostrError::UserNotFound)
--        }
--    }
--
--    pub async fn validate_session(&self, pubkey: &str, token: &str) -> bool {
--        if let Some(user) = self.get_user(pubkey).await {
--            if let Some(session_token) = user.session_token {
--                return session_token == token;
--            }
--        }
--        false
--    }
--
--    pub async fn refresh_session(&self, pubkey: &str) -> Result<String, NostrError> {
--        let mut users = self.users.write().await;
--        
--        if let Some(user) = users.get_mut(pubkey) {
--            let new_token = Uuid::new_v4().to_string();
--            user.session_token = Some(new_token.clone());
--            user.last_seen = Utc::now();
--            Ok(new_token)
--        } else {
--            Err(NostrError::UserNotFound)
--        }
--    }
--
--    pub async fn logout(&self, pubkey: &str) -> Result<(), NostrError> {
--        let mut users = self.users.write().await;
--        
--        if let Some(user) = users.get_mut(pubkey) {
--            user.session_token = None;
--            user.last_seen = Utc::now();
--            Ok(())
--        } else {
--            Err(NostrError::UserNotFound)
--        }
--    }
--
--    pub async fn cleanup_sessions(&self, max_age_hours: i64) {
--        let now = Utc::now();
--        let mut users = self.users.write().await;
--        
--        users.retain(|_, user| {
--            now.signed_duration_since(user.last_seen).num_hours() < max_age_hours
--        });
--    }
--}
--
--impl Default for NostrService {
--    fn default() -> Self {
--        Self::new()
--    }
--}
-\ No newline at end of file
-diff --git a/src/utils/gpu_compute.rs b/src/utils/gpu_compute.rs
-index 847cc71c..dc067cc2 100755
---- a/src/utils/gpu_compute.rs
-+++ b/src/utils/gpu_compute.rs
-@@ -1,26 +1,50 @@
-+#[cfg(feature = "gpu")]
- use cudarc::driver::{CudaDevice, CudaFunction, CudaSlice, LaunchConfig, LaunchAsync};
-+#[cfg(feature = "gpu")]
- use cudarc::nvrtc::Ptx;
-+
- use std::io::Error;
- use std::sync::Arc;
--use log::debug;
-+use log::{debug, warn};
- use crate::models::graph::GraphData;
- use crate::models::simulation_params::SimulationParams;
- use crate::utils::socket_flow_messages::NodeData;
- use tokio::sync::RwLock;
- 
-+// Constants for GPU computation
-+#[cfg(feature = "gpu")]
- const BLOCK_SIZE: u32 = 256;
-+#[cfg(feature = "gpu")]
- const MAX_NODES: u32 = 1_000_000;
--const NODE_SIZE: u32 = 28; // 12 bytes position + 12 bytes velocity + 4 bytes mass/flags/padding
-+#[cfg(feature = "gpu")]
-+const NODE_SIZE: u32 = std::mem::size_of::<NodeData>() as u32;
-+#[cfg(feature = "gpu")]
- const SHARED_MEM_SIZE: u32 = BLOCK_SIZE * NODE_SIZE;
- 
-+// CPU-only version
-+#[cfg(not(feature = "gpu"))]
-+#[derive(Debug)]
-+pub struct GPUCompute;
-+
-+#[cfg(not(feature = "gpu"))]
-+impl GPUCompute {
-+    pub async fn new(_graph: &GraphData) -> Result<Arc<RwLock<Self>>, Error> {
-+        Err(Error::new(std::io::ErrorKind::Unsupported, "GPU support is not enabled"))
-+    }
-+}
-+
-+// GPU-enabled version
-+#[cfg(feature = "gpu")]
-+#[derive(Debug)]
- pub struct GPUCompute {
--    device: Arc<CudaDevice>,
--    force_kernel: CudaFunction,
--    node_data: CudaSlice<NodeData>,
--    num_nodes: u32,
--    simulation_params: SimulationParams,
-+    pub device: Arc<CudaDevice>,
-+    pub force_kernel: CudaFunction,
-+    pub node_data: CudaSlice<NodeData>,
-+    pub num_nodes: u32,
-+    pub simulation_params: SimulationParams,
- }
- 
-+#[cfg(feature = "gpu")]
- impl GPUCompute {
-     pub async fn new(graph: &GraphData) -> Result<Arc<RwLock<Self>>, Error> {
-         let num_nodes = graph.nodes.len() as u32;
-@@ -86,6 +110,13 @@ impl GPUCompute {
-     }
- 
-     pub fn step(&mut self) -> Result<(), Error> {
-+        // Debug initial node data
-+        let initial_nodes = self.get_node_data()?;
-+        debug!("Initial node data before GPU step:");
-+        for (i, node) in initial_nodes.iter().take(5).enumerate() {
-+            debug!("Node {}: pos={:?}, vel={:?}", i, node.position, node.velocity);
-+        }
-+
-         let blocks = (self.num_nodes + BLOCK_SIZE - 1) / BLOCK_SIZE;
-         let cfg = LaunchConfig {
-             grid_dim: (blocks, 1, 1),
-@@ -93,7 +124,12 @@ impl GPUCompute {
-             shared_mem_bytes: SHARED_MEM_SIZE,
-         };
- 
--        let params = &self.simulation_params;
-+        // Adjust simulation parameters for stability
-+        let mut params = self.simulation_params.clone();
-+        params.spring_strength *= 0.1; // Reduce force strength
-+        params.repulsion *= 0.1;      // Reduce repulsion force
-+        params.damping = params.damping.max(0.95); // Increase damping for stability
-+
-         unsafe {
-             self.force_kernel.clone().launch(cfg, (
-                 &mut self.node_data,
-@@ -103,6 +139,37 @@ impl GPUCompute {
-                 params.damping,
-             )).map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))?;
-         }
-+        
-+        // Sanity-check: retrieve updated node data and correct any NaN values
-+        let mut updated_nodes = self.get_node_data()?;
-+        let mut needs_fix = false;
-+        for node in &mut updated_nodes {
-+            for v in &mut node.position {
-+                if v.is_nan() {
-+                    *v = 0.0;
-+                    needs_fix = true;
-+                }
-+            }
-+            for v in &mut node.velocity {
-+                if v.is_nan() {
-+                    *v = 0.0;
-+                    needs_fix = true;
-+                }
-+            }
-+        }
-+        if needs_fix {
-+            // Log the correction
-+            warn!("GPUCompute: Detected NaN in node data. Correcting values to 0.");
-+            self.device.htod_sync_copy_into(&updated_nodes, &mut self.node_data)
-+                .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))?;
-+        }
-+        
-+        // Debug: log a sample of node positions after update
-+        debug!("Sample node positions after update:");
-+        for (i, node) in updated_nodes.iter().take(5).enumerate() {
-+            debug!("Node {}: pos={:?}, vel={:?}", i, node.position, node.velocity);
-+        }
-+        
-         Ok(())
-     }
- 
-@@ -118,7 +185,6 @@ impl GPUCompute {
-         self.device.dtoh_sync_copy_into(&self.node_data, &mut gpu_nodes)
-             .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?;
- 
--        // Return node data directly
-         Ok(gpu_nodes)
-     }
- }
-@@ -126,19 +192,21 @@ impl GPUCompute {
- #[cfg(test)]
- mod tests {
-     use super::*;
--    use crate::models::graph::GraphData;
- 
-     #[tokio::test]
-     async fn test_gpu_compute_initialization() {
-         let graph = GraphData::default();
-         let gpu_compute = GPUCompute::new(&graph).await;
-+        #[cfg(feature = "gpu")]
-         assert!(gpu_compute.is_ok());
-+        #[cfg(not(feature = "gpu"))]
-+        assert!(gpu_compute.is_err());
-     }
- 
-+    #[cfg(feature = "gpu")]
-     #[tokio::test]
-     async fn test_node_data_transfer() {
-         let mut graph = GraphData::default();
--        // Add test nodes...
-         let gpu_compute = GPUCompute::new(&graph).await.unwrap();
-         let gpu_compute = Arc::try_unwrap(gpu_compute).unwrap().into_inner();
-         let node_data = gpu_compute.get_node_data().unwrap();
-diff --git a/vite.config.ts b/vite.config.ts
-index 5657de8f..c680fdaa 100644
---- a/vite.config.ts
-+++ b/vite.config.ts
-@@ -14,14 +14,7 @@ export default defineConfig(({ mode, command }) => {
-       outDir: resolve(__dirname, 'data/public/dist'),
-       emptyOutDir: true,
-       sourcemap: !isProd,
--      minify: isProd ? 'esbuild' : false,
--      target: 'esnext',
--      assetsInlineLimit: 4096,
--      cssMinify: isProd,
--      cssCodeSplit: true,
--      modulePreload: {
--        polyfill: true
--      },
-+      minify: false,
-       rollupOptions: {
-         input: {
-           main: resolve(__dirname, 'client/index.html')
-@@ -69,24 +62,7 @@ export default defineConfig(({ mode, command }) => {
-     },
- 
-     optimizeDeps: {
--      include: ['three'],
--      esbuildOptions: {
--        target: 'esnext',
--        supported: {
--          'top-level-await': true
--        },
--        treeShaking: true
--      }
--    },
--
--    esbuild: {
--      target: 'esnext',
--      drop: isProd ? ['console', 'debugger'] : [],
--      pure: isProd ? ['console.log', 'console.debug', 'console.trace'] : [],
--      treeShaking: true,
--      minifyWhitespace: isProd,
--      minifyIdentifiers: isProd,
--      minifySyntax: isProd
-+      include: ['three']
-     },
- 
-     define: {
diff --git a/settings.yaml b/settings.yaml
index ed511ff1..8fa3a43b 100644
--- a/settings.yaml
+++ b/settings.yaml
@@ -91,17 +91,23 @@ visualization:
 # System settings
 system:
   network:
-    bind_address: "127.0.0.1"
+    bind_address: "0.0.0.0"
     domain: "localhost"
-    port: 3000
-    enable_http2: true
+    enable_http2: false
+    enable_rate_limiting: true
     enable_tls: false
-    min_tls_version: "TLS1.2"
     max_request_size: 10485760
-    enable_rate_limiting: true
+    min_tls_version: ""
+    port: 3001
     rate_limit_requests: 100
     rate_limit_window: 60
-    tunnel_id: ""
+    tunnel_id: "dummy"
+    api_client_timeout: 30
+    enable_metrics: true
+    max_concurrent_requests: 5
+    max_retries: 3
+    metrics_port: 9090
+    retry_delay: 5
 
   websocket:
     binary_chunk_size: 1024
@@ -109,7 +115,7 @@ system:
     binary_message_version: 1
     compression_enabled: true
     compression_threshold: 1024
-    heartbeat_interval: 30000
+    heartbeat_interval: 15000
     heartbeat_timeout: 60000
     max_connections: 1000
     max_message_size: 100485760
@@ -117,13 +123,25 @@ system:
     reconnect_delay: 5000
     update_rate: 60
 
+  security:
+    allowed_origins: []
+    audit_log_path: "/app/logs/audit.log"
+    cookie_httponly: true
+    cookie_samesite: "Strict"
+    cookie_secure: true
+    csrf_token_timeout: 3600
+    enable_audit_logging: true
+    enable_request_validation: true
+    session_timeout: 3600
+
   debug:
     enabled: false
+    log_level: "warn"
+    log_format: "json"
     enable_data_debug: false
     enable_websocket_debug: false
     log_binary_headers: false
     log_full_json: false
-    log_level: "info"
 
 # XR settings
 xr:
@@ -161,47 +179,45 @@ xr:
   show_plane_overlay: true
   snap_to_floor: true
 
-# Nostr authentication settings
-nostr:
-  enabled: true
-  power_user_pubkeys: []  # List of power user pubkeys
-  token_expiry: 3600      # 1 hour in seconds
-  token_secret: ""        # Set in environment
-  min_relay_count: 2
-  challenge_timeout: 300  # 5 minutes in seconds
+  # Passthrough settings
+  enable_passthrough_portal: false
+  passthrough_opacity: 1.0
+  passthrough_brightness: 1.0
+  passthrough_contrast: 1.0
+  portal_size: 2.0
+  portal_edge_color: "#ffffff"
+  portal_edge_width: 2.0
 
-# GitHub settings
+# External service settings
 github:
+  rate_limit: true
+  version: "v3"
   token: ""
   owner: ""
-  repo: ""
-  path: "/pages"
-  version: ""
-  rate_limit: 5000
+  repo: "logseq"
+  base_path: ""  # Loaded from GITHUB_BASE_PATH environment variable
 
-# RAGFlow settings
 ragflow:
   api_key: ""
-  api_base_url: "http://ragflow-server/v1/"
+  api_base_url: ""
   timeout: 30
   max_retries: 3
+  chat_id: ""
 
-# Perplexity settings
 perplexity:
   api_key: ""
   model: "llama-3.1-sonar-small-128k-online"
-  api_url: "https://api.perplexity.ai/chat/completions"
+  api_url: ""
   max_tokens: 4096
   temperature: 0.5
   top_p: 0.9
   presence_penalty: 0.0
-  frequency_penalty: 1.0
+  frequency_penalty: 0.0
   timeout: 30
   rate_limit: 100
 
-# OpenAI settings
 openai:
   api_key: ""
-  base_url: "wss://api.openai.com/v1/realtime"
+  base_url: ""
   timeout: 30
   rate_limit: 100
\ No newline at end of file
diff --git a/src/app_state.rs b/src/app_state.rs
index f0d4ca01..ec09d64f 100755
--- a/src/app_state.rs
+++ b/src/app_state.rs
@@ -1,7 +1,5 @@
 use std::sync::{Arc, atomic::{AtomicUsize, Ordering}};
 use tokio::sync::RwLock;
-use std::collections::HashMap;
-use chrono::{DateTime, Utc};
 
 use crate::config::Settings;
 use crate::models::metadata::MetadataStore;
@@ -11,18 +9,9 @@ use crate::services::perplexity_service::PerplexityService;
 use crate::services::ragflow_service::RAGFlowService;
 use crate::utils::gpu_compute::GPUCompute;
 
-// Nostr user session data
-#[derive(Clone, Debug)]
-pub struct NostrSession {
-    pub pubkey: String,
-    pub npub: String,
-    pub is_power_user: bool,
-    pub last_seen: DateTime<Utc>,
-}
-
 #[derive(Clone)]
 pub struct AppState {
-    pub graph_service: Arc<GraphService>,
+    pub graph_service: GraphService,
     pub gpu_compute: Option<Arc<RwLock<GPUCompute>>>,
     pub settings: Arc<RwLock<Settings>>,
     pub metadata: Arc<RwLock<MetadataStore>>,
@@ -32,8 +21,6 @@ pub struct AppState {
     pub ragflow_service: Option<Arc<RAGFlowService>>,
     pub ragflow_conversation_id: String,
     pub active_connections: Arc<AtomicUsize>,
-    // Nostr sessions
-    pub nostr_sessions: Arc<RwLock<HashMap<String, NostrSession>>>,
 }
 
 impl AppState {
@@ -47,7 +34,7 @@ impl AppState {
         ragflow_conversation_id: String,
     ) -> Self {
         Self {
-            graph_service: Arc::new(GraphService::new()),
+            graph_service: GraphService::new(),
             gpu_compute,
             settings,
             metadata: Arc::new(RwLock::new(MetadataStore::new())),
@@ -57,7 +44,6 @@ impl AppState {
             ragflow_service,
             ragflow_conversation_id,
             active_connections: Arc::new(AtomicUsize::new(0)),
-            nostr_sessions: Arc::new(RwLock::new(HashMap::new())),
         }
     }
 
@@ -68,40 +54,4 @@ impl AppState {
     pub fn decrement_connections(&self) -> usize {
         self.active_connections.fetch_sub(1, Ordering::SeqCst)
     }
-
-    // Nostr session management
-    pub async fn add_nostr_session(&self, pubkey: String, npub: String, is_power_user: bool) {
-        let mut sessions = self.nostr_sessions.write().await;
-        sessions.insert(pubkey.clone(), NostrSession {
-            pubkey,
-            npub,
-            is_power_user,
-            last_seen: Utc::now(),
-        });
-    }
-
-    pub async fn get_nostr_session(&self, pubkey: &str) -> Option<NostrSession> {
-        let sessions = self.nostr_sessions.read().await;
-        sessions.get(pubkey).cloned()
-    }
-
-    pub async fn update_nostr_session(&self, pubkey: &str) {
-        let mut sessions = self.nostr_sessions.write().await;
-        if let Some(session) = sessions.get_mut(pubkey) {
-            session.last_seen = Utc::now();
-        }
-    }
-
-    pub async fn remove_nostr_session(&self, pubkey: &str) {
-        let mut sessions = self.nostr_sessions.write().await;
-        sessions.remove(pubkey);
-    }
-
-    pub async fn cleanup_nostr_sessions(&self, max_age_hours: i64) {
-        let now = Utc::now();
-        let mut sessions = self.nostr_sessions.write().await;
-        sessions.retain(|_, session| {
-            now.signed_duration_since(session.last_seen).num_hours() < max_age_hours
-        });
-    }
 }
diff --git a/src/config.rs b/src/config.rs
index 75438a2f..7fb2d44c 100644
--- a/src/config.rs
+++ b/src/config.rs
@@ -1,111 +1,12 @@
-use config::{Config, ConfigError, Environment, File};
+use config::{ConfigBuilder, ConfigError, Environment};
+use log::{debug, info};
 use serde::{Deserialize, Serialize};
-use std::env;
+use serde_json::Value;
+use serde_yaml;
+use std::path::PathBuf;
 
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct Settings {
-    pub server: ServerConfig,
-    pub network: NetworkConfig,
-    pub github: GitHubConfig,
-    pub ragflow: RagFlowConfig,
-    pub perplexity: PerplexityConfig,
-    pub openai: OpenAIConfig,
-    pub nostr: NostrConfig,
-    pub system: SystemConfig,
-    pub visualization: VisualizationSettings,
-    pub xr: XRSettings,
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct ServerConfig {
-    pub bind_address: String,
-    pub debug_mode: bool,
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct NetworkConfig {
-    pub domain: String,
-    pub tunnel_token: Option<String>,
-    pub tunnel_id: Option<String>,
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct GitHubConfig {
-    pub token: String,
-    pub owner: String,
-    pub repo: String,
-    pub path: String,
-    pub version: Option<String>,
-    pub rate_limit: Option<u32>,
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct RagFlowConfig {
-    pub api_key: String,
-    pub api_base_url: String,
-    pub timeout: u64,
-    pub max_retries: u32,
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct PerplexityConfig {
-    pub api_key: String,
-    pub model: String,
-    pub api_url: String,
-    pub max_tokens: u32,
-    pub temperature: f32,
-    pub top_p: f32,
-    pub presence_penalty: f32,
-    pub frequency_penalty: f32,
-    pub timeout: u64,
-    pub rate_limit: u32,
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct OpenAIConfig {
-    pub api_key: String,
-    pub base_url: String,
-    pub timeout: u64,
-    pub rate_limit: u32,
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct NostrConfig {
-    pub enabled: bool,
-    pub power_user_pubkeys: Vec<String>,
-    pub token_expiry: u64,
-    pub token_secret: String,
-    pub min_relay_count: u32,
-    pub challenge_timeout: u64,
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct SystemConfig {
-    pub websocket: WebSocketConfig,
-    pub debug: DebugConfig,
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct WebSocketConfig {
-    pub reconnect_attempts: u32,
-    pub reconnect_delay: u64,
-    pub binary_chunk_size: usize,
-    pub compression_enabled: bool,
-    pub compression_threshold: usize,
-    pub update_rate: u32,
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct DebugConfig {
-    pub enabled: bool,
-    pub enable_data_debug: bool,
-    pub enable_websocket_debug: bool,
-    pub log_binary_headers: bool,
-    pub log_full_json: bool,
-    pub log_level: String,
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
+// Core visualization settings
+#[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct VisualizationSettings {
     pub nodes: NodeSettings,
     pub edges: EdgeSettings,
@@ -117,62 +18,81 @@ pub struct VisualizationSettings {
     pub hologram: HologramSettings,
 }
 
-#[derive(Debug, Clone, Serialize, Deserialize)]
+// System settings
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct SystemSettings {
+    pub network: NetworkSettings,
+    pub websocket: WebSocketSettings,
+    pub security: SecuritySettings,
+    pub debug: DebugSettings,
+}
+
+// Main settings struct
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct Settings {
+    pub visualization: VisualizationSettings,
+    pub system: SystemSettings,
+    pub xr: XRSettings,
+    pub github: GitHubSettings,
+    pub ragflow: RagFlowSettings,
+    pub perplexity: PerplexitySettings,
+    pub openai: OpenAISettings,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct NodeSettings {
-    pub quality: String,
-    pub enable_instancing: bool,
-    pub enable_metadata_shape: bool,
-    pub enable_metadata_visualization: bool,
-    pub base_size: f32,
-    pub size_range: [f32; 2],
     pub base_color: String,
-    pub opacity: f32,
-    pub color_range_age: [String; 2],
-    pub color_range_links: [String; 2],
+    pub base_size: f32,
     pub metalness: f32,
+    pub opacity: f32,
     pub roughness: f32,
+    pub size_range: Vec<f32>,
+    pub quality: String,
+    pub enable_instancing: bool,
     pub enable_hologram: bool,
+    pub enable_metadata_shape: bool,
+    pub enable_metadata_visualization: bool,
 }
 
-#[derive(Debug, Clone, Serialize, Deserialize)]
+#[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct EdgeSettings {
-    pub color: String,
-    pub opacity: f32,
     pub arrow_size: f32,
     pub base_width: f32,
+    pub color: String,
     pub enable_arrows: bool,
-    pub width_range: [f32; 2],
+    pub opacity: f32,
+    pub width_range: Vec<f32>,
 }
 
-#[derive(Debug, Clone, Serialize, Deserialize)]
+#[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct PhysicsSettings {
-    pub enabled: bool,
     pub attraction_strength: f32,
-    pub repulsion_strength: f32,
-    pub spring_strength: f32,
+    pub bounds_size: f32,
+    pub collision_radius: f32,
     pub damping: f32,
+    pub enable_bounds: bool,
+    pub enabled: bool,
     pub iterations: u32,
     pub max_velocity: f32,
-    pub collision_radius: f32,
-    pub enable_bounds: bool,
-    pub bounds_size: f32,
+    pub repulsion_strength: f32,
+    pub spring_strength: f32,
 }
 
-#[derive(Debug, Clone, Serialize, Deserialize)]
+#[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct RenderingSettings {
     pub ambient_light_intensity: f32,
-    pub directional_light_intensity: f32,
-    pub environment_intensity: f32,
     pub background_color: String,
+    pub directional_light_intensity: f32,
     pub enable_ambient_occlusion: bool,
     pub enable_antialiasing: bool,
     pub enable_shadows: bool,
+    pub environment_intensity: f32,
 }
 
-#[derive(Debug, Clone, Serialize, Deserialize)]
+#[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct AnimationSettings {
-    pub enable_node_animations: bool,
     pub enable_motion_blur: bool,
+    pub enable_node_animations: bool,
     pub motion_blur_strength: f32,
     pub selection_wave_enabled: bool,
     pub pulse_enabled: bool,
@@ -181,37 +101,30 @@ pub struct AnimationSettings {
     pub wave_speed: f32,
 }
 
-#[derive(Debug, Clone, Serialize, Deserialize)]
+#[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct LabelSettings {
-    pub enable_labels: bool,
     pub desktop_font_size: u32,
+    pub enable_labels: bool,
     pub text_color: String,
-    pub text_outline_color: String,
-    pub text_outline_width: f32,
-    pub text_resolution: u32,
-    pub text_padding: u32,
-    pub billboard_mode: bool,
 }
 
-#[derive(Debug, Clone, Serialize, Deserialize)]
+#[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct BloomSettings {
-    pub enabled: bool,
-    pub strength: f32,
-    pub radius: f32,
-    pub threshold: f32,
     pub edge_bloom_strength: f32,
-    pub node_bloom_strength: f32,
+    pub enabled: bool,
     pub environment_bloom_strength: f32,
+    pub node_bloom_strength: f32,
+    pub radius: f32,
+    pub strength: f32,
 }
 
-#[derive(Debug, Clone, Serialize, Deserialize)]
+#[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct HologramSettings {
     pub ring_count: u32,
-    pub ring_sizes: Vec<f32>,
-    pub ring_rotation_speed: f32,
-    pub global_rotation_speed: f32,
     pub ring_color: String,
     pub ring_opacity: f32,
+    pub ring_sizes: Vec<f32>,
+    pub ring_rotation_speed: f32,
     pub enable_buckminster: bool,
     pub buckminster_scale: f32,
     pub buckminster_opacity: f32,
@@ -221,14 +134,76 @@ pub struct HologramSettings {
     pub enable_triangle_sphere: bool,
     pub triangle_sphere_scale: f32,
     pub triangle_sphere_opacity: f32,
+    pub global_rotation_speed: f32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct NetworkSettings {
+    pub bind_address: String,
+    pub domain: String,
+    pub enable_http2: bool,
+    pub enable_rate_limiting: bool,
+    pub enable_tls: bool,
+    pub max_request_size: usize,
+    pub min_tls_version: String,
+    pub port: u16,
+    pub rate_limit_requests: u32,
+    pub rate_limit_window: u32,
+    pub tunnel_id: String,
+    pub api_client_timeout: u64,
+    pub enable_metrics: bool,
+    pub max_concurrent_requests: u32,
+    pub max_retries: u32,
+    pub metrics_port: u16,
+    pub retry_delay: u32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct WebSocketSettings {
+    pub binary_chunk_size: usize,
+    pub binary_update_rate: u32,
+    pub binary_message_version: u32,
+    pub compression_enabled: bool,
+    pub compression_threshold: usize,
+    pub heartbeat_interval: u64,
+    pub heartbeat_timeout: u64,
+    pub max_connections: usize,
+    pub max_message_size: usize,
+    pub reconnect_attempts: u32,
+    pub reconnect_delay: u64,
+    pub update_rate: u32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct SecuritySettings {
+    pub allowed_origins: Vec<String>,
+    pub audit_log_path: String,
+    pub cookie_httponly: bool,
+    pub cookie_samesite: String,
+    pub cookie_secure: bool,
+    pub csrf_token_timeout: u32,
+    pub enable_audit_logging: bool,
+    pub enable_request_validation: bool,
+    pub session_timeout: u32,
 }
 
-#[derive(Debug, Clone, Serialize, Deserialize)]
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct DebugSettings {
+    pub enabled: bool,
+    pub enable_data_debug: bool,
+    pub enable_websocket_debug: bool,
+    pub log_binary_headers: bool,
+    pub log_full_json: bool,
+    pub log_level: String,
+    pub log_format: String,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct XRSettings {
     pub mode: String,
-    pub quality: String,
     pub room_scale: bool,
     pub space_type: String,
+    pub quality: String,
     pub enable_hand_tracking: bool,
     pub hand_mesh_enabled: bool,
     pub hand_mesh_color: String,
@@ -251,23 +226,414 @@ pub struct XRSettings {
     pub plane_opacity: f32,
     pub show_plane_overlay: bool,
     pub snap_to_floor: bool,
+    pub enable_passthrough_portal: bool,
+    pub passthrough_opacity: f32,
+    pub passthrough_brightness: f32,
+    pub passthrough_contrast: f32,
+    pub portal_size: f32,
+    pub portal_edge_color: String,
+    pub portal_edge_width: f32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct GitHubSettings {
+    pub token: String,
+    pub owner: String,
+    pub repo: String,
+    pub base_path: String,
+    pub rate_limit: bool,
+    pub version: String,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct RagFlowSettings {
+    pub api_key: String,
+    pub api_base_url: String,
+    pub timeout: u64,
+    pub max_retries: u32,
+    pub chat_id: String,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct PerplexitySettings {
+    pub api_key: String,
+    pub model: String,
+    pub api_url: String,
+    pub max_tokens: u32,
+    pub temperature: f32,
+    pub top_p: f32,
+    pub presence_penalty: f32,
+    pub frequency_penalty: f32,
+    pub timeout: u64,
+    pub rate_limit: u32,
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
+pub struct OpenAISettings {
+    pub api_key: String,
+    pub base_url: String,
+    pub timeout: u64,
+    pub rate_limit: u32,
 }
 
 impl Settings {
     pub fn new() -> Result<Self, ConfigError> {
-        let run_mode = env::var("RUN_MODE").unwrap_or_else(|_| "development".into());
-
-        let s = Config::builder()
-            // Start with default settings
-            .add_source(File::with_name("settings.yaml"))
-            // Add environment-specific settings
-            .add_source(File::with_name(&format!("settings.{}.yaml", run_mode)).required(false))
-            // Add local settings
-            .add_source(File::with_name("settings.local.yaml").required(false))
-            // Add environment variables with prefix
-            .add_source(Environment::with_prefix("APP").separator("_"))
+        debug!("Initializing settings");
+
+        // Load .env file first
+        dotenvy::dotenv().ok();
+
+        let settings_path = std::env::var("SETTINGS_FILE_PATH")
+            .map(PathBuf::from)
+            .unwrap_or_else(|_| PathBuf::from("/app/settings.yaml"));
+
+        debug!("Loading settings from: {:?}", settings_path);
+
+        // Read and parse YAML file
+        let yaml_content = std::fs::read_to_string(&settings_path)
+            .map_err(|e| ConfigError::NotFound(format!("Failed to read settings file: {}", e)))?;
+
+        debug!("Deserializing settings from YAML");
+        let mut settings: Settings = serde_yaml::from_str(&yaml_content)
+            .map_err(|e| ConfigError::Message(format!("Failed to parse YAML: {}", e)))?;
+
+        // Apply environment variables on top of YAML settings
+        if let Ok(env_settings) = Settings::from_env() {
+            settings.merge_env(env_settings);
+        }
+
+        // Load required GitHub settings from environment variables
+        settings.github.token = std::env::var("GITHUB_TOKEN")
+            .map_err(|_| ConfigError::NotFound("GITHUB_TOKEN".into()))?;
+        settings.github.owner = std::env::var("GITHUB_OWNER")
+            .map_err(|_| ConfigError::NotFound("GITHUB_OWNER".into()))?;
+        settings.github.repo = std::env::var("GITHUB_REPO")
+            .map_err(|_| ConfigError::NotFound("GITHUB_REPO".into()))?;
+        settings.github.base_path = std::env::var("GITHUB_BASE_PATH")
+            .map_err(|_| ConfigError::NotFound("GITHUB_BASE_PATH".into()))?;
+
+        // Validate GitHub settings are not empty
+        if settings.github.token.is_empty()
+            || settings.github.owner.is_empty()
+            || settings.github.repo.is_empty()
+            || settings.github.base_path.is_empty()
+        {
+            return Err(ConfigError::Message(
+                "Required GitHub settings cannot be empty".into(),
+            ));
+        }
+
+        info!(
+            "GitHub settings loaded: owner={}, repo={}, base_path={}",
+            settings.github.owner, settings.github.repo, settings.github.base_path
+        );
+
+        Ok(settings)
+    }
+
+    pub fn merge_env(&mut self, env_settings: Settings) {
+        // Merge environment settings, only overwriting if they are non-default values
+        if !env_settings.github.token.is_empty() {
+            self.github.token = env_settings.github.token;
+        }
+        if !env_settings.github.owner.is_empty() {
+            self.github.owner = env_settings.github.owner;
+        }
+        if !env_settings.github.repo.is_empty() {
+            self.github.repo = env_settings.github.repo;
+        }
+        if !env_settings.github.base_path.is_empty() {
+            self.github.base_path = env_settings.github.base_path;
+        }
+        // Add other environment-specific settings as needed
+    }
+
+    pub fn merge(&mut self, value: Value) -> Result<(), String> {
+        // Convert incoming JSON value to snake_case
+        let snake_case_value = self.to_snake_case_value(value);
+
+        // Deserialize the value into a temporary Settings
+        let new_settings: Settings = serde_json::from_value(snake_case_value)
+            .map_err(|e| format!("Failed to deserialize settings: {}", e))?;
+
+        // Update only the fields that were present in the input
+        // This preserves existing values for fields that weren't included in the update
+        if let Ok(visualization) = serde_json::to_value(&new_settings.visualization) {
+            if !visualization.is_null() {
+                self.visualization = new_settings.visualization;
+            }
+        }
+        if let Ok(system) = serde_json::to_value(&new_settings.system) {
+            if !system.is_null() {
+                self.system = new_settings.system;
+            }
+        }
+        if let Ok(xr) = serde_json::to_value(&new_settings.xr) {
+            if !xr.is_null() {
+                self.xr = new_settings.xr;
+            }
+        }
+
+        Ok(())
+    }
+
+    pub fn save(&self) -> Result<(), String> {
+        let settings_path = std::env::var("SETTINGS_FILE_PATH")
+            .map(PathBuf::from)
+            .unwrap_or_else(|_| PathBuf::from("/app/settings.yaml"));
+
+        // Convert to YAML
+        let yaml = serde_yaml::to_string(&self)
+            .map_err(|e| format!("Failed to serialize settings to YAML: {}", e))?;
+
+        // Write to file
+        std::fs::write(&settings_path, yaml)
+            .map_err(|e| format!("Failed to write settings file: {}", e))?;
+
+        Ok(())
+    }
+
+    fn to_snake_case_value(&self, value: Value) -> Value {
+        match value {
+            Value::Object(map) => {
+                let converted: serde_json::Map<String, Value> = map
+                    .into_iter()
+                    .map(|(k, v)| {
+                        let snake_case_key = crate::utils::case_conversion::to_snake_case(&k);
+                        (snake_case_key, self.to_snake_case_value(v))
+                    })
+                    .collect();
+                Value::Object(converted)
+            }
+            Value::Array(arr) => Value::Array(
+                arr.into_iter()
+                    .map(|v| self.to_snake_case_value(v))
+                    .collect(),
+            ),
+            _ => value,
+        }
+    }
+
+    pub fn from_env() -> Result<Self, ConfigError> {
+        let builder = ConfigBuilder::<config::builder::DefaultState>::default();
+        let config = builder
+            .add_source(Environment::default().separator("_").try_parsing(true))
             .build()?;
 
-        s.try_deserialize()
+        config.try_deserialize()
+    }
+}
+
+impl Default for Settings {
+    fn default() -> Self {
+        Self {
+            visualization: VisualizationSettings {
+                nodes: NodeSettings {
+                    base_color: "#c3ab6f".to_string(),
+                    base_size: 0.5,
+                    metalness: 0.3,
+                    opacity: 0.4,
+                    roughness: 0.35,
+                    size_range: vec![0.5, 1.0],
+                    quality: "medium".to_string(),
+                    enable_instancing: false,
+                    enable_hologram: false,
+                    enable_metadata_shape: false,
+                    enable_metadata_visualization: false,
+                },
+                edges: EdgeSettings {
+                    arrow_size: 0.15,
+                    base_width: 2.0,
+                    color: "#917f18".to_string(),
+                    enable_arrows: false,
+                    opacity: 0.6,
+                    width_range: vec![1.0, 3.0],
+                },
+                physics: PhysicsSettings {
+                    attraction_strength: 0.015,
+                    bounds_size: 12.0,
+                    collision_radius: 0.25,
+                    damping: 0.88,
+                    enable_bounds: true,
+                    enabled: false,
+                    iterations: 500,
+                    max_velocity: 2.5,
+                    repulsion_strength: 1500.0,
+                    spring_strength: 0.018,
+                },
+                rendering: RenderingSettings {
+                    ambient_light_intensity: 0.3,
+                    background_color: "#000000".to_string(),
+                    directional_light_intensity: 1.0,
+                    enable_ambient_occlusion: false,
+                    enable_antialiasing: false,
+                    enable_shadows: false,
+                    environment_intensity: 0.6,
+                },
+                animations: AnimationSettings {
+                    enable_motion_blur: false,
+                    enable_node_animations: false,
+                    motion_blur_strength: 0.4,
+                    selection_wave_enabled: false,
+                    pulse_enabled: false,
+                    pulse_speed: 1.0,
+                    pulse_strength: 1.0,
+                    wave_speed: 1.0,
+                },
+                labels: LabelSettings {
+                    desktop_font_size: 48,
+                    enable_labels: true,
+                    text_color: "#FFFFFF".to_string(),
+                },
+                bloom: BloomSettings {
+                    edge_bloom_strength: 0.3,
+                    enabled: false,
+                    environment_bloom_strength: 0.5,
+                    node_bloom_strength: 0.2,
+                    radius: 0.5,
+                    strength: 1.8,
+                },
+                hologram: HologramSettings {
+                    ring_count: 3,
+                    ring_color: "#00ff00".to_string(),
+                    ring_opacity: 0.5,
+                    ring_sizes: vec![1.0, 1.2, 1.5],
+                    ring_rotation_speed: 0.001,
+                    enable_buckminster: false,
+                    buckminster_scale: 1.0,
+                    buckminster_opacity: 0.3,
+                    enable_geodesic: false,
+                    geodesic_scale: 1.0,
+                    geodesic_opacity: 0.3,
+                    enable_triangle_sphere: false,
+                    triangle_sphere_scale: 1.0,
+                    triangle_sphere_opacity: 0.3,
+                    global_rotation_speed: 0.0005,
+                },
+            },
+            system: SystemSettings {
+                network: NetworkSettings {
+                    bind_address: "0.0.0.0".to_string(),
+                    domain: "localhost".to_string(),
+                    enable_http2: false,
+                    enable_rate_limiting: true,
+                    enable_tls: false,
+                    max_request_size: 10485760,
+                    min_tls_version: String::new(),
+                    port: 3001,
+                    rate_limit_requests: 100,
+                    rate_limit_window: 60,
+                    tunnel_id: "dummy".to_string(),
+                    api_client_timeout: 30,
+                    enable_metrics: true,
+                    max_concurrent_requests: 5,
+                    max_retries: 3,
+                    metrics_port: 9090,
+                    retry_delay: 5,
+                },
+                websocket: WebSocketSettings {
+                    binary_chunk_size: 65536,
+                    binary_update_rate: 30,
+                    binary_message_version: 1,
+                    compression_enabled: true,
+                    compression_threshold: 1024,
+                    heartbeat_interval: 15000,
+                    heartbeat_timeout: 60000,
+                    max_connections: 1000,
+                    max_message_size: 100485760,
+                    reconnect_attempts: 3,
+                    reconnect_delay: 5000,
+                    update_rate: 90,
+                },
+                security: SecuritySettings {
+                    allowed_origins: Vec::new(),
+                    audit_log_path: "/app/logs/audit.log".to_string(),
+                    cookie_httponly: true,
+                    cookie_samesite: "Strict".to_string(),
+                    cookie_secure: true,
+                    csrf_token_timeout: 3600,
+                    enable_audit_logging: true,
+                    enable_request_validation: true,
+                    session_timeout: 3600,
+                },
+                debug: DebugSettings {
+                    enabled: true,
+                    enable_data_debug: true,
+                    enable_websocket_debug: true,
+                    log_binary_headers: true,
+                    log_full_json: true,
+                    log_level: "debug".to_string(),
+                    log_format: "json".to_string(),
+                },
+            },
+            xr: XRSettings {
+                mode: "immersive-ar".to_string(),
+                room_scale: true,
+                space_type: "local-floor".to_string(),
+                quality: "medium".to_string(),
+                enable_hand_tracking: true,
+                hand_mesh_enabled: true,
+                hand_mesh_color: "#ffffff".to_string(),
+                hand_mesh_opacity: 0.5,
+                hand_point_size: 5.0,
+                hand_ray_enabled: true,
+                hand_ray_color: "#00ff00".to_string(),
+                hand_ray_width: 2.0,
+                gesture_smoothing: 0.5,
+                enable_haptics: true,
+                haptic_intensity: 0.5,
+                drag_threshold: 0.02,
+                pinch_threshold: 0.7,
+                rotation_threshold: 0.1,
+                interaction_radius: 0.5,
+                enable_light_estimation: true,
+                enable_plane_detection: true,
+                enable_scene_understanding: true,
+                plane_color: "#808080".to_string(),
+                plane_opacity: 0.5,
+                show_plane_overlay: true,
+                snap_to_floor: true,
+                enable_passthrough_portal: false,
+                passthrough_opacity: 1.0,
+                passthrough_brightness: 1.0,
+                passthrough_contrast: 1.0,
+                portal_size: 2.0,
+                portal_edge_color: "#ffffff".to_string(),
+                portal_edge_width: 2.0,
+            },
+            github: GitHubSettings {
+                token: String::new(),
+                owner: String::new(),
+                repo: String::new(),
+                base_path: String::new(),
+                rate_limit: true,
+                version: "v3".to_string(),
+            },
+            ragflow: RagFlowSettings {
+                api_key: String::new(),
+                api_base_url: String::new(),
+                timeout: 30,
+                max_retries: 3,
+                chat_id: String::new(),
+            },
+            perplexity: PerplexitySettings {
+                api_key: String::new(),
+                model: String::new(),
+                api_url: String::new(),
+                max_tokens: 4096,
+                temperature: 0.5,
+                top_p: 0.9,
+                presence_penalty: 0.0,
+                frequency_penalty: 0.0,
+                timeout: 30,
+                rate_limit: 100,
+            },
+            openai: OpenAISettings {
+                api_key: String::new(),
+                base_url: String::new(),
+                timeout: 30,
+                rate_limit: 100,
+            },
+        }
     }
 }
diff --git a/src/handlers/mod.rs b/src/handlers/mod.rs
index 0a8452b5..5d6237e7 100755
--- a/src/handlers/mod.rs
+++ b/src/handlers/mod.rs
@@ -2,20 +2,6 @@ pub mod api_handler;
 pub mod health_handler;
 pub mod pages_handler;
 pub mod perplexity_handler;
+pub mod ragflow_handler;
 pub mod settings_handler;
 pub mod socket_flow_handler;
-pub mod nostr_handler;
-
-#[cfg(test)]
-mod tests;
-
-pub use api_handler::config as api_config;
-pub use health_handler::config as health_config;
-pub use pages_handler::config as pages_config;
-pub use perplexity_handler::handle_perplexity;
-pub use settings_handler::config as settings_config;
-pub use socket_flow_handler::socket_flow_handler;
-pub use nostr_handler::config as nostr_config;
-
-// Re-export commonly used handlers
-pub use settings_handler::get_graph_settings;
diff --git a/src/handlers/nostr_handler.rs b/src/handlers/nostr_handler.rs
deleted file mode 100644
index df23e6fe..00000000
--- a/src/handlers/nostr_handler.rs
+++ /dev/null
@@ -1,231 +0,0 @@
-use actix_web::{web, Error, HttpRequest, HttpResponse};
-use nostr_sdk::{
-    prelude::*,
-    Keys, PublicKey,
-    nips::nip19,
-};
-use serde::{Deserialize, Serialize};
-use serde_json::json;
-use std::env;
-use std::time::{SystemTime, UNIX_EPOCH};
-use jsonwebtoken::{encode, decode, Header, EncodingKey, DecodingKey, Validation};
-use thiserror::Error;
-
-use crate::app_state::AppState;
-
-#[derive(Debug, Error)]
-pub enum NostrError {
-    #[error("Invalid event: {0}")]
-    InvalidEvent(String),
-    #[error("Invalid signature")]
-    InvalidSignature,
-    #[error("Challenge expired")]
-    ChallengeExpired,
-    #[error("Environment error: {0}")]
-    Environment(String),
-    #[error("JWT error: {0}")]
-    Jwt(#[from] jsonwebtoken::errors::Error),
-    #[error("Nostr error: {0}")]
-    Nostr(String),
-}
-
-impl actix_web::error::ResponseError for NostrError {
-    fn error_response(&self) -> HttpResponse {
-        match self {
-            NostrError::InvalidSignature => HttpResponse::Unauthorized().json(json!({
-                "error": "Invalid signature"
-            })),
-            NostrError::ChallengeExpired => HttpResponse::Unauthorized().json(json!({
-                "error": "Challenge expired"
-            })),
-            _ => HttpResponse::InternalServerError().json(json!({
-                "error": self.to_string()
-            })),
-        }
-    }
-}
-
-#[derive(Debug, Serialize, Deserialize)]
-pub struct Claims {
-    pub sub: String,      // Subject (pubkey)
-    pub exp: usize,       // Expiration time
-    pub iat: usize,       // Issued at
-    pub power_user: bool, // Power user flag
-}
-
-#[derive(Debug, Serialize, Deserialize)]
-pub struct NostrAuthResponse {
-    pub pubkey: String,
-    pub npub: String,
-    pub is_power_user: bool,
-    pub token: String,
-    pub expires_at: i64,
-}
-
-#[derive(Debug, Serialize, Deserialize)]
-pub struct NostrVerifyResponse {
-    pub valid: bool,
-    pub is_power_user: bool,
-}
-
-pub fn config(cfg: &mut web::ServiceConfig) {
-    cfg.service(
-        web::scope("/auth/nostr")
-            .route("", web::post().to(login))
-            .route("", web::delete().to(logout))
-            .route("/verify", web::post().to(verify))
-            .route("/refresh", web::post().to(refresh)),
-    );
-}
-
-async fn login(event: web::Json<EventBuilder>, state: web::Data<AppState>) -> Result<HttpResponse, Error> {
-    // Build and verify the event
-    let event = event.to_event().map_err(|e| NostrError::Nostr(e.to_string()))?;
-    if !event.verify() {
-        return Err(NostrError::InvalidSignature.into());
-    }
-
-    // Check if pubkey is in power users list
-    let power_users = env::var("NOSTR_POWER_USER_PUBKEYS")
-        .unwrap_or_default()
-        .split(',')
-        .map(|s| s.trim().to_string())
-        .collect::<Vec<_>>();
-
-    let pubkey_hex = event.pubkey.to_string();
-    let is_power_user = power_users.contains(&pubkey_hex);
-
-    // Create JWT token
-    let token_expiry = env::var("NOSTR_TOKEN_EXPIRY")
-        .unwrap_or_else(|_| "3600".to_string())
-        .parse::<i64>()
-        .unwrap_or(3600);
-
-    let now = SystemTime::now()
-        .duration_since(UNIX_EPOCH)
-        .unwrap()
-        .as_secs() as usize;
-
-    let claims = Claims {
-        sub: pubkey_hex.clone(),
-        exp: now + token_expiry as usize,
-        iat: now,
-        power_user: is_power_user,
-    };
-
-    let token = encode(
-        &Header::default(),
-        &claims,
-        &EncodingKey::from_secret(
-            env::var("NOSTR_TOKEN_SECRET")
-                .map_err(|_| NostrError::Environment("NOSTR_TOKEN_SECRET must be set".to_string()))?
-                .as_bytes(),
-        ),
-    )?;
-
-    // Convert pubkey to npub
-    let npub = nip19::encode(&event.pubkey)
-        .map_err(|e| NostrError::Nostr(e.to_string()))?;
-
-    // Add session to app state
-    state.add_nostr_session(
-        pubkey_hex.clone(),
-        npub.clone(),
-        is_power_user
-    ).await;
-
-    Ok(HttpResponse::Ok().json(NostrAuthResponse {
-        pubkey: pubkey_hex,
-        npub,
-        is_power_user,
-        token,
-        expires_at: (now + token_expiry as usize) as i64,
-    }))
-}
-
-async fn logout(req: HttpRequest, state: web::Data<AppState>) -> Result<HttpResponse, Error> {
-    // Get pubkey from token
-    if let Some(pubkey) = extract_pubkey_from_token(&req)? {
-        state.remove_nostr_session(&pubkey).await;
-    }
-    Ok(HttpResponse::Ok().finish())
-}
-
-async fn verify(req: HttpRequest, state: web::Data<AppState>) -> Result<HttpResponse, Error> {
-    let (pubkey, claims) = validate_token(&req)?;
-    
-    // Update session last seen
-    state.update_nostr_session(&pubkey).await;
-
-    Ok(HttpResponse::Ok().json(NostrVerifyResponse {
-        valid: true,
-        is_power_user: claims.power_user,
-    }))
-}
-
-async fn refresh(req: HttpRequest, state: web::Data<AppState>) -> Result<HttpResponse, Error> {
-    let (pubkey, claims) = validate_token(&req)?;
-
-    // Create new token
-    let token_expiry = env::var("NOSTR_TOKEN_EXPIRY")
-        .unwrap_or_else(|_| "3600".to_string())
-        .parse::<i64>()
-        .unwrap_or(3600);
-
-    let now = SystemTime::now()
-        .duration_since(UNIX_EPOCH)
-        .unwrap()
-        .as_secs() as usize;
-
-    let new_claims = Claims {
-        sub: pubkey.clone(),
-        exp: now + token_expiry as usize,
-        iat: now,
-        power_user: claims.power_user,
-    };
-
-    let token_secret = env::var("NOSTR_TOKEN_SECRET")
-        .map_err(|_| NostrError::Environment("NOSTR_TOKEN_SECRET must be set".to_string()))?;
-
-    let new_token = encode(
-        &Header::default(),
-        &new_claims,
-        &EncodingKey::from_secret(token_secret.as_bytes()),
-    )?;
-
-    // Update session last seen
-    state.update_nostr_session(&pubkey).await;
-
-    Ok(HttpResponse::Ok().json(json!({
-        "token": new_token,
-        "expires_at": (now + token_expiry as usize) as i64
-    })))
-}
-
-fn validate_token(req: &HttpRequest) -> Result<(String, Claims), Error> {
-    let token = req
-        .headers()
-        .get("Authorization")
-        .and_then(|h| h.to_str().ok())
-        .and_then(|s| s.strip_prefix("Bearer "))
-        .ok_or_else(|| NostrError::InvalidSignature)?;
-
-    let token_secret = env::var("NOSTR_TOKEN_SECRET")
-        .map_err(|_| NostrError::Environment("NOSTR_TOKEN_SECRET must be set".to_string()))?;
-
-    let validation = Validation::default();
-    let token_data = decode::<Claims>(
-        token,
-        &DecodingKey::from_secret(token_secret.as_bytes()),
-        &validation,
-    )?;
-
-    Ok((token_data.claims.sub.clone(), token_data.claims))
-}
-
-fn extract_pubkey_from_token(req: &HttpRequest) -> Result<Option<String>, Error> {
-    match validate_token(req) {
-        Ok((pubkey, _)) => Ok(Some(pubkey)),
-        Err(_) => Ok(None),
-    }
-}
\ No newline at end of file
diff --git a/src/handlers/socket_flow_handler.rs b/src/handlers/socket_flow_handler.rs
index 6e436926..f71598b9 100644
--- a/src/handlers/socket_flow_handler.rs
+++ b/src/handlers/socket_flow_handler.rs
@@ -1,109 +1,294 @@
-use actix::{Actor, ActorContext, AsyncContext, StreamHandler};
+use actix::prelude::*;
 use actix_web::{web, Error, HttpRequest, HttpResponse};
 use actix_web_actors::ws;
-use bytes::Bytes;
-use log::{debug, error, info};
-use serde_json::json;
-use std::time::{Duration, Instant};
-use jsonwebtoken::{decode, DecodingKey, Validation};
+use flate2::{read::ZlibDecoder, write::ZlibEncoder, Compression};
+use glam::Vec3;
+use log::{debug, error, info, warn};
+use std::io::{Read, Write};
+use std::sync::Arc;
+use tokio::sync::RwLock;
 
 use crate::app_state::AppState;
-use crate::handlers::nostr_handler::Claims;
-use crate::models::graph::{Node, Position, Velocity};
+use crate::utils::binary_protocol::{self, MessageType, NodeData};
+use crate::utils::socket_flow_messages::{PingMessage, PongMessage};
 
-const HEARTBEAT_INTERVAL: Duration = Duration::from_secs(5);
-const CLIENT_TIMEOUT: Duration = Duration::from_secs(10);
+pub struct SocketFlowServer {
+    app_state: Arc<AppState>,
+    settings: Arc<RwLock<crate::config::Settings>>,
+    last_ping: Option<u64>,
+    update_interval: std::time::Duration,
+}
 
-pub struct WebSocketConnection {
-    app_state: web::Data<AppState>,
-    last_heartbeat: Instant,
-    pubkey: Option<String>,
+impl SocketFlowServer {
+    pub fn new(app_state: Arc<AppState>, settings: Arc<RwLock<crate::config::Settings>>) -> Self {
+        // Calculate update interval from settings
+        let update_rate = settings
+            .try_read()
+            .map(|s| s.system.websocket.binary_update_rate)
+            .unwrap_or(30);
+
+        let update_interval =
+            std::time::Duration::from_millis((1000.0 / update_rate as f64) as u64);
+
+        Self {
+            app_state,
+            settings,
+            last_ping: None,
+            update_interval,
+        }
+    }
+
+    fn handle_ping(&mut self, msg: PingMessage) -> PongMessage {
+        self.last_ping = Some(msg.timestamp);
+        PongMessage {
+            type_: "pong".to_string(),
+            timestamp: msg.timestamp,
+        }
+    }
+
+    fn maybe_compress(&self, data: Vec<u8>) -> Vec<u8> {
+        if let Ok(settings) = self.settings.try_read() {
+            if settings.system.websocket.compression_enabled
+                && data.len() >= settings.system.websocket.compression_threshold
+            {
+                let mut encoder = ZlibEncoder::new(Vec::new(), Compression::default());
+                if encoder.write_all(&data).is_ok() {
+                    if let Ok(compressed) = encoder.finish() {
+                        if compressed.len() < data.len() {
+                            debug!(
+                                "Compressed binary message: {} -> {} bytes",
+                                data.len(),
+                                compressed.len()
+                            );
+                            return compressed;
+                        }
+                    }
+                }
+            }
+        }
+        data
+    }
+
+    fn maybe_decompress(&self, data: Vec<u8>) -> Result<Vec<u8>, String> {
+        if let Ok(settings) = self.settings.try_read() {
+            if settings.system.websocket.compression_enabled {
+                let mut decoder = ZlibDecoder::new(data.as_slice());
+                let mut decompressed = Vec::new();
+                match decoder.read_to_end(&mut decompressed) {
+                    Ok(_) => {
+                        if decompressed.len() > data.len() {
+                            debug!(
+                                "Decompressed binary message: {} -> {} bytes",
+                                data.len(),
+                                decompressed.len()
+                            );
+                            return Ok(decompressed);
+                        }
+                    }
+                    Err(e) => {
+                        // If decompression fails, assume the data wasn't compressed
+                        debug!("Decompression failed (data likely uncompressed): {}", e);
+                    }
+                }
+            }
+        }
+        Ok(data)
+    }
 }
 
-impl Actor for WebSocketConnection {
+impl Actor for SocketFlowServer {
     type Context = ws::WebsocketContext<Self>;
 
     fn started(&mut self, ctx: &mut Self::Context) {
-        self.heartbeat(ctx);
-        if let Some(pubkey) = &self.pubkey {
-            debug!("WebSocket connection started for user: {}", pubkey);
+        info!("[WebSocket] Client connected from {:?}", ctx.address());
+
+        // Send simple connection established message
+        let response = serde_json::json!({
+            "type": "connection_established",
+            "timestamp": chrono::Utc::now().timestamp_millis()
+        });
+
+        if let Ok(msg_str) = serde_json::to_string(&response) {
+            ctx.text(msg_str);
         }
     }
 
     fn stopped(&mut self, _: &mut Self::Context) {
-        if let Some(pubkey) = &self.pubkey {
-            debug!("WebSocket connection closed for user: {}", pubkey);
-        }
-        self.app_state.decrement_connections();
+        info!("[WebSocket] Client disconnected");
+        // Cleanup any resources if needed
     }
 }
 
-impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WebSocketConnection {
+impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for SocketFlowServer {
     fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {
         match msg {
             Ok(ws::Message::Ping(msg)) => {
-                self.last_heartbeat = Instant::now();
+                debug!("[WebSocket] Received ping");
                 ctx.pong(&msg);
             }
             Ok(ws::Message::Pong(_)) => {
-                self.last_heartbeat = Instant::now();
+                debug!("[WebSocket] Received pong");
+                // Update last pong time if needed
             }
-            Ok(ws::Message::Binary(bin)) => {
-                // Handle binary position updates
-                if let Err(e) = self.handle_binary_message(&bin, ctx) {
-                    error!("Error handling binary message: {}", e);
+            Ok(ws::Message::Text(text)) => {
+                info!("Received text message: {}", text);
+                match serde_json::from_str::<serde_json::Value>(&text) {
+                    Ok(msg) => {
+                        match msg.get("type").and_then(|t| t.as_str()) {
+                            Some("ping") => {
+                                if let Ok(ping_msg) =
+                                    serde_json::from_value::<PingMessage>(msg.clone())
+                                {
+                                    let pong = self.handle_ping(ping_msg);
+                                    if let Ok(response) = serde_json::to_string(&pong) {
+                                        ctx.text(response);
+                                    }
+                                }
+                            }
+                            Some("requestInitialData") => {
+                                // Start sending GPU-computed position updates
+                                let app_state = self.app_state.clone();
+                                
+                                ctx.run_interval(self.update_interval, move |actor, ctx| {
+                                    let app_state_clone = app_state.clone();
+
+                                    let fut = async move {
+                                        let raw_nodes = app_state_clone
+                                            .graph_service
+                                            .get_node_positions()
+                                            .await;
+
+                                        // Only process and send updates if we have nodes
+                                        if !raw_nodes.is_empty() {
+                                            debug!(
+                                                "Processing binary update for {} nodes",
+                                                raw_nodes.len()
+                                            );
+                                            let nodes: Vec<NodeData> = raw_nodes
+                                                .into_iter()
+                                                .map(|node| NodeData {
+                                                    id: node.id.parse().unwrap_or(0),
+                                                    position: Vec3::new(
+                                                        node.data.position[0],
+                                                        node.data.position[1],
+                                                        node.data.position[2],
+                                                    ),
+                                                    velocity: Vec3::new(
+                                                        node.data.velocity[0],
+                                                        node.data.velocity[1],
+                                                        node.data.velocity[2],
+                                                    ),
+                                                })
+                                                .collect::<Vec<_>>();
+
+                                            debug!(
+                                                "Encoding binary update with {} nodes",
+                                                nodes.len()
+                                            );
+                                            let data = binary_protocol::encode_node_data(
+                                                &nodes,
+                                                MessageType::PositionVelocityUpdate,
+                                            );
+                                            debug!("Binary message size: {} bytes", data.len());
+                                            Some(data)
+                                        } else {
+                                            debug!("No nodes to update, skipping binary message");
+                                            None
+                                        }
+                                    };
+
+                                    let fut = fut.into_actor(actor);
+                                    ctx.spawn(fut.map(|maybe_binary_data, actor, ctx| {
+                                        if let Some(binary_data) = maybe_binary_data {
+                                            let final_data = actor.maybe_compress(binary_data);
+                                            ctx.binary(final_data);
+                                        }
+                                        // Do not send any message if there are no nodes
+                                    }));
+                                });
+
+                                // Send confirmation that updates are starting
+                                let response = serde_json::json!({
+                                    "type": "updatesStarted",
+                                    "timestamp": chrono::Utc::now().timestamp_millis()
+                                });
+                                if let Ok(msg_str) = serde_json::to_string(&response) {
+                                    ctx.text(msg_str);
+                                }
+                            }
+                            _ => {
+                                warn!("[WebSocket] Unknown message type: {:?}", msg);
+                            }
+                        }
+                    }
+                    Err(e) => {
+                        warn!("[WebSocket] Failed to parse text message: {}", e);
+                    }
+                }
+            }
+            Ok(ws::Message::Binary(data)) => {
+                info!("Received binary message, length: {}", data.len());
+                // Handle user interaction updates
+                match binary_protocol::decode_node_data(&data) {
+                    Ok((msg_type, nodes)) => {
+                        if nodes.len() <= 2 {
+                            // Only allow updates for up to 2 nodes during interaction
+                            match msg_type {
+                                MessageType::PositionVelocityUpdate => {
+                                    // Update positions in graph service for interacted nodes
+                                    let app_state = self.app_state.clone();
+                                    let nodes_clone = nodes.clone();
+
+                                    // Spawn a future to update the graph data
+                                    let fut = async move {
+                                        let mut graph =
+                                            app_state.graph_service.graph_data.write().await;
+                                        for node_data in nodes_clone {
+                                            if let Some(node) = graph.nodes.iter_mut().find(|n| {
+                                                n.id.parse::<u32>().unwrap_or(0) == node_data.id
+                                            }) {
+                                                // Update position and velocity from user interaction
+                                                node.data.position = [
+                                                    node_data.position.x,
+                                                    node_data.position.y,
+                                                    node_data.position.z,
+                                                ];
+                                                node.data.velocity = [
+                                                    node_data.velocity.x,
+                                                    node_data.velocity.y,
+                                                    node_data.velocity.z,
+                                                ];
+                                            }
+                                        }
+                                    };
+
+                                    let fut = fut.into_actor(self);
+                                    ctx.spawn(fut.map(|_, _, _| ()));
+                                }
+                            }
+                        } else {
+                            warn!("Received update for too many nodes: {}", nodes.len());
+                        }
+                    }
+                    Err(e) => error!("Failed to decode binary message: {}", e),
                 }
             }
             Ok(ws::Message::Close(reason)) => {
-                info!("WebSocket connection closing: {:?}", reason);
+                info!("[WebSocket] Client initiated close: {:?}", reason);
                 ctx.close(reason);
                 ctx.stop();
             }
-            _ => {}
-        }
-    }
-}
-
-impl WebSocketConnection {
-    fn new(app_state: web::Data<AppState>, pubkey: Option<String>) -> Self {
-        Self {
-            app_state,
-            last_heartbeat: Instant::now(),
-            pubkey,
-        }
-    }
-
-    fn heartbeat(&self, ctx: &mut ws::WebsocketContext<Self>) {
-        ctx.run_interval(HEARTBEAT_INTERVAL, |act, ctx| {
-            if Instant::now().duration_since(act.last_heartbeat) > CLIENT_TIMEOUT {
-                info!("WebSocket Client heartbeat failed, disconnecting!");
-                ctx.stop();
-                return;
+            Ok(ws::Message::Continuation(_)) => {
+                warn!("[WebSocket] Received unexpected continuation frame");
             }
-            ctx.ping(b"");
-        });
-    }
-
-    fn handle_binary_message(&self, bin: &Bytes, ctx: &mut ws::WebsocketContext<Self>) -> Result<(), Box<dyn std::error::Error>> {
-        // Parse binary message into node updates
-        let nodes = serde_json::from_slice::<Vec<Node>>(bin)?;
-
-        // Update node positions in graph service
-        if let Ok(mut graph) = self.app_state.graph_service.graph_data.try_write() {
-            for update_node in &nodes {
-                if let Some(node) = graph.nodes.iter_mut().find(|n| n.id == update_node.id) {
-                    node.position = update_node.position.clone();
-                    node.velocity = update_node.velocity.clone();
-                }
+            Ok(ws::Message::Nop) => {
+                debug!("[WebSocket] Received Nop");
+            }
+            Err(e) => {
+                error!("[WebSocket] Error in WebSocket connection: {}", e);
+                ctx.stop();
             }
         }
-
-        // Broadcast updated positions to all clients
-        if let Ok(encoded) = serde_json::to_vec(&nodes) {
-            ctx.binary(encoded);
-        }
-
-        Ok(())
     }
 }
 
@@ -111,54 +296,26 @@ pub async fn socket_flow_handler(
     req: HttpRequest,
     stream: web::Payload,
     app_state: web::Data<AppState>,
+    settings: web::Data<Arc<RwLock<crate::config::Settings>>>,
 ) -> Result<HttpResponse, Error> {
-    // Extract and validate auth token
-    let token = match req
-        .headers()
-        .get("Authorization")
-        .and_then(|h| h.to_str().ok())
-        .and_then(|s| s.strip_prefix("Bearer "))
-    {
-        Some(token) => token,
-        None => {
-            return Ok(HttpResponse::Unauthorized().json(json!({
-                "error": "Missing or invalid authorization header"
-            })));
-        }
-    };
-
-    let token_secret = match std::env::var("NOSTR_TOKEN_SECRET") {
-        Ok(secret) => secret,
-        Err(_) => {
-            return Ok(HttpResponse::InternalServerError().json(json!({
-                "error": "Server configuration error"
-            })));
-        }
-    };
-
-    // Verify token
-    let validation = Validation::default();
-    let claims = match decode::<Claims>(
-        token,
-        &DecodingKey::from_secret(token_secret.as_bytes()),
-        &validation,
-    ) {
-        Ok(token_data) => token_data.claims,
-        Err(_) => {
-            return Ok(HttpResponse::Unauthorized().json(json!({
-                "error": "Invalid token"
-            })));
-        }
-    };
+    debug!("WebSocket connection attempt from {:?}", req.peer_addr());
 
-    // Update session last seen
-    app_state.update_nostr_session(&claims.sub).await;
+    // Check for WebSocket upgrade
+    if !req.headers().contains_key("Upgrade") {
+        debug!("Not a WebSocket upgrade request");
+        return Ok(HttpResponse::BadRequest().body("WebSocket upgrade required"));
+    }
 
-    // Increment connection counter
-    app_state.increment_connections();
+    let ws = SocketFlowServer::new(app_state.into_inner(), settings.get_ref().clone());
 
-    // Start WebSocket connection
-    let ws = WebSocketConnection::new(app_state, Some(claims.sub));
-    let resp = ws::start(ws, &req, stream)?;
-    Ok(resp)
+    match ws::start(ws, &req, stream) {
+        Ok(response) => {
+            info!("[WebSocket] Client connected successfully");
+            Ok(response)
+        }
+        Err(e) => {
+            error!("[WebSocket] Failed to start WebSocket: {}", e);
+            Err(e)
+        }
+    }
 }
diff --git a/src/handlers/tests/mod.rs b/src/handlers/tests/mod.rs
deleted file mode 100644
index 3d6a3565..00000000
--- a/src/handlers/tests/mod.rs
+++ /dev/null
@@ -1,42 +0,0 @@
-mod nostr_tests;
-
-// Re-export test utilities
-pub(crate) use nostr_tests::*;
-
-// Common test utilities
-#[cfg(test)]
-pub(crate) mod test_utils {
-    use crate::app_state::AppState;
-    use actix_web::web;
-    use std::sync::Arc;
-    use tokio::sync::RwLock;
-    use crate::config::Settings;
-
-    /// Create a test app state with default settings
-    pub async fn create_test_app_state() -> web::Data<AppState> {
-        let settings = Arc::new(RwLock::new(Settings::new().unwrap()));
-        web::Data::new(AppState::new(
-            settings,
-            Default::default(),
-            Default::default(),
-            None,
-            None,
-            None,
-            "test".to_string(),
-        ))
-    }
-
-    /// Set up test environment variables
-    pub fn setup_test_env() {
-        std::env::set_var("NOSTR_TOKEN_SECRET", "test_secret");
-        std::env::set_var("NOSTR_TOKEN_EXPIRY", "3600");
-        std::env::set_var("NOSTR_POWER_USER_PUBKEYS", "");
-    }
-
-    /// Clean up test environment variables
-    pub fn cleanup_test_env() {
-        std::env::remove_var("NOSTR_TOKEN_SECRET");
-        std::env::remove_var("NOSTR_TOKEN_EXPIRY");
-        std::env::remove_var("NOSTR_POWER_USER_PUBKEYS");
-    }
-}
\ No newline at end of file
diff --git a/src/handlers/tests/nostr_tests.rs b/src/handlers/tests/nostr_tests.rs
deleted file mode 100644
index cd8b5a31..00000000
--- a/src/handlers/tests/nostr_tests.rs
+++ /dev/null
@@ -1,221 +0,0 @@
-use actix_web::{test, web, App};
-use nostr_sdk::{prelude::*, Event, EventBuilder, Keys};
-use serde_json::json;
-
-use crate::handlers::nostr_handler::{self, NostrAuthResponse, NostrVerifyResponse};
-use super::test_utils::{create_test_app_state, setup_test_env, cleanup_test_env};
-
-#[actix_web::test]
-async fn test_nostr_login_flow() {
-    setup_test_env();
-
-    // Create test keys
-    let keys = Keys::generate();
-    let pubkey = keys.public_key();
-
-    // Create auth event
-    let event = EventBuilder::new(Kind::Custom(27235), "Login request", &[])
-        .to_event(&keys)
-        .expect("Failed to create event");
-
-    // Create test app state
-    let app_state = create_test_app_state().await;
-
-    // Create test app
-    let app = test::init_service(
-        App::new()
-            .app_data(app_state.clone())
-            .configure(nostr_handler::config),
-    )
-    .await;
-
-    // Test login
-    let login_req = test::TestRequest::post()
-        .uri("/auth/nostr")
-        .set_json(&event)
-        .to_request();
-
-    let login_resp = test::call_service(&app, login_req).await;
-    assert!(login_resp.status().is_success());
-
-    let auth_response: NostrAuthResponse = test::read_body_json(login_resp).await;
-    assert_eq!(auth_response.pubkey, pubkey.to_hex());
-    assert!(!auth_response.is_power_user);
-    assert!(!auth_response.token.is_empty());
-
-    // Test verify
-    let verify_req = test::TestRequest::post()
-        .uri("/auth/nostr/verify")
-        .header("Authorization", format!("Bearer {}", auth_response.token))
-        .to_request();
-
-    let verify_resp = test::call_service(&app, verify_req).await;
-    assert!(verify_resp.status().is_success());
-
-    let verify_response: NostrVerifyResponse = test::read_body_json(verify_resp).await;
-    assert!(verify_response.valid);
-    assert!(!verify_response.is_power_user);
-
-    // Test refresh
-    let refresh_req = test::TestRequest::post()
-        .uri("/auth/nostr/refresh")
-        .header("Authorization", format!("Bearer {}", auth_response.token))
-        .to_request();
-
-    let refresh_resp = test::call_service(&app, refresh_req).await;
-    assert!(refresh_resp.status().is_success());
-
-    let refresh_json: serde_json::Value = test::read_body_json(refresh_resp).await;
-    assert_ne!(refresh_json["token"], auth_response.token);
-
-    // Test logout
-    let logout_req = test::TestRequest::delete()
-        .uri("/auth/nostr")
-        .header("Authorization", format!("Bearer {}", auth_response.token))
-        .to_request();
-
-    let logout_resp = test::call_service(&app, logout_req).await;
-    assert!(logout_resp.status().is_success());
-
-    // Verify session is removed
-    let session = app_state.get_nostr_session(&pubkey.to_hex()).await;
-    assert!(session.is_none());
-
-    cleanup_test_env();
-}
-
-#[actix_web::test]
-async fn test_nostr_power_user_flow() {
-    setup_test_env();
-
-    // Create test keys
-    let keys = Keys::generate();
-    let pubkey_hex = keys.public_key().to_hex();
-    std::env::set_var("NOSTR_POWER_USER_PUBKEYS", &pubkey_hex);
-
-    // Create auth event
-    let event = EventBuilder::new(Kind::Custom(27235), "Login request", &[])
-        .to_event(&keys)
-        .expect("Failed to create event");
-
-    // Create test app state
-    let app_state = create_test_app_state().await;
-
-    // Create test app
-    let app = test::init_service(
-        App::new()
-            .app_data(app_state.clone())
-            .configure(nostr_handler::config),
-    )
-    .await;
-
-    // Test power user login
-    let login_req = test::TestRequest::post()
-        .uri("/auth/nostr")
-        .set_json(&event)
-        .to_request();
-
-    let login_resp = test::call_service(&app, login_req).await;
-    assert!(login_resp.status().is_success());
-
-    let auth_response: NostrAuthResponse = test::read_body_json(login_resp).await;
-    assert_eq!(auth_response.pubkey, pubkey_hex);
-    assert!(auth_response.is_power_user);
-
-    cleanup_test_env();
-}
-
-#[actix_web::test]
-async fn test_nostr_error_cases() {
-    setup_test_env();
-
-    // Create test app state
-    let app_state = create_test_app_state().await;
-
-    // Create test app
-    let app = test::init_service(
-        App::new()
-            .app_data(app_state.clone())
-            .configure(nostr_handler::config),
-    )
-    .await;
-
-    // Test invalid event
-    let invalid_event = Event {
-        id: "test".to_string().into(),
-        pubkey: Keys::generate().public_key(),
-        created_at: 0,
-        kind: Kind::Custom(27235),
-        tags: vec![],
-        content: "Login request".to_string(),
-        sig: "invalid".to_string().into(),
-    };
-
-    let req = test::TestRequest::post()
-        .uri("/auth/nostr")
-        .set_json(&invalid_event)
-        .to_request();
-
-    let resp = test::call_service(&app, req).await;
-    assert_eq!(resp.status(), 401);
-
-    // Test missing auth header
-    let req = test::TestRequest::post()
-        .uri("/auth/nostr/verify")
-        .to_request();
-
-    let resp = test::call_service(&app, req).await;
-    assert_eq!(resp.status(), 401);
-
-    // Test invalid token
-    let req = test::TestRequest::post()
-        .uri("/auth/nostr/verify")
-        .header("Authorization", "Bearer invalid_token")
-        .to_request();
-
-    let resp = test::call_service(&app, req).await;
-    assert_eq!(resp.status(), 401);
-
-    cleanup_test_env();
-}
-
-#[actix_web::test]
-async fn test_nostr_session_cleanup() {
-    setup_test_env();
-
-    // Create test app state
-    let app_state = create_test_app_state().await;
-
-    // Add test sessions
-    let keys1 = Keys::generate();
-    let keys2 = Keys::generate();
-
-    app_state
-        .add_nostr_session(
-            keys1.public_key().to_hex(),
-            "test_npub1".to_string(),
-            false,
-        )
-        .await;
-
-    app_state
-        .add_nostr_session(
-            keys2.public_key().to_hex(),
-            "test_npub2".to_string(),
-            true,
-        )
-        .await;
-
-    // Verify both sessions exist
-    assert!(app_state.get_nostr_session(&keys1.public_key().to_hex()).await.is_some());
-    assert!(app_state.get_nostr_session(&keys2.public_key().to_hex()).await.is_some());
-
-    // Run cleanup with 0 hours max age (should remove all sessions)
-    app_state.cleanup_nostr_sessions(0).await;
-
-    // Verify sessions are removed
-    assert!(app_state.get_nostr_session(&keys1.public_key().to_hex()).await.is_none());
-    assert!(app_state.get_nostr_session(&keys2.public_key().to_hex()).await.is_none());
-
-    cleanup_test_env();
-}
\ No newline at end of file
diff --git a/src/lib.rs b/src/lib.rs
index b1cf7cc0..4f27176e 100755
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,38 +1,45 @@
+#![recursion_limit = "256"]
+
+extern crate log;
+
+// Declare modules
+pub mod utils;
 pub mod app_state;
 pub mod config;
 pub mod handlers;
 pub mod models;
 pub mod services;
-pub mod utils;
+pub mod types;
+pub mod state;
 
+// Re-export standard logging if needed
+pub use log::{debug, error, info, warn};
+
+// Re-export GPU compute
+pub use crate::utils::gpu_compute::GPUCompute;
+
+// Re-export socket flow handler
+pub use crate::handlers::socket_flow_handler::{SocketFlowServer, socket_flow_handler};
+
+// Public re-exports
 pub use app_state::AppState;
 pub use config::Settings;
-pub use handlers::{
-    api_handler,
-    health_handler,
-    pages_handler,
-    socket_flow_handler::socket_flow_handler,
-    nostr_handler,
-};
-pub use utils::gpu_compute::GPUCompute;
-pub use utils::logging;
-
-// Re-export commonly used types
-pub use models::graph::GraphData;
-pub use models::node::Node;
-pub use models::edge::Edge;
+pub use models::position_update::PositionUpdate;
 pub use models::metadata::MetadataStore;
 pub use models::simulation_params::SimulationParams;
-pub use models::ui_settings::UISettings;
-
-// Re-export services
-pub use services::file_service::FileService;
+pub use models::graph::GraphData;
 pub use services::graph_service::GraphService;
-pub use services::github::{GitHubClient, ContentAPI};
+pub use services::file_service::FileService;
 pub use services::perplexity_service::PerplexityService;
-pub use services::ragflow_service::RAGFlowService;
+pub use services::ragflow_service::{RAGFlowService, RAGFlowError};
+pub use services::github::{GitHubClient, ContentAPI};
 
-// Re-export utils
-pub use utils::binary_protocol::{decode_binary_message, encode_binary_message};
-pub use utils::socket_flow_messages::NodeData;
-pub use utils::socket_flow_constants::*;
+// Re-export handlers
+pub use handlers::api_handler::files as file_handler;
+pub use handlers::api_handler::graph as graph_handler;
+pub use handlers::health_handler;
+pub use handlers::pages_handler;
+pub use handlers::perplexity_handler;
+pub use handlers::ragflow_handler;
+pub use handlers::api_handler::visualization as visualization_handler;
+pub use handlers::settings_handler;
diff --git a/src/main.rs b/src/main.rs
index 07228c9f..43666224 100755
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,12 +1,3 @@
-use actix_web::{web, App, HttpServer, middleware};
-use actix_cors::Cors;
-use actix_files::Files;
-use std::sync::Arc;
-use tokio::sync::RwLock;
-use dotenvy::dotenv;
-use log::{error, warn, info, debug};
-use tokio::time::{interval, Duration};
-
 use webxr::{
     AppState, Settings,
     handlers::{
@@ -14,7 +5,6 @@ use webxr::{
         health_handler,
         pages_handler,
         socket_flow_handler::socket_flow_handler,
-        nostr_handler,
     },
     GPUCompute, GraphData,
     services::{
@@ -24,6 +14,13 @@ use webxr::{
     },
 };
 
+use actix_web::{web, App, HttpServer, middleware};
+use actix_cors::Cors;
+use actix_files::Files;
+use std::sync::Arc;
+use tokio::sync::RwLock;
+use dotenvy::dotenv;
+use log::{error, warn, info, debug};
 use webxr::utils::logging::{init_logging_with_config, LogConfig};
 
 #[actix_web::main]
@@ -70,13 +67,14 @@ async fn main() -> std::io::Result<()> {
 
     info!("Starting WebXR application...");
     
+    // Replace log_data! and log_warn! with standard log macros
     info!("Initializing GPU compute...");
     
     let gpu_compute = if cfg!(feature = "gpu") {
         match GPUCompute::new(&GraphData::default()).await {
             Ok(gpu) => {
                 info!("GPU initialization successful");
-                Some(Arc::new(RwLock::new(gpu)))
+                Some(gpu)
             }
             Err(e) => {
                 warn!("Failed to initialize GPU: {}. Falling back to CPU computations.", e);
@@ -89,6 +87,9 @@ async fn main() -> std::io::Result<()> {
         None
     };
 
+    // Create web::Data instances first
+    let settings_data = web::Data::new(settings.clone());
+
     // Initialize services
     let settings_read = settings.read().await;
     let github_client = match GitHubClient::new(
@@ -153,16 +154,6 @@ async fn main() -> std::io::Result<()> {
         }
     }
 
-    // Start Nostr session cleanup task
-    let app_state_cleanup = app_state.clone();
-    tokio::spawn(async move {
-        let mut interval = interval(Duration::from_secs(3600)); // Run every hour
-        loop {
-            interval.tick().await;
-            app_state_cleanup.cleanup_nostr_sessions(24).await; // Clean up sessions older than 24 hours
-        }
-    });
-
     // Start the server
     let bind_address = {
         let settings_read = settings.read().await;
@@ -184,16 +175,16 @@ async fn main() -> std::io::Result<()> {
             .wrap(middleware::Logger::default())
             .wrap(cors)
             .wrap(middleware::Compress::default())
+            .app_data(settings_data.clone())
             .app_data(app_state.clone())
             .app_data(web::Data::new(github_client.clone()))
             .app_data(web::Data::new(content_api.clone()))
             .route("/wss", web::get().to(socket_flow_handler))
             .service(
-                web::scope("/api")
+                web::scope("")
                     .configure(api_handler::config)
-                    .configure(health_handler::config)
-                    .configure(pages_handler::config)
-                    .configure(nostr_handler::config)
+                    .service(web::scope("/health").configure(health_handler::config))
+                    .service(web::scope("/pages").configure(pages_handler::config))
             )
             .service(Files::new("/", "/app/client").index_file("index.html"))
     })
diff --git a/src/models/graph.rs b/src/models/graph.rs
index 5463e2d1..689d095e 100755
--- a/src/models/graph.rs
+++ b/src/models/graph.rs
@@ -1,233 +1,27 @@
+use crate::utils::socket_flow_messages::Node;
+use super::edge::Edge;
+use super::metadata::MetadataStore;
 use serde::{Deserialize, Serialize};
-use std::collections::HashMap;
 
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct Position {
-    pub x: f32,
-    pub y: f32,
-    pub z: f32,
-}
-
-impl Default for Position {
-    fn default() -> Self {
-        Self {
-            x: 0.0,
-            y: 0.0,
-            z: 0.0,
-        }
-    }
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct Velocity {
-    pub x: f32,
-    pub y: f32,
-    pub z: f32,
-}
-
-impl Default for Velocity {
-    fn default() -> Self {
-        Self {
-            x: 0.0,
-            y: 0.0,
-            z: 0.0,
-        }
-    }
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct Node {
-    pub id: String,
-    pub title: String,
-    pub position: Position,
-    pub velocity: Velocity,
-    pub mass: f32,
-    pub metadata: HashMap<String, String>,
-    pub created_at: i64,
-}
-
-impl Node {
-    pub fn new(
-        id: String,
-        title: String,
-        created_at: i64,
-        metadata: HashMap<String, String>,
-    ) -> Self {
-        Self {
-            id,
-            title,
-            position: Position::default(),
-            velocity: Velocity::default(),
-            mass: 1.0,
-            metadata,
-            created_at,
-        }
-    }
-
-    pub fn with_position(mut self, x: f32, y: f32, z: f32) -> Self {
-        self.position = Position { x, y, z };
-        self
-    }
-
-    pub fn with_velocity(mut self, x: f32, y: f32, z: f32) -> Self {
-        self.velocity = Velocity { x, y, z };
-        self
-    }
-
-    pub fn with_mass(mut self, mass: f32) -> Self {
-        self.mass = mass;
-        self
-    }
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct Edge {
-    pub source: String,
-    pub target: String,
-    pub weight: f32,
-    pub metadata: HashMap<String, String>,
-}
-
-impl Edge {
-    pub fn new(
-        source: String,
-        target: String,
-        weight: f32,
-        metadata: HashMap<String, String>,
-    ) -> Self {
-        Self {
-            source,
-            target,
-            weight,
-            metadata,
-        }
-    }
-}
-
-#[derive(Debug, Clone, Default, Serialize, Deserialize)]
+/// Represents the graph data structure containing nodes, edges, and metadata.
+/// All fields use camelCase serialization for client compatibility.
+#[derive(Default, Serialize, Deserialize, Clone, Debug)]
+#[serde(rename_all = "camelCase")]
 pub struct GraphData {
+    /// List of nodes in the graph.
     pub nodes: Vec<Node>,
+    /// List of edges connecting the nodes.
     pub edges: Vec<Edge>,
+    /// Metadata associated with the graph, using camelCase keys.
+    pub metadata: MetadataStore,
 }
 
 impl GraphData {
     pub fn new() -> Self {
-        Self::default()
-    }
-
-    pub fn add_node(&mut self, node: Node) {
-        self.nodes.push(node);
-    }
-
-    pub fn add_edge(&mut self, edge: Edge) {
-        self.edges.push(edge);
-    }
-
-    pub fn get_node(&self, id: &str) -> Option<&Node> {
-        self.nodes.iter().find(|n| n.id == id)
-    }
-
-    pub fn get_node_mut(&mut self, id: &str) -> Option<&mut Node> {
-        self.nodes.iter_mut().find(|n| n.id == id)
-    }
-
-    pub fn get_edges_for_node(&self, node_id: &str) -> Vec<&Edge> {
-        self.edges
-            .iter()
-            .filter(|e| e.source == node_id || e.target == node_id)
-            .collect()
-    }
-
-    pub fn clear(&mut self) {
-        self.nodes.clear();
-        self.edges.clear();
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_node_creation() {
-        let mut metadata = HashMap::new();
-        metadata.insert("key".to_string(), "value".to_string());
-
-        let node = Node::new(
-            "test".to_string(),
-            "Test Node".to_string(),
-            1234567890,
-            metadata.clone(),
-        )
-        .with_position(1.0, 2.0, 3.0)
-        .with_velocity(0.1, 0.2, 0.3)
-        .with_mass(2.0);
-
-        assert_eq!(node.id, "test");
-        assert_eq!(node.title, "Test Node");
-        assert_eq!(node.position.x, 1.0);
-        assert_eq!(node.position.y, 2.0);
-        assert_eq!(node.position.z, 3.0);
-        assert_eq!(node.velocity.x, 0.1);
-        assert_eq!(node.velocity.y, 0.2);
-        assert_eq!(node.velocity.z, 0.3);
-        assert_eq!(node.mass, 2.0);
-        assert_eq!(node.metadata, metadata);
-        assert_eq!(node.created_at, 1234567890);
-    }
-
-    #[test]
-    fn test_edge_creation() {
-        let mut metadata = HashMap::new();
-        metadata.insert("type".to_string(), "reference".to_string());
-
-        let edge = Edge::new(
-            "source".to_string(),
-            "target".to_string(),
-            1.5,
-            metadata.clone(),
-        );
-
-        assert_eq!(edge.source, "source");
-        assert_eq!(edge.target, "target");
-        assert_eq!(edge.weight, 1.5);
-        assert_eq!(edge.metadata, metadata);
-    }
-
-    #[test]
-    fn test_graph_operations() {
-        let mut graph = GraphData::new();
-        let node1 = Node::new(
-            "1".to_string(),
-            "Node 1".to_string(),
-            1234567890,
-            HashMap::new(),
-        );
-        let node2 = Node::new(
-            "2".to_string(),
-            "Node 2".to_string(),
-            1234567891,
-            HashMap::new(),
-        );
-
-        graph.add_node(node1.clone());
-        graph.add_node(node2.clone());
-
-        let edge = Edge::new(
-            "1".to_string(),
-            "2".to_string(),
-            1.0,
-            HashMap::new(),
-        );
-        graph.add_edge(edge);
-
-        assert_eq!(graph.nodes.len(), 2);
-        assert_eq!(graph.edges.len(), 1);
-        assert_eq!(graph.get_node("1").unwrap().id, "1");
-        assert_eq!(graph.get_edges_for_node("1").len(), 1);
-
-        graph.clear();
-        assert_eq!(graph.nodes.len(), 0);
-        assert_eq!(graph.edges.len(), 0);
+        Self {
+            nodes: Vec::new(),
+            edges: Vec::new(),
+            metadata: MetadataStore::new(),
+        }
     }
 }
diff --git a/src/models/simulation_params.rs b/src/models/simulation_params.rs
index 2da6e9cc..14756c34 100755
--- a/src/models/simulation_params.rs
+++ b/src/models/simulation_params.rs
@@ -1,21 +1,38 @@
 use serde::{Deserialize, Serialize};
+use bytemuck::{Pod, Zeroable};
 
-#[derive(Debug, Clone, Serialize, Deserialize)]
+#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
+#[serde(rename_all = "camelCase")]
+pub enum SimulationMode {
+    Remote,  // GPU-accelerated remote computation
+    GPU,     // Local GPU computation
+    Local,   // CPU-based computation
+}
+
+impl Default for SimulationMode {
+    fn default() -> Self {
+        SimulationMode::Remote
+    }
+}
+
+#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
+#[serde(rename_all = "camelCase")]
 pub enum SimulationPhase {
-    Initial,
-    Dynamic,
-    Static,
+    Initial,    // Heavy computation for initial layout
+    Dynamic,    // Lighter computation for dynamic updates
+    Finalize,   // Final positioning and cleanup
 }
 
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub enum SimulationMode {
-    Global,
-    Local,
-    GPU,
+impl Default for SimulationPhase {
+    fn default() -> Self {
+        SimulationPhase::Initial
+    }
 }
 
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct SimulationParams {
+// GPU-compatible simulation parameters
+#[repr(C)]
+#[derive(Default, Clone, Copy, Pod, Zeroable, Debug)]
+pub struct GPUSimulationParams {
     pub iterations: u32,
     pub spring_length: f32,
     pub spring_strength: f32,
@@ -23,96 +40,80 @@ pub struct SimulationParams {
     pub attraction: f32,
     pub damping: f32,
     pub time_step: f32,
-    pub max_velocity: f32,
-    pub phase: SimulationPhase,
-    pub mode: SimulationMode,
+    pub padding: u32,  // For alignment
 }
 
-impl Default for SimulationParams {
-    fn default() -> Self {
-        Self {
-            iterations: 500,
-            spring_length: 50.0,
-            spring_strength: 0.05,
-            repulsion: 10.0,
-            attraction: 0.2,
-            damping: 0.95,
-            time_step: 0.1,
-            max_velocity: 5.0,
-            phase: SimulationPhase::Dynamic,
-            mode: SimulationMode::Local,
-        }
-    }
+#[derive(Default, Serialize, Deserialize, Clone, Debug)]
+#[serde(rename_all = "camelCase")]
+pub struct SimulationParams {
+    pub iterations: u32,           // Range: 1-500, Default: varies by phase
+    pub spring_length: f32,        // Range: 10-500, Default: 100
+    pub spring_strength: f32,      // Range: 0.1-10, Default: 0.5
+    pub repulsion: f32,           // Range: 1-1000, Default: 100
+    pub attraction: f32,          // Range: 0.1-10, Default: 1.0
+    pub damping: f32,             // Range: 0-1, Default: 0.5
+    pub time_step: f32,           // Range: 0.01-1, Default: 0.2 (5fps)
+    pub phase: SimulationPhase,   // Current simulation phase
+    pub mode: SimulationMode,     // Computation mode
 }
 
 impl SimulationParams {
     pub fn new() -> Self {
-        Self::default()
-    }
-
-    pub fn with_iterations(mut self, iterations: u32) -> Self {
-        self.iterations = iterations;
-        self
-    }
-
-    pub fn with_spring_length(mut self, spring_length: f32) -> Self {
-        self.spring_length = spring_length;
-        self
-    }
-
-    pub fn with_spring_strength(mut self, spring_strength: f32) -> Self {
-        self.spring_strength = spring_strength;
-        self
-    }
-
-    pub fn with_repulsion(mut self, repulsion: f32) -> Self {
-        self.repulsion = repulsion;
-        self
-    }
-
-    pub fn with_attraction(mut self, attraction: f32) -> Self {
-        self.attraction = attraction;
-        self
-    }
-
-    pub fn with_damping(mut self, damping: f32) -> Self {
-        self.damping = damping;
-        self
-    }
-
-    pub fn with_time_step(mut self, time_step: f32) -> Self {
-        self.time_step = time_step;
-        self
-    }
-
-    pub fn with_max_velocity(mut self, max_velocity: f32) -> Self {
-        self.max_velocity = max_velocity;
-        self
-    }
-
-    pub fn with_phase(mut self, phase: SimulationPhase) -> Self {
-        self.phase = phase;
-        self
+        Self {
+            iterations: 100,
+            spring_length: 100.0,
+            spring_strength: 0.5,
+            repulsion: 100.0,
+            attraction: 1.0,
+            damping: 0.5,
+            time_step: 0.2,        // Updated to 5fps
+            phase: SimulationPhase::Initial,
+            mode: SimulationMode::Remote,
+        }
     }
 
-    pub fn with_mode(mut self, mode: SimulationMode) -> Self {
-        self.mode = mode;
-        self
+    pub fn with_phase(phase: SimulationPhase) -> Self {
+        match phase {
+            SimulationPhase::Initial => Self {
+                iterations: 300,           // Reduced from 500
+                spring_length: 100.0,
+                spring_strength: 0.5,      // Reduced from 1.0
+                repulsion: 100.0,          // Reduced from 200.0
+                attraction: 1.0,           // Reduced from 2.0
+                damping: 0.95,            // Increased from 0.9
+                time_step: 0.2,           // Updated to 5fps
+                phase,
+                mode: SimulationMode::Remote,
+            },
+            SimulationPhase::Dynamic => Self {
+                iterations: 50,
+                spring_length: 100.0,
+                spring_strength: 0.5,
+                repulsion: 100.0,
+                attraction: 1.0,
+                damping: 0.5,
+                time_step: 0.2,           // Updated to 5fps
+                phase,
+                mode: SimulationMode::Remote,
+            },
+            SimulationPhase::Finalize => Self {
+                iterations: 200,
+                spring_length: 100.0,
+                spring_strength: 0.1,
+                repulsion: 50.0,
+                attraction: 0.5,
+                damping: 0.95,
+                time_step: 0.2,           // Updated to 5fps
+                phase,
+                mode: SimulationMode::Remote,
+            },
+        }
     }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
 
-    #[test]
-    fn test_simulation_params_builder() {
-        let params = SimulationParams::new()
-            .with_iterations(1000)
-            .with_spring_length(100.0)
-            .with_spring_strength(0.1)
-            .with_repulsion(20.0)
-            .with_attraction(0.3)
+    // Convert to GPU-compatible parameters
+    pub fn to_gpu_params(&self) -> GPUSimulationParams {
+        GPUSimulationParams {
+            iterations: self.iterations,
             spring_length: self.spring_length,
             spring_strength: self.spring_strength,
             repulsion: self.repulsion,
diff --git a/src/services/graph_service.rs b/src/services/graph_service.rs
index b8a360f7..67a305fe 100755
--- a/src/services/graph_service.rs
+++ b/src/services/graph_service.rs
@@ -1,204 +1,439 @@
 use std::sync::Arc;
 use tokio::sync::RwLock;
-use log::{debug, error};
+use std::collections::{HashMap, HashSet};
+use actix_web::web;
+use log::{info, warn};
+use rand::Rng;
+use serde_json;
 
 use crate::models::graph::GraphData;
-use crate::models::node::Node;
+use crate::utils::socket_flow_messages::Node;
 use crate::models::edge::Edge;
 use crate::models::metadata::MetadataStore;
-use crate::models::simulation_params::SimulationParams;
+use crate::app_state::AppState;
 use crate::utils::gpu_compute::GPUCompute;
+use crate::models::simulation_params::{SimulationParams, SimulationPhase, SimulationMode};
+use crate::models::pagination::PaginatedGraphData;
 
+#[derive(Clone)]
 pub struct GraphService {
     pub graph_data: Arc<RwLock<GraphData>>,
-    pub gpu_compute: Option<Arc<RwLock<GPUCompute>>>,
 }
 
 impl GraphService {
     pub fn new() -> Self {
-        Self {
+        let graph_service = Self {
             graph_data: Arc::new(RwLock::new(GraphData::default())),
-            gpu_compute: None,
-        }
+        };
+
+        // Start simulation loop
+        let graph_data = graph_service.graph_data.clone();
+        tokio::spawn(async move {
+            let params = SimulationParams {
+                iterations: 1,  // One iteration per frame
+                spring_length: 50.0,  // Match ideal_length in CPU layout
+                spring_strength: 0.05,  // Reduced for stability
+                repulsion: 10.0,  // Significantly reduced repulsion
+                attraction: 0.2,  // Reduced attraction
+                damping: 0.95,  // Higher damping for more stability
+                time_step: 0.1,  // Match dt in CPU layout
+                phase: SimulationPhase::Dynamic,
+                mode: SimulationMode::Local,  // Use CPU for continuous updates
+            };
+
+            loop {
+                // Update positions
+                let mut graph = graph_data.write().await;
+                if let Err(e) = Self::calculate_layout_cpu(
+                    &mut graph,
+                    params.iterations,
+                    params.spring_strength,
+                    params.damping
+                ) {
+                    warn!("[Graph] Error updating positions: {}", e);
+                }
+                drop(graph); // Release lock
+
+                // Sleep for ~16ms (60fps)
+                tokio::time::sleep(tokio::time::Duration::from_millis(16)).await;
+            }
+        });
+
+        graph_service
     }
 
-    pub fn with_gpu(gpu_compute: Arc<RwLock<GPUCompute>>) -> Self {
-        Self {
-            graph_data: Arc::new(RwLock::new(GraphData::default())),
-            gpu_compute: Some(gpu_compute),
+    pub async fn build_graph_from_metadata(metadata: &MetadataStore) -> Result<GraphData, Box<dyn std::error::Error + Send + Sync>> {
+        let mut graph = GraphData::new();
+        let mut edge_map = HashMap::new();
+
+        // First pass: Create nodes from files in metadata
+        let mut valid_nodes = HashSet::new();
+        for file_name in metadata.keys() {
+            let node_id = file_name.trim_end_matches(".md").to_string();
+            valid_nodes.insert(node_id);
         }
-    }
 
-    pub async fn build_graph_from_metadata(metadata: &MetadataStore) -> Result<GraphData, Box<dyn std::error::Error>> {
-        let mut graph = GraphData::default();
-
-        // Create nodes from metadata
-        for (id, item) in metadata.items() {
-            let node = Node::new(
-                id.clone(),
-                item.title.clone(),
-                item.created_at,
-                item.metadata.clone(),
-            );
+        // Create nodes for all valid node IDs
+        for node_id in &valid_nodes {
+            let mut node = Node::new(node_id.clone());
+            
+            // Get metadata for this node
+            if let Some(metadata) = metadata.get(&format!("{}.md", node_id)) {
+                node.size = Some(metadata.node_size as f32);
+                node.file_size = metadata.file_size as u64;
+                node.label = node_id.clone(); // Set label to node ID (filename without .md)
+                
+                // Add metadata fields to node's metadata map
+                node.metadata.insert("fileSize".to_string(), metadata.file_size.to_string());
+                node.metadata.insert("hyperlinkCount".to_string(), metadata.hyperlink_count.to_string());
+                node.metadata.insert("lastModified".to_string(), metadata.last_modified.to_string());
+            }
+            
             graph.nodes.push(node);
         }
 
-        // Create edges from metadata links
-        for (source_id, item) in metadata.items() {
-            for link in &item.links {
-                if metadata.contains_key(&link.target) {
-                    let edge = Edge::new(
-                        source_id.clone(),
-                        link.target.clone(),
-                        link.weight,
-                        link.metadata.clone(),
-                    );
-                    graph.edges.push(edge);
+        // Store metadata in graph
+        graph.metadata = metadata.clone();
+
+        // Second pass: Create edges from topic counts
+        for (source_file, metadata) in metadata.iter() {
+            let source_id = source_file.trim_end_matches(".md").to_string();
+            
+            for (target_file, count) in &metadata.topic_counts {
+                let target_id = target_file.trim_end_matches(".md").to_string();
+                
+                // Only create edge if both nodes exist and they're different
+                if source_id != target_id && valid_nodes.contains(&target_id) {
+                    let edge_key = if source_id < target_id {
+                        (source_id.clone(), target_id.clone())
+                    } else {
+                        (target_id.clone(), source_id.clone())
+                    };
+
+                    edge_map.entry(edge_key)
+                        .and_modify(|weight| *weight += *count as f32)
+                        .or_insert(*count as f32);
                 }
             }
         }
 
+        // Convert edge map to edges
+        graph.edges = edge_map.into_iter()
+            .map(|((source, target), weight)| {
+                Edge::new(source, target, weight)
+            })
+            .collect();
+
+        // Initialize random positions
+        Self::initialize_random_positions(&mut graph);
+
+        info!("Built graph with {} nodes and {} edges", graph.nodes.len(), graph.edges.len());
         Ok(graph)
     }
 
-    pub async fn update_node_positions(&self, nodes: &[Node]) -> Result<(), Box<dyn std::error::Error>> {
-        let mut graph = self.graph_data.write().await;
-        for update_node in nodes {
-            if let Some(node) = graph.nodes.iter_mut().find(|n| n.id == update_node.id) {
-                node.set_position(update_node.position());
-                node.set_velocity(update_node.velocity());
+    pub async fn build_graph(state: &web::Data<AppState>) -> Result<GraphData, Box<dyn std::error::Error + Send + Sync>> {
+        let current_graph = state.graph_service.graph_data.read().await;
+        let mut graph = GraphData::new();
+
+        // Copy metadata from current graph
+        graph.metadata = current_graph.metadata.clone();
+
+        let mut edge_map = HashMap::new();
+
+        // Create nodes from metadata entries
+        let mut valid_nodes = HashSet::new();
+        for file_name in graph.metadata.keys() {
+            let node_id = file_name.trim_end_matches(".md").to_string();
+            valid_nodes.insert(node_id);
+        }
+
+        // Create nodes for all valid node IDs
+        for node_id in &valid_nodes {
+            let mut node = Node::new(node_id.clone());
+            
+            // Get metadata for this node
+            if let Some(metadata) = graph.metadata.get(&format!("{}.md", node_id)) {
+                node.size = Some(metadata.node_size as f32);
+                node.file_size = metadata.file_size as u64;
+                node.label = node_id.clone(); // Set label to node ID (filename without .md)
+                
+                // Add metadata fields to node's metadata map
+                node.metadata.insert("fileSize".to_string(), metadata.file_size.to_string());
+                node.metadata.insert("hyperlinkCount".to_string(), metadata.hyperlink_count.to_string());
+                node.metadata.insert("lastModified".to_string(), metadata.last_modified.to_string());
             }
+            
+            graph.nodes.push(node);
         }
-        Ok(())
-    }
 
-    pub async fn step_simulation(&self, params: &SimulationParams) -> Result<(), Box<dyn std::error::Error>> {
-        // Try GPU compute first
-        if let Some(gpu) = &self.gpu_compute {
-            match self.step_simulation_gpu(gpu, params).await {
-                Ok(_) => return Ok(()),
-                Err(e) => {
-                    error!("GPU simulation failed, falling back to CPU: {}", e);
-                    // Fall through to CPU simulation
+        // Create edges from metadata topic counts
+        for (source_file, metadata) in graph.metadata.iter() {
+            let source_id = source_file.trim_end_matches(".md").to_string();
+            
+            // Process outbound links from this file to other topics
+            for (target_file, count) in &metadata.topic_counts {
+                let target_id = target_file.trim_end_matches(".md").to_string();
+                
+                // Only create edge if both nodes exist and they're different
+                if source_id != target_id && valid_nodes.contains(&target_id) {
+                    let edge_key = if source_id < target_id {
+                        (source_id.clone(), target_id.clone())
+                    } else {
+                        (target_id.clone(), source_id.clone())
+                    };
+
+                    // Sum the weights for bi-directional references
+                    edge_map.entry(edge_key)
+                        .and_modify(|w| *w += *count as f32)
+                        .or_insert(*count as f32);
                 }
             }
         }
 
-        // Fall back to CPU simulation
-        self.step_simulation_cpu(params).await
+        // Convert edge map to edges
+        graph.edges = edge_map.into_iter()
+            .map(|((source, target), weight)| {
+                Edge::new(source, target, weight)
+            })
+            .collect();
+
+        // Initialize random positions for all nodes
+        Self::initialize_random_positions(&mut graph);
+
+        info!("Built graph with {} nodes and {} edges", graph.nodes.len(), graph.edges.len());
+        Ok(graph)
     }
 
-    async fn step_simulation_gpu(
-        &self,
-        gpu: &Arc<RwLock<GPUCompute>>,
-        params: &SimulationParams,
-    ) -> Result<(), Box<dyn std::error::Error>> {
-        let mut gpu = gpu.write().await;
-        gpu.step()?;
+    fn initialize_random_positions(graph: &mut GraphData) {
+        let mut rng = rand::thread_rng();
+        let node_count = graph.nodes.len() as f32;
+        let initial_radius = 100.0; // Larger initial radius
+        let golden_ratio = (1.0 + 5.0_f32.sqrt()) / 2.0;
         
-        // Update graph data from GPU
-        let nodes = gpu.get_node_data()?;
-        self.update_node_positions(&nodes).await?;
-        
-        Ok(())
+        // Use Fibonacci sphere distribution for more uniform initial positions
+        for (i, node) in graph.nodes.iter_mut().enumerate() {
+            let i = i as f32;
+            
+            // Calculate Fibonacci sphere coordinates
+            let theta = 2.0 * std::f32::consts::PI * i / golden_ratio;
+            let phi = (1.0 - 2.0 * (i + 0.5) / node_count).acos();
+            
+            // Add slight randomness to prevent exact overlaps
+            let r = initial_radius * (0.9 + rng.gen_range(0.0..0.2));
+            
+            node.set_x(r * phi.sin() * theta.cos());
+            node.set_y(r * phi.sin() * theta.sin());
+            node.set_z(r * phi.cos());
+            
+            // Initialize with zero velocity
+            node.set_vx(0.0);
+            node.set_vy(0.0);
+            node.set_vz(0.0);
+        }
     }
 
-    async fn step_simulation_cpu(&self, params: &SimulationParams) -> Result<(), Box<dyn std::error::Error>> {
-        let mut graph = self.graph_data.write().await;
-        
-        // Calculate forces
-        let mut forces = vec![(0.0f32, 0.0f32, 0.0f32); graph.nodes.len()];
-        
-        // Node repulsion
-        for i in 0..graph.nodes.len() {
-            for j in (i + 1)..graph.nodes.len() {
-                let dx = graph.nodes[j].x() - graph.nodes[i].x();
-                let dy = graph.nodes[j].y() - graph.nodes[i].y();
-                let dz = graph.nodes[j].z() - graph.nodes[i].z();
-                
-                let distance = (dx * dx + dy * dy + dz * dz).sqrt().max(0.1);
-                let force = params.repulsion_strength / (distance * distance);
+    pub async fn calculate_layout(
+        gpu_compute: &Option<Arc<RwLock<GPUCompute>>>,
+        graph: &mut GraphData,
+        params: &SimulationParams,
+    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
+        match gpu_compute {
+            Some(gpu) => {
+                info!("Using GPU for layout calculation");
+                let mut gpu_compute = gpu.write().await;
                 
-                let fx = dx * force / distance;
-                let fy = dy * force / distance;
-                let fz = dz * force / distance;
+                // Only initialize positions for new graphs
+                if graph.nodes.iter().all(|n| n.x() == 0.0 && n.y() == 0.0 && n.z() == 0.0) {
+                    Self::initialize_random_positions(graph);
+                }
                 
-                forces[i].0 -= fx;
-                forces[i].1 -= fy;
-                forces[i].2 -= fz;
+                gpu_compute.update_graph_data(graph)?;
+                gpu_compute.update_simulation_params(params)?;
                 
-                forces[j].0 += fx;
-                forces[j].1 += fy;
-                forces[j].2 += fz;
+                // Run iterations with more frequent updates
+                for _ in 0..params.iterations {
+                    gpu_compute.step()?;
+                    
+                    // Update positions every iteration for smoother motion
+                    // gpu_compute.get_node_data() now returns socket_flow_messages::NodeData directly
+                    let updated_nodes = gpu_compute.get_node_data()?;
+                    for (i, node) in graph.nodes.iter_mut().enumerate() {
+                        node.data = updated_nodes[i].clone();
+                    }
+                }
+                Ok(())
+            },
+            None => {
+                warn!("GPU not available. Falling back to CPU-based layout calculation.");
+                Self::calculate_layout_cpu(graph, params.iterations, params.spring_strength, params.damping)?;
+                Ok(())
             }
         }
+    }
+
+    fn calculate_layout_cpu(graph: &mut GraphData, iterations: u32, spring_strength: f32, damping: f32) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
+        let repulsion_strength = spring_strength * 1000.0; // Reduced repulsion strength
+        let min_distance = 0.1; // Minimum distance to prevent division by zero
         
-        // Edge spring forces
-        for edge in &graph.edges {
-            if let (Some(source_idx), Some(target_idx)) = (
-                graph.nodes.iter().position(|n| n.id == edge.source),
-                graph.nodes.iter().position(|n| n.id == edge.target)
-            ) {
-                let source = &graph.nodes[source_idx];
-                let target = &graph.nodes[target_idx];
+        for _ in 0..iterations {
+            // Calculate forces between nodes
+            let mut forces = vec![(0.0, 0.0, 0.0); graph.nodes.len()];
+            
+            // Calculate repulsion forces
+            for i in 0..graph.nodes.len() {
+                for j in i+1..graph.nodes.len() {
+                    let dx = graph.nodes[j].x() - graph.nodes[i].x();
+                    let dy = graph.nodes[j].y() - graph.nodes[i].y();
+                    let dz = graph.nodes[j].z() - graph.nodes[i].z();
+                    
+                    let distance_squared = dx * dx + dy * dy + dz * dz;
+                    let distance = distance_squared.sqrt().max(min_distance);
+                    
+                    // Use inverse square law with clamped maximum force
+                    let force = (repulsion_strength / distance_squared).min(100.0);
+                    
+                    // Normalize direction vector
+                    let fx = (dx / distance) * force;
+                    let fy = (dy / distance) * force;
+                    let fz = (dz / distance) * force;
+                    
+                    forces[i].0 -= fx;
+                    forces[i].1 -= fy;
+                    forces[i].2 -= fz;
+                    
+                    forces[j].0 += fx;
+                    forces[j].1 += fy;
+                    forces[j].2 += fz;
+                }
+            }
+
+            // Calculate spring forces along edges
+            let ideal_length = 50.0; // Ideal spring length
+            let max_spring_force = 10.0; // Maximum spring force
+            
+            for edge in &graph.edges {
+                // Find indices of source and target nodes
+                let source_idx = graph.nodes.iter().position(|n| n.id == edge.source);
+                let target_idx = graph.nodes.iter().position(|n| n.id == edge.target);
                 
-                let dx = target.x() - source.x();
-                let dy = target.y() - source.y();
-                let dz = target.z() - source.z();
+                if let (Some(si), Some(ti)) = (source_idx, target_idx) {
+                    let source = &graph.nodes[si];
+                    let target = &graph.nodes[ti];
+                    
+                    let dx = target.x() - source.x();
+                    let dy = target.y() - source.y();
+                    let dz = target.z() - source.z();
+                    
+                    let distance_squared = dx * dx + dy * dy + dz * dz;
+                    let distance = distance_squared.sqrt().max(0.1); // Prevent division by zero
+                    
+                    // Calculate spring force with ideal length and weight
+                    let displacement = distance - ideal_length;
+                    let force = (spring_strength * displacement * edge.weight)
+                        .clamp(-max_spring_force, max_spring_force);
+                    
+                    // Normalize direction vector and apply force
+                    let fx = (dx / distance) * force;
+                    let fy = (dy / distance) * force;
+                    let fz = (dz / distance) * force;
+                    
+                    forces[si].0 += fx;
+                    forces[si].1 += fy;
+                    forces[si].2 += fz;
+                    
+                    forces[ti].0 -= fx;
+                    forces[ti].1 -= fy;
+                    forces[ti].2 -= fz;
+                }
+            }
+            
+            // Apply forces and update positions with stability constraints
+            let max_velocity = 5.0; // Maximum allowed velocity
+            let dt = 0.1; // Time step for integration
+            
+            for (i, node) in graph.nodes.iter_mut().enumerate() {
+                // Update velocity with damping and clamping
+                let mut vx = node.vx() + forces[i].0 * dt;
+                let mut vy = node.vy() + forces[i].1 * dt;
+                let mut vz = node.vz() + forces[i].2 * dt;
                 
-                let distance = (dx * dx + dy * dy + dz * dz).sqrt().max(0.1);
-                let displacement = distance - params.spring_length;
-                let force = params.spring_strength * displacement * edge.weight;
+                // Apply damping
+                vx *= damping;
+                vy *= damping;
+                vz *= damping;
                 
-                let fx = dx * force / distance;
-                let fy = dy * force / distance;
-                let fz = dz * force / distance;
+                // Clamp velocity magnitude
+                let v_mag = (vx * vx + vy * vy + vz * vz).sqrt();
+                if v_mag > max_velocity {
+                    let scale = max_velocity / v_mag;
+                    vx *= scale;
+                    vy *= scale;
+                    vz *= scale;
+                }
                 
-                forces[source_idx].0 += fx;
-                forces[source_idx].1 += fy;
-                forces[source_idx].2 += fz;
+                // Update position using clamped velocity
+                let x = node.x() + vx * dt;
+                let y = node.y() + vy * dt;
+                let z = node.z() + vz * dt;
                 
-                forces[target_idx].0 -= fx;
-                forces[target_idx].1 -= fy;
-                forces[target_idx].2 -= fz;
+                // Store updated values
+                node.set_vx(vx);
+                node.set_vy(vy);
+                node.set_vz(vz);
+                node.set_x(x);
+                node.set_y(y);
+                node.set_z(z);
             }
         }
+        Ok(())
+    }
+
+    pub async fn get_paginated_graph_data(
+        &self,
+        page: u32,
+        page_size: u32,
+    ) -> Result<PaginatedGraphData, Box<dyn std::error::Error + Send + Sync>> {
+        let graph = self.graph_data.read().await;
         
-        // Update positions
-        for (i, node) in graph.nodes.iter_mut().enumerate() {
-            let mut vx = node.vx() + forces[i].0 * params.time_step;
-            let mut vy = node.vy() + forces[i].1 * params.time_step;
-            let mut vz = node.vz() + forces[i].2 * params.time_step;
-            
-            // Apply damping
-            vx *= params.damping;
-            vy *= params.damping;
-            vz *= params.damping;
-            
-            // Clamp velocity
-            let v_mag = (vx * vx + vy * vy + vz * vz).sqrt();
-            if v_mag > params.max_velocity {
-                let scale = params.max_velocity / v_mag;
-                vx *= scale;
-                vy *= scale;
-                vz *= scale;
-            }
-            
-            // Update position
-            let x = node.x() + vx * params.time_step;
-            let y = node.y() + vy * params.time_step;
-            let z = node.z() + vz * params.time_step;
-            
-            node.set_position([x, y, z]);
-            node.set_velocity([vx, vy, vz]);
-        }
+        // Convert page and page_size to usize for vector operations
+        let page = page as usize;
+        let page_size = page_size as usize;
+        let total_nodes = graph.nodes.len();
         
-        Ok(())
+        let start = page * page_size;
+        let end = std::cmp::min((page + 1) * page_size, total_nodes);
+
+        let page_nodes: Vec<Node> = graph.nodes
+            .iter()
+            .skip(start)
+            .take(end - start)
+            .cloned()
+            .collect();
+
+        // Get edges that connect to these nodes
+        let node_ids: HashSet<String> = page_nodes.iter()
+            .map(|n| n.id.clone())
+            .collect();
+
+        let edges: Vec<Edge> = graph.edges
+            .iter()
+            .filter(|e| node_ids.contains(&e.source) || node_ids.contains(&e.target))
+            .cloned()
+            .collect();
+
+        Ok(PaginatedGraphData {
+            nodes: page_nodes,
+            edges: edges.clone(),
+            metadata: serde_json::to_value(graph.metadata.clone()).unwrap_or_default(),
+            total_nodes,
+            total_edges: graph.edges.len(),
+            total_pages: ((total_nodes as f32 / page_size as f32).ceil()) as u32,
+            current_page: page as u32,
+        })
     }
-}
 
-impl Default for GraphService {
-    fn default() -> Self {
-        Self::new()
+    pub async fn get_node_positions(&self) -> Vec<Node> {
+        let graph = self.graph_data.read().await;
+        graph.nodes.clone()
     }
 }
