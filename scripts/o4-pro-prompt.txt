<file_tree>
logseqSpringThing/
├── client/
│   ├── src/
│   │   ├── app/
│   │   │   ├── components/
│   │   │   │   ├── ConversationPane.tsx
│   │   │   │   ├── MarkdownDisplayPanel.tsx
│   │   │   │   ├── NarrativeGoldminePanel.tsx
│   │   │   │   └── RightPaneControlPanel.tsx
│   │   │   ├── App.tsx
│   │   │   ├── AppInitializer.tsx
│   │   │   ├── main.tsx
│   │   │   └── TwoPaneLayout.tsx
│   │   ├── components/
│   │   │   └── layout/
│   │   │       ├── ControlPanel.tsx
│   │   │       └── ViewportContainer.tsx
│   │   ├── contexts/
│   │   │   ├── ApplicationModeContext.tsx
│   │   │   └── WindowSizeContext.tsx
│   │   ├── features/
│   │   │   ├── auth/
│   │   │   │   ├── components/
│   │   │   │   │   ├── AuthUIHandler.tsx
│   │   │   │   │   └── NostrAuthSection.tsx
│   │   │   │   ├── hooks/
│   │   │   │   │   └── useAuth.ts
│   │   │   │   └── initAuth.ts
│   │   │   ├── graph/
│   │   │   │   ├── components/
│   │   │   │   │   ├── GraphCanvas.tsx
│   │   │   │   │   ├── GraphManager.tsx
│   │   │   │   │   └── GraphViewport.tsx
│   │   │   │   ├── managers/
│   │   │   │   │   ├── graphDataManager.ts
│   │   │   │   │   └── graphWorkerProxy.ts
│   │   │   │   └── workers/
│   │   │   │       └── graph.worker.ts
│   │   │   ├── settings/
│   │   │   │   ├── components/
│   │   │   │   │   ├── panels/
│   │   │   │   │   │   ├── AIPanel.tsx
│   │   │   │   │   │   ├── SettingsPanelRedesign.tsx
│   │   │   │   │   │   ├── SystemPanel.tsx
│   │   │   │   │   │   ├── VisualisationPanel.tsx
│   │   │   │   │   │   └── XRPanel.tsx
│   │   │   │   │   ├── BackendUrlSetting.tsx
│   │   │   │   │   ├── control-panel-context.tsx
│   │   │   │   │   ├── SettingControlComponent.tsx
│   │   │   │   │   ├── SettingsSection.tsx
│   │   │   │   │   └── SettingsSubsection.tsx
│   │   │   │   ├── config/
│   │   │   │   │   ├── defaultSettings.ts
│   │   │   │   │   ├── settings.ts
│   │   │   │   │   ├── settingsConfig.ts
│   │   │   │   │   └── settingsUIDefinition.ts
│   │   │   │   └── types/
│   │   │   │       ├── settingsSchema.ts
│   │   │   │       ├── settingsTypes.ts
│   │   │   │       └── uiSetting.ts
│   │   │   ├── visualisation/
│   │   │   │   ├── components/
│   │   │   │   │   ├── ActionButtons.tsx
│   │   │   │   │   ├── CameraController.tsx
│   │   │   │   │   ├── HologramVisualisation.tsx
│   │   │   │   │   └── MetadataVisualizer.tsx
│   │   │   │   ├── managers/
│   │   │   │   │   └── sceneManager.ts
│   │   │   │   ├── renderers/
│   │   │   │   │   ├── materials/
│   │   │   │   │   │   └── HologramMaterial.tsx
│   │   │   │   │   ├── HologramManager.tsx
│   │   │   │   │   └── TextRenderer.tsx
│   │   │   │   ├── types/
│   │   │   │   │   └── visualisationTypes.ts
│   │   │   │   └── utils/
│   │   │   │       └── animations.ts
│   │   │   └── xr/
│   │   │       ├── components/
│   │   │       │   ├── ui/
│   │   │       │   │   └── XRControlPanel.tsx
│   │   │       │   ├── XRController.tsx
│   │   │       │   ├── XRScene.tsx
│   │   │       │   └── XRVisualisationConnector.tsx
│   │   │       ├── hooks/
│   │   │       │   ├── useSafeXRHooks.tsx
│   │   │       │   └── useXRContextCheck.tsx
│   │   │       ├── managers/
│   │   │       │   ├── xrInitializer.ts
│   │   │       │   └── xrSessionManager.ts
│   │   │       ├── providers/
│   │   │       │   ├── SafeXRProvider.tsx
│   │   │       │   ├── XRContextWrapper.tsx
│   │   │       │   └── XRCoreProvider.tsx
│   │   │       ├── systems/
│   │   │       │   └── HandInteractionSystem.tsx
│   │   │       └── types/
│   │   │           ├── webxr-extensions.d.ts
│   │   │           └── xr.ts
│   │   ├── hooks/
│   │   │   ├── useContainerSize.ts
│   │   │   └── useWindowSize.ts
│   │   ├── services/
│   │   │   ├── api.ts
│   │   │   ├── nostrAuthService.ts
│   │   │   ├── platformManager.ts
│   │   │   ├── settingsService.ts
│   │   │   └── WebSocketService.ts
│   │   ├── store/
│   │   │   └── settingsStore.ts
│   │   ├── styles/
│   │   │   ├── globals.css
│   │   │   ├── index.css
│   │   │   └── tokens.css
│   │   ├── types/
│   │   │   ├── binaryProtocol.ts
│   │   │   ├── getalby-sdk.d.ts
│   │   │   ├── lucide-react.d.ts
│   │   │   ├── nip07.d.ts
│   │   │   ├── node-env.d.ts
│   │   │   ├── ragflowTypes.ts
│   │   │   ├── react-syntax-highlighter.d.ts
│   │   │   ├── tailwind-merge.d.ts
│   │   │   └── webxr-extensions.d.ts
│   │   ├── ui/
│   │   │   ├── formGroup/
│   │   │   │   └── FormGroup.tsx
│   │   │   ├── markdown/
│   │   │   │   └── MarkdownRenderer.tsx
│   │   │   ├── Button.tsx
│   │   │   ├── Card.tsx
│   │   │   ├── Collapsible.tsx
│   │   │   ├── Input.tsx
│   │   │   ├── Label.tsx
│   │   │   ├── RadioGroup.tsx
│   │   │   ├── Select.tsx
│   │   │   ├── Slider.tsx
│   │   │   ├── Switch.tsx
│   │   │   ├── Tabs.tsx
│   │   │   ├── ThemeProvider.tsx
│   │   │   ├── ThemeSelector.tsx
│   │   │   ├── Toast.tsx
│   │   │   ├── Toaster.tsx
│   │   │   ├── Tooltip.tsx
│   │   │   └── useToast.tsx
│   │   └── utils/
│   │       ├── binaryUtils.ts
│   │       ├── caseConversion.ts
│   │       ├── cn.ts
│   │       ├── debugState.ts
│   │       ├── deepMerge.ts
│   │       ├── logger.ts
│   │       ├── objectPath.ts
│   │       └── utils.ts
│   ├── index.html
│   ├── package.json
│   ├── postcss.config.cjs
│   ├── tailwind.config.js
│   ├── tsconfig.json
│   ├── vite-start.js
│   └── vite.config.ts
├── data/
│   └── settings.yaml
├── docs/
│   ├── api/
│   │   ├── index.md
│   │   ├── rest.md
│   │   └── websocket.md
│   ├── client/
│   │   ├── architecture.md
│   │   ├── components.md
│   │   ├── core.md
│   │   ├── index.md
│   │   ├── rendering.md
│   │   ├── settings-panel-redesign.md
│   │   ├── state.md
│   │   ├── types.md
│   │   ├── user-controls-summary.md
│   │   ├── visualization.md
│   │   ├── websocket-readiness.md
│   │   ├── websocket.md
│   │   └── xr.md
│   ├── deployment/
│   │   ├── docker.md
│   │   └── index.md
│   ├── overview/
│   │   └── architecture.md
│   ├── technical/
│   │   └── decoupled-graph-architecture.md
│   └── index.md
├── scripts/
│   ├── dev.sh
│   └── launch-production.sh
├── Cargo.toml
├── config.yml
├── docker-compose.dev.yml
├── docker-compose.production.yml
├── docker-compose.yml
├── Dockerfile
├── Dockerfile.dev
├── Dockerfile.production
└── nginx.conf

</file_tree>

<files>
workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/index.html
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/index.html
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Logseq Force Directed Knowledge Graph</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/app/main.tsx"></script>
  </body>
</html>
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/package.json
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/package.json
```json
{
  "name": "logseq-spring-thing-client",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint src --ext ts,tsx --report-unused-disable-directives"
  },
  "dependencies": {
    "@getalby/sdk": "^4.1.1",
    "@radix-ui/react-collapsible": "^1.1.4",
    "@radix-ui/react-dialog": "^1.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.7",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-radio-group": "^1.1.3",
    "@radix-ui/react-select": "^2.2.4",
    "@radix-ui/react-slider": "^1.2.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.1.4",
    "@radix-ui/react-toast": "^1.2.7",
    "@radix-ui/react-tooltip": "^1.2.0",
    "@radix-ui/themes": "^3.2.1",
    "@react-three/drei": "^9.80.0",
    "@react-three/fiber": "^8.15.0",
    "@react-three/postprocessing": "^2.15.0",
    "@react-three/xr": "^6.0.0",
    "@types/node": "^22.14.1",
    "@types/three": "^0.175.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "comlink": "^4.4.1",
    "framer-motion": "^12.6.5",
    "hls.js": "^1.6.2",
    "immer": "^10.1.1",
    "lucide-react": "^0.487.0",
    "nostr-tools": "^2.12.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-markdown": "^10.1.0",
    "react-rnd": "^10.5.2",
    "react-syntax-highlighter": "^15.6.1",
    "remark-gfm": "^4.0.1",
    "tailwind-merge": "^3.2.0",
    "three": "^0.175.0",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4.1.7",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@types/uuid": "^10.0.0",
    "@vitejs/plugin-react": "^4.3.4",
    "autoprefixer": "^10.4.21",
    "postcss": "^8.5.3",
    "tailwindcss": "^4.1.3",
    "typescript": "^5.8.3",
    "vite": "^6.2.6"
  }
}

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/postcss.config.cjs
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/postcss.config.cjs
```cjs
module.exports = {
  plugins: {
    '@tailwindcss/postcss': {},
    autoprefixer: {},
  },
};
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/app/App.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/app/App.tsx
```tsx
import { useEffect, Component, ReactNode, useCallback } from 'react'
import AppInitializer from './AppInitializer'
import { ThemeProvider } from '../ui/ThemeProvider'
import { ApplicationModeProvider } from '../contexts/ApplicationModeContext'
import { Toaster } from '../ui/Toaster'
import XRCoreProvider from '../features/xr/providers/XRCoreProvider'
import { useSettingsStore } from '../store/settingsStore'
import { createLogger, createErrorMetadata } from '../utils/logger'
import TwoPaneLayout from './TwoPaneLayout'; // Added import for TwoPaneLayout

import '../styles/tokens.css'
const logger = createLogger('App')

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}

class ErrorBoundary extends Component<ErrorBoundaryProps, { hasError: boolean; error: Error | null; errorInfo: any }> {
  state = { hasError: false, error: null, errorInfo: null };

  static getDerivedStateFromError(error: any) {
    return { hasError: true, error };
  }

  componentDidCatch(error: any, errorInfo: any) {
    logger.error('React error boundary caught error:', {
      ...createErrorMetadata(error),
      component: errorInfo?.componentStack
        ? errorInfo.componentStack.split('\n')[1]?.trim()
        : 'Unknown component'
    });
    this.setState({ errorInfo });
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="p-4 bg-destructive text-destructive-foreground rounded-md">
          <h2 className="text-xl font-bold mb-2">Something went wrong</h2>
          <p className="mb-4">The application encountered an error. Try refreshing the page.</p>
          {process.env.NODE_ENV === 'development' && (
            <pre className="bg-muted p-2 rounded text-sm overflow-auto">
              {this.state.error
                ? (this.state.error.message || String(this.state.error))
                : 'No error details available'}
            </pre>
          )}
        </div>
      );
    }
    return this.props.children;
  }
}

function App() {
  // Removed isLoading, panel visibility states, isSimpleMode state
  // Select the primitive value directly to avoid unnecessary re-renders
  const initialized = useSettingsStore(state => state.initialized)

  // Simplified useEffect, only checking initialization
  useEffect(() => {
    // No need to set isLoading here if AppInitializer handles it or SimpleGraphPage has its own loading state
  }, [initialized])

  // Wrap handleInitialized in useCallback to stabilize its reference
  const handleInitialized = useCallback(() => {
    const settings = useSettingsStore.getState().settings;
    const debugEnabled = settings?.system?.debug?.enabled === true;
    if (debugEnabled) {
      logger.debug('Application initialized');
    }
    // No need for setIsLoading(false) here if SimpleGraphPage handles its own loading
  }, []) // Dependency array is empty as it only uses getState

  // Removed viewport control handlers (handleResetCamera, etc.) as they belong in SimpleGraphPage or its children
  // Removed panel toggle handlers (handleToggleLeftPanel, etc.)
  // Removed handleViewportResize callback

  // No longer need the isSimpleMode check, always render SimpleGraphPage

  return (
    <ThemeProvider defaultTheme="dark">
      {/* Removed WindowSizeProvider */}
      <ErrorBoundary>
        <ApplicationModeProvider>
          {/* Removed PanelProvider */}
          <XRCoreProvider>
            {/* Render TwoPaneLayout only after settings are initialized */}
            {initialized ? <TwoPaneLayout /> : <div>Loading application...</div>}
            <AppInitializer onInitialized={handleInitialized} />
            {/* Toaster remains at the top level */}
            <Toaster />
          </XRCoreProvider>
        </ApplicationModeProvider>
      </ErrorBoundary>
    </ThemeProvider>
  )
}

export default App

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/app/AppInitializer.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/app/AppInitializer.tsx
```tsx
import React, { useEffect } from 'react';
import { createLogger, createErrorMetadata } from '../utils/logger';
import { debugState } from '../utils/debugState';
import { useSettingsStore } from '../store/settingsStore';
import WebSocketService from '../services/WebSocketService';
import { graphDataManager } from '../features/graph/managers/graphDataManager';
import { initializeAuth } from '../features/auth/initAuth';

const loadServices = async (): Promise<void> => {
  if (debugState.isEnabled()) {
    logger.info('Initializing services...');
  }

  try {
    // Initialize auth system
    await initializeAuth();

    if (debugState.isEnabled()) {
      logger.info('Auth system initialized');
    }
  } catch (error) {
    logger.error('Error initializing services:', createErrorMetadata(error));
  }
}

const logger = createLogger('AppInitializer');

interface AppInitializerProps {
  onInitialized: () => void;
}

const AppInitializer: React.FC<AppInitializerProps> = ({ onInitialized }) => {
  const { settings, initialize } = useSettingsStore();

  useEffect(() => {
    const initApp = async () => {
      // Load services first
      await loadServices();

      if (debugState.isEnabled()) {
        logger.info('Starting application initialization...');
        }

        try {
          // Initialize settings
          const settings = await initialize();

          // Apply debug settings safely
          if (settings.system?.debug) {
            try {
              const debugSettings = settings.system.debug;
              debugState.enableDebug(debugSettings.enabled);
              if (debugSettings.enabled) {
                debugState.enableDataDebug(debugSettings.enableDataDebug);
                debugState.enablePerformanceDebug(debugSettings.enablePerformanceDebug);
              }
            } catch (debugError) {
              logger.warn('Error applying debug settings:', createErrorMetadata(debugError));
            }
          }

          // Try to initialize WebSocket
          if (typeof WebSocketService !== 'undefined' && typeof graphDataManager !== 'undefined') {
            try {
              // Initialize WebSocket
              await initializeWebSocket(settings);
              // logger.info('WebSocket initialization deliberately disabled - using REST API only.'); // Commented out the disabling message
            } catch (wsError) {
              logger.error('WebSocket initialization failed, continuing with UI only:', createErrorMetadata(wsError));
              // We'll proceed without WebSocket connectivity
            }
          } else {
            logger.warn('WebSocket services not available, continuing with UI only');
          }

          // Fetch initial graph data AFTER settings and BEFORE signaling completion
          try {
            logger.info('Fetching initial graph data via REST API');
            await graphDataManager.fetchInitialData();
            if (debugState.isDataDebugEnabled()) {
              logger.debug('Initial graph data fetched successfully');
            }
          } catch (fetchError) {
            logger.error('Failed to fetch initial graph data:', createErrorMetadata(fetchError));
            // Initialize with empty data as fallback
            await graphDataManager.setGraphData({ nodes: [], edges: [] });
          }

          if (debugState.isEnabled()) {
            logger.info('Application initialized successfully');
          }

          // Signal that initialization is complete
          onInitialized();

      } catch (error) {
          logger.error('Failed to initialize application components:', createErrorMetadata(error));
          // Even if initialization fails, try to signal completion to show UI
          onInitialized();
      }
    };

    initApp();
  }, [initialize, onInitialized]);

  // Initialize WebSocket and set up event handlers - now safer with more error handling
  const initializeWebSocket = async (settings: any): Promise<void> => {
    try {
      const websocketService = WebSocketService.getInstance();

      // Handle binary position updates from WebSocket
      websocketService.onBinaryMessage((data) => {
        if (data instanceof ArrayBuffer) {
          try {
            // Log receipt of binary data only if data debug is enabled
            if (debugState.isDataDebugEnabled()) {
              logger.info(`Received binary data from WebSocket: ${data.byteLength} bytes`);
            }

            // Process binary position update through graph data manager
            graphDataManager.updateNodePositions(data).then(() => {
              if (debugState.isDataDebugEnabled()) {
                logger.debug(`Processed binary position update: ${data.byteLength} bytes`);
              }
            }).catch(error => {
              logger.error('Failed to process binary position update via worker:', createErrorMetadata(error));
            });
          } catch (error) {
            logger.error('Failed to process binary position update:', createErrorMetadata(error));

            // Add diagnostic info in debug mode
            if (debugState.isEnabled()) {
              // Display basic info about the data
              logger.debug(`Binary data size: ${data.byteLength} bytes`);

              // Display the first few bytes for debugging - helps detect compression headers
              try {
                const view = new DataView(data);
                const hexBytes = [];
                const maxBytesToShow = Math.min(16, data.byteLength);

                for (let i = 0; i < maxBytesToShow; i++) {
                  hexBytes.push(view.getUint8(i).toString(16).padStart(2, '0'));
                }

                logger.debug(`First ${maxBytesToShow} bytes: ${hexBytes.join(' ')}`);

                // Check if data might be compressed (zlib headers)
                if (data.byteLength >= 2) {
                  const firstByte = view.getUint8(0);
                  const secondByte = view.getUint8(1);
                  if (firstByte === 0x78 && (secondByte === 0x01 || secondByte === 0x9C || secondByte === 0xDA)) {
                    logger.debug('Data appears to be zlib compressed (has zlib header)');
                  }
                }
              } catch (e) {
                logger.debug('Could not display binary data preview');
              }

              // Check if the data length is a multiple of expected formats
              const nodeSize = 26; // 2 bytes (ID) + 12 bytes (position) + 12 bytes (velocity)
              if (data.byteLength % nodeSize !== 0) {
                logger.debug(`Invalid data length: not a multiple of ${nodeSize} bytes per node (remainder: ${data.byteLength % nodeSize})`);
              }
            }
          }
        }
      });

      // Set up connection status handler
      websocketService.onConnectionStatusChange((connected) => {
        if (debugState.isEnabled()) {
          logger.info(`WebSocket connection status changed: ${connected}`);
        }

        // Check if websocket is both connected AND ready (received 'connection_established' message)
        if (connected) {
          try {
            if (websocketService.isReady()) {
              // WebSocket is fully ready, now it's safe to enable binary updates
              logger.info('WebSocket is connected and fully established - enabling binary updates');
              graphDataManager.setBinaryUpdatesEnabled(true);

              // Subscribe to position updates
              logger.info('Sending subscribe_position_updates message to server');
              websocketService.sendMessage('subscribe_position_updates', {
                binary: true,
                interval: settings?.system?.websocket?.updateRate || 60
              });

              if (debugState.isDataDebugEnabled()) {
                logger.debug('Binary updates enabled and subscribed to position updates');
              }
            } else {
              logger.info('WebSocket connected but not fully established yet - waiting for readiness');

              // We'll let graphDataManager handle the binary updates enablement
              // through its retry mechanism that now checks for websocket readiness
              graphDataManager.enableBinaryUpdates();

              // Set up a listener for the 'connection_established' message
              const unsubscribe = websocketService.onMessage((message) => {
                if (message.type === 'connection_established') {
                  // Now that we're fully connected, subscribe to position updates
                  logger.info('Connection established message received, sending subscribe_position_updates');
                  websocketService.sendMessage('subscribe_position_updates', {
                    binary: true,
                    interval: settings?.system?.websocket?.updateRate || 60
                  });
                  unsubscribe(); // Remove this one-time listener

                  if (debugState.isDataDebugEnabled()) {
                    logger.debug('Connection established, subscribed to position updates');
                  }
                }
              });
            }
          } catch (connectionError) {
            logger.error('Error during WebSocket status change handling:', createErrorMetadata(connectionError));
          }
        }
      });

      // Configure GraphDataManager with WebSocket service (adapter pattern)
      if (websocketService) {
        const wsAdapter = {
          send: (data: ArrayBuffer) => {
            websocketService.sendRawBinaryData(data);
          },
          isReady: () => websocketService.isReady()
        };
        graphDataManager.setWebSocketService(wsAdapter);
      }

      try {
        // Connect WebSocket
        await websocketService.connect();
      } catch (connectError) {
        logger.error('Failed to connect to WebSocket:', createErrorMetadata(connectError));
      }
    } catch (error) {
      logger.error('Failed during WebSocket/data initialization:', createErrorMetadata(error));
      throw error;
    }
  };

  return null; // This component doesn't render anything directly
};

export default AppInitializer;

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/app/TwoPaneLayout.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/app/TwoPaneLayout.tsx
```tsx
import React, { useState, useCallback, CSSProperties } from 'react';
import GraphViewport from '../features/graph/components/GraphViewport';
import RightPaneControlPanel from './components/RightPaneControlPanel';
import ConversationPane from './components/ConversationPane'; // Add this
import NarrativeGoldminePanel from './components/NarrativeGoldminePanel';

const TwoPaneLayout: React.FC = () => {
  // Initialize leftPaneWidth to 80% of window width, or a fallback.
  const [leftPaneWidth, setLeftPaneWidth] = useState<number>(() => {
    if (typeof window !== 'undefined') {
      return window.innerWidth * 0.8;
    }
    return 600; // Fallback for environments without window object during initial SSR/render
  });
  const [isDraggingVertical, setIsDraggingVertical] = useState<boolean>(false);
  const [isRightPaneDocked, setIsRightPaneDocked] = useState<boolean>(false);

  // State for TOP horizontal splitter in right pane (dividing Control Panel and the rest)
  // Initial heights will be set by useEffect
  const [rightPaneTopHeight, setRightPaneTopHeight] = useState<number>(200);
  const [isDraggingHorizontalTop, setIsDraggingHorizontalTop] = useState<boolean>(false);

  // State for the new BOTTOM horizontal splitter within the lower part of the right pane
  const [bottomRightUpperHeight, setBottomRightUpperHeight] = useState<number>(200);
  const [isDraggingHorizontalBottom, setIsDraggingHorizontalBottom] = useState<boolean>(false);
  const [isBottomPaneDocked, setIsBottomPaneDocked] = useState<boolean>(false);
  const [isLowerRightPaneDocked, setIsLowerRightPaneDocked] = useState<boolean>(false); // New state for docking middle and bottom panes

  const handleVerticalMouseDown = useCallback((e: React.MouseEvent) => {
    setIsDraggingVertical(true);
    e.preventDefault();
  }, []);

  const handleVerticalMouseUp = useCallback(() => {
    setIsDraggingVertical(false);
  }, []);

  const handleVerticalMouseMove = useCallback(
    (e: MouseEvent) => {
      if (isDraggingVertical && !isRightPaneDocked) {
        const newWidth = e.clientX;
        // Ensure the new width is within reasonable bounds (e.g., not too small or too large)
        const minPaneWidth = 50; // Minimum width for any pane
        const maxPaneWidth = window.innerWidth - minPaneWidth - 10; // 10 for divider
        if (newWidth > minPaneWidth && newWidth < maxPaneWidth) {
          setLeftPaneWidth(newWidth);
        }
      }
    },
    [isDraggingVertical, isRightPaneDocked]
  );

  // Event handlers for TOP horizontal splitter
  const handleHorizontalTopMouseDown = useCallback((e: React.MouseEvent) => {
    setIsDraggingHorizontalTop(true);
    e.preventDefault();
  }, []);

  const handleHorizontalTopMouseUp = useCallback(() => {
    setIsDraggingHorizontalTop(false);
  }, []);

  const handleHorizontalTopMouseMove = useCallback(
    (e: MouseEvent) => {
      if (isDraggingHorizontalTop) {
        const rightPaneContainer = document.getElementById('right-pane-container');
        if (rightPaneContainer) {
            const rightPaneRect = rightPaneContainer.getBoundingClientRect();
            const newTopPanelHeight = e.clientY - rightPaneRect.top;

            const minPanelHeight = 50;
            const dividerHeight = 10; // From horizontalTopDividerStyle and horizontalBottomDividerStyle

            // Ensure top panel doesn't get too small or too large, leaving space for two other panels and two dividers
            if (newTopPanelHeight > minPanelHeight &&
                newTopPanelHeight < (rightPaneRect.height - (2 * minPanelHeight + 2 * dividerHeight))) {

                setRightPaneTopHeight(newTopPanelHeight);

                // Recalculate height for the middle panel (ConversationPane)
                // so it and the bottom panel (NarrativeGoldminePanel) share the remaining space equally.
                const remainingHeightForBottomTwo = rightPaneRect.height - newTopPanelHeight - dividerHeight;
                const heightForOneOfTheBottomTwo = (remainingHeightForBottomTwo - dividerHeight) / 2;

                if (heightForOneOfTheBottomTwo > minPanelHeight) {
                    setBottomRightUpperHeight(heightForOneOfTheBottomTwo);
                } else {
                    setBottomRightUpperHeight(minPanelHeight);
                    // If ConversationPane is at minHeight, NarrativeGoldminePanel will take the rest due to flex-grow.
                }
            }
        }
      }
    },
    [isDraggingHorizontalTop] // setBottomRightUpperHeight should be added if it's not stable via dispatch
  );

  // Event handlers for BOTTOM horizontal splitter
  const handleHorizontalBottomMouseDown = useCallback((e: React.MouseEvent) => {
    setIsDraggingHorizontalBottom(true);
    e.preventDefault();
  }, []);

  const handleHorizontalBottomMouseUp = useCallback(() => {
    setIsDraggingHorizontalBottom(false);
  }, []);

  const handleHorizontalBottomMouseMove = useCallback(
    (e: MouseEvent) => {
      if (isDraggingHorizontalBottom) {
        const bottomRightContainer = document.getElementById('right-pane-bottom-container');
        if (bottomRightContainer) {
            const rect = bottomRightContainer.getBoundingClientRect();
            const relativeNewHeight = e.clientY - rect.top;
            // Min 50 for upper (ConversationPane), 60 for lower (NarrativeGoldminePanel + its potential minHeight + divider)
            if (relativeNewHeight > 50 && relativeNewHeight < rect.height - 60) {
                 setBottomRightUpperHeight(relativeNewHeight);
            }
        }
      }
    },
    [isDraggingHorizontalBottom]
  );

  const toggleRightPaneDock = () => {
    setIsRightPaneDocked(!isRightPaneDocked);
  };

  const toggleBottomPaneDock = () => {
    setIsBottomPaneDocked(!isBottomPaneDocked);
  };

  const toggleLowerRightPaneDock = () => {
    setIsLowerRightPaneDocked(!isLowerRightPaneDocked);
  };

  // Effect for setting initial pane widths and heights
  React.useEffect(() => {
    const updateLayout = () => {
      if (typeof window !== 'undefined') {
        if (!isDraggingVertical) {
          setLeftPaneWidth(isRightPaneDocked ? window.innerWidth : window.innerWidth * 0.8);
        }

        // Calculate heights for right pane panels
        const rightPaneContainer = document.getElementById('right-pane-container');
        if (rightPaneContainer && !isDraggingHorizontalTop && !isDraggingHorizontalBottom) {
          const totalHeight = rightPaneContainer.clientHeight;
          const dividerHeight = 10;

          if (isLowerRightPaneDocked) {
            // When lower right pane is docked, top pane takes all available space
            setRightPaneTopHeight(totalHeight);
          } else if (isBottomPaneDocked) {
            // When bottom pane is docked, ConversationPane takes all available space below the top panel
            const remainingHeight = totalHeight - rightPaneTopHeight - dividerHeight;
            setBottomRightUpperHeight(remainingHeight > 50 ? remainingHeight : 50);
          } else {
            // Normal three-panel split
            const panelHeight = (totalHeight - 2 * dividerHeight) / 3;
            setRightPaneTopHeight(panelHeight > 50 ? panelHeight : 50);
            setBottomRightUpperHeight(panelHeight > 50 ? panelHeight : 50);
          }
        }
      }
    };

    updateLayout(); // Initial setup

    window.addEventListener('resize', updateLayout);
    return () => window.removeEventListener('resize', updateLayout);
  }, [isRightPaneDocked, isDraggingVertical, isDraggingHorizontalTop, isDraggingHorizontalBottom]);


  // Add and remove mouse move/up listeners on the window for dragging
  React.useEffect(() => {
    const handleGlobalMouseMove = (e: MouseEvent) => {
      handleVerticalMouseMove(e);
      handleHorizontalTopMouseMove(e);
      handleHorizontalBottomMouseMove(e);
    };

    const handleGlobalMouseUp = () => {
      handleVerticalMouseUp();
      handleHorizontalTopMouseUp();
      handleHorizontalBottomMouseUp();
    };

    if (isDraggingVertical || isDraggingHorizontalTop || isDraggingHorizontalBottom) {
      window.addEventListener('mousemove', handleGlobalMouseMove);
      window.addEventListener('mouseup', handleGlobalMouseUp);
    } else {
      window.removeEventListener('mousemove', handleGlobalMouseMove);
      window.removeEventListener('mouseup', handleGlobalMouseUp);
    }
    return () => {
      window.removeEventListener('mousemove', handleGlobalMouseMove);
      window.removeEventListener('mouseup', handleGlobalMouseUp);
    };
  }, [
      isDraggingVertical, isDraggingHorizontalTop, isDraggingHorizontalBottom,
      handleVerticalMouseMove, handleHorizontalTopMouseMove, handleHorizontalBottomMouseMove,
      handleVerticalMouseUp, handleHorizontalTopMouseUp, handleHorizontalBottomMouseUp
    ]);

  const containerStyle: CSSProperties = {
    display: 'flex',
    height: '100vh', // Full viewport height
    overflow: 'hidden', // Prevent scrollbars on the container itself
  };

  const leftPaneStyle: CSSProperties = {
    width: isRightPaneDocked ? '100%' : `${leftPaneWidth}px`,
    minWidth: '50px', // Minimum width for the left pane
    // backgroundColor: '#f0f0f0', // Removed, canvas has its own
    // padding: '20px', // Removed, GraphViewport handles its own layout
    // overflow: 'auto', // Removed, GraphViewport handles its own overflow/scroll
    height: '100%', // Ensure left pane takes full height for the canvas
    position: 'relative', // For potential absolute positioned elements within GraphViewport
    transition: 'width 0.3s ease', // Smooth transition for docking
    borderRight: isRightPaneDocked ? 'none' : '1px solid #cccccc', // Visual delineation
  };

  const dividerStyle: CSSProperties = {
    width: '10px',
    cursor: isRightPaneDocked ? 'default' : 'ew-resize', // Change cursor when docked
    backgroundColor: '#cccccc',
    display: isRightPaneDocked ? 'none' : 'flex', // Hide divider when docked
    alignItems: 'center',
    justifyContent: 'center',
    userSelect: 'none',
  };

  const rightPaneContainerStyle: CSSProperties = { // Renamed for clarity
    flexGrow: 1,
    display: isRightPaneDocked ? 'none' : 'flex', // Use flex column for top/bottom sections
    flexDirection: 'column',
    overflow: 'hidden', // Containing div handles overflow
    height: '100vh', // Ensure it takes full viewport height
  };

  const rightPaneTopStyle: CSSProperties = {
    height: isLowerRightPaneDocked ? '100%' : `${rightPaneTopHeight}px`, // Take full height when lower is docked
    flexGrow: isLowerRightPaneDocked ? 1 : 0, // Allow it to grow when lower is docked
    minHeight: '50px',
    // backgroundColor: '#e0e0e0', // Removed, panel has its own
    // padding: '10px', // Removed, panel has its own
    overflowY: 'auto',   // Allow scrolling of panel content
    position: 'relative',
  };

  const horizontalTopDividerStyle: CSSProperties = {
    height: '10px',
    cursor: 'ns-resize',
    backgroundColor: '#b0b0b0',
    display: isLowerRightPaneDocked ? 'none' : 'flex', // Hide when lower is docked
    alignItems: 'center',
    justifyContent: 'center',
    userSelect: 'none',
    borderTop: '1px solid #999999',
    borderBottom: '1px solid #999999',
    flexShrink: 0,
  };

  const rightPaneBottomContainerStyle: CSSProperties = {
    flexGrow: 1,
    minHeight: isLowerRightPaneDocked ? '0px' : '110px', // Collapse when lower is docked
    display: isLowerRightPaneDocked ? 'none' : 'flex', // Hide when lower is docked
    flexDirection: 'column',
    overflow: 'hidden',
    backgroundColor: '#d0d0d0', // Base for this area
  };

  const bottomRightUpperStyle: CSSProperties = {
    height: isBottomPaneDocked ? 'auto' : `${bottomRightUpperHeight}px`, // Auto height when docked
    flexGrow: isBottomPaneDocked ? 1 : 0, // Take all available space when docked
    minHeight: '50px',
    // backgroundColor: '#d8d8d8', // Panel has its own bg
    padding: '0px', // Panel has its own padding
    overflowY: 'hidden', // Panel handles scroll
    position: 'relative',
  };

  const horizontalBottomDividerStyle: CSSProperties = { // New divider
    height: '10px',
    cursor: 'ns-resize',
    backgroundColor: '#a0a0a0',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    userSelect: 'none',
    borderTop: '1px solid #888888',
    borderBottom: '1px solid #888888',
    flexShrink: 0,
  };

  const bottomRightLowerStyle: CSSProperties = {
    flexGrow: 1,
    minHeight: isBottomPaneDocked ? '0px' : '50px', // Collapse when docked
    height: isBottomPaneDocked ? '0px' : 'auto', // Collapse when docked
    display: isBottomPaneDocked ? 'none' : 'flex', // Hide when docked
    // backgroundColor: '#c8c8c8', // Panel has its own bg
    padding: '0px', // Panel has its own padding
    overflowY: 'hidden', // Panel handles scroll
    position: 'relative',
  };

  const dockButtonStyle: CSSProperties = {
    position: 'absolute',
    top: '10px',
    right: isRightPaneDocked ? '10px' : `${10 + (isRightPaneDocked ? 0 : 0)}px`, // Adjust button position
    zIndex: 100,
    padding: '5px 10px',
    cursor: 'pointer',
  };


  return (
    <div style={containerStyle}>
      <div style={leftPaneStyle}>
        <GraphViewport />
      </div>
      <div
        style={dividerStyle}
        onMouseDown={!isRightPaneDocked ? handleVerticalMouseDown : undefined}
        title={isRightPaneDocked ? "" : "Drag to resize"}
      >
        ||
      </div>
      <div id="right-pane-container" style={rightPaneContainerStyle}>
        {!isRightPaneDocked && (
          <>
            <div style={rightPaneTopStyle}>
              <RightPaneControlPanel toggleLowerRightPaneDock={toggleLowerRightPaneDock} isLowerRightPaneDocked={isLowerRightPaneDocked} />
            </div>
            {!isLowerRightPaneDocked && ( // Hide divider and lower container when docked
              <>
                <div
                  style={horizontalTopDividerStyle}
                  onMouseDown={handleHorizontalTopMouseDown}
                  title="Drag to resize Control Panel / Lower Area"
                >
                  ══
                </div>
                <div id="right-pane-bottom-container" style={rightPaneBottomContainerStyle}>
                  <div style={bottomRightUpperStyle}>
                    <ConversationPane />
                    {/* Dock button for ConversationPane */}
                    <button
                      onClick={toggleBottomPaneDock}
                      style={{
                        position: 'absolute',
                        bottom: '10px',
                        right: '10px',
                        zIndex: 100,
                        padding: '5px 10px',
                        cursor: 'pointer',
                      }}
                      title={isBottomPaneDocked ? "Expand Lower Panel" : "Collapse Lower Panel"}
                    >
                      {isBottomPaneDocked ? '^' : 'v'}
                    </button>
                  </div>
                  {!isBottomPaneDocked && (
                    <>
                      <div
                        style={horizontalBottomDividerStyle}
                        onMouseDown={handleHorizontalBottomMouseDown}
                        title="Drag to resize Markdown / Narrative Goldmine"
                      >
                        ══
                      </div>
                      <div style={bottomRightLowerStyle}>
                        <NarrativeGoldminePanel />
                      </div>
                    </>
                  )}
                </div>
              </>
            )}
          </>
        )}
      </div>
      <button onClick={toggleRightPaneDock} style={dockButtonStyle} title={isRightPaneDocked ? "Expand Right Pane" : "Collapse Right Pane"}>
        {isRightPaneDocked ? '>' : '<'}
      </button>
    </div>
  );
};

export default TwoPaneLayout;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/app/components/ConversationPane.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/app/components/ConversationPane.tsx
```tsx
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Button } from '../../ui/Button';
import { Input } from '../../ui/Input';
import { Send } from 'lucide-react';
import { apiService } from '../../services/api';
import { useSettingsStore } from '../../store/settingsStore'; // For auth check
import { nostrAuth } from '../../services/nostrAuthService'; // For getting token
import { createLogger, createErrorMetadata } from '../../utils/logger';
import MarkdownRenderer from '../../ui/markdown/MarkdownRenderer'; // For rendering bot responses
import { RagflowChatRequestPayload, RagflowChatResponsePayload } from '../../types/ragflowTypes'; // Import DTOs

const logger = createLogger('ConversationPane');

interface Message {
  id: string;
  sender: 'user' | 'bot';
  text: string;
}

const ConversationPane: React.FC = () => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [currentInput, setCurrentInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [sessionId, setSessionId] = useState<string | null>(null);

  const authUser = useSettingsStore(state => state.user);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(scrollToBottom, [messages]);

  const isPowerUser = authUser?.isPowerUser === true;

  const handleSendMessage = useCallback(async () => {
    if (!currentInput.trim() || isLoading || !isPowerUser) return;

    const userMessage: Message = { id: Date.now().toString() + '_user', sender: 'user', text: currentInput };
    setMessages(prev => [...prev, userMessage]);
    const question = currentInput;
    setCurrentInput('');
    setIsLoading(true);
    setError(null);

    try {
      const headers: Record<string, string> = {};
      if (nostrAuth.isAuthenticated()) {
        const nostrUser = nostrAuth.getCurrentUser();
        const token = nostrAuth.getSessionToken();
        if (nostrUser && token) {
          headers['X-Nostr-Pubkey'] = nostrUser.pubkey;
          headers['Authorization'] = `Bearer ${token}`;
        }
      }

      const payload: RagflowChatRequestPayload = { question, sessionId: sessionId ?? undefined, stream: false };
      const response: RagflowChatResponsePayload = await apiService.sendRagflowChatMessage(payload, headers);

      const botMessage: Message = { id: response.sessionId + '_bot', sender: 'bot', text: response.answer };
      setMessages(prev => [...prev, botMessage]);
      setSessionId(response.sessionId);
    } catch (err: any) {
      logger.error('Error sending RAGFlow message:', createErrorMetadata(err));
      const errorMessageText = err.message || 'Failed to get response.';
      setError(errorMessageText);
      const errorMessage: Message = { id: Date.now().toString() + '_error', sender: 'bot', text: `Error: ${errorMessageText}` };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  }, [currentInput, isLoading, sessionId, isPowerUser]);

  if (!isPowerUser && !authUser) { // Show loading or placeholder if authUser is not yet loaded
    return (
      <div className="flex flex-col items-center justify-center h-full p-4 bg-card text-card-foreground">
        <p className="text-muted-foreground">Loading user information...</p>
      </div>
    );
  }

  if (!isPowerUser) {
    return (
      <div className="flex flex-col items-center justify-center h-full p-4 bg-card text-card-foreground">
        <p className="text-lg font-semibold text-muted-foreground">RAGFlow Chat</p>
        <p className="text-sm text-muted-foreground mt-2">This chat feature is available for Power Users only.</p>
        <p className="text-xs text-muted-foreground mt-1">Please authenticate as a power user to enable RAGFlow chat.</p>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full p-2 bg-background text-foreground">
      <div className="flex-grow overflow-y-auto mb-2 p-2 border border-border rounded custom-scrollbar space-y-3">
        {messages.map(msg => (
          <div key={msg.id} className={`flex ${msg.sender === 'user' ? 'justify-end' : 'justify-start'}`}>
            <div
              className={`max-w-[70%] p-3 rounded-lg shadow-sm text-sm break-words ${
                msg.sender === 'user'
                  ? 'bg-primary text-primary-foreground'
                  : 'bg-secondary text-secondary-foreground'
              }`}
            >
              {msg.sender === 'bot' ? <MarkdownRenderer content={msg.text} className="prose prose-sm prose-invert max-w-none" /> : msg.text}
            </div>
          </div>
        ))}
        <div ref={messagesEndRef} />
      </div>
      {error && <p className="text-destructive text-xs mb-1 px-1">{error}</p>}
      <div className="flex items-center gap-2 p-1">
        <Input
          type="text"
          value={currentInput}
          onChange={(e) => setCurrentInput(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && !isLoading && handleSendMessage()}
          placeholder="Ask RAGFlow..."
          className="flex-grow bg-input border-border placeholder-muted-foreground"
          disabled={isLoading || !isPowerUser}
          aria-label="Chat input"
        />
        <Button
            onClick={handleSendMessage}
            disabled={isLoading || !currentInput.trim() || !isPowerUser}
            size="icon"
            variant="ghost"
            aria-label="Send message"
            className="hover:bg-primary/10"
        >
          <Send size={18} className="text-primary" />
        </Button>
      </div>
    </div>
  );
};

export default ConversationPane;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/app/components/MarkdownDisplayPanel.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/app/components/MarkdownDisplayPanel.tsx
```tsx
import React, { CSSProperties } from 'react';
import MarkdownRenderer from '../../ui/markdown/MarkdownRenderer'; // Adjusted path

const sampleMarkdownContent = `
# Markdown Display Panel

This panel uses the existing \`MarkdownRenderer\` component.

## Features
*   Renders Markdown text.
*   Supports GitHub Flavored Markdown (GFM).
*   Includes syntax highlighting for code blocks.

\`\`\`javascript
function helloWorld() {
  console.log("Hello, from the Markdown Panel!");
}
helloWorld();
\`\`\`

### More Content
You can add more Markdown content here to test scrolling and layout.
This panel is designed to fit within one of the resizable sub-panes.

${'- List item to add more content for scrolling.\n'.repeat(15)}

End of sample content.
`;

const MarkdownDisplayPanel: React.FC = () => {
  const panelStyle: CSSProperties = {
    width: '100%',
    height: '100%',
    overflowY: 'auto', // Enable vertical scroll for overflow within this panel
    padding: '10px', // Inner padding for the content area
    boxSizing: 'border-box',
    backgroundColor: '#fff', // White background for the markdown content area
  };

  return (
    <div style={panelStyle} className="custom-scrollbar">
      <MarkdownRenderer content={sampleMarkdownContent} className="" />
    </div>
  );
};

export default MarkdownDisplayPanel;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/app/components/NarrativeGoldminePanel.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/app/components/NarrativeGoldminePanel.tsx
```tsx
import React, { CSSProperties } from 'react';

const NarrativeGoldminePanel: React.FC = () => {
  const panelStyle: CSSProperties = {
    width: '100%',
    height: '100%',
    overflow: 'hidden', // Iframe will handle its own scrolling
    backgroundColor: '#000', // Optional: background while iframe loads
  };

  const iframeStyle: CSSProperties = {
    width: '100%',
    height: '100%',
    border: 'none', // Remove default iframe border
  };

  return (
    <div style={panelStyle}>
      <iframe
        id="narrative-goldmine-iframe" // Added ID
        src="https://narrativegoldmine.com//#/graph"
        style={iframeStyle}
        title="Narrative Goldmine"
        sandbox="allow-scripts allow-same-origin allow-popups allow-forms" // Standard sandbox attributes
        loading="lazy"
        referrerPolicy="no-referrer"
      ></iframe>
    </div>
  );
};

export default NarrativeGoldminePanel;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/app/components/RightPaneControlPanel.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/app/components/RightPaneControlPanel.tsx
```tsx
import React from 'react';
import { SettingsPanelRedesign } from '../../features/settings/components/panels/SettingsPanelRedesign';
import NostrAuthSection from '../../features/auth/components/NostrAuthSection';

interface RightPaneControlPanelProps {
  toggleLowerRightPaneDock: () => void;
  isLowerRightPaneDocked: boolean;
}

const RightPaneControlPanel: React.FC<RightPaneControlPanelProps> = ({ toggleLowerRightPaneDock, isLowerRightPaneDocked }) => {
  return (
    <div className="h-full flex flex-col bg-background">
      {/* Auth Section */}
      <div className="p-4 border-b">
        <NostrAuthSection />
      </div>

      {/* Settings Panel */}
      <div className="flex-1 overflow-y-auto">
        <SettingsPanelRedesign toggleLowerRightPaneDock={toggleLowerRightPaneDock} isLowerRightPaneDocked={isLowerRightPaneDocked} />
      </div>
    </div>
  );
};

export default RightPaneControlPanel;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/app/main.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/app/main.tsx
```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import '../styles/index.css'; // Use relative path

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/components/layout/ControlPanel.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/components/layout/ControlPanel.tsx
```tsx
import React from 'react';
import Tabs from '../../ui/Tabs';
import NostrAuthSection from '../../features/auth/components/NostrAuthSection';
import SystemPanel from '../../features/settings/components/panels/SystemPanel';
import VisualisationPanel from '../../features/settings/components/panels/VisualisationPanel';
import XRPanel from '../../features/settings/components/panels/XRPanel';
import AIPanel from '../../features/settings/components/panels/AIPanel';
import MarkdownRenderer from '../../ui/markdown/MarkdownRenderer';
import { Button } from '../../ui/Button';
import { Settings, Eye, Smartphone, Send, Anchor } from 'lucide-react'; // Using Settings as universal placeholder
import { settingsUIDefinition } from '../../features/settings/config/settingsUIDefinition';

const placeholderMarkdown = `
# Markdown Tab

This tab uses the \`MarkdownRenderer\` component.

*   Supports standard Markdown.
*   Includes syntax highlighting for code blocks.

\`\`\`javascript
function greet(name) {
  console.log(\`Hello, \${name}!\`);
}
greet('World');
\`\`\`

Visit [Narrative Gold Mine](https://narrativegoldmine.com/#/graph).

## Extra Content to Force Scrolling

${'- This is a repeated line to force scrolling\n'.repeat(20)}

### More Content

${'- Another repeated line with different text\n'.repeat(20)}
`;

const LowerControlPanel: React.FC = () => {
  // Define tabs for settings
  const settingsTabs = [
    { label: 'Auth', icon: <Settings size={16} />, content: <div className="p-4 overflow-y-auto h-full custom-scrollbar"><NostrAuthSection /></div> },
    { label: 'Visualisation', icon: <Eye size={16} />, content: <VisualisationPanel settingsDef={settingsUIDefinition.visualisation} /> },
    { label: 'System', icon: <Settings size={16} />, content: <SystemPanel settingsDef={settingsUIDefinition.system} /> },
    { label: 'XR', icon: <Smartphone size={16} />, content: <XRPanel settingsDef={settingsUIDefinition.xr} /> },
    { label: 'AI', icon: <Settings size={16} />, content: <AIPanel settingsDef={settingsUIDefinition.ai} /> }, // Placeholder icon for AI
  ];

  // Define tabs for tools (including NGM)
  const toolTabs = [
    { label: 'Narrative Gold Mine', icon: <Anchor size={16} />, content: (
        // Ensure the parent div allows the iframe to take full height
        <div className="w-full h-full flex flex-col overflow-hidden">
          <iframe
            src="https://narrativegoldmine.com//#/graph" // This is the external website
            className="w-full h-full border-none flex-grow" // Use flex-grow to fill space
            title="Narrative Gold Mine"
            sandbox="allow-scripts allow-same-origin allow-popups allow-forms"
            loading="lazy"
            referrerPolicy="no-referrer"
          />
        </div>
      )
    },
    { label: 'Markdown', icon: <Settings size={16} />, content: <div className="p-4 overflow-y-auto h-full custom-scrollbar"><MarkdownRenderer content={placeholderMarkdown} className="" /></div> }, // Placeholder icon for Markdown
    { label: 'LLM Query', icon: <Send size={16} />, content: (
        <div className="p-4 flex flex-col h-full">
          <textarea
            className="flex-1 mb-2 p-2 border border-border rounded bg-input text-foreground resize-none focus:outline-none focus:ring-2 focus:ring-primary custom-scrollbar"
            placeholder="Enter your query..."
          />
          <Button className="self-end">Send Query</Button>
        </div>
      )
    },
  ];

  return (
    // Main container now stacks its children vertically and ensures full height.
    <div className="flex flex-col w-full h-full bg-card text-card-foreground overflow-hidden">
      {/* Top Section: Settings Tabs - Takes 60% of the available height */}
      <div className="h-[60%] border-b border-border flex flex-col overflow-hidden">
        <Tabs
          tabs={settingsTabs}
          tabListClassName="flex-shrink-0 bg-background border-b border-border" // Tab bar doesn't shrink
          tabContentClassName="flex-grow overflow-y-auto custom-scrollbar" // Tab content area scrolls
        />
      </div>

      {/* Bottom Section: Tools Tabs (including NGM iframe) - Takes 40% of the available height */}
      <div className="h-[40%] flex flex-col overflow-hidden">
        <Tabs
          tabs={toolTabs}
          tabListClassName="flex-shrink-0 bg-background border-b border-border" // Tab bar doesn't shrink
          tabContentClassName="flex-grow overflow-y-auto custom-scrollbar" // Tab content area scrolls
        />
      </div>
    </div>
  );
};

export default LowerControlPanel;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/components/layout/ViewportContainer.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/components/layout/ViewportContainer.tsx
```tsx
import React, { useRef, useEffect, useState, type ReactNode } from 'react';
import { useSettingsStore } from '../../store/settingsStore';
import { createLogger } from '../../utils/logger';

const logger = createLogger('ViewportContainer');

interface ViewportContainerProps {
  children: ReactNode;

  /**
   * Optional callback for when the viewport size changes
   */
  onResize?: (width: number, height: number) => void;
}

/**
 * ViewportContainer serves as the main container for the Three.js visualisation.
 * It handles resize events and coordinates with the panel system to adjust its dimensions
 * when panels are docked/undocked.
 */
const ViewportContainer = ({
  children,
  onResize
}: ViewportContainerProps) => {
  const viewportRef = useRef<HTMLDivElement>(null);
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
  // Select primitive values individually to ensure stable references
  const initialized = useSettingsStore(state => state.initialized);
  const debugEnabled = useSettingsStore(state => state.settings?.system?.debug?.enabled === true);

  // Only log if debug is enabled
  if (debugEnabled) {
    logger.debug("Rendering ViewportContainer");
  }

  // Track resize events to update viewport dimensions
  useEffect(() => {
    const updateDimensions = () => {
      if (viewportRef.current) {
        const { width, height } = viewportRef.current.getBoundingClientRect();

        // Only update dimensions if they've actually changed
        if (Math.abs(dimensions.width - width) > 1 || Math.abs(dimensions.height - height) > 1) {
          setDimensions({ width, height });

          if (onResize) {
            onResize(width, height);
          }

          if (debugEnabled && width > 0 && height > 0) {
            logger.debug('Viewport dimensions:', {
              width: Math.round(width),
              height: Math.round(height),
              containerElement: viewportRef.current.parentElement
            });
          }
        }
      }
    };

    // Enhance the measurement by forcing a layout recalculation
    const forceLayoutAndMeasure = () => {
      if (viewportRef.current) {
        // Force a layout recalculation
        void viewportRef.current.offsetHeight;
        // Now measure
        updateDimensions();
      }
    };

    // Initial size measurement
    forceLayoutAndMeasure();

    // Also measure after a slight delay to catch any post-render adjustments
    const initialMeasurementTimer = setTimeout(() => {
      forceLayoutAndMeasure();
    }, 100);

    // And another measurement after layout has fully settled
    const finalMeasurementTimer = setTimeout(() => {
      forceLayoutAndMeasure();
    }, 500);

    // Add resize event listener
    window.addEventListener('resize', updateDimensions);

    // Create ResizeObserver to track container size changes
    const resizeObserver = new ResizeObserver(updateDimensions);
    if (viewportRef.current) {
      resizeObserver.observe(viewportRef.current);
    }

    return () => {
      clearTimeout(initialMeasurementTimer);
      clearTimeout(finalMeasurementTimer);
      window.removeEventListener('resize', updateDimensions);
      resizeObserver.disconnect();
    };
  }, [onResize, dimensions, debugEnabled]);

  // Trigger resize notification when initialization completes
  useEffect(() => {
    if (initialized && viewportRef.current) {
      const { width, height } = viewportRef.current.getBoundingClientRect();

      if (debugEnabled) {
        logger.debug('Viewport initialized with dimensions:', {
          width: Math.round(width),
          height: Math.round(height)
        });
      }

      if (onResize) {
        onResize(width, height);
      }
    }
  }, [initialized, onResize, debugEnabled]);

  return (
    <div
      ref={viewportRef}
      className="viewport-container relative w-full h-full min-h-0 bg-background" // Removed flex-1 class
      data-testid="viewport-container"
      style={{
        // flex: '1 1 auto', // Removed inline flex grow, rely on h-full class
        minHeight: '0',
        display: 'flex', // Keep as flex column container
        flexDirection: 'column' // Keep as flex column container
      }}
    >
      {/* Render children directly, removing the intermediate div */}
      {children}

      {/* Viewport size indicator for debugging */}
      {debugEnabled && process.env.NODE_ENV === 'development' && (
        <div className="absolute bottom-2 right-2 text-xs text-muted-foreground bg-background/70 px-2 py-1 rounded-md z-10">
          {`${Math.round(dimensions.width)} × ${Math.round(dimensions.height)}`}
        </div>
      )}
    </div>
  );
}

export default ViewportContainer;

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/contexts/ApplicationModeContext.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/contexts/ApplicationModeContext.tsx
```tsx
import { jsx as _jsx } from "react/jsx-runtime";
import { createContext, useContext, useState, useEffect } from 'react';
import { createLogger } from '../utils/logger';
const logger = createLogger('ApplicationModeContext');
const defaultContext = {
    mode: 'desktop',
    previousMode: null,
    isXRMode: false,
    isMobileView: false,
    setMode: () => { },
    layoutSettings: {
        showPanels: true,
        showViewport: true,
        showControls: true
    }
};
const ApplicationModeContext = createContext(defaultContext);
/**
 * Provider component for application mode
 */
export const ApplicationModeProvider = ({ children }) => {
    const [mode, setMode] = useState('desktop');
    const [previousMode, setPreviousMode] = useState(null);
    const [isMobileView, setIsMobileView] = useState(false);
    // Check for mobile view on mount and resize
    useEffect(() => {
        const handleResize = () => {
            const isMobile = window.innerWidth < 768; // Breakpoint for mobile view
            setIsMobileView(isMobile);
            // Auto-switch to mobile mode based on screen size
            // but don't override XR mode
            if (isMobile && mode !== 'xr') {
                setMode('mobile');
            }
            else if (!isMobile && mode === 'mobile') {
                setMode('desktop');
            }
        };
        // Initial check
        handleResize();
        // Add event listener
        window.addEventListener('resize', handleResize);
        // Cleanup
        return () => {
            window.removeEventListener('resize', handleResize);
        };
    }, [mode]);
    // Handle mode change
    const handleModeChange = (newMode) => {
        logger.info(`Changing mode: ${mode} -> ${newMode}`);
        setPreviousMode(mode);
        setMode(newMode);
    };
    // Compute layout settings based on current mode
    const getLayoutSettings = () => {
        switch (mode) {
            case 'desktop':
                return {
                    showPanels: true,
                    showViewport: true,
                    showControls: true
                };
            case 'mobile':
                return {
                    showPanels: true,
                    showViewport: true,
                    showControls: true
                };
            case 'xr':
                return {
                    showPanels: false,
                    showViewport: true,
                    showControls: false
                };
            default:
                return {
                    showPanels: true,
                    showViewport: true,
                    showControls: true
                };
        }
    };
    const contextValue = {
        mode,
        previousMode,
        isXRMode: mode === 'xr',
        isMobileView,
        setMode: handleModeChange,
        layoutSettings: getLayoutSettings()
    };
    return (_jsx(ApplicationModeContext.Provider, { value: contextValue, children: children }));
};
/**
 * Hook to use the application mode context
 */
export const useApplicationMode = () => {
    const context = useContext(ApplicationModeContext);
    if (!context) {
        throw new Error('useApplicationMode must be used within an ApplicationModeProvider');
    }
    return context;
};

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/contexts/WindowSizeContext.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/contexts/WindowSizeContext.tsx
```tsx
import { createContext, useContext, ReactNode, FC } from 'react';
import { useWindowSize, WindowSize } from '../hooks/useWindowSize';

const WindowSizeContext = createContext<WindowSize | undefined>(undefined);

interface WindowSizeProviderProps {
  children: ReactNode;
}

/**
 * Provider component that wraps the app and provides window size information
 * to all child components that need it
 */
export const WindowSizeProvider: FC<WindowSizeProviderProps> = ({ children }) => {
  const windowSize = useWindowSize();

  return (
    <WindowSizeContext.Provider value={windowSize}>
      {children}
    </WindowSizeContext.Provider>
  );
};

/**
 * Hook to use the window size context
 * Throws an error if used outside of the WindowSizeProvider
 */
export function useWindowSizeContext(): WindowSize {
  const context = useContext(WindowSizeContext);

  if (context === undefined) {
    throw new Error('useWindowSizeContext must be used within a WindowSizeProvider');
  }

  return context;
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/auth/components/AuthUIHandler.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/auth/components/AuthUIHandler.tsx
```tsx
import React, { useEffect, useState } from 'react';
import { nostrAuth, AuthState } from '../../../services/nostrAuthService';
import { createLogger, createErrorMetadata } from '../../../utils/logger';
import { Button } from '../../../ui/Button';
import { Card, CardContent } from '../../../ui/Card';

const logger = createLogger('AuthUIHandler');

interface AuthUIHandlerProps {
  className?: string;
}

/**
 * AuthUIHandler component that handles the UI for authentication
 */
const AuthUIHandler: React.FC<AuthUIHandlerProps> = ({ className = '' }) => {
  const [authState, setAuthState] = useState<AuthState>({
    authenticated: false
  });
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    // Subscribe to auth state changes
    const unsubscribe = nostrAuth.onAuthStateChanged((state) => {
      setAuthState(state);
    });

    // Cleanup subscription on unmount
    return () => {
      unsubscribe();
    };
  }, []);

  const handleLogin = async () => {
    try {
      setIsLoading(true);
      await nostrAuth.login();
    } catch (error) {
      logger.error('Login failed:', createErrorMetadata(error));
      // Error is already handled by the auth service and will be in authState
    } finally {
      setIsLoading(false);
    }
  };

  const handleLogout = async () => {
    try {
      setIsLoading(true);
      await nostrAuth.logout();
    } catch (error) {
      logger.error('Logout failed:', createErrorMetadata(error));
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className={`auth-ui-handler ${className}`}>
      {authState.authenticated && authState.user ? (
        <div className="user-info space-y-4">
          <div className="flex flex-col space-y-2">
            <div className="flex items-center justify-between">
              <span className="text-sm text-gray-400">Logged in as:</span>
              <span className="font-mono text-sm">
                {authState.user.pubkey.slice(0, 8)}...{authState.user.pubkey.slice(-8)}
              </span>
            </div>
            <div className="flex items-center justify-between">
              <span className="text-sm text-gray-400">Role:</span>
              <span className="text-sm font-medium">
                {authState.user.isPowerUser ? 'Power User' : 'Authenticated User'}
              </span>
            </div>
          </div>
          <Button
            variant="destructive"
            onClick={handleLogout}
            disabled={isLoading}
            className="w-full"
          >
            {isLoading ? 'Logging out...' : 'Logout'}
          </Button>
        </div>
      ) : (
        <div className="space-y-4">
          <Button
            onClick={handleLogin}
            disabled={isLoading}
            className="w-full"
          >
            {isLoading ? 'Connecting...' : 'Login with Nostr'}
          </Button>
          {authState.error && (
            <div className="text-red-500 text-sm mt-2">{authState.error}</div>
          )}
        </div>
      )}
    </div>
  );
};

export default AuthUIHandler;

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/auth/components/NostrAuthSection.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/auth/components/NostrAuthSection.tsx
```tsx
import React, { useEffect } from 'react'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../../../ui/Card'
import AuthUIHandler from './AuthUIHandler'
import { initializeAuth } from '../initAuth'
import { createLogger, createErrorMetadata } from '../../../utils/logger'

const logger = createLogger('NostrAuthSection');

const NostrAuthSection: React.FC = () => {
  useEffect(() => {
    // Initialize auth system when component mounts
    initializeAuth().catch(error => {
      logger.error('Failed to initialize auth system:', createErrorMetadata(error));
    });
  }, []);

  return (
    // Explicitly set dark background and text for the card to ensure theme consistency
    <Card className="bg-card text-card-foreground border-border">
      <CardHeader>
        <CardTitle>Nostr Authentication</CardTitle>
        <CardDescription>Authenticate with your Nostr key to unlock advanced features.</CardDescription>
      </CardHeader>
      <CardContent className="flex flex-col space-y-2">
        <AuthUIHandler />
      </CardContent>
    </Card>
  )
}

export default NostrAuthSection

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/auth/hooks/useAuth.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/auth/hooks/useAuth.ts
```ts
import { useState, useEffect } from 'react';
import { useSettingsStore } from '../../../store/settingsStore';
import { createLogger, createErrorMetadata } from '../../../utils/logger';
import { nostrAuth, AuthState } from '../../../services/nostrAuthService';

const logger = createLogger('useAuth');

/**
 * Hook for accessing Nostr authentication functionality
 * This hook synchronizes the auth state with the settings store
 */
const useAuth = () => {
  const { setAuthenticated, setUser, authenticated, user } = useSettingsStore();
  const [authError, setAuthError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  // Listen for auth state changes and update the settings store
  useEffect(() => {
    const unsubscribe = nostrAuth.onAuthStateChanged((state: AuthState) => {
      if (state.authenticated && state.user) {
        setAuthenticated(true);
        setUser({
          isPowerUser: state.user.isPowerUser,
          pubkey: state.user.pubkey
        });
        setAuthError(null);
      } else {
        setAuthenticated(false);
        setUser(null);
        if (state.error) {
          setAuthError(state.error);
        }
      }
    });

    return () => {
      unsubscribe();
    };
  }, [setAuthenticated, setUser]);

  const login = async () => {
    try {
      setIsLoading(true);
      setAuthError(null);
      await nostrAuth.login();
      logger.info('Login successful');
    } catch (error) {
      logger.error('Login failed:', createErrorMetadata(error));
      setAuthError(error instanceof Error ? error.message : 'Login failed');
    } finally {
      setIsLoading(false);
    }
  };

  const logout = async () => {
    try {
      setIsLoading(true);
      setAuthError(null);
      await nostrAuth.logout();
      logger.info('Logout successful');
    } catch (error) {
      logger.error('Logout failed:', createErrorMetadata(error));
      setAuthError(error instanceof Error ? error.message : 'Logout failed');
    } finally {
      setIsLoading(false);
    }
  };

  return {
    authenticated,
    user,
    authError,
    isLoading,
    login,
    logout,
  };
};

export default useAuth;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/auth/initAuth.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/auth/initAuth.ts
```ts
import { nostrAuth, AuthState } from '../../services/nostrAuthService';
import { createLogger, createErrorMetadata } from '../../utils/logger';
import { useSettingsStore } from '../../store/settingsStore';

const logger = createLogger('initAuth');

/**
 * Initialize the authentication system and subscribe to auth changes
 */
export async function initializeAuth(): Promise<void> {
  try {
    // Initialize Nostr auth service
    await nostrAuth.initialize(); // This will also trigger an initial state notification if a session exists

    // Subscribe to auth state changes from nostrAuthService
    nostrAuth.onAuthStateChanged((authState: AuthState) => {
      console.log('[initAuth] Auth state changed:', JSON.stringify(authState, null, 2)); // DEBUG CONSOLE LOG
      logger.info('Auth state changed:', authState);
      if (authState.authenticated && authState.user) {
        console.log('[initAuth] User authenticated:', JSON.stringify(authState.user, null, 2)); // DEBUG CONSOLE LOG
        useSettingsStore.getState().setUser({
          pubkey: authState.user.pubkey,
          isPowerUser: authState.user.isPowerUser,
        });
        useSettingsStore.getState().setAuthenticated(true);
        logger.info('User set in settingsStore:', authState.user);
      } else {
        console.log('[initAuth] User not authenticated or no user data.'); // DEBUG CONSOLE LOG
        useSettingsStore.getState().setUser(null);
        useSettingsStore.getState().setAuthenticated(false);
        logger.info('User cleared from settingsStore.');
      }
    });

    logger.info('Auth system initialized and listener set up successfully');
  } catch (error) {
    logger.error('Failed to initialize auth system:', createErrorMetadata(error));
    // Ensure settings store reflects unauthenticated state on error
    useSettingsStore.getState().setUser(null);
    useSettingsStore.getState().setAuthenticated(false);
    throw error;
  }
}

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/graph/components/GraphCanvas.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/graph/components/GraphCanvas.tsx
```tsx
import { useRef } from 'react';
import { Canvas, useThree } from '@react-three/fiber';
import { OrbitControls, Stats } from '@react-three/drei';

 import GraphManager from './GraphManager';
import XRController from '../../xr/components/XRController';
import XRVisualisationConnector from '../../xr/components/XRVisualisationConnector';

import { useSettingsStore } from '../../../store/settingsStore';
import { createLogger } from '../../../utils/logger';
import { debugState } from '../../../utils/debugState';

const logger = createLogger('GraphCanvas');

const SceneSetup = () => {
    const { scene } = useThree();
    const settings = useSettingsStore(state => state.settings?.visualisation);

    // Render lights using JSX
    return (
        <>
            <color attach="background" args={[0, 0, 0.8]} /> {/* Medium blue background */}
            <ambientLight intensity={0.6} />
            <directionalLight
                intensity={0.8}
                position={[1, 1, 1]}
            />
        </>
    );
};

const GraphCanvas = () => {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const { settings } = useSettingsStore();
    const showStats = settings?.system?.debug?.enablePerformanceDebug ?? false; // Use performance debug flag
    const xrEnabled = settings?.xr?.enabled !== false;
    const antialias = settings?.visualisation?.rendering?.enableAntialiasing !== false; // Correct property name

    // Removed the outer div wrapper
    return (
        <Canvas
            ref={canvasRef}
            className="r3f-canvas overflow-hidden" // Added overflow-hidden class here
            style={{
                width: '100%',
                height: '100%',
                minHeight: '0', // Ensure it can shrink
                display: 'block' // Revert to display: block
                // Removed flex properties from Canvas style
            }}
            gl={{
                antialias,
                alpha: true,
                powerPreference: 'high-performance',
                failIfMajorPerformanceCaveat: false
            }}
            camera={{
                fov: 75,
                near: 0.1,
                far: 2000, // Remove settings access, camera settings likely managed elsewhere
                position: [0, 10, 50]
            }}
            onCreated={({ gl }) => {
                if (debugState.isEnabled()) {
                    logger.debug('Canvas created with dimensions:', {
                        width: gl.domElement.width,
                        height: gl.domElement.height,
                        containerWidth: gl.domElement.parentElement?.clientWidth,
                        containerHeight: gl.domElement.parentElement?.clientHeight
                    });
                }
            }}
        >
            <SceneSetup />
            <GraphManager />
            {xrEnabled && <XRController />}
            {xrEnabled && <XRVisualisationConnector />}
            {showStats && <Stats />}
        </Canvas>
    );
};

export default GraphCanvas;

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/graph/components/GraphManager.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/graph/components/GraphManager.tsx
```tsx
import React, { useRef, useEffect, useState, useMemo, useCallback } from 'react'
import { useThree, useFrame, ThreeEvent } from '@react-three/fiber'
import { Line } from '@react-three/drei/core/Line'
import { Text, Billboard } from '@react-three/drei' // OrbitControls removed
import * as THREE from 'three'
import { graphDataManager, type GraphData, type Node as GraphNode } from '../managers/graphDataManager'
import { createLogger, createErrorMetadata } from '../../../utils/logger'
import { debugState } from '../../../utils/debugState'
import { useSettingsStore } from '../../../store/settingsStore'
import { BinaryNodeData, createBinaryNodeData } from '../../../types/binaryProtocol'

const logger = createLogger('GraphManager')

const getPositionForNode = (node: GraphNode, index: number): [number, number, number] => {
  if (!node.position ||
      (node.position.x === 0 && node.position.y === 0 && node.position.z === 0)) {
    // All nodes are at (0,0,0), so generate a random position in a sphere
    const radius = 10
    const phi = Math.acos(2 * Math.random() - 1)
    const theta = Math.random() * Math.PI * 2

    const x = radius * Math.sin(phi) * Math.cos(theta)
    const y = radius * Math.sin(phi) * Math.sin(theta)
    const z = radius * Math.cos(phi)

    // Update the original node position so edges will work
    if (node.position) {
      node.position.x = x
      node.position.y = y
      node.position.z = z
    } else {
      node.position = { x, y, z }
    }

    return [x, y, z]
  }

  return [node.position.x, node.position.y, node.position.z]
}

interface GraphManagerProps {
  onNodeDragStateChange: (isDragging: boolean) => void;
}

const GraphManager: React.FC<GraphManagerProps> = ({ onNodeDragStateChange }) => { // Accept prop
  const meshRef = useRef<THREE.InstancedMesh>(null) // Initialize with null, use THREE namespace
  // REMOVE: const orbitControlsRef = useRef<any>(null);

  // Use useMemo for stable object references across renders
  const tempMatrix = useMemo(() => new THREE.Matrix4(), [])
  const tempPosition = useMemo(() => new THREE.Vector3(), [])
  const tempScale = useMemo(() => new THREE.Vector3(), [])
  const tempQuaternion = useMemo(() => new THREE.Quaternion(), [])
  const screenPosition = useMemo(() => new THREE.Vector2(), [])

  const [graphData, setGraphData] = useState<GraphData>({ nodes: [], edges: [] })
  const [nodesAreAtOrigin, setNodesAreAtOrigin] = useState(false)
  const settings = useSettingsStore(state => state.settings)
  const [forceUpdate, setForceUpdate] = useState(0) // Force re-render on settings change

  // Minimal drag state for UI feedback
  const [dragState, setDragState] = useState<{
    nodeId: string | null;
    instanceId: number | null;
  }>({ nodeId: null, instanceId: null });

  // Performance-optimized drag data using refs (no re-renders)
  const dragDataRef = useRef({
    isDragging: false,
    nodeId: null as string | null,
    instanceId: null as number | null,
    startPosition: new THREE.Vector3(),
    currentPosition: new THREE.Vector3(),
    offset: new THREE.Vector2(),
    lastUpdateTime: 0,
    pendingUpdate: null as BinaryNodeData | null
  });

  const { camera, size } = useThree()

  useEffect(() => {
    if (meshRef.current) {
      const count = graphData.nodes.length;
      const mesh = meshRef.current;
      mesh.count = count; // Set the count

      if (count > 0) {
        // Check if matrices need initialization (e.g., if they are identity)
        // This avoids re-initializing if positions are already set by useFrame
        let needsInitialization = false;
        const identityMatrix = new THREE.Matrix4(); // Re-use for comparison
        for (let i = 0; i < count; i++) {
          const currentMatrix = new THREE.Matrix4();
          // Ensure mesh has enough allocated matrices before calling getMatrixAt
          if (i < mesh.instanceMatrix.array.length / 16) { // 16 floats per matrix
            mesh.getMatrixAt(i, currentMatrix);
            if (currentMatrix.equals(identityMatrix)) {
              needsInitialization = true;
              break;
            }
          } else {
            // If count increased beyond allocated, it needs initialization
            needsInitialization = true;
            break;
          }
        }

        if (needsInitialization) {
          for (let i = 0; i < count; i++) {
            // Set to identity or a default non-zero position if appropriate
            mesh.setMatrixAt(i, tempMatrix.identity());
          }
        }
      }
      mesh.instanceMatrix.needsUpdate = true;
      if (debugState.isEnabled()) {
        logger.debug(`InstancedMesh count updated to: ${count}`);
      }
    }
  }, [graphData.nodes.length, tempMatrix]);

  // Separate matrix update function for better performance
  const updateInstanceMatrix = (
    index: number,
    x: number,
    y: number,
    z: number,
    scale: number
  ) => {
    if (!meshRef.current) return

    tempPosition.set(x, y, z)
    tempScale.set(scale, scale, scale)

    tempMatrix.makeScale(scale, scale, scale)
    tempMatrix.setPosition(tempPosition)

    meshRef.current.setMatrixAt(index, tempMatrix)
  }

  // Optimized drag event handlers
  const clickTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const lastClickTimeRef = useRef<number>(0);
  const DOUBLE_CLICK_THRESHOLD = 300; // ms

  const slugifyNodeLabel = (label: string): string => {
    return label.toLowerCase().replace(/\s+/g, '%20');
  };

  const handleNodeClick = useCallback((event: ThreeEvent<PointerEvent>) => {
    const instanceId = event.instanceId;
    if (instanceId === undefined) return;

    event.stopPropagation();
    const node = graphData.nodes[instanceId];
    if (!node || !node.label) return;

    const currentTime = Date.now();

    if (clickTimeoutRef.current) {
      clearTimeout(clickTimeoutRef.current);
      clickTimeoutRef.current = null;
    }

    // Double click
    if (currentTime - lastClickTimeRef.current < DOUBLE_CLICK_THRESHOLD) {
      if (debugState.isEnabled()) {
        logger.debug(`Double-clicked node ${node.id} (instance ${instanceId})`);
      }
      // Initiate drag on double click
      const pointer = event.pointer;
      dragDataRef.current = {
        isDragging: true,
        nodeId: node.id,
        instanceId,
        startPosition: new THREE.Vector3(node.position.x, node.position.y, node.position.z),
        currentPosition: new THREE.Vector3(node.position.x, node.position.y, node.position.z),
        offset: new THREE.Vector2(pointer.x, pointer.y),
        lastUpdateTime: 0,
        pendingUpdate: null
      };
      onNodeDragStateChange(true);
      setDragState({ nodeId: node.id, instanceId });
      lastClickTimeRef.current = 0; // Reset for next double click
    } else {
      // Single click (or first click of a potential double click)
      clickTimeoutRef.current = setTimeout(() => {
        if (debugState.isEnabled()) {
          logger.debug(`Single-clicked node ${node.id} (instance ${instanceId})`);
        }
        const slug = slugifyNodeLabel(node.label!);
        const narrativeGoldmineUrl = `https://narrativegoldmine.com//#/page/${slug}`;
        // This assumes the Narrative Goldmine panel is an iframe or a component that listens to URL changes.
        // If it's an iframe, you might target its src. If it's a React component, you might use react-router or a state management solution.
        // For now, let's log it. A more robust solution would involve a shared service or context.
        logger.info(`Updating Narrative Goldmine URL to: ${narrativeGoldmineUrl}`);
        // Example: window.postMessage({ type: 'UPDATE_NARRATIVE_URL', url: narrativeGoldmineUrl }, '*');
        // Or if it's a sibling iframe:
        // const iframe = document.getElementById('narrative-goldmine-iframe') as HTMLIFrameElement;
        // if (iframe) iframe.src = narrativeGoldmineUrl;

        // To actually change the browser's URL (if Narrative Goldmine is part of the same SPA but different route):
        // window.history.pushState({}, '', narrativeGoldmineUrl); // or router.push(...)

        // For now, we'll assume a global event or direct update if possible.
        // This part needs to be integrated with how NarrativeGoldminePanel actually receives its URL.
        // One simple way, if it's an iframe with a known ID:
        const narrativeIframe = document.getElementById('narrative-goldmine-iframe') as HTMLIFrameElement | null;
        if (narrativeIframe) {
           narrativeIframe.src = narrativeGoldmineUrl;
        } else {
           logger.warn('Narrative Goldmine iframe not found. Cannot update URL.');
        }

      }, DOUBLE_CLICK_THRESHOLD);
    }
    lastClickTimeRef.current = currentTime;
  }, [graphData.nodes, onNodeDragStateChange, camera, size]);

  const handlePointerMove = useCallback((event: ThreeEvent<PointerEvent>) => {
    const drag = dragDataRef.current;
    if (!drag.isDragging || !meshRef.current) return;

    event.stopPropagation();

    // Use R3F's pointer coordinates directly
    const pointer = event.pointer;

    // Create a plane at the node's depth perpendicular to the camera
    const cameraDirection = new THREE.Vector3();
    camera.getWorldDirection(cameraDirection);

    // Create a plane at the drag start position
    const planeNormal = cameraDirection.clone().negate();
    const plane = new THREE.Plane(planeNormal, -planeNormal.dot(drag.startPosition));

    // Cast a ray from the camera through the mouse position
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(pointer, camera);

    // Find where the ray intersects the plane
    const intersection = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, intersection);

    if (intersection) {
      drag.currentPosition.copy(intersection);

      // Update visual immediately (no React state)
      const nodeSize = settings?.visualisation?.nodes?.nodeSize || 0.01;
      const BASE_SPHERE_RADIUS = 0.5; // Ensure this matches your sphereGeometry radius
      const scale = nodeSize / BASE_SPHERE_RADIUS;

      const tempMatrix = new THREE.Matrix4(); // Local temp matrix
      tempMatrix.makeScale(scale, scale, scale);
      tempMatrix.setPosition(drag.currentPosition);
      meshRef.current.setMatrixAt(drag.instanceId!, tempMatrix);
      meshRef.current.instanceMatrix.needsUpdate = true;

      // Update the node in graphData to keep edges and labels in sync
      setGraphData(prev => ({
        ...prev,
        nodes: prev.nodes.map((node, idx) =>
          idx === drag.instanceId
            ? { ...node, position: {
                x: drag.currentPosition.x,
                y: drag.currentPosition.y,
                z: drag.currentPosition.z
              }}
            : node
        )
      }));

      // Prepare update for throttled send
      const now = Date.now();
      if (now - drag.lastUpdateTime > 30) { // Throttle WebSocket updates (e.g., ~30fps)
        const numericId = graphDataManager.nodeIdMap.get(drag.nodeId!);
        if (numericId !== undefined) {
          drag.pendingUpdate = {
            nodeId: numericId,
            position: {
              x: drag.currentPosition.x,
              y: drag.currentPosition.y,
              z: drag.currentPosition.z
            },
            velocity: { x: 0, y: 0, z: 0 } // Assuming velocity resets or is handled server-side
          };
          drag.lastUpdateTime = now;
        }
      }
    }
  }, [settings?.visualisation?.nodes?.nodeSize, camera, setGraphData]); // Added setGraphData to deps

  const handlePointerUp = useCallback(() => {
    const drag = dragDataRef.current;
    if (!drag.isDragging) return;

    // Send final position
    if (drag.nodeId && graphDataManager.webSocketService) {
      const numericId = graphDataManager.nodeIdMap.get(drag.nodeId);
      if (numericId !== undefined) {
        const finalUpdate: BinaryNodeData = {
          nodeId: numericId,
          position: {
            x: drag.currentPosition.x,
            y: drag.currentPosition.y,
            z: drag.currentPosition.z
          },
          velocity: { x: 0, y: 0, z: 0 }
        };
        graphDataManager.webSocketService.send(
          createBinaryNodeData([finalUpdate])
        );

        if (debugState.isEnabled()) {
          logger.debug(`Sent final position for node ${drag.nodeId}`);
        }
      }
    }

    dragDataRef.current.isDragging = false;
    dragDataRef.current.pendingUpdate = null; // Clear pending update
    onNodeDragStateChange(false); // <--- Signal drag end to parent
    setDragState({ nodeId: null, instanceId: null });
  }, [onNodeDragStateChange]); // Add onNodeDragStateChange to deps

  // Global pointer up listener for cases where mouse is released outside canvas
  useEffect(() => {
    const handleGlobalPointerUp = () => {
      if (dragDataRef.current.isDragging) {
        handlePointerUp();
      }
    };

    window.addEventListener('pointerup', handleGlobalPointerUp);
    return () => {
      window.removeEventListener('pointerup', handleGlobalPointerUp);
    };
  }, [handlePointerUp]);

  // Subscribe to graph data changes
  useEffect(() => {
    const handleGraphDataChange = (newData: GraphData) => {
      setGraphData(newData)

      // Check if nodes are all at origin
      const allAtOrigin = newData.nodes.every(node =>
        !node.position || (node.position.x === 0 && node.position.y === 0 && node.position.z === 0)
      )
      setNodesAreAtOrigin(allAtOrigin)
    }

    // Initial data load (now async)
    graphDataManager.getGraphData().then(initialData => {
      handleGraphDataChange(initialData)
    }).catch(error => {
      logger.error('Error getting initial graph data:', createErrorMetadata(error));
    })

    // Subscribe to updates
    const unsubscribeData = graphDataManager.onGraphDataChange(handleGraphDataChange)
    const unsubscribePositions = graphDataManager.onPositionUpdate((positions) => {
      updateNodePositions(positions)
    })

    // Subscribe to viewport updates from settings store
    // We'll use a different approach - subscribe to the whole store and check for changes
    const unsubscribeViewport = useSettingsStore.subscribe((state, prevState) => {
      // Check if any visualization settings changed
      const visualizationChanged = state.settings?.visualisation !== prevState.settings?.visualisation
      const xrChanged = state.settings?.xr !== prevState.settings?.xr
      const debugChanged = state.settings?.system?.debug !== prevState.settings?.system?.debug

      if (visualizationChanged || xrChanged || debugChanged) {
        logger.debug('GraphManager: Detected settings change, forcing update')
        setForceUpdate(prev => prev + 1)
      }
    })

    return () => {
      unsubscribeData()
      unsubscribePositions()
      unsubscribeViewport()
    }
  }, [])

  // Update node positions from binary data
  // Update node positions - Modified to NOT directly update mesh matrices from WebSocket data
  const updateNodePositions = useCallback((positions: Float32Array) => {
    // This function is called by GraphDataManager when WebSocket binary data arrives.
    // GraphDataManager is responsible for updating the central 'graphData' state.
    // This component (GraphManager) re-renders when 'graphData' (from useState) changes.
    // The useFrame hook then uses the updated 'graphData' to set instance matrices.
    // Therefore, this callback doesn't need to directly manipulate meshRef.current.
    if (debugState.isEnabled()) {
      const sample = positions.slice(0, Math.min(12, positions.length)); // Log first few nodes
      logger.debug('GraphManager received raw position update data (sample):', sample);
    }
  }, []); // No dependencies needed if it's just logging or relying on external state updates.

  // Constants for file size normalization
  const MIN_LOG_FILE_SIZE_ESTIMATE = Math.log10(100 + 1); // Approx 2, for 100 bytes
  const MAX_LOG_FILE_SIZE_ESTIMATE = Math.log10(5 * 1024 * 1024 + 1); // Approx 6.7, for 5MB
  const BASE_SPHERE_RADIUS = 0.5;

  useFrame(() => {
    if (!meshRef.current) return;

    // Handle pending drag updates via RAF
    const drag = dragDataRef.current;
    if (drag.pendingUpdate && graphDataManager.webSocketService && graphDataManager.webSocketService.isReady()) {
      graphDataManager.webSocketService.send(
        createBinaryNodeData([drag.pendingUpdate])
      );
      drag.pendingUpdate = null; // Clear after sending
    }

    const nodeSettings = settings?.visualisation?.nodes;
    const nodeSize = nodeSettings?.nodeSize || 0.01; // Default if not loaded

    // Log the nodeSize being used
    if (debugState.isEnabled()) { // Only log if debug mode is on
        logger.debug('GraphManager useFrame - nodeSize:', nodeSize);
    }

    let needsUpdate = false;
    graphData.nodes.forEach((node, index) => {
      const pos = node.position;
      if (pos && (pos.x !== 0 || pos.y !== 0 || pos.z !== 0)) {
        // Use nodeSize directly as the scale
        const scale = nodeSize / BASE_SPHERE_RADIUS;
        updateInstanceMatrix(index, pos.x, pos.y, pos.z, scale);
        needsUpdate = true;
      }
    });

    if (needsUpdate) {
      meshRef.current.instanceMatrix.needsUpdate = true;
    }
  })

  // Memoize edge points
  const edgePoints = useMemo(() => {
    if (!graphData.nodes || !graphData.edges) return []

    const points: [number, number, number][] = []
    const { nodes, edges } = graphData

    edges.forEach(edge => {
      if (edge.source && edge.target) {
        const sourceNode = nodes.find(n => n.id === edge.source)
        const targetNode = nodes.find(n => n.id === edge.target)
        if (sourceNode?.position && targetNode?.position) {
          if (nodesAreAtOrigin) {
            points.push(
              getPositionForNode(sourceNode, nodes.indexOf(sourceNode)),
              getPositionForNode(targetNode, nodes.indexOf(targetNode))
            )
          } else {
            points.push(
              [sourceNode.position.x, sourceNode.position.y, sourceNode.position.z],
              [targetNode.position.x, targetNode.position.y, targetNode.position.z]
            )
          }
        }
      }
    })
    return points
  }, [graphData.nodes, graphData.edges, nodesAreAtOrigin])

  // Node labels component using settings from YAML
  const NodeLabels = () => {
    const labelSettings = settings?.visualisation?.labels || {
      enabled: true,
      desktopFontSize: 0.1,
      textColor: '#000000',
      textOutlineColor: '#ffffff',
      textOutlineWidth: 0.01,
      textPadding: 0.3,
      textResolution: 32,
      billboardMode: 'camera'
    };

    const isEnabled = typeof labelSettings === 'object' && labelSettings !== null && 'enabled' in labelSettings ? labelSettings.enabled : true;
    if (!isEnabled) return null;

    const mainLabelFontSize = labelSettings.desktopFontSize || 0.1;
    const metadataFontSize = mainLabelFontSize * 0.7; // Smaller font for metadata
    const lineSpacing = mainLabelFontSize * 0.15; // Space between main label and metadata

    return (
      <group>
        {graphData.nodes.map(node => {
          if (!node.position || !node.label) return null;

          // Construct metadata string
          let metadataString = '';
          if (node.metadata) {
            const fileSize = node.metadata.fileSize; // Already a string from server
            const hyperlinkCount = node.metadata.hyperlinkCount; // Already a string

            if (fileSize) {
              const sizeInKB = parseInt(fileSize, 10) / 1024;
              metadataString += `${sizeInKB.toFixed(1)} KB`;
            }
            if (hyperlinkCount) {
              if (metadataString) metadataString += ' | ';
              metadataString += `${hyperlinkCount} links`;
            }
            // Could add lastModified here too, but might be too much info
            // const lastModified = node.metadata.lastModified;
            // if (lastModified) {
            //   if (metadataString) metadataString += ' | ';
            //   metadataString += `Mod: ${new Date(lastModified).toLocaleDateString()}`;
            // }
          }

          return (
            <Billboard
              key={node.id}
              // Position the billboard slightly above the node center to accommodate two lines of text
              position={[
                node.position.x,
                node.position.y + (labelSettings.textPadding || 0.3) + (metadataString ? mainLabelFontSize / 2 + lineSpacing / 2 : 0),
                node.position.z
              ]}
              follow={labelSettings.billboardMode === 'camera'}
            >
              {/* Main Label (Filename) */}
              <Text
                fontSize={mainLabelFontSize}
                color={labelSettings.textColor || '#000000'}
                anchorX="center"
                anchorY="middle" // Anchor to middle for the main label
                outlineWidth={labelSettings.textOutlineWidth || 0.01}
                outlineColor={labelSettings.textOutlineColor || '#ffffff'}
                outlineOpacity={1.0}
                renderOrder={10}
                material-depthTest={false}
                maxWidth={labelSettings.textResolution || 32}
              >
                {node.label}
              </Text>

              {/* Metadata String (File Size, Links) - rendered below the main label */}
              {metadataString && (
                <Text
                  fontSize={metadataFontSize}
                  color={labelSettings.textColor ? new THREE.Color(labelSettings.textColor).multiplyScalar(0.8).getStyle() : '#333333'} // Slightly dimmer
                  anchorX="center"
                  anchorY="top" // Anchor to top, so it sits below the main label
                  position={[0, -mainLabelFontSize / 2 - lineSpacing, 0]} // Position it below the main label
                  outlineWidth={(labelSettings.textOutlineWidth || 0.01) * 0.7}
                  outlineColor={labelSettings.textOutlineColor || '#ffffff'}
                  outlineOpacity={0.8}
                  renderOrder={10}
                  material-depthTest={false}
                  maxWidth={(labelSettings.textResolution || 32) * 1.5} // Allow metadata to be a bit wider
                >
                  {metadataString}
                </Text>
              )}
            </Billboard>
          );
        })}
      </group>
    );
  };

  return (
    <>
      {/* REMOVE THE LOCAL OrbitControls INSTANCE:
      <OrbitControls ref={orbitControlsRef} ... />
      */}

      <instancedMesh
        ref={meshRef}
        args={[undefined, undefined, graphData.nodes.length]} // Geometry, Material, Count
        frustumCulled={false}
        onPointerDown={handleNodeClick} // Corrected to use handleNodeClick
        onPointerMove={handlePointerMove}
        onPointerUp={handlePointerUp} // To handle release on the mesh
        onPointerMissed={() => { // To handle release outside the mesh but on canvas
          if (dragDataRef.current.isDragging) {
            handlePointerUp();
          }
        }}
      >
        <sphereGeometry args={[0.5, 16, 16]} />
        <meshStandardMaterial
          color={settings?.visualisation?.nodes?.baseColor || "#ffffff"}
          emissive={settings?.visualisation?.nodes?.baseColor || "#00ffff"}
          emissiveIntensity={0.8}
          metalness={settings?.visualisation?.nodes?.metalness || 0.2}
          roughness={settings?.visualisation?.nodes?.roughness || 0.3}
          opacity={settings?.visualisation?.nodes?.opacity || 1.0}
          transparent={true}
          toneMapped={false} // Important for bloom effect
        />
      </instancedMesh>

      {edgePoints.length > 0 && (
        <Line
          points={edgePoints}
          color={settings?.visualisation?.edges?.color || "#00ffff"}
          lineWidth={settings?.visualisation?.edges?.baseWidth || 1.0}
          transparent
          opacity={settings?.visualisation?.edges?.opacity || 0.6}
          toneMapped={false} // Important for bloom effect
        />
      )}

      <NodeLabels />
    </>
  )
}


export default GraphManager

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/graph/components/GraphViewport.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/graph/components/GraphViewport.tsx
```tsx
import React, { Suspense, useEffect, useState, useCallback, useMemo } from 'react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls, Stats } from '@react-three/drei';
import { EffectComposer, Bloom } from '@react-three/postprocessing';
import { graphDataManager } from '../managers/graphDataManager';
import GraphManager from './GraphManager';
import CameraController from '../../visualisation/components/CameraController'; // Adjusted path
import { useSettingsStore } from '../../../store/settingsStore';
import { createLogger } from '../../../utils/logger';


const logger = createLogger('GraphViewport');

const GraphViewport: React.FC = () => {
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [graphCenter, setGraphCenter] = useState<[number, number, number]>([0, 0, 0]);
  const [graphSize, setGraphSize] = useState(50); // Default size
  const [isNodeDragging, setIsNodeDragging] = useState(false); // <--- Add this state

  // Settings for camera and visuals
  const settings = useSettingsStore(state => state.settings);
  const cameraSettings = settings.visualisation.camera;
  const renderingSettings = settings.visualisation.rendering;
  const bloomSettingsStore = settings.visualisation.bloom;
  const debugSettings = settings.system.debug;

  const fov = cameraSettings?.fov ?? 75;
  const near = cameraSettings?.near ?? 0.1;
  const far = cameraSettings?.far ?? 2000;

  // Memoize cameraPosition to ensure stable reference unless underlying values change
  const cameraPosition = useMemo(() => (
    cameraSettings?.position
      ? [cameraSettings.position.x, cameraSettings.position.y, cameraSettings.position.z]
      : [0, 10, 50] // Default camera position
  ), [cameraSettings?.position]);

  const enableBloom = bloomSettingsStore?.enabled ?? true;
  // Using properties from BloomSettings in settings.ts
  const bloomStrength = bloomSettingsStore?.strength ?? 1.5;
  const bloomThreshold = bloomSettingsStore?.threshold ?? 0.2;
  const bloomRadius = bloomSettingsStore?.radius ?? 0.9;


  useEffect(() => {
    const initializeGraph = async () => {
      setIsLoading(true);
      setError(null);
      try {
        logger.debug('Fetching initial graph data...');
        await graphDataManager.fetchInitialData();
        logger.debug('Graph data fetched.');
        const data = await graphDataManager.getGraphData();

        if (!data || !data.nodes || data.nodes.length === 0) {
          logger.warn('No graph data or empty nodes received.');
          setGraphCenter([0,0,0]);
          setGraphSize(50); // Default size for empty graph
          setIsLoading(false);
          return;
        }

        let minX = Infinity, minY = Infinity, minZ = Infinity;
        let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

        data.nodes.forEach((node) => {
          if (node.position) {
            minX = Math.min(minX, node.position.x);
            maxX = Math.max(maxX, node.position.x);
            minY = Math.min(minY, node.position.y);
            maxY = Math.max(maxY, node.position.y);
            minZ = Math.min(minZ, node.position.z);
            maxZ = Math.max(maxZ, node.position.z);
          }
        });

        const centerX = (minX === Infinity || maxX === -Infinity) ? 0 : (maxX + minX) / 2;
        const centerY = (minY === Infinity || maxY === -Infinity) ? 0 : (maxY + minY) / 2;
        const centerZ = (minZ === Infinity || maxZ === -Infinity) ? 0 : (maxZ + minZ) / 2;

        const width = (minX === Infinity || maxX === -Infinity) ? 0 : maxX - minX;
        const height = (minY === Infinity || maxY === -Infinity) ? 0 : maxY - minY;
        const depth = (minZ === Infinity || maxZ === -Infinity) ? 0 : maxZ - minZ;

        const maxDimension = Math.max(width, height, depth, 1); // Ensure maxDimension is at least 1

        setGraphCenter([centerX, centerY, centerZ]);
        setGraphSize(maxDimension > 0 ? maxDimension : 50);
        logger.debug('Graph initialized and centered.', { center: [centerX, centerY, centerZ], size: maxDimension });

      } catch (err) {
        logger.error('Failed to fetch initial graph data:', err);
        setError(err instanceof Error ? err.message : 'An unknown error occurred during data fetch.');
      } finally {
        setIsLoading(false);
      }
    };
    initializeGraph();
  }, []);

  if (isLoading) {
    return <div style={{ padding: '2rem', color: '#ccc', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>Loading graph data...</div>;
  }

  if (error) {
    return <div style={{ padding: '2rem', color: 'red', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>Error loading graph data: {error}</div>;
  }

  const backgroundColor = renderingSettings?.backgroundColor ?? '#000000';

  return (
    <div style={{ width: '100%', height: '100%', position: 'relative' }}>
      <Canvas
        style={{ display: 'block', width: '100%', height: '100%' }}
        camera={{
          fov: fov,
          near: near,
          far: far,
          position: cameraPosition as [number, number, number],
        }}
        gl={{ antialias: true, alpha: true, powerPreference: 'high-performance' }}
        dpr={[1, 2]} // Pixel ratio for sharpness
        shadows // Enable shadows
      >
        <color attach="background" args={[backgroundColor]} />
        <CameraController center={graphCenter} size={graphSize} />

        <ambientLight intensity={renderingSettings?.ambientLightIntensity ?? 0.6} />
        <directionalLight
          position={[10, 10, 5]} // Using hardcoded default as not in settings
          intensity={renderingSettings?.directionalLightIntensity ?? 1}
          castShadow
        />
        <pointLight
          position={[-10, -10, -5]} // Using hardcoded default as not in settings
          intensity={0.5} // Using hardcoded default as not in settings
        />

        <OrbitControls
          makeDefault
          enableDamping
          dampingFactor={0.05}
          minDistance={1}
          maxDistance={far / 2} // Max distance related to camera far plane
          target={graphCenter}
          enabled={!isNodeDragging} // <--- Control OrbitControls here
        />

        <Suspense fallback={null}>
          {/* Pass setIsNodeDragging to GraphManager */}
          <GraphManager onNodeDragStateChange={setIsNodeDragging} />
          {/* HologramVisualisation could be added here if it's part of the core graph view */}
          {/* <HologramVisualisation standalone={false} position={[0, 0, 0]} size={20} /> */}
        </Suspense>

        {/* Removed showAxesHelper and showStats as they are not in DebugSettings type from settings.ts */}
        {/* {debugSettings?.showAxesHelper && <axesHelper args={[graphSize > 0 ? graphSize / 10 : 2]} />} */}
        {/* {debugSettings?.showStats && <Stats />} */}
        {debugSettings?.enabled && <Stats />} {/* Show Stats if general debug is enabled, as a fallback */}


        {enableBloom && (
          <EffectComposer>
            <Bloom
              intensity={bloomStrength} // Mapped from BloomSettings.strength
              luminanceThreshold={bloomThreshold} // Mapped from BloomSettings.threshold
              luminanceSmoothing={bloomRadius} // Mapped from BloomSettings.radius (best guess)
            />
          </EffectComposer>
        )}
      </Canvas>
    </div>
  );
};

export default GraphViewport;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/graph/managers/graphDataManager.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/graph/managers/graphDataManager.ts
```ts
import { createLogger, createErrorMetadata } from '../../../utils/logger';
import { debugState } from '../../../utils/debugState';
import { WebSocketAdapter } from '../../../services/WebSocketService';
import { BinaryNodeData, parseBinaryNodeData, createBinaryNodeData, Vec3, BINARY_NODE_SIZE } from '../../../types/binaryProtocol';
import { graphWorkerProxy } from './graphWorkerProxy';
import type { GraphData, Node, Edge } from './graphWorkerProxy';
import { startTransition } from 'react';

const logger = createLogger('GraphDataManager');

export type { Node, Edge, GraphData } from './graphWorkerProxy';

type GraphDataChangeListener = (data: GraphData) => void;
type PositionUpdateListener = (positions: Float32Array) => void;

class GraphDataManager {
  private static instance: GraphDataManager;
  private binaryUpdatesEnabled: boolean = false;
  public webSocketService: WebSocketAdapter | null = null;
  private graphDataListeners: GraphDataChangeListener[] = [];
  private positionUpdateListeners: PositionUpdateListener[] = [];
  private lastBinaryUpdateTime: number = 0;
  private retryTimeout: number | null = null;
  public nodeIdMap: Map<string, number> = new Map();
  private reverseNodeIdMap: Map<number, string> = new Map();
  private workerInitialized: boolean = false;

  private constructor() {
    // Worker proxy initializes automatically, just wait for it to be ready
    this.waitForWorker();
  }

  private async waitForWorker(): Promise<void> {
    try {
      // Poll until worker is ready
      while (!graphWorkerProxy.isReady()) {
        await new Promise(resolve => setTimeout(resolve, 10));
      }
      this.workerInitialized = true;

      // Connect to worker proxy listeners
      this.setupWorkerListeners();

      if (debugState.isEnabled()) {
        logger.info('Graph worker proxy is ready');
      }
    } catch (error) {
      logger.error('Failed to wait for graph worker proxy:', createErrorMetadata(error));
    }
  }

  private setupWorkerListeners(): void {
    // Forward graph data changes from worker to our listeners
    graphWorkerProxy.onGraphDataChange((data) => {
      this.graphDataListeners.forEach(listener => {
        try {
          startTransition(() => {
            listener(data);
          });
        } catch (error) {
          logger.error('Error in forwarded graph data listener:', createErrorMetadata(error));
        }
      });
    });

    // Forward position updates from worker to our listeners
    graphWorkerProxy.onPositionUpdate((positions) => {
      this.positionUpdateListeners.forEach(listener => {
        try {
          listener(positions);
        } catch (error) {
          logger.error('Error in forwarded position update listener:', createErrorMetadata(error));
        }
      });
    });
  }

  public static getInstance(): GraphDataManager {
    if (!GraphDataManager.instance) {
      GraphDataManager.instance = new GraphDataManager();
    }
    return GraphDataManager.instance;
  }

  // Set WebSocket service for sending binary updates
  public setWebSocketService(service: WebSocketAdapter): void {
    this.webSocketService = service;
    if (debugState.isDataDebugEnabled()) {
      logger.debug('WebSocket service set');
    }
  }

  // Fetch initial graph data from the API
  public async fetchInitialData(): Promise<GraphData> {
    try {
      if (debugState.isEnabled()) {
        logger.info('Fetching initial graph data');
      }

      const response = await fetch('/api/graph/data');
      if (!response.ok) {
        throw new Error(`API request failed with status ${response.status}`);
      }

      try {
        const data = await response.json();

        // Validate that the response has the expected structure
        if (!data || typeof data !== 'object') {
          throw new Error('Invalid graph data format: data is not an object');
        }

        // Ensure nodes and edges exist, even if empty
        const validatedData = {
          nodes: Array.isArray(data.nodes) ? data.nodes : [],
          edges: Array.isArray(data.edges) ? data.edges : []
        };

        if (debugState.isEnabled()) {
          logger.info(`Received initial graph data: ${validatedData.nodes.length} nodes, ${validatedData.edges.length} edges`);
          if (validatedData.nodes.length > 0) {
            logger.debug('Sample node data:', {
              id: validatedData.nodes[0].id,
              label: validatedData.nodes[0].label,
              position: validatedData.nodes[0].position,
              metadata: validatedData.nodes[0].metadata
            });
          }
          if (validatedData.edges.length > 0) {
            logger.debug('Sample edge data:', {
              id: validatedData.edges[0].id,
              source: validatedData.edges[0].source,
              target: validatedData.edges[0].target
            });
          }
        }

        await this.setGraphData(validatedData);

        const currentData = await graphWorkerProxy.getGraphData();
        if (debugState.isEnabled()) {
          logger.info(`Loaded initial graph data: ${currentData.nodes.length} nodes, ${currentData.edges.length} edges`);
          logger.debug('Node ID mappings created:', {
            numericIds: Array.from(this.nodeIdMap.entries()).slice(0, 5),
            totalMappings: this.nodeIdMap.size
          });
        }

        return currentData;
      } catch (parseError) {
        throw new Error(`Failed to parse graph data: ${parseError}`);
      }
    } catch (error) {
      logger.error('Failed to fetch initial graph data:', createErrorMetadata(error));
      throw error;
    }
  }

  // Set graph data and notify listeners
  public async setGraphData(data: GraphData): Promise<void> {
    if (debugState.isEnabled()) {
      logger.info(`Setting graph data: ${data.nodes.length} nodes, ${data.edges.length} edges`);
    }

    // Ensure all nodes have valid positions before setting the data
    let validatedData = data;
    if (data && data.nodes) {
      const validatedNodes = data.nodes.map(node => this.ensureNodeHasValidPosition(node));
      validatedData = {
        ...data,
        nodes: validatedNodes
      };

      if (debugState.isEnabled()) {
        logger.info(`Validated ${validatedNodes.length} nodes with positions`);
      }
    } else {
      // Initialize with empty arrays if data is invalid
      validatedData = { nodes: [], edges: data?.edges || [] };
      logger.warn('Initialized with empty graph data');
    }

    // Reset ID maps and rebuild them
    this.nodeIdMap.clear();
    this.reverseNodeIdMap.clear();

    // Create mappings between string IDs and numeric IDs (now u32 instead of u16)
    validatedData.nodes.forEach((node, index) => {
      const numericId = parseInt(node.id, 10);
      if (!isNaN(numericId) && numericId >= 0 && numericId <= 0xFFFFFFFF) {
        // If the ID can be parsed as a u32 number, use it directly
        this.nodeIdMap.set(node.id, numericId);
        this.reverseNodeIdMap.set(numericId, node.id);
      } else {
        // For non-numeric IDs, use the index + 1 as the numeric ID
        // We add 1 to avoid using 0 as an ID
        const mappedId = index + 1;
        this.nodeIdMap.set(node.id, mappedId);
        this.reverseNodeIdMap.set(mappedId, node.id);
      }
    });

    // Delegate to worker
    await graphWorkerProxy.setGraphData(validatedData);

    if (debugState.isDataDebugEnabled()) {
      logger.debug(`Graph data updated: ${validatedData.nodes.length} nodes, ${validatedData.edges.length} edges`);
    }
  }

  // Setup node IDs (simplified since data is now in worker)
  private validateNodeMappings(nodes: Node[]): void {
    if (debugState.isDataDebugEnabled()) {
      logger.debug(`Validated ${nodes.length} nodes with ID mapping`);
    }
  }

  // Enable binary updates and start the retry mechanism
  public enableBinaryUpdates(): void {
    if (!this.webSocketService) {
      logger.warn('Cannot enable binary updates: WebSocket service not set');
      return;
    }

    // If WebSocket is already ready, enable binary updates immediately
    if (this.webSocketService.isReady()) {
      this.setBinaryUpdatesEnabled(true);
      return;
    }

    // Otherwise, start a retry mechanism
    if (this.retryTimeout) {
      window.clearTimeout(this.retryTimeout);
    }

    this.retryTimeout = window.setTimeout(() => {
      if (this.webSocketService && this.webSocketService.isReady()) {
        this.setBinaryUpdatesEnabled(true);
        if (debugState.isEnabled()) {
          logger.info('WebSocket ready, binary updates enabled');
        }
      } else {
        if (debugState.isEnabled()) {
          logger.info('WebSocket not ready yet, retrying...');
        }
        this.enableBinaryUpdates();
      }
    }, 500);
  }

  public setBinaryUpdatesEnabled(enabled: boolean): void {
    this.binaryUpdatesEnabled = enabled;

    if (debugState.isEnabled()) {
      logger.info(`Binary updates ${enabled ? 'enabled' : 'disabled'}`);
    }
  }

  // Get the current graph data
  public async getGraphData(): Promise<GraphData> {
    return await graphWorkerProxy.getGraphData();
  }

  // Add a node to the graph
  public async addNode(node: Node): Promise<void> {
    // Update node mappings
    const numericId = parseInt(node.id, 10);
    if (!isNaN(numericId)) {
      this.nodeIdMap.set(node.id, numericId);
      this.reverseNodeIdMap.set(numericId, node.id);
    } else {
      // For non-numeric IDs, we'll get the current length from worker
      const currentData = await graphWorkerProxy.getGraphData();
      const mappedId = currentData.nodes.length + 1;
      this.nodeIdMap.set(node.id, mappedId);
      this.reverseNodeIdMap.set(mappedId, node.id);
    }

    await graphWorkerProxy.updateNode(node);
  }

  // Add an edge to the graph (for backward compatibility - edges go through worker)
  public async addEdge(edge: Edge): Promise<void> {
    // Worker doesn't have addEdge method, so we get current data, add edge, and set it back
    const currentData = await graphWorkerProxy.getGraphData();
    const existingIndex = currentData.edges.findIndex(e => e.id === edge.id);

    if (existingIndex >= 0) {
      currentData.edges[existingIndex] = {
        ...currentData.edges[existingIndex],
        ...edge
      };
    } else {
      currentData.edges.push(edge);
    }

    await graphWorkerProxy.setGraphData(currentData);
  }

  // Remove a node from the graph
  public async removeNode(nodeId: string): Promise<void> {
    // Get numeric ID before removing the node
    const numericId = this.nodeIdMap.get(nodeId);

    await graphWorkerProxy.removeNode(nodeId);

    // Remove from ID maps
    if (numericId !== undefined) {
      this.nodeIdMap.delete(nodeId);
      this.reverseNodeIdMap.delete(numericId);
    }
  }

  // Remove an edge from the graph
  public async removeEdge(edgeId: string): Promise<void> {
    // Worker doesn't have removeEdge method, so we get current data, remove edge, and set it back
    const currentData = await graphWorkerProxy.getGraphData();
    currentData.edges = currentData.edges.filter(edge => edge.id !== edgeId);
    await graphWorkerProxy.setGraphData(currentData);
  }

  // Update node positions from binary data
  public async updateNodePositions(positionData: ArrayBuffer): Promise<void> {
    if (!positionData || positionData.byteLength === 0) {
      return;
    }

    // Check if this is a duplicate update (can happen with WebSocket)
    const now = Date.now();
    if (now - this.lastBinaryUpdateTime < 16) { // Less than 16ms (60fps)
      if (debugState.isDataDebugEnabled()) {
        logger.debug('Skipping duplicate position update');
      }
      return;
    }
    this.lastBinaryUpdateTime = now;

    try {
      // Add diagnostic information about the received data
      if (debugState.isDataDebugEnabled()) {
        logger.debug(`Received binary data: ${positionData.byteLength} bytes`);

        // Check if data length is a multiple of our expected node size
        const remainder = positionData.byteLength % BINARY_NODE_SIZE;
        if (remainder !== 0) {
          logger.warn(`Binary data size (${positionData.byteLength} bytes) is not a multiple of ${BINARY_NODE_SIZE}. Remainder: ${remainder} bytes`);
        }
      }

      // Delegate to worker proxy for processing
      await graphWorkerProxy.processBinaryData(positionData);

      if (debugState.isDataDebugEnabled()) {
        logger.debug(`Processed binary data through worker`);
      }
    } catch (error) {
      logger.error('Error processing binary position data:', createErrorMetadata(error));

      // Add additional diagnostic information
      if (debugState.isEnabled()) {
        try {
          // Try to display the first few bytes for debugging
          const view = new DataView(positionData);
          const byteArray = [];
          const maxBytesToShow = Math.min(64, positionData.byteLength);

          for (let i = 0; i < maxBytesToShow; i++) {
            byteArray.push(view.getUint8(i).toString(16).padStart(2, '0'));
          }

          logger.debug(`First ${maxBytesToShow} bytes of binary data: ${byteArray.join(' ')}${positionData.byteLength > maxBytesToShow ? '...' : ''}`);
        } catch (e) {
          logger.debug('Could not display binary data preview:', e);
        }
      }
    }
  }

  // Send node positions to the server via WebSocket
  public async sendNodePositions(): Promise<void> {
    if (!this.binaryUpdatesEnabled || !this.webSocketService) {
      return;
    }

    try {
      // Get current graph data from worker
      const currentData = await graphWorkerProxy.getGraphData();

      // Create binary node data array in the format expected by the server
      const binaryNodes: BinaryNodeData[] = currentData.nodes
        .filter(node => node && node.id) // Filter out invalid nodes
        .map(node => {
          // Ensure node has a valid position
          const validatedNode = this.ensureNodeHasValidPosition(node);

          // Get numeric ID from map or create a new one
          const numericId = this.nodeIdMap.get(validatedNode.id) || 0;
          if (numericId === 0) {
            logger.warn(`No numeric ID found for node ${validatedNode.id}, skipping`);
            return null;
          }

          // Get velocity from metadata or default to zero
          const velocity: Vec3 = (validatedNode.metadata?.velocity as Vec3) || { x: 0, y: 0, z: 0 };

          return {
            nodeId: numericId,
            position: {
              x: validatedNode.position.x || 0,
              y: validatedNode.position.y || 0,
              z: validatedNode.position.z || 0
            },
            velocity
          };
        })
        .filter((node): node is BinaryNodeData => node !== null);

      // Create binary buffer using our protocol encoder
      const buffer = createBinaryNodeData(binaryNodes);

      // Send the buffer via WebSocket
      this.webSocketService.send(buffer);

      if (debugState.isDataDebugEnabled()) {
        logger.debug(`Sent positions for ${binaryNodes.length} nodes using binary protocol`);
      }
    } catch (error) {
      logger.error('Error sending node positions:', createErrorMetadata(error));
    }
  }

  // Add listener for graph data changes
  public onGraphDataChange(listener: GraphDataChangeListener): () => void {
    this.graphDataListeners.push(listener);

    // Call immediately with current data from worker
    graphWorkerProxy.getGraphData().then(data => {
      listener(data);
    }).catch(error => {
      logger.error('Error getting initial graph data for listener:', createErrorMetadata(error));
    });

    // Return unsubscribe function
    return () => {
      this.graphDataListeners = this.graphDataListeners.filter(l => l !== listener);
    };
  }

  // Add listener for position updates
  public onPositionUpdate(listener: PositionUpdateListener): () => void {
    this.positionUpdateListeners.push(listener);

    // Return unsubscribe function
    return () => {
      this.positionUpdateListeners = this.positionUpdateListeners.filter(l => l !== listener);
    };
  }

  // Notify all graph data listeners
  private async notifyGraphDataListeners(): Promise<void> {
    try {
      const currentData = await graphWorkerProxy.getGraphData();
      this.graphDataListeners.forEach(listener => {
        try {
          listener(currentData);
        } catch (error) {
          logger.error('Error in graph data listener:', createErrorMetadata(error));
        }
      });
    } catch (error) {
      logger.error('Error getting graph data for listeners:', createErrorMetadata(error));
    }
  }

  // Notify all position update listeners
  private notifyPositionUpdateListeners(positions: Float32Array): void {
    this.positionUpdateListeners.forEach(listener => {
      try {
        listener(positions);
      } catch (error) {
        logger.error('Error in position update listener:', createErrorMetadata(error));
      }
    });
  }

  // Initialize a node with default position if needed
  public ensureNodeHasValidPosition(node: Node): Node {
    if (!node.position) {
      // Provide a default position if none exists
      return {
        ...node,
        position: { x: 0, y: 0, z: 0 }
      };
    } else if (typeof node.position.x !== 'number' ||
               typeof node.position.y !== 'number' ||
               typeof node.position.z !== 'number') {
      // Fix any NaN or undefined coordinates
      node.position.x = typeof node.position.x === 'number' ? node.position.x : 0;
      node.position.y = typeof node.position.y === 'number' ? node.position.y : 0;
      node.position.z = typeof node.position.z === 'number' ? node.position.z : 0;
    }
    return node;
  }

  // Clean up resources
  public dispose(): void {
    if (this.retryTimeout) {
      window.clearTimeout(this.retryTimeout);
      this.retryTimeout = null;
    }

    this.graphDataListeners = [];
    this.positionUpdateListeners = [];
    this.webSocketService = null;
    this.nodeIdMap.clear();
    this.reverseNodeIdMap.clear();

    if (debugState.isEnabled()) {
      logger.info('GraphDataManager disposed');
    }
  }
}

export const graphDataManager = GraphDataManager.getInstance();


```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/graph/managers/graphWorkerProxy.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/graph/managers/graphWorkerProxy.ts
```ts
/**
 * Graph Worker Proxy
 * Main thread interface to the graph worker using Comlink
 */

import { wrap, Remote } from 'comlink';
import { GraphWorkerType } from '../workers/graph.worker';
import { createLogger } from '../../../utils/logger';
import { debugState } from '../../../utils/debugState';

const logger = createLogger('GraphWorkerProxy');

export interface Node {
  id: string;
  label: string;
  position: {
    x: number;
    y: number;
    z: number;
  };
  metadata?: Record<string, any>;
}

export interface Edge {
  id: string;
  source: string;
  target: string;
  label?: string;
  weight?: number;
  metadata?: Record<string, any>;
}

export interface GraphData {
  nodes: Node[];
  edges: Edge[];
}

type GraphDataChangeListener = (data: GraphData) => void;
type PositionUpdateListener = (positions: Float32Array) => void;

/**
 * Proxy class that communicates with the graph worker
 */
class GraphWorkerProxy {
  private static instance: GraphWorkerProxy;
  private worker: Worker | null = null;
  private workerApi: Remote<GraphWorkerType> | null = null;
  private graphDataListeners: GraphDataChangeListener[] = [];
  private positionUpdateListeners: PositionUpdateListener[] = [];
  private sharedBuffer: SharedArrayBuffer | null = null;
  private isInitialized: boolean = false;

  private constructor() {
    this.initializeWorker();
  }

  public static getInstance(): GraphWorkerProxy {
    if (!GraphWorkerProxy.instance) {
      GraphWorkerProxy.instance = new GraphWorkerProxy();
    }
    return GraphWorkerProxy.instance;
  }

  private async initializeWorker(): Promise<void> {
    try {
      // Create worker instance
      this.worker = new Worker(
        new URL('../workers/graph.worker.ts', import.meta.url),
        { type: 'module' }
      );

      // Wrap worker with Comlink
      this.workerApi = wrap<GraphWorkerType>(this.worker);

      // Set up shared array buffer for position data (4 floats per node * max 10k nodes)
      const maxNodes = 10000;
      const bufferSize = maxNodes * 4 * 4; // 4 floats * 4 bytes per float

      if (typeof SharedArrayBuffer !== 'undefined') {
        this.sharedBuffer = new SharedArrayBuffer(bufferSize);
        await this.workerApi.setupSharedPositions(this.sharedBuffer);
        if (debugState.isEnabled()) {
          logger.info(`Initialized SharedArrayBuffer: ${bufferSize} bytes for ${maxNodes} nodes`);
        }
      } else {
        logger.warn('SharedArrayBuffer not available, falling back to regular message passing');
      }

      this.isInitialized = true;
      if (debugState.isEnabled()) {
        logger.info('Graph worker initialized successfully');
      }
    } catch (error) {
      logger.error('Failed to initialize graph worker:', error);
      throw error;
    }
  }

  /**
   * Set graph data in the worker
   */
  public async setGraphData(data: GraphData): Promise<void> {
    if (!this.workerApi) {
      throw new Error('Worker not initialized');
    }

    await this.workerApi.setGraphData(data);
    this.notifyGraphDataListeners(data);

    if (debugState.isEnabled()) {
      logger.info(`Set graph data: ${data.nodes.length} nodes, ${data.edges.length} edges`);
    }
  }

  /**
   * Process binary data through the worker (with decompression)
   */
  public async processBinaryData(data: ArrayBuffer): Promise<void> {
    if (!this.workerApi) {
      throw new Error('Worker not initialized');
    }

    try {
      const positionArray = await this.workerApi.processBinaryData(data);
      this.notifyPositionUpdateListeners(positionArray);

      // Get updated graph data from worker
      const graphData = await this.workerApi.getGraphData();
      this.notifyGraphDataListeners(graphData);

      if (debugState.isDataDebugEnabled()) {
        logger.debug(`Processed binary data: ${positionArray.length / 4} position updates`);
      }
    } catch (error) {
      logger.error('Error processing binary data in worker:', error);
      throw error;
    }
  }

  /**
   * Get current graph data from worker
   */
  public async getGraphData(): Promise<GraphData> {
    if (!this.workerApi) {
      throw new Error('Worker not initialized');
    }
    return await this.workerApi.getGraphData();
  }

  /**
   * Add or update a node in the worker
   */
  public async updateNode(node: Node): Promise<void> {
    if (!this.workerApi) {
      throw new Error('Worker not initialized');
    }

    await this.workerApi.updateNode(node);

    // Get updated data and notify listeners
    const graphData = await this.workerApi.getGraphData();
    this.notifyGraphDataListeners(graphData);
  }

  /**
   * Remove a node from the worker
   */
  public async removeNode(nodeId: string): Promise<void> {
    if (!this.workerApi) {
      throw new Error('Worker not initialized');
    }

    await this.workerApi.removeNode(nodeId);

    // Get updated data and notify listeners
    const graphData = await this.workerApi.getGraphData();
    this.notifyGraphDataListeners(graphData);
  }

  /**
   * Get shared array buffer view for position data
   */
  public getSharedPositionBuffer(): Float32Array | null {
    if (!this.sharedBuffer) {
      return null;
    }
    return new Float32Array(this.sharedBuffer);
  }

  /**
   * Add listener for graph data changes
   */
  public onGraphDataChange(listener: GraphDataChangeListener): () => void {
    this.graphDataListeners.push(listener);

    // Return unsubscribe function
    return () => {
      this.graphDataListeners = this.graphDataListeners.filter(l => l !== listener);
    };
  }

  /**
   * Add listener for position updates
   */
  public onPositionUpdate(listener: PositionUpdateListener): () => void {
    this.positionUpdateListeners.push(listener);

    // Return unsubscribe function
    return () => {
      this.positionUpdateListeners = this.positionUpdateListeners.filter(l => l !== listener);
    };
  }

  /**
   * Check if worker is ready
   */
  public isReady(): boolean {
    return this.isInitialized && this.workerApi !== null;
  }

  /**
   * Dispose of worker resources
   */
  public dispose(): void {
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }

    this.workerApi = null;
    this.graphDataListeners = [];
    this.positionUpdateListeners = [];
    this.sharedBuffer = null;
    this.isInitialized = false;

    if (debugState.isEnabled()) {
      logger.info('Graph worker disposed');
    }
  }

  private notifyGraphDataListeners(data: GraphData): void {
    this.graphDataListeners.forEach(listener => {
      try {
        listener(data);
      } catch (error) {
        logger.error('Error in graph data listener:', error);
      }
    });
  }

  private notifyPositionUpdateListeners(positions: Float32Array): void {
    this.positionUpdateListeners.forEach(listener => {
      try {
        listener(positions);
      } catch (error) {
        logger.error('Error in position update listener:', error);
      }
    });
  }
}

export const graphWorkerProxy = GraphWorkerProxy.getInstance();
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/graph/workers/graph.worker.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/graph/workers/graph.worker.ts
```ts
/**
 * Graph Data Web Worker
 * Handles graph data processing, binary decompression, and position updates off the main thread
 */

import { expose } from 'comlink';
import { BinaryNodeData, parseBinaryNodeData, createBinaryNodeData, Vec3 } from '../../../types/binaryProtocol';

export interface Node {
  id: string;
  label: string;
  position: {
    x: number;
    y: number;
    z: number;
  };
  metadata?: Record<string, any>;
}

export interface Edge {
  id: string;
  source: string;
  target: string;
  label?: string;
  weight?: number;
  metadata?: Record<string, any>;
}

export interface GraphData {
  nodes: Node[];
  edges: Edge[];
}

/**
 * Decompress zlib compressed data in worker thread
 */
async function decompressZlib(compressedData: ArrayBuffer): Promise<ArrayBuffer> {
  if (typeof DecompressionStream !== 'undefined') {
    try {
      const cs = new DecompressionStream('deflate-raw');
      const writer = cs.writable.getWriter();
      writer.write(new Uint8Array(compressedData.slice(2))); // Skip zlib header
      writer.close();

      const output = [];
      const reader = cs.readable.getReader();

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        output.push(value);
      }

      const totalLength = output.reduce((acc, arr) => acc + arr.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;

      for (const arr of output) {
        result.set(arr, offset);
        offset += arr.length;
      }

      return result.buffer;
    } catch (error) {
      console.error('Worker decompression failed:', error);
      throw error;
    }
  }
  throw new Error('DecompressionStream not available');
}

/**
 * Check if data is zlib compressed
 */
function isZlibCompressed(data: ArrayBuffer): boolean {
  if (data.byteLength < 2) return false;
  const view = new Uint8Array(data);
  return view[0] === 0x78 && [0x01, 0x5E, 0x9C, 0xDA].includes(view[1]);
}

/**
 * Graph Worker API exposed to main thread
 */
class GraphWorker {
  private graphData: GraphData = { nodes: [], edges: [] };
  private nodeIdMap: Map<string, number> = new Map();
  private reverseNodeIdMap: Map<number, string> = new Map();
  private positionBuffer: SharedArrayBuffer | null = null;
  private positionView: Float32Array | null = null;

  /**
   * Initialize the worker with graph data
   */
  async setGraphData(data: GraphData): Promise<void> {
    this.graphData = {
      nodes: data.nodes.map(node => this.ensureNodeHasValidPosition(node)),
      edges: data.edges
    };

    // Create ID mappings
    this.nodeIdMap.clear();
    this.reverseNodeIdMap.clear();

    this.graphData.nodes.forEach((node, index) => {
      const numericId = parseInt(node.id, 10);
      if (!isNaN(numericId) && numericId >= 0 && numericId <= 0xFFFFFFFF) {
        this.nodeIdMap.set(node.id, numericId);
        this.reverseNodeIdMap.set(numericId, node.id);
      } else {
        const mappedId = index + 1;
        this.nodeIdMap.set(node.id, mappedId);
        this.reverseNodeIdMap.set(mappedId, node.id);
      }
    });

    console.log(`GraphWorker: Initialized with ${this.graphData.nodes.length} nodes`);
  }

  /**
   * Set up shared array buffer for position data
   */
  async setupSharedPositions(buffer: SharedArrayBuffer): Promise<void> {
    this.positionBuffer = buffer;
    this.positionView = new Float32Array(buffer);
    console.log(`GraphWorker: SharedArrayBuffer set up with ${buffer.byteLength} bytes`);
  }

  /**
   * Process binary position data with decompression
   */
  async processBinaryData(data: ArrayBuffer): Promise<Float32Array> {
    try {
      // Decompress if needed
      if (isZlibCompressed(data)) {
        data = await decompressZlib(data);
      }

      // Parse binary data
      const nodeUpdates = parseBinaryNodeData(data);

      if (nodeUpdates.length === 0) {
        console.warn('No valid node updates parsed from binary data');
        return new Float32Array(0);
      }

      // Create position array (4 values per node: id, x, y, z)
      const positionArray = new Float32Array(nodeUpdates.length * 4);
      let updatedCount = 0;

      nodeUpdates.forEach((nodeUpdate, index) => {
        const { nodeId, position, velocity } = nodeUpdate;
        const stringNodeId = this.reverseNodeIdMap.get(nodeId);

        if (stringNodeId) {
          const nodeIndex = this.graphData.nodes.findIndex(node => node.id === stringNodeId);
          if (nodeIndex >= 0) {
            const oldNode = this.graphData.nodes[nodeIndex];
            this.graphData.nodes[nodeIndex] = {
              ...oldNode,
              position: { ...position },
              metadata: {
                ...oldNode.metadata,
                velocity: { ...velocity }
              }
            };
            updatedCount++;
          }
        }

        // Update position array
        const arrayOffset = index * 4;
        positionArray[arrayOffset] = nodeId;
        positionArray[arrayOffset + 1] = position.x;
        positionArray[arrayOffset + 2] = position.y;
        positionArray[arrayOffset + 3] = position.z;
      });

      // Update shared buffer if available
      if (this.positionView && positionArray.length <= this.positionView.length) {
        this.positionView.set(positionArray);
      }

      console.log(`GraphWorker: Updated ${updatedCount} nodes from binary data`);
      return positionArray;
    } catch (error) {
      console.error('GraphWorker: Error processing binary data:', error);
      throw error;
    }
  }

  /**
   * Get current graph data
   */
  async getGraphData(): Promise<GraphData> {
    return this.graphData;
  }

  /**
   * Add or update a node
   */
  async updateNode(node: Node): Promise<void> {
    const existingIndex = this.graphData.nodes.findIndex(n => n.id === node.id);

    if (existingIndex >= 0) {
      this.graphData.nodes[existingIndex] = { ...this.graphData.nodes[existingIndex], ...node };
    } else {
      this.graphData.nodes.push(this.ensureNodeHasValidPosition(node));

      // Update ID mappings
      const numericId = parseInt(node.id, 10);
      if (!isNaN(numericId)) {
        this.nodeIdMap.set(node.id, numericId);
        this.reverseNodeIdMap.set(numericId, node.id);
      } else {
        const mappedId = this.graphData.nodes.length;
        this.nodeIdMap.set(node.id, mappedId);
        this.reverseNodeIdMap.set(mappedId, node.id);
      }
    }
  }

  /**
   * Remove a node
   */
  async removeNode(nodeId: string): Promise<void> {
    const numericId = this.nodeIdMap.get(nodeId);

    this.graphData.nodes = this.graphData.nodes.filter(node => node.id !== nodeId);
    this.graphData.edges = this.graphData.edges.filter(
      edge => edge.source !== nodeId && edge.target !== nodeId
    );

    if (numericId !== undefined) {
      this.nodeIdMap.delete(nodeId);
      this.reverseNodeIdMap.delete(numericId);
    }
  }

  /**
   * Create binary node data
   */
  async createBinaryData(nodes: BinaryNodeData[]): Promise<ArrayBuffer> {
    return createBinaryNodeData(nodes);
  }

  private ensureNodeHasValidPosition(node: Node): Node {
    if (!node.position) {
      return { ...node, position: { x: 0, y: 0, z: 0 } };
    }

    return {
      ...node,
      position: {
        x: typeof node.position.x === 'number' ? node.position.x : 0,
        y: typeof node.position.y === 'number' ? node.position.y : 0,
        z: typeof node.position.z === 'number' ? node.position.z : 0
      }
    };
  }
}

const worker = new GraphWorker();
expose(worker);

export type GraphWorkerType = GraphWorker;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/settings/components/BackendUrlSetting.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/settings/components/BackendUrlSetting.tsx
```tsx
import React, { useState, useEffect } from 'react';
import { useSettingsStore } from '@/store/settingsStore';
import { Button } from '@/ui/Button';
import { Input } from '@/ui/Input';
import { Label } from '@/ui/Label';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/ui/Card';
import WebSocketService from '@/services/WebSocketService';
import { createLogger } from '@/utils/logger';

const logger = createLogger('BackendUrlSetting');

export function BackendUrlSetting() {
  const { get: getSetting, set: setSetting } = useSettingsStore();
  const [backendUrl, setBackendUrl] = useState<string>('');
  const [isConnected, setIsConnected] = useState<boolean>(false);

  // Initialize from settings
  useEffect(() => {
    const storedUrl = getSetting('system.customBackendUrl') as string;
    setBackendUrl(storedUrl || '');

    // Check connection status
    const websocketService = WebSocketService.getInstance();
    setIsConnected(websocketService.isReady());

    // Subscribe to connection status changes
    const unsubscribe = websocketService.onConnectionStatusChange((connected) => {
      setIsConnected(connected);
    });

    return () => {
      unsubscribe();
    };
  }, [getSetting]);

  const handleSave = () => {
    // Save to settings
    setSetting('system.customBackendUrl', backendUrl);

    // Update WebSocket service
    const websocketService = WebSocketService.getInstance();
    websocketService.setCustomBackendUrl(backendUrl || null);

    logger.info(`Backend URL set to: ${backendUrl || 'default'}`);
  };

  const handleReset = () => {
    setBackendUrl('');
    setSetting('system.customBackendUrl', '');

    // Reset WebSocket service to default URL
    const websocketService = WebSocketService.getInstance();
    websocketService.setCustomBackendUrl(null);

    logger.info('Backend URL reset to default');
  };

  return (
    <Card className="w-full">
      <CardHeader>
        <CardTitle>Backend Connection</CardTitle>
        <CardDescription>
          Configure the connection to the backend server
        </CardDescription>
      </CardHeader>
      <CardContent>
        <div className="grid gap-4">
          <div className="flex items-center gap-2">
            <div className={`w-3 h-3 rounded-full ${isConnected ? 'bg-green-500' : 'bg-red-500'}`}></div>
            <span>{isConnected ? 'Connected' : 'Disconnected'}</span>
          </div>

          <div className="grid gap-2">
            <Label htmlFor="backendUrl">Backend URL</Label>
            <Input
              id="backendUrl"
              placeholder="e.g., http://192.168.0.51:8000"
              value={backendUrl}
              onChange={(e) => setBackendUrl(e.target.value)}
            />
            <p className="text-sm text-muted-foreground">
              Leave empty to use the default backend URL. Changes require reconnection.
            </p>
          </div>
        </div>
      </CardContent>
      <CardFooter className="flex justify-between">
        <Button variant="outline" onClick={handleReset}>
          Reset to Default
        </Button>
        <Button onClick={handleSave}>
          Save & Reconnect
        </Button>
      </CardFooter>
    </Card>
  );
}

export default BackendUrlSetting;

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/settings/components/SettingControlComponent.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/settings/components/SettingControlComponent.tsx
```tsx
import React, { useState, useEffect, useCallback } from 'react';
import { UISettingDefinition } from '../config/settingsUIDefinition'; // Import the new definition type
import { Label } from '@/ui/Label';
import { Slider } from '@/ui/Slider';
import { Switch } from '@/ui/Switch';
import { Input } from '@/ui/Input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/ui/Select';
import { RadioGroup, RadioGroupItem } from '@/ui/RadioGroup'; // Added RadioGroup imports
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/ui/Tooltip';
import { Button } from '@/ui/Button';
import { Info, Eye, EyeOff } from 'lucide-react';

function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export interface SettingControlProps {
  path: string;
  settingDef: UISettingDefinition;
  value: any;
  onChange: (value: any) => void;
}

export function SettingControlComponent({ path, settingDef, value, onChange }: SettingControlProps) {
  // State for debounced inputs
  const [inputValue, setInputValue] = useState(String(value ?? ''));
  const debouncedInputValue = useDebounce(inputValue, 300); // 300ms debounce
  const [showPassword, setShowPassword] = useState(false); // For password visibility toggle

  // Update internal state when the external value changes
  useEffect(() => {
    // Only update if the debounced value isn't the source of the change
    // This prevents loops but might need refinement depending on useDebounce implementation
    if (String(value) !== inputValue) {
       if (settingDef.type === 'rangeSlider' || settingDef.type === 'dualColorPicker') {
         // For array types, handle string conversion carefully if needed, or maybe skip input state?
         // For now, let's assume direct value prop usage for sliders/pickers is better for arrays.
       } else {
         setInputValue(String(value ?? ''));
       }
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [value, settingDef.type]); // Rerun if value or type changes

  // Effect to call onChange when debounced value changes
  useEffect(() => {
    if (settingDef.type === 'textInput' || settingDef.type === 'numberInput') {
      // Avoid calling onChange with the initial value or if it hasn't changed
      if (debouncedInputValue !== String(value ?? '')) {
        if (settingDef.type === 'numberInput') {
          const numValue = parseFloat(debouncedInputValue);
          if (!isNaN(numValue)) {
            onChange(numValue);
          }
        } else {
          onChange(debouncedInputValue);
        }
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [debouncedInputValue, settingDef.type, onChange]); // Depend on debounced value

  // Handler for immediate input changes (updates local state)
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setInputValue(e.target.value);
  };

  // Render appropriate control based on settingDef.type
  const renderControl = () => {
    switch (settingDef.type) {
      case 'toggle':
        return (
          <Switch
            id={path}
            checked={Boolean(value)}
            onCheckedChange={onChange}
          />
        );

      case 'slider': {
        // Defensive fallback if value is undefined or invalid
        const numericValue = typeof value === 'number' && !isNaN(value)
          ? value
          : (settingDef.min ?? 0);
        return (
          <div className="flex w-full items-center gap-3">
            <Slider
              id={path}
              value={[numericValue]}
              min={settingDef.min ?? 0}
              max={settingDef.max ?? 1}
              step={settingDef.step ?? 0.01}
              onValueChange={([val]) => onChange(val)}
              className="flex-1"
            />
            <span className="text-xs font-mono w-16 text-right tabular-nums">
              {numericValue.toFixed(settingDef.step && settingDef.step < 1 ? 2 : 0)}
              {settingDef.unit && <span className="ml-1">{settingDef.unit}</span>}
            </span>
          </div>
        );
      }

      case 'numberInput':
        // Always render an Input for 'numberInput' type.
        // If a slider is preferred, 'slider' type should be used in definition.
        return (
          <div className="flex items-center w-full">
            <Input
              id={path}
              type="number"
              value={inputValue}
              onChange={handleInputChange}
              min={settingDef.min}
              max={settingDef.max}
              step={settingDef.step ?? 1}
              className="h-8 flex-1 tabular-nums"
            />
            {settingDef.unit && <span className="text-xs text-muted-foreground pl-2">{settingDef.unit}</span>}
          </div>
        );

      case 'textInput':
        // Special handling for obscured fields like API keys
        const isSensitive = settingDef.label.toLowerCase().includes('key') ||
                           settingDef.label.toLowerCase().includes('secret') ||
                           settingDef.label.toLowerCase().includes('token');
        return (
          <div className="flex items-center w-full gap-2">
            <Input
              id={path}
              type={isSensitive && !showPassword ? "password" : "text"}
              value={inputValue} // Use local state for debouncing
              onChange={handleInputChange} // Update local state immediately
              className="h-8 flex-1" // Allow input to grow
              placeholder={isSensitive ? "Enter secure value" : "Enter value"}
            />
            {isSensitive && (
              <Button
                type="button"
                variant="ghost"
                size="icon"
                className="h-8 w-8"
                onClick={() => setShowPassword(!showPassword)}
                title={showPassword ? "Hide value" : "Show value"}
              >
                {showPassword ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
              </Button>
            )}
            {settingDef.unit && <span className="text-xs text-muted-foreground">{settingDef.unit}</span>}
          </div>
        );

      case 'colorPicker':
        return (
          <div className="flex items-center gap-2">
            <Input
              id={path}
              type="color"
              value={String(value ?? '#000000')} // Ensure value is a string, default if null/undefined
              onChange={(e) => {
                // Ensure a valid hex color is always passed
                const newValue = e.target.value;
                if (/^#[0-9A-Fa-f]{6}$/i.test(newValue)) {
                  onChange(newValue);
                } else {
                  onChange('#000000'); // Fallback if somehow invalid from color input
                }
              }}
              className="h-8 w-10 p-0.5 border-border cursor-pointer"
            />
            <Input
              type="text"
              value={String(value ?? '')} // Reflect current value, allow empty for typing
              onChange={(e) => {
                const newValue = e.target.value;
                if (/^#[0-9A-Fa-f]{6}$/i.test(newValue)) {
                  onChange(newValue);
                } else if (newValue === '') {
                  // If user clears the input, set to a default to avoid sending empty string
                  // Or, you could choose not to call onChange, making the text input temporarily invalid
                  // For now, let's set a default to prevent server errors.
                  onChange('#000000'); // Default if cleared
                }
                // For other invalid inputs, we don't call onChange,
                // so the store isn't updated with an invalid partial hex.
                // The visual input will show the invalid text until corrected or blurred.
              }}
              onBlur={(e) => { // Ensure on blur, if invalid, it reverts or uses a default
                const currentValue = e.target.value;
                if (!/^#[0-9A-Fa-f]{6}$/i.test(currentValue)) {
                    // If current store value is valid, revert to it, else default
                    if (typeof value === 'string' && /^#[0-9A-Fa-f]{6}$/i.test(value)) {
                        onChange(value); // Revert to last known good value from store
                    } else {
                        onChange('#000000'); // Fallback to black
                    }
                }
              }}
              className="h-8 flex-1 font-mono text-xs"
              placeholder="#rrggbb"
            />
          </div>
        );

      case 'select':
        return (
          <Select
            value={String(value)} // Ensure value is string for Select
            onValueChange={(val) => onChange(val)} // Pass the string value back
          >
            <SelectTrigger id={path} className="h-8 w-full">
              <SelectValue placeholder={settingDef.label} />
            </SelectTrigger>
            <SelectContent>
              {settingDef.options?.map(opt => (
                <SelectItem key={String(opt.value)} value={String(opt.value)}>
                  {opt.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        );

      case 'radioGroup':
        return (
          <RadioGroup
            id={path}
            value={String(value)}
            onValueChange={(val) => onChange(val)}
            className="flex flex-row gap-4" // Arrange radio buttons horizontally
          >
            {settingDef.options?.map(opt => (
              <div key={String(opt.value)} className="flex items-center space-x-2">
                <RadioGroupItem value={String(opt.value)} id={`${path}-${opt.value}`} />
                <Label htmlFor={`${path}-${opt.value}`} className="text-sm font-normal">
                  {opt.label}
                </Label>
              </div>
            ))}
          </RadioGroup>
        );

      case 'rangeSlider': { // For [number, number] arrays
        const [minVal, maxVal] = Array.isArray(value) ? value : [settingDef.min ?? 0, settingDef.max ?? 1];
        const handleMinChange = (e: React.ChangeEvent<HTMLInputElement>) => {
          const newMin = parseFloat(e.target.value);
          if (!isNaN(newMin)) {
            onChange([newMin, maxVal]);
          }
        };
        const handleMaxChange = (e: React.ChangeEvent<HTMLInputElement>) => {
          const newMax = parseFloat(e.target.value);
          if (!isNaN(newMax)) {
            onChange([minVal, newMax]);
          }
        };
        return (
          <div className="flex flex-col gap-2">
            <div className="flex items-center gap-2">
              <Label htmlFor={`${path}-min`} className="text-xs w-10">Min:</Label>
              <Input id={`${path}-min`} type="number" value={minVal} onChange={handleMinChange} min={settingDef.min} max={maxVal} step={settingDef.step} className="h-8 flex-1" placeholder="Min" />
            </div>
            <div className="flex items-center gap-2">
              <Label htmlFor={`${path}-max`} className="text-xs w-10">Max:</Label>
              <Input id={`${path}-max`} type="number" value={maxVal} onChange={handleMaxChange} min={minVal} max={settingDef.max} step={settingDef.step} className="h-8 flex-1" placeholder="Max" />
            </div>
            {settingDef.unit && <span className="text-xs text-muted-foreground self-end">{settingDef.unit}</span>}
          </div>
        );
      }

      case 'dualColorPicker': { // For [string, string] color arrays
        const [color1 = '#ffffff', color2 = '#000000'] = Array.isArray(value) && value.length === 2 ? value : ['#ffffff', '#000000'];

        const createColorChangeHandler = (index: 0 | 1) => (e: React.ChangeEvent<HTMLInputElement>) => {
          const newColorValue = e.target.value;
          const currentColors = [color1, color2];

          if (/^#[0-9A-Fa-f]{6}$/i.test(newColorValue)) {
            currentColors[index] = newColorValue;
            onChange([...currentColors]);
          } else if (newColorValue === '') {
            currentColors[index] = '#000000'; // Default if cleared
            onChange([...currentColors]);
          }
          // For other invalid inputs, do not call onChange from text input
        };

        const createColorBlurHandler = (index: 0 | 1) => (e: React.ChangeEvent<HTMLInputElement>) => {
            const currentColors = [color1, color2];
            const blurredValue = e.target.value;
            if (!/^#[0-9A-Fa-f]{6}$/i.test(blurredValue)) {
                // Revert to original value for this specific color input if it was valid, else default
                const originalColorAtIndex = (Array.isArray(value) && value.length === 2 && typeof value[index] === 'string' && /^#[0-9A-Fa-f]{6}$/i.test(value[index])) ? value[index] : '#000000';
                currentColors[index] = originalColorAtIndex;
                onChange([...currentColors]);
            }
        };

        return (
          <div className="flex flex-col gap-2">
            <div className="flex items-center gap-2">
              <Label className="text-xs w-16">Start:</Label>
              <Input type="color" value={color1} onChange={createColorChangeHandler(0)} className="h-8 w-10 p-0.5 border-border cursor-pointer" title="Start Color" />
              <Input type="text" value={color1} onChange={createColorChangeHandler(0)} onBlur={createColorBlurHandler(0)} className="h-8 flex-1 font-mono text-xs" placeholder="#rrggbb" />
            </div>
            <div className="flex items-center gap-2">
              <Label className="text-xs w-16">End:</Label>
              <Input type="color" value={color2} onChange={createColorChangeHandler(1)} className="h-8 w-10 p-0.5 border-border cursor-pointer" title="End Color" />
              <Input type="text" value={color2} onChange={createColorChangeHandler(1)} onBlur={createColorBlurHandler(1)} className="h-8 flex-1 font-mono text-xs" placeholder="#rrggbb" />
            </div>
          </div>
        );
      }


      case 'buttonAction':
        return (
          <Button onClick={settingDef.action} size="sm" variant="outline">
            {settingDef.label} {/* Button text is the label */}
          </Button>
        );

      default:
        // Render value as string for unknown types
        return <span className="text-sm text-muted-foreground">{JSON.stringify(value)}</span>;
    }
  };

  // For button actions, the label is the button itself, so we don't need a separate label.
  if (settingDef.type === 'buttonAction') {
    return renderControl();
  }

  return (
    <div className="setting-control grid grid-cols-3 items-center gap-x-4 gap-y-2 py-3 border-b border-border/30 last:border-b-0 hover:bg-muted/20 transition-colors rounded-sm px-1 -mx-1">
      <div className="col-span-1 flex items-center"> {/* Label takes 1/3rd */}
        <Label htmlFor={path} className="text-sm flex items-center gap-1.5">
          <span>{settingDef.label}</span>
          {settingDef.description && (
            <TooltipProvider delayDuration={100}>
              <Tooltip content={settingDef.description} side="top" align="start">
                <Info className="h-3.5 w-3.5 text-muted-foreground/70 hover:text-muted-foreground cursor-help" />
              </Tooltip>
            </TooltipProvider>
          )}
        </Label>
      </div>
      <div className="col-span-2"> {/* Control takes 2/3rds */}
        {renderControl()}
      </div>
    </div>
  );
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/settings/components/SettingsSection.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/settings/components/SettingsSection.tsx
```tsx
import React, { useState } from 'react'; // Added React import
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/ui/Collapsible';
import { Card, CardContent, CardHeader, CardTitle } from '@/ui/Card';
import { ChevronDown, ChevronUp, Minimize, Maximize } from 'lucide-react';
import { Button } from '@/ui/Button';
import Draggable from 'react-draggable';
import { useControlPanelContext } from './control-panel-context';
import { UISettingDefinition } from '../config/settingsUIDefinition'; // Import the definition type
import { SettingControlComponent } from './SettingControlComponent'; // Import the control component
import { useSettingsStore } from '@/store/settingsStore'; // Adjust path if necessary

interface SettingsSectionProps {
  id: string;
  title: string;
  subsectionSettings: Record<string, UISettingDefinition>;
}

export function SettingsSection({ id, title, subsectionSettings }: SettingsSectionProps) {
  const [isOpen, setIsOpen] = useState(true);
  const [isDetached, setIsDetached] = useState(false);
  const { advancedMode } = useControlPanelContext();
  const settingsStore = useSettingsStore.getState(); // Get store state once

  // Removed advanced prop check at the top level

  // Removed old subsection mapping logic

  const handleDetach = () => {
    setIsDetached(!isDetached);
  };

  const renderSettings = () => (
    <div className="space-y-4">
      {Object.entries(subsectionSettings).map(([settingKey, settingDef]) => {
        // Visibility check: Advanced
        if (settingDef.isAdvanced && !advancedMode) {
          return null;
        }

        // Visibility/Read-only check: Power User
        const isPowerUser = useSettingsStore.getState().isPowerUser;
        if (settingDef.isPowerUserOnly && !isPowerUser) {
          // Decide whether to hide or show as read-only. Hiding for now.
          // TODO: Implement read-only display if needed
          return null;
        }

        // Retrieve value and define onChange handler
        const value = settingsStore.get(settingDef.path);
        const handleChange = (newValue: any) => {
          settingsStore.set(settingDef.path, newValue);
        };

        return (
          <SettingControlComponent
            key={settingKey}
            path={settingDef.path}
            settingDef={settingDef}
            value={value}
            onChange={handleChange}
          />
        );
      })}
    </div>
  );

  if (isDetached) {
    return (
      <DetachedSection
        title={title}
        onReattach={handleDetach}
        sectionId={id}
      >
        <div className="p-2"> {/* Removed extra space-y-4, handled by renderSettings */}
          {renderSettings()}
        </div>
      </DetachedSection>
    );
  }

  return (
    <Card className="settings-section bg-card border border-border"> {/* Added background and border */}
      <CardHeader className="py-2 px-4">
        <Collapsible open={isOpen} onOpenChange={setIsOpen}>
          <div className="flex items-center justify-between">
            <CollapsibleTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 p-0 hover:bg-muted/50"> {/* Added hover effect */}
                <CardTitle className="text-sm font-medium text-card-foreground">{title}</CardTitle>
                {isOpen ? <ChevronUp className="ml-2 h-4 w-4 text-muted-foreground" /> : <ChevronDown className="ml-2 h-4 w-4 text-muted-foreground" />}
              </Button>
            </CollapsibleTrigger>
            <Button
              variant="ghost"
              size="icon"
              className="h-6 w-6 text-muted-foreground hover:text-card-foreground hover:bg-muted/50" // Added hover effect
              onClick={handleDetach}
              title="Detach section"
            >
              <Maximize className="h-3 w-3" />
            </Button>
          </div>

          <CollapsibleContent>
            <CardContent className="p-4 pt-3"> {/* Adjusted padding */}
              {renderSettings()}
            </CardContent>
          </CollapsibleContent>
        </Collapsible>
      </CardHeader>
    </Card>
  );
}

function DetachedSection({
  children,
  title,
  onReattach,
  sectionId
}: {
  children: React.ReactNode;
  title: string;
  onReattach: () => void;
  sectionId: string;
}) {
  const [position, setPosition] = useState({ x: 100, y: 100 });

  const handleDrag = (e: any, data: { x: number; y: number }) => {
    setPosition({ x: data.x, y: data.y });
  };

  // Ensure the parent element for bounds exists and covers the intended area
  // If bounds="parent" doesn't work as expected, might need a specific selector or DOM element reference.

  return (
    <Draggable
      handle=".drag-handle" // Use a specific handle for dragging
      position={position}
      onDrag={handleDrag}
      bounds="body" // Changed bounds to body to allow freer movement
    >
      <div
        className="detached-panel absolute z-[3000] min-w-[300px] bg-card rounded-lg shadow-lg border border-border" // Added background, rounded corners
        data-section-id={sectionId}
      >
        <div className="drag-handle flex items-center justify-between border-b border-border p-2 cursor-move bg-muted/50 rounded-t-lg"> {/* Added handle class, background */}
          <div className="text-sm font-medium text-card-foreground">
            {title}
          </div>
          <Button
            variant="ghost"
            size="icon"
            className="h-6 w-6 text-muted-foreground hover:text-card-foreground hover:bg-muted/50" // Added hover effect
            onClick={onReattach}
            title="Reattach section"
          >
            <Minimize className="h-3 w-3" />
          </Button>
        </div>
        <div className="p-4 max-h-[400px] overflow-y-auto custom-scrollbar"> {/* Added padding, max-height and scroll */}
          {children}
        </div>
      </div>
    </Draggable>
  );
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/settings/components/SettingsSubsection.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/settings/components/SettingsSubsection.tsx
```tsx
import { useSettingsStore } from '@/store/settingsStore'
import { SettingsSubsectionProps } from '../types/settingsTypes'
import { SettingControl } from '../types/settingsTypes'
import { formatSettingName } from '../config/settingsConfig'
import { SettingControlComponent } from './SettingControlComponent'

export function SettingsSubsection({ title, settings, path }: SettingsSubsectionProps) {
  const settingsStore = useSettingsStore()

  // Check if this is a single setting or a group of settings
  // Fix: Check if settings is an object before using 'in' operator
  const isObject = settings !== null && typeof settings === 'object';
  const isSingleSetting = isObject && 'type' in settings;

  // Format the title for display
  const formattedTitle = formatSettingName(title);

  return (
    <div className="settings-subsection">
      <h3 className="mb-2 text-sm font-medium text-muted-foreground">
        {formattedTitle}
      </h3>

      <div className="space-y-2">
        {isSingleSetting ? (
          // Render a single setting control
          <SettingControlComponent
            path={path}
            setting={settings as SettingControl}
            value={settingsStore.get(path)}
            onChange={(value) => settingsStore.set(path, value)}
          />
        ) : (
          // Render multiple setting controls
          Object.entries(settings as Record<string, SettingControl>).map(([key, setting]) => {
            const fullPath = `${path}.${key}`;
            return (
              <SettingControlComponent
                key={key}
                path={fullPath}
                setting={setting}
                value={settingsStore.get(fullPath)}
                onChange={(value) => settingsStore.set(fullPath, value)}
              />
            );
          })
        )}
      </div>
    </div>
  );
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/settings/components/control-panel-context.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/settings/components/control-panel-context.tsx
```tsx
import React, { createContext, useContext, useState, ReactNode } from 'react';

interface ControlPanelContextType {
  advancedMode: boolean;
  toggleAdvancedMode: () => void;
}

const defaultContext: ControlPanelContextType = {
  advancedMode: false,
  toggleAdvancedMode: () => {},
};

const ControlPanelContext = createContext<ControlPanelContextType>(defaultContext);

interface ControlPanelProviderProps {
  children: ReactNode;
}

export const ControlPanelProvider: React.FC<ControlPanelProviderProps> = ({ children }) => {
  const [advancedMode, setAdvancedMode] = useState(false);

  const toggleAdvancedMode = () => {
    setAdvancedMode(prev => !prev);
  };

  return (
    <ControlPanelContext.Provider value={{ advancedMode, toggleAdvancedMode }}>
      {children}
    </ControlPanelContext.Provider>
  );
};

export const useControlPanelContext = (): ControlPanelContextType => {
  const context = useContext(ControlPanelContext);
  if (!context) {
    // Return default context instead of throwing an error
    // This makes the hook more resilient when used outside the provider
    return defaultContext;
  }
  return context;
};

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/settings/components/panels/AIPanel.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/settings/components/panels/AIPanel.tsx
```tsx
import React from 'react';
import { SettingsSection } from '../SettingsSection'; // Import SettingsSection
import { UICategoryDefinition } from '../../config/settingsUIDefinition'; // Import definition type

export interface AIPanelProps { // Renamed interface
  settingsDef: UICategoryDefinition;
}

const AIPanel: React.FC<AIPanelProps> = ({ settingsDef }) => {
  // Removed settings store access and handleChange function.
  // This will now be handled by SettingsSection and SettingControlComponent via settingsDef.

  return (
    <div className="p-4 space-y-6 overflow-y-auto h-full custom-scrollbar">
      {/* Iterate through AI service subsections defined in settingsDef */}
      {Object.entries(settingsDef.subsections).map(([subsectionKey, subsectionDef]) => (
        <SettingsSection
          key={subsectionKey}
          id={`settings-${settingsDef.label.toLowerCase().replace(/\s+/g, '-')}-${subsectionKey}`} // e.g., settings-ai-services-ragflow
          title={subsectionDef.label}
          subsectionSettings={subsectionDef.settings}
        />
      ))}
    </div>
  );
};

export default AIPanel;

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/settings/components/panels/SettingsPanelRedesign.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/settings/components/panels/SettingsPanelRedesign.tsx
```tsx
import React, { useState, useMemo } from 'react';
import Tabs from '@/ui/Tabs';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/ui/Card';
import { Button } from '@/ui/Button';
import {
  Eye,
  Settings, // Reverted to Settings
  Smartphone,
  Info,
  ChevronDown,
  ChevronUp, // Added ChevronUp
  Check
} from 'lucide-react';
import { useSettingsStore } from '@/store/settingsStore';
import { SettingControlComponent } from '../SettingControlComponent';
import { settingsUIDefinition } from '../../config/settingsUIDefinition';
import { cn } from '@/utils/cn';

interface SettingItem {
  key: string;
  path: string;
  definition: any;
  isPowerUser?: boolean;
}

interface SettingGroup {
  title: string;
  description?: string;
  items: SettingItem[];
  isPowerUser?: boolean;
}

interface SettingsPanelRedesignProps {
  toggleLowerRightPaneDock: () => void;
  isLowerRightPaneDocked: boolean;
}

export function SettingsPanelRedesign({ toggleLowerRightPaneDock, isLowerRightPaneDocked }: SettingsPanelRedesignProps) {
  const { settings, isPowerUser } = useSettingsStore();
  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(new Set(['Node Appearance']));
  const [savedNotification, setSavedNotification] = useState<string | null>(null);

  // Dynamically get background and text color from settings
  const panelBackground: string = String(useSettingsStore.getState().get('visualisation.rendering.backgroundColor') || '#18181b');
  const panelForeground: string = String(useSettingsStore.getState().get('visualisation.labels.textOutlineColor') || '#fff');

  // Organize settings into logical groups with better structure
  const settingsStructure = useMemo(() => ({
    appearance: {
      label: 'Appearance',
      icon: <Eye className="h-4 w-4" />,
      groups: [
        {
          title: 'Node Appearance',
          description: 'Customize how nodes look',
          items: [
            { key: 'baseColor', path: 'visualisation.nodes.baseColor', definition: settingsUIDefinition.visualisation.subsections.nodes.settings.baseColor },
            { key: 'opacity', path: 'visualisation.nodes.opacity', definition: settingsUIDefinition.visualisation.subsections.nodes.settings.opacity },
            { key: 'metalness', path: 'visualisation.nodes.metalness', definition: settingsUIDefinition.visualisation.subsections.nodes.settings.metalness },
            { key: 'roughness', path: 'visualisation.nodes.roughness', definition: settingsUIDefinition.visualisation.subsections.nodes.settings.roughness },
            { key: 'nodeSize', path: 'visualisation.nodes.nodeSize', definition: settingsUIDefinition.visualisation.subsections.nodes.settings.nodeSize },
            { key: 'enableInstancing', path: 'visualisation.nodes.enableInstancing', definition: settingsUIDefinition.visualisation.subsections.nodes.settings.enableInstancing },
            { key: 'enableHologram', path: 'visualisation.nodes.enableHologram', definition: settingsUIDefinition.visualisation.subsections.nodes.settings.enableHologram },
            { key: 'enableMetadataShape', path: 'visualisation.nodes.enableMetadataShape', definition: settingsUIDefinition.visualisation.subsections.nodes.settings.enableMetadataShape },
            { key: 'enableMetadataVisualisation', path: 'visualisation.nodes.enableMetadataVisualisation', definition: settingsUIDefinition.visualisation.subsections.nodes.settings.enableMetadataVisualisation },
          ]
        },
        {
          title: 'Edge Appearance',
          description: 'Customize connection lines',
          items: [
            { key: 'color', path: 'visualisation.edges.color', definition: settingsUIDefinition.visualisation.subsections.edges.settings.color },
            { key: 'opacity', path: 'visualisation.edges.opacity', definition: settingsUIDefinition.visualisation.subsections.edges.settings.opacity },
            { key: 'baseWidth', path: 'visualisation.edges.baseWidth', definition: settingsUIDefinition.visualisation.subsections.edges.settings.baseWidth },
            { key: 'enableArrows', path: 'visualisation.edges.enableArrows', definition: settingsUIDefinition.visualisation.subsections.edges.settings.enableArrows },
            { key: 'arrowSize', path: 'visualisation.edges.arrowSize', definition: settingsUIDefinition.visualisation.subsections.edges.settings.arrowSize },
            { key: 'widthRange', path: 'visualisation.edges.widthRange', definition: settingsUIDefinition.visualisation.subsections.edges.settings.widthRange },
            { key: 'enableFlowEffect', path: 'visualisation.edges.enableFlowEffect', definition: settingsUIDefinition.visualisation.subsections.edges.settings.enableFlowEffect },
            { key: 'flowSpeed', path: 'visualisation.edges.flowSpeed', definition: settingsUIDefinition.visualisation.subsections.edges.settings.flowSpeed },
            { key: 'flowIntensity', path: 'visualisation.edges.flowIntensity', definition: settingsUIDefinition.visualisation.subsections.edges.settings.flowIntensity },
            { key: 'glowStrength', path: 'visualisation.edges.glowStrength', definition: settingsUIDefinition.visualisation.subsections.edges.settings.glowStrength },
            { key: 'distanceIntensity', path: 'visualisation.edges.distanceIntensity', definition: settingsUIDefinition.visualisation.subsections.edges.settings.distanceIntensity },
            { key: 'useGradient', path: 'visualisation.edges.useGradient', definition: settingsUIDefinition.visualisation.subsections.edges.settings.useGradient },
            { key: 'gradientColors', path: 'visualisation.edges.gradientColors', definition: settingsUIDefinition.visualisation.subsections.edges.settings.gradientColors },
          ]
        },
        {
          title: 'Labels',
          description: 'Text display settings',
          items: [
            { key: 'enableLabels', path: settingsUIDefinition.visualisation.subsections.labels.settings.enableLabels.path, definition: settingsUIDefinition.visualisation.subsections.labels.settings.enableLabels },
            { key: 'desktopFontSize', path: 'visualisation.labels.desktopFontSize', definition: settingsUIDefinition.visualisation.subsections.labels.settings.desktopFontSize },
            { key: 'textColor', path: 'visualisation.labels.textColor', definition: settingsUIDefinition.visualisation.subsections.labels.settings.textColor },
            { key: 'textOutlineColor', path: 'visualisation.labels.textOutlineColor', definition: settingsUIDefinition.visualisation.subsections.labels.settings.textOutlineColor },
            { key: 'textOutlineWidth', path: 'visualisation.labels.textOutlineWidth', definition: settingsUIDefinition.visualisation.subsections.labels.settings.textOutlineWidth },
            { key: 'textResolution', path: 'visualisation.labels.textResolution', definition: settingsUIDefinition.visualisation.subsections.labels.settings.textResolution },
            { key: 'textPadding', path: 'visualisation.labels.textPadding', definition: settingsUIDefinition.visualisation.subsections.labels.settings.textPadding },
            { key: 'billboardMode', path: 'visualisation.labels.billboardMode', definition: settingsUIDefinition.visualisation.subsections.labels.settings.billboardMode },
          ]
        },
        {
          title: 'Visual Effects',
          description: 'Bloom and glow effects',
          items: [
            { key: 'bloomEnabled', path: 'visualisation.bloom.enabled', definition: settingsUIDefinition.visualisation.subsections.bloom.settings.enabled },
            { key: 'bloomStrength', path: 'visualisation.bloom.strength', definition: settingsUIDefinition.visualisation.subsections.bloom.settings.strength },
            { key: 'bloomRadius', path: 'visualisation.bloom.radius', definition: settingsUIDefinition.visualisation.subsections.bloom.settings.radius },
            { key: 'edgeBloomStrength', path: 'visualisation.bloom.edgeBloomStrength', definition: settingsUIDefinition.visualisation.subsections.bloom.settings.edgeBloomStrength },
            { key: 'environmentBloomStrength', path: 'visualisation.bloom.environmentBloomStrength', definition: settingsUIDefinition.visualisation.subsections.bloom.settings.environmentBloomStrength },
            { key: 'nodeBloomStrength', path: 'visualisation.bloom.nodeBloomStrength', definition: settingsUIDefinition.visualisation.subsections.bloom.settings.nodeBloomStrength },
            { key: 'threshold', path: 'visualisation.bloom.threshold', definition: settingsUIDefinition.visualisation.subsections.bloom.settings.threshold },
          ]
        },
        {
          title: 'Lighting & Rendering',
          description: 'Control lighting and background',
          items: [
            { key: 'ambientLightIntensity', path: 'visualisation.rendering.ambientLightIntensity', definition: settingsUIDefinition.visualisation.subsections.rendering.settings.ambientLightIntensity },
            { key: 'directionalLightIntensity', path: 'visualisation.rendering.directionalLightIntensity', definition: settingsUIDefinition.visualisation.subsections.rendering.settings.directionalLightIntensity },
            { key: 'environmentIntensity', path: 'visualisation.rendering.environmentIntensity', definition: settingsUIDefinition.visualisation.subsections.rendering.settings.environmentIntensity },
            { key: 'backgroundColor', path: 'visualisation.rendering.backgroundColor', definition: settingsUIDefinition.visualisation.subsections.rendering.settings.backgroundColor },
            { key: 'enableAmbientOcclusion', path: 'visualisation.rendering.enableAmbientOcclusion', definition: settingsUIDefinition.visualisation.subsections.rendering.settings.enableAmbientOcclusion, isPowerUser: true },
            { key: 'enableShadows', path: 'visualisation.rendering.enableShadows', definition: settingsUIDefinition.visualisation.subsections.rendering.settings.enableShadows, isPowerUser: true },
            { key: 'shadowMapSize', path: 'visualisation.rendering.shadowMapSize', definition: settingsUIDefinition.visualisation.subsections.rendering.settings.shadowMapSize, isPowerUser: true },
            { key: 'shadowBias', path: 'visualisation.rendering.shadowBias', definition: settingsUIDefinition.visualisation.subsections.rendering.settings.shadowBias, isPowerUser: true },
            { key: 'context', path: 'visualisation.rendering.context', definition: settingsUIDefinition.visualisation.subsections.rendering.settings.context },
          ]
        },
        {
          title: 'Hologram Effect',
          description: 'Control hologram visualization',
          items: [
            { key: 'ringCount', path: 'visualisation.hologram.ringCount', definition: settingsUIDefinition.visualisation.subsections.hologram.settings.ringCount },
            { key: 'ringColor', path: 'visualisation.hologram.ringColor', definition: settingsUIDefinition.visualisation.subsections.hologram.settings.ringColor },
            { key: 'ringOpacity', path: 'visualisation.hologram.ringOpacity', definition: settingsUIDefinition.visualisation.subsections.hologram.settings.ringOpacity },
            { key: 'sphereSizes', path: 'visualisation.hologram.sphereSizes', definition: settingsUIDefinition.visualisation.subsections.hologram.settings.sphereSizes },
            { key: 'ringRotationSpeed', path: 'visualisation.hologram.ringRotationSpeed', definition: settingsUIDefinition.visualisation.subsections.hologram.settings.ringRotationSpeed },
            { key: 'globalRotationSpeed', path: 'visualisation.hologram.globalRotationSpeed', definition: settingsUIDefinition.visualisation.subsections.hologram.settings.globalRotationSpeed },
          ]
        },
        {
          title: 'Animations',
          description: 'Animation controls',
          items: [
            { key: 'enableNodeAnimations', path: 'visualisation.animations.enableNodeAnimations', definition: settingsUIDefinition.visualisation.subsections.animations.settings.enableNodeAnimations },
            { key: 'enableMotionBlur', path: 'visualisation.animations.enableMotionBlur', definition: settingsUIDefinition.visualisation.subsections.animations.settings.enableMotionBlur, isPowerUser: true },
            { key: 'motionBlurStrength', path: 'visualisation.animations.motionBlurStrength', definition: settingsUIDefinition.visualisation.subsections.animations.settings.motionBlurStrength, isPowerUser: true },
            { key: 'selectionWaveEnabled', path: 'visualisation.animations.selectionWaveEnabled', definition: settingsUIDefinition.visualisation.subsections.animations.settings.selectionWaveEnabled },
            { key: 'pulseEnabled', path: 'visualisation.animations.pulseEnabled', definition: settingsUIDefinition.visualisation.subsections.animations.settings.pulseEnabled },
            { key: 'pulseSpeed', path: 'visualisation.animations.pulseSpeed', definition: settingsUIDefinition.visualisation.subsections.animations.settings.pulseSpeed },
            { key: 'pulseStrength', path: 'visualisation.animations.pulseStrength', definition: settingsUIDefinition.visualisation.subsections.animations.settings.pulseStrength },
            { key: 'waveSpeed', path: 'visualisation.animations.waveSpeed', definition: settingsUIDefinition.visualisation.subsections.animations.settings.waveSpeed },
          ]
        }
      ]
    },
    performance: {
      label: 'Performance',
      icon: <Settings className="h-4 w-4" />,
      groups: [
        {
          title: 'Rendering Quality',
          description: 'Balance quality and performance',
          items: [
            { key: 'nodeQuality', path: 'visualisation.nodes.quality', definition: settingsUIDefinition.visualisation.subsections.nodes.settings.quality },
            { key: 'edgeQuality', path: 'visualisation.edges.quality', definition: settingsUIDefinition.visualisation.subsections.edges.settings.quality },
            { key: 'enableAntialiasing', path: 'visualisation.rendering.enableAntialiasing', definition: settingsUIDefinition.visualisation.subsections.rendering.settings.enableAntialiasing },
          ]
        },
        {
          title: 'Physics Engine',
          description: 'Node movement behavior',
          items: [
            { key: 'physicsEnabled', path: 'visualisation.physics.enabled', definition: settingsUIDefinition.visualisation.subsections.physics.settings.enabled },
            { key: 'iterations', path: 'visualisation.physics.iterations', definition: settingsUIDefinition.visualisation.subsections.physics.settings.iterations },
            { key: 'damping', path: 'visualisation.physics.damping', definition: settingsUIDefinition.visualisation.subsections.physics.settings.damping },
            { key: 'boundsSize', path: 'visualisation.physics.boundsSize', definition: settingsUIDefinition.visualisation.subsections.physics.settings.boundsSize },
            { key: 'collisionRadius', path: 'visualisation.physics.collisionRadius', definition: settingsUIDefinition.visualisation.subsections.physics.settings.collisionRadius },
            { key: 'enableBounds', path: 'visualisation.physics.enableBounds', definition: settingsUIDefinition.visualisation.subsections.physics.settings.enableBounds },
            { key: 'maxVelocity', path: 'visualisation.physics.maxVelocity', definition: settingsUIDefinition.visualisation.subsections.physics.settings.maxVelocity },
            { key: 'repulsionDistance', path: 'visualisation.physics.repulsionDistance', definition: settingsUIDefinition.visualisation.subsections.physics.settings.repulsionDistance },
            { key: 'massScale', path: 'visualisation.physics.massScale', definition: settingsUIDefinition.visualisation.subsections.physics.settings.massScale },
            { key: 'boundaryDamping', path: 'visualisation.physics.boundaryDamping', definition: settingsUIDefinition.visualisation.subsections.physics.settings.boundaryDamping },
          ]
        },
        {
          title: 'Force Settings',
          description: 'Control attraction, repulsion, and spring forces',
          items: [
            { key: 'attractionStrength', path: 'visualisation.physics.attractionStrength', definition: settingsUIDefinition.visualisation.subsections.physics.settings.attractionStrength },
            { key: 'repulsionStrength', path: 'visualisation.physics.repulsionStrength', definition: settingsUIDefinition.visualisation.subsections.physics.settings.repulsionStrength },
            { key: 'springStrength', path: 'visualisation.physics.springStrength', definition: settingsUIDefinition.visualisation.subsections.physics.settings.springStrength },
          ]
        },
        {
          title: 'Network Settings',
          description: 'Connection optimization',
          items: [
            { key: 'updateRate', path: 'system.websocket.updateRate', definition: settingsUIDefinition.system.subsections.websocket.settings.updateRate },
            { key: 'compressionEnabled', path: 'system.websocket.compressionEnabled', definition: settingsUIDefinition.system.subsections.websocket.settings.compressionEnabled },
          ],
          isPowerUser: true
        }
      ]
    },
    xr: {
      label: 'XR/VR',
      icon: <Smartphone className="h-4 w-4" />,
      groups: [
        {
          title: 'XR Mode',
          description: 'Virtual reality settings',
          items: [
            { key: 'clientSideEnableXR', path: settingsUIDefinition.xr.subsections.general.settings.clientSideEnableXR.path, definition: settingsUIDefinition.xr.subsections.general.settings.clientSideEnableXR },
            { key: 'displayMode', path: settingsUIDefinition.xr.subsections.general.settings.displayMode.path, definition: settingsUIDefinition.xr.subsections.general.settings.displayMode },
            { key: 'quality', path: settingsUIDefinition.xr.subsections.general.settings.quality.path, definition: settingsUIDefinition.xr.subsections.general.settings.quality },
          ]
        },
        {
          title: 'Interaction',
          description: 'Hand tracking and controls',
          items: [
            { key: 'enableHandTracking', path: 'xr.handFeatures.enableHandTracking', definition: settingsUIDefinition.xr.subsections.handFeatures.settings.enableHandTracking },
            { key: 'enableHaptics', path: 'xr.handFeatures.enableHaptics', definition: settingsUIDefinition.xr.subsections.handFeatures.settings.enableHaptics },
            { key: 'interactionRadius', path: 'xr.handFeatures.interactionRadius', definition: settingsUIDefinition.xr.subsections.handFeatures.settings.interactionRadius },
            { key: 'movementAxesHorizontal', path: 'xr.handFeatures.movementAxesHorizontal', definition: settingsUIDefinition.xr.subsections.handFeatures.settings.movementAxesHorizontal },
            { key: 'movementAxesVertical', path: 'xr.handFeatures.movementAxesVertical', definition: settingsUIDefinition.xr.subsections.handFeatures.settings.movementAxesVertical },
          ],
          isPowerUser: true
        },
        {
          title: 'Environment Understanding',
          description: 'Settings for AR environment features',
          items: [
            { key: 'enableLightEstimation', path: 'xr.environmentUnderstanding.enableLightEstimation', definition: settingsUIDefinition.xr.subsections.environmentUnderstanding.settings.enableLightEstimation },
            { key: 'enablePlaneDetection', path: 'xr.environmentUnderstanding.enablePlaneDetection', definition: settingsUIDefinition.xr.subsections.environmentUnderstanding.settings.enablePlaneDetection },
            { key: 'enableSceneUnderstanding', path: 'xr.environmentUnderstanding.enableSceneUnderstanding', definition: settingsUIDefinition.xr.subsections.environmentUnderstanding.settings.enableSceneUnderstanding },
            { key: 'planeColor', path: 'xr.environmentUnderstanding.planeColor', definition: settingsUIDefinition.xr.subsections.environmentUnderstanding.settings.planeColor },
            { key: 'planeOpacity', path: 'xr.environmentUnderstanding.planeOpacity', definition: settingsUIDefinition.xr.subsections.environmentUnderstanding.settings.planeOpacity },
            { key: 'planeDetectionDistance', path: 'xr.environmentUnderstanding.planeDetectionDistance', definition: settingsUIDefinition.xr.subsections.environmentUnderstanding.settings.planeDetectionDistance },
            { key: 'showPlaneOverlay', path: 'xr.environmentUnderstanding.showPlaneOverlay', definition: settingsUIDefinition.xr.subsections.environmentUnderstanding.settings.showPlaneOverlay },
            { key: 'snapToFloor', path: 'xr.environmentUnderstanding.snapToFloor', definition: settingsUIDefinition.xr.subsections.environmentUnderstanding.settings.snapToFloor },
          ],
          isPowerUser: true
        },
        {
          title: 'Passthrough',
          description: 'Control passthrough portal settings',
          items: [
            { key: 'enablePassthroughPortal', path: 'xr.passthrough.enablePassthroughPortal', definition: settingsUIDefinition.xr.subsections.passthrough.settings.enablePassthroughPortal },
            { key: 'passthroughOpacity', path: 'xr.passthrough.passthroughOpacity', definition: settingsUIDefinition.xr.subsections.passthrough.settings.passthroughOpacity },
            { key: 'passthroughBrightness', path: 'xr.passthrough.passthroughBrightness', definition: settingsUIDefinition.xr.subsections.passthrough.settings.passthroughBrightness },
            { key: 'passthroughContrast', path: 'xr.passthrough.passthroughContrast', definition: settingsUIDefinition.xr.subsections.passthrough.settings.passthroughContrast },
            { key: 'portalSize', path: 'xr.passthrough.portalSize', definition: settingsUIDefinition.xr.subsections.passthrough.settings.portalSize },
            { key: 'portalEdgeColor', path: 'xr.passthrough.portalEdgeColor', definition: settingsUIDefinition.xr.subsections.passthrough.settings.portalEdgeColor },
            { key: 'portalEdgeWidth', path: 'xr.passthrough.portalEdgeWidth', definition: settingsUIDefinition.xr.subsections.passthrough.settings.portalEdgeWidth },
          ],
          isPowerUser: true
        }
      ]
    },
    advanced: {
      label: 'Advanced',
      icon: <Settings className="h-4 w-4" />,
      isPowerUser: true,
      groups: [
        {
          title: 'Debug Options',
          description: 'Developer tools',
          items: [
            { key: 'debugMode', path: settingsUIDefinition.system.subsections.debug.settings.enabled.path, definition: settingsUIDefinition.system.subsections.debug.settings.enabled },
            { key: 'logLevel', path: 'system.debug.logLevel', definition: settingsUIDefinition.system.subsections.debug.settings.logLevel },
          ]
        },
        {
          title: 'AI Services',
          description: 'API configuration',
          items: [
            { key: 'ragflowApiKey', path: settingsUIDefinition.ai.subsections.ragflow.settings.apiKey.path, definition: settingsUIDefinition.ai.subsections.ragflow.settings.apiKey },
            { key: 'perplexityKey', path: settingsUIDefinition.ai.subsections.perplexity.settings.apiKey.path, definition: settingsUIDefinition.ai.subsections.perplexity.settings.apiKey },
            { key: 'openaiKey', path: settingsUIDefinition.ai.subsections.openai.settings.apiKey.path, definition: settingsUIDefinition.ai.subsections.openai.settings.apiKey },
          ]
        }
      ]
    }
  }), []);

  const toggleGroup = (groupTitle: string) => {
    setExpandedGroups(prev => {
      const next = new Set(prev);
      if (next.has(groupTitle)) {
        next.delete(groupTitle);
      } else {
        next.add(groupTitle);
      }
      return next;
    });
  };

  const handleSettingChange = (path: string, value: any) => {
    useSettingsStore.getState().set(path, value);

    // Show save notification
    setSavedNotification(path);
    setTimeout(() => setSavedNotification(null), 2000);
  };

  const renderSettingGroup = (group: SettingGroup) => {
    if (group.isPowerUser && !isPowerUser) return null;

    const isExpanded = expandedGroups.has(group.title);

    return (
      <Card key={group.title} className="mb-3 overflow-hidden">
        <CardHeader
          className="cursor-pointer py-3 px-4 hover:bg-muted/50 transition-colors"
          onClick={() => toggleGroup(group.title)}
        >
          <div className="flex items-center justify-between">
            <div className="flex-1">
              <CardTitle className="text-sm font-medium flex items-center gap-2">
                {group.title}
                {group.isPowerUser && (
                  <span className="text-xs px-1.5 py-0.5 bg-primary/10 text-primary rounded">
                    Pro
                  </span>
                )}
              </CardTitle>
              {group.description && (
                <CardDescription className="text-xs mt-1">
                  {group.description}
                </CardDescription>
              )}
            </div>
            <ChevronDown
              className={cn(
                "h-4 w-4 transition-transform duration-200",
                isExpanded ? "" : "-rotate-90"
              )}
            />
          </div>
        </CardHeader>

        {isExpanded && (
          <CardContent className="pt-0 pb-3 px-4 space-y-3">
            {group.items.map((item) => {
              if (item.isPowerUser && !isPowerUser) return null;

              const value = useSettingsStore.getState().get(item.path);

              return (
                <div key={item.key} className="relative">
                  <SettingControlComponent
                    path={item.path}
                    settingDef={item.definition}
                    value={value}
                    onChange={(newValue) => handleSettingChange(item.path, newValue)}
                  />
                  {savedNotification === item.path && (
                    <div className="absolute -top-1 -right-1 flex items-center gap-1 text-xs text-green-600 bg-green-50 px-2 py-1 rounded">
                      <Check className="h-3 w-3" />
                      Saved
                    </div>
                  )}
                </div>
              );
            })}
          </CardContent>
        )}
      </Card>
    );
  };

  const renderTabContent = (tabKey: string) => {
    const tab = settingsStructure[tabKey];
    if (!tab) return null;

    if (tab.isPowerUser && !isPowerUser) {
      return (
        <div className="flex flex-col items-center justify-center h-64 text-center p-6">
          <Settings className="h-12 w-12 text-muted-foreground mb-4" />
          <h3 className="text-lg font-medium mb-2">Power User Features</h3>
          <p className="text-sm text-muted-foreground max-w-sm">
            Authenticate with Nostr to unlock advanced settings and features.
          </p>
        </div>
      );
    }

    return (
      <div className="flex-1 min-h-0 space-y-3">
        {tab.groups.map(group => (
          <React.Fragment key={group.title}>
            {renderSettingGroup(group)}
          </React.Fragment>
        ))}
      </div>
    );
  };

  // Create tabs array for the Tabs component
  const tabs = Object.entries(settingsStructure).map(([key, section]) => ({
    label: section.label,
    icon: section.icon,
    content: renderTabContent(key)
  }));

  return (
    // Dynamically set background and text color from settings
    <div
      className="w-full h-full flex flex-col min-h-0"
      style={{
        background: panelBackground,
        color: panelForeground,
      }}
    >
      <div className="px-4 py-3 border-b flex items-center justify-between">
        <div>
          <h2 className="text-lg font-semibold">Settings</h2>
          <p className="text-sm" style={{ color: panelForeground }}>
            Customize your visualization
          </p>
        </div>
        <Button
          variant="ghost"
          size="icon"
          onClick={toggleLowerRightPaneDock}
          title={isLowerRightPaneDocked ? "Expand lower panels" : "Collapse lower panels"}
        >
          {isLowerRightPaneDocked ? <ChevronDown className="h-4 w-4" /> : <ChevronUp className="h-4 w-4" />}
        </Button>
      </div>

      <div className="flex-1 overflow-auto">
        <Tabs
          tabs={tabs}
          className="h-full"
          tabListClassName="px-4 bg-muted/30" // Added subtle background to tab list
          tabContentClassName="px-4 py-3"
        />
      </div>

      {/* Status bar */}
      <div className="px-4 py-2 border-t bg-muted/30 flex items-center justify-between text-xs" style={{ color: panelForeground }}>
        <div className="flex items-center gap-2" style={{ color: panelForeground }}>
          <Info className="h-3 w-3" />
          <span>Changes save automatically</span>
        </div>
        {isPowerUser && (
          <div className="flex items-center gap-1" style={{ color: panelForeground }}>
            <Settings className="h-3 w-3 text-primary" />
            <span className="text-primary">Power User</span>
          </div>
        )}
      </div>
    </div>
  );
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/settings/components/panels/SystemPanel.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/settings/components/panels/SystemPanel.tsx
```tsx
import React, { useState, useEffect } from 'react'; // Added React
import { useSettingsStore } from '../../../../store/settingsStore';
import { createLogger } from '../../../../utils/logger';
import { graphDataManager } from '../../../graph/managers/graphDataManager';
import { SettingsSection } from '../SettingsSection'; // Import SettingsSection
import { UICategoryDefinition } from '../../config/settingsUIDefinition'; // Import definition type

const logger = createLogger('SystemPanel');


export interface SystemPanelProps { // Renamed interface
  settingsDef: UICategoryDefinition;
}

const SystemPanel: React.FC<SystemPanelProps> = ({ settingsDef }) => {
  // Removed activeSubsection state
  const [apiStatus, setApiStatus] = useState({
    isConnected: false,
    lastFetchTime: null as string | null,
    nodesCount: 0,
    edgesCount: 0
  });

  // Removed settings and setSettings from useSettingsStore as they are handled by SettingsSection/SettingControlComponent

  // Removed old systemSettings retrieval and updateSetting/toggleSetting functions

  useEffect(() => {
    const updateApiStatus = async () => {
      try {
        const currentData = await graphDataManager.getGraphData();
        setApiStatus({
          isConnected: true,
          lastFetchTime: new Date().toLocaleTimeString(),
          nodesCount: currentData.nodes.length,
          edgesCount: currentData.edges.length
        });
      } catch (error) {
        logger.error('Failed to update API status:', error);
        setApiStatus(prev => ({
          ...prev,
          isConnected: false
        }));
      }
    };
    updateApiStatus();
    const unsubscribe = graphDataManager.onGraphDataChange(updateApiStatus);
    return () => unsubscribe();
  }, []);

  const handleClearConsole = () => {
    console.clear();
    logger.info('Console cleared');
  };

  const handleResetGraph = async () => {
    try {
      await graphDataManager.fetchInitialData();
      logger.info('Graph data reset successfully');
    } catch (error) {
      logger.error('Failed to reset graph:', error);
    }
  };

  const handleExportLogs = () => {
    const logs = logger.getLogs();
    const blob = new Blob([JSON.stringify(logs, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `logs-${new Date().toISOString()}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const handleMemoryUsage = () => {
    try {
      // @ts-ignore - performance.memory is Chrome-specific
      const memory = window.performance.memory;
      if (memory) {
        logger.info('Memory usage:', {
          usedJSHeapSize: `${(memory.usedJSHeapSize / 1024 / 1024).toFixed(2)} MB`,
          totalJSHeapSize: `${(memory.totalJSHeapSize / 1024 / 1024).toFixed(2)} MB`,
          jsHeapSizeLimit: `${(memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2)} MB`
        });
      } else {
        logger.warn('Memory usage information not available in this browser');
      }
    } catch (error) {
      logger.error('Failed to get memory usage:', error);
    }
  };

  return (
    <div className="p-4 space-y-6 overflow-y-auto h-full custom-scrollbar">
      {/* Iterate through subsections defined in settingsDef */}
      {Object.entries(settingsDef.subsections).map(([subsectionKey, subsectionDef]) => (
        <SettingsSection
          key={subsectionKey}
          id={`settings-${settingsDef.label.toLowerCase()}-${subsectionKey}`}
          title={subsectionDef.label}
          subsectionSettings={subsectionDef.settings}
        />
      ))}

      {/* Custom System Panel Content: API Status and Debug Actions */}
      <div className="space-y-6 pt-4 border-t border-border mt-6">
        <h3 className="text-lg font-semibold text-foreground">API Status & Diagnostics</h3>
        {/* API Connection Status */}
        <div className="p-4 bg-muted rounded-md shadow">
          <div className="flex items-center justify-between mb-2">
            <span className="text-sm font-medium text-foreground">API Status</span>
            <div className="flex items-center space-x-2">
              <span className={`inline-block w-2.5 h-2.5 rounded-full ${
                apiStatus.isConnected ? 'bg-green-500' : 'bg-red-500'
              }`}></span>
              <span className="text-sm text-muted-foreground">
                {apiStatus.isConnected ? 'Connected' : 'Disconnected'}
              </span>
            </div>
          </div>
          <div className="grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
            <div className="text-muted-foreground">Last Fetch:</div>
            <div className="text-foreground">{apiStatus.lastFetchTime || 'N/A'}</div>
            <div className="text-muted-foreground">Nodes:</div>
            <div className="text-foreground">{apiStatus.nodesCount}</div>
            <div className="text-muted-foreground">Edges:</div>
            <div className="text-foreground">{apiStatus.edgesCount}</div>
          </div>
          <div className="mt-3 flex justify-end">
            <button
              className="px-3 py-1.5 text-xs bg-secondary text-secondary-foreground rounded-md hover:bg-secondary/80 transition-colors"
              onClick={() => {
                graphDataManager.fetchInitialData().catch(error => {
                  logger.error('Failed to refresh graph data:', error);
                });
              }}
            >
              Refresh Data
            </button>
          </div>
        </div>

        {/* Debug Actions */}
        <div className="p-4 bg-muted rounded-md shadow">
          <h4 className="text-sm font-medium text-foreground mb-3">Debug Actions</h4>
          <div className="grid grid-cols-2 gap-2">
            <button
              className="px-3 py-2 bg-secondary text-secondary-foreground rounded-md hover:bg-secondary/80 text-sm transition-colors"
              onClick={handleClearConsole}
            >
              Clear Console
            </button>
            <button
              className="px-3 py-2 bg-secondary text-secondary-foreground rounded-md hover:bg-secondary/80 text-sm transition-colors"
              onClick={handleResetGraph}
            >
              Reset Graph
            </button>
            <button
              className="px-3 py-2 bg-secondary text-secondary-foreground rounded-md hover:bg-secondary/80 text-sm transition-colors"
              onClick={handleExportLogs}
            >
              Export Logs
            </button>
            <button
              className="px-3 py-2 bg-secondary text-secondary-foreground rounded-md hover:bg-secondary/80 text-sm transition-colors"
              onClick={handleMemoryUsage}
            >
              Memory Usage
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default SystemPanel;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/settings/components/panels/VisualisationPanel.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/settings/components/panels/VisualisationPanel.tsx
```tsx
import React from 'react';
import { SettingsSection } from '../SettingsSection'; // Adjust path if necessary
import { UICategoryDefinition } from '../../config/settingsUIDefinition'; // Adjust path if necessary


export interface VisualisationPanelProps { // Renamed interface for clarity
  settingsDef: UICategoryDefinition;
}

/**
 * VisualisationPanel renders settings controls for the 'Visualisation' category,
 * driven by the provided settings definition.
 */
const VisualisationPanel: React.FC<VisualisationPanelProps> = ({ settingsDef }) => {
  // Removed old state (activeSubsection) and settings retrieval logic (useSettingsStore, useMemo)
  // Removed updateSetting function (will be handled within SettingsSection/SettingControlComponent)
  // Removed theme logic (assuming handled by ThemeProvider globally)

  return (
    // Main container: Added padding, space between sections, overflow for scrolling, and full height
    <div className="p-4 space-y-6 overflow-y-auto h-full custom-scrollbar">
      {/* Iterate through subsections defined in settingsDef */}
      {Object.entries(settingsDef.subsections).map(([subsectionKey, subsectionDef]) => (
        <SettingsSection
          key={subsectionKey}
          // Generate a unique ID for accessibility/linking if needed
          id={`settings-${settingsDef.label.toLowerCase()}-${subsectionKey}`} // e.g., settings-visualisation-nodes
          title={subsectionDef.label}
          // Pass the specific settings definitions for this subsection
          subsectionSettings={subsectionDef.settings}
        />
      ))}
    </div>
  );
};

export default VisualisationPanel;

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/settings/components/panels/XRPanel.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/settings/components/panels/XRPanel.tsx
```tsx
import React from 'react'; // Removed useState
import { useSettingsStore } from '../../../../store/settingsStore'; // Keep for persisting preference if needed
import { createLogger } from '../../../../utils/logger';
import { SettingsSection } from '../SettingsSection';
import { UICategoryDefinition, UISettingDefinition } from '../../config/settingsUIDefinition';
import { useApplicationMode } from '../../../../contexts/ApplicationModeContext'; // For XR mode toggle
import { Switch } from '../../../../ui/Switch'; // For XR mode toggle
import { Label } from '../../../../ui/Label'; // For XR mode toggle label
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/ui/Tooltip'; // For XR mode toggle tooltip
import { Info } from 'lucide-react'; // For XR mode toggle tooltip icon
import { FormGroup } from '@/ui/formGroup/FormGroup'; // For XR mode toggle styling

const logger = createLogger('XRPanel');


export interface XRPanelProps { // Renamed interface
  settingsDef: UICategoryDefinition;
}

const XRPanel: React.FC<XRPanelProps> = ({ settingsDef }) => {
  const { mode: applicationMode, setMode: setApplicationMode } = useApplicationMode();
  const settingsStoreSet = useSettingsStore(state => state.set); // For persisting preference

  // Find the clientSideEnableXR definition for direct rendering
  let clientSideEnableXRDef: UISettingDefinition | undefined;
  for (const subsec of Object.values(settingsDef.subsections)) {
    if (subsec.settings['clientSideEnableXR']) {
      clientSideEnableXRDef = subsec.settings['clientSideEnableXR'];
      break;
    }
  }

  const handleXRModeToggle = (checked: boolean) => {
    setApplicationMode(checked ? 'xr' : 'desktop');
    // Optionally persist this preference to settings store if clientSideEnableXRDef.path is valid
    if (clientSideEnableXRDef?.path) {
      settingsStoreSet(clientSideEnableXRDef.path, checked);
      logger.info(`XR mode preference (${clientSideEnableXRDef.path}) set to: ${checked}`);
    }
  };

  const isClientXRModeEnabled = applicationMode === 'xr';

  return (
    <div className="p-4 space-y-6 overflow-y-auto h-full custom-scrollbar">
      {/* Special handling for clientSideEnableXR toggle */}
      {clientSideEnableXRDef && (
        <FormGroup
            label={clientSideEnableXRDef.label}
            id="client-xr-toggle"
            helpText={clientSideEnableXRDef.description}
            className="border-b border-border pb-4 mb-4"
        >
            <div className="flex items-center justify-between">
                <Label htmlFor="client-xr-toggle-switch" className="text-sm flex items-center gap-1">
                    <span>{clientSideEnableXRDef.label}</span>
                    {clientSideEnableXRDef.description && (
                    <TooltipProvider delayDuration={100}>
                        <Tooltip>
                            <TooltipTrigger asChild>
                                <Info className="h-3 w-3 text-muted-foreground cursor-help" />
                            </TooltipTrigger>
                            <TooltipContent side="top" align="start" className="max-w-xs z-[4000]">
                                <p>{clientSideEnableXRDef.description}</p>
                            </TooltipContent>
                        </Tooltip>
                    </TooltipProvider>
                    )}
                </Label>
                <Switch
                    id="client-xr-toggle-switch"
                    checked={isClientXRModeEnabled}
                    onCheckedChange={handleXRModeToggle}
                />
            </div>
        </FormGroup>
      )}

      {/* Iterate through subsections defined in settingsDef */}
      {Object.entries(settingsDef.subsections).map(([subsectionKey, subsectionDef]) => {
        // Filter out the clientSideEnableXR setting if it was handled above, to avoid rendering it twice
        const filteredSettings = { ...subsectionDef.settings };
        if (clientSideEnableXRDef && filteredSettings[clientSideEnableXRDef.path.split('.').pop()!]) {
             // Check if the current subsection contains the clientSideEnableXR setting
            if (clientSideEnableXRDef.path.startsWith(`${settingsDef.label.toLowerCase()}.${subsectionKey}`)) {
                delete filteredSettings[clientSideEnableXRDef.path.split('.').pop()!];
            }
        }

        // If after filtering, the subsection has no settings left (and it's not the one containing the special toggle),
        // or if it only contained the special toggle, don't render the section.
        if (Object.keys(filteredSettings).length === 0) {
            return null;
        }

        return (
          <SettingsSection
            key={subsectionKey}
            id={`settings-${settingsDef.label.toLowerCase()}-${subsectionKey}`}
            title={subsectionDef.label}
            subsectionSettings={filteredSettings} // Pass filtered settings
          />
        );
      })}

      {/* Retain custom informational text if needed */}
      <div className="space-y-6 pt-4 border-t border-border mt-6">
        <div className="bg-muted p-4 rounded-md text-sm shadow">
          <h4 className="font-medium mb-2 text-foreground">XR Control Information</h4>
          <p className="text-muted-foreground mb-2">
            These settings control how interaction works in VR and AR modes.
            When using a VR headset, you can use the controllers to interact with the visualisation.
          </p>
          <ul className="list-disc list-inside text-muted-foreground space-y-1">
            <li>Trigger button: Select</li>
            <li>Grip button: Grab and move</li>
            <li>Thumbstick: Navigate and rotate</li>
          </ul>
        </div>
        <div className="bg-muted p-4 rounded-md text-sm shadow">
          <h4 className="font-medium mb-2 text-foreground">XR Environment</h4>
          <p className="text-muted-foreground">
            These settings control the visual environment in VR and AR modes,
            including background, lighting, and scale.
          </p>
        </div>
      </div>
    </div>
  );
};

export default XRPanel;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/settings/config/defaultSettings.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/settings/config/defaultSettings.ts
```ts

import { Settings } from './settings';

export const defaultSettings: Settings = {
  visualisation: {
    nodes: {
      baseColor: "#0008ff",
      metalness: 0.63,
      opacity: 0.65,
      roughness: 0.73,
      nodeSize: 0.04,
      quality: "medium",
      enableInstancing: false, // From JSON (camelCase)
      enableHologram: true,    // From JSON (camelCase)
      enableMetadataShape: false,
      enableMetadataVisualisation: false, // From JSON (camelCase)
      // sizeRange: [0.01, 0.15], // Removed, does not exist in NodeSettings
      // color: "#ff4500", // Removed, not in NodeSettings
      // highlightColor: "#ffff00", // Removed, not in NodeSettings
      // outlineWidth: 0.1, // Removed, not in NodeSettings
      // outlineColor: "#ffffff", // Removed, not in NodeSettings
      // selectedColor: "#00ff00", // Removed, not in NodeSettings
    },
    edges: {
      arrowSize: 0.02, // From JSON (camelCase, was 0.5)
      baseWidth: 0.1,  // From JSON (camelCase, was 0.64)
      color: "#56b6c2",
      enableArrows: false,
      opacity: 0.25,
      widthRange: [0.1, 1.0], // Kept existing, JSON had [0.1, 0.2] and [0.1, 1]
      quality: "medium",
      enableFlowEffect: true,
      flowSpeed: 1,
      flowIntensity: 0.6,
      glowStrength: 1,
      distanceIntensity: 1,
      useGradient: true,
      gradientColors: ["#ffffff", "#000000"],
      // width: 1, // Removed, does not exist in EdgeSettings
      // highlightColor: "#ffff00", // Removed, not in EdgeSettings
      // showLabels: false, // Removed, not in EdgeSettings
      // dashSize: 3, // Removed, not in EdgeSettings
      // gapSize: 1, // Removed, not in EdgeSettings
    },
    physics: {
      attractionStrength: 0.05,
      boundsSize: 15.0, // From JSON (camelCase, was 45)
      collisionRadius: 0.5, // From JSON (camelCase, was 0.9)
      damping: 0.95,
      enableBounds: true,
      enabled: true,
      iterations: 100,
      maxVelocity: 0.02, // From JSON (camelCase, was 0.446)
      repulsionStrength: 0.1,
      springStrength: 0.2,
      repulsionDistance: 2.0, // From JSON (camelCase, was 7.6)
      massScale: 1.0, // From JSON (camelCase, was 6.3)
      boundaryDamping: 0.95, // From JSON (camelCase, was 0.15)
      // gravity: 0, // Removed, does not exist in PhysicsSettings
      // friction: 0.9, // Removed, not in PhysicsSettings
      // attraction: 0.5, // Removed, not in PhysicsSettings
      // springLength: 30, // Removed, not in PhysicsSettings
    },
    rendering: {
      ambientLightIntensity: 0.8, // From JSON (camelCase, was 1.65)
      backgroundColor: "#181c28", // From JSON (camelCase, was #000000)
      directionalLightIntensity: 0.7, // From JSON (camelCase, was 1.3)
      enableAmbientOcclusion: false,
      enableAntialiasing: false, // From JSON (camelCase, was true)
      enableShadows: false, // From JSON (camelCase, was true)
      environmentIntensity: 0.7,
      shadowMapSize: "2048",
      shadowBias: 0.0001,
      context: "desktop",
      // pixelRatio: 1.5, // Removed, does not exist in RenderingSettings
      // enableBloom: true, // Removed, not in RenderingSettings. Use visualisation.bloom.enabled
      // bloomStrength: 1.5, // Removed, not in RenderingSettings
      // bloomThreshold: 0.4, // Removed, not in RenderingSettings
      // bloomRadius: 0.85, // Removed, not in RenderingSettings
    },
    animations: {
      enableMotionBlur: false,
      enableNodeAnimations: false,
      motionBlurStrength: 0.2,
      selectionWaveEnabled: false,
      pulseEnabled: false,
      pulseSpeed: 0.8,
      pulseStrength: 0.6,
      waveSpeed: 0.5,
    },
    labels: {
      desktopFontSize: 0.15, // From JSON (camelCase, was 0.02)
      enableLabels: true, // From JSON (camelCase, was false)
      textColor: "#f8f8f2", // From JSON (camelCase, was #851414)
      textOutlineColor: "#181c28", // From JSON (camelCase, was #dcdbdb)
      textOutlineWidth: 0.01, // From JSON (camelCase, was 0.001)
      textResolution: 32, // From JSON (camelCase, was 15)
      textPadding: 0.3, // From JSON (camelCase, was 0.06)
      billboardMode: "camera",
      // enabled: true, // Removed, 'enableLabels' is used
    },
    bloom: { // This section is for visualisation.bloom specific settings
      edgeBloomStrength: 0.4, // From JSON (camelCase, was 2.8)
      enabled: true, // From JSON (camelCase)
      environmentBloomStrength: 2.0, // From JSON (camelCase, was 3.8)
      nodeBloomStrength: 3.0, // From JSON (camelCase, was 1.5)
      radius: 0.4,
      strength: 1.77,
      threshold: 0.06,
    },
    hologram: {
      ringCount: 1, // From JSON (camelCase, was 3)
      ringColor: "#c2a200", // From JSON (camelCase, was #ffffff)
      ringOpacity: 0.001, // From JSON (camelCase, was 1)
      sphereSizes: [4, 8], // From JSON (camelCase, was [40.5, 80])
      ringRotationSpeed: 10.0, // From JSON (camelCase, was 12)
      enableBuckminster: false,
      buckminsterSize: 10,
      buckminsterOpacity: 0.05,
      enableGeodesic: false,
      geodesicSize: 10,
      geodesicOpacity: 0.05,
      enableTriangleSphere: false, // From JSON (camelCase, was true)
      triangleSphereSize: 10, // From JSON (camelCase, was 60)
      triangleSphereOpacity: 0.05, // From JSON (camelCase, was 0.3)
      globalRotationSpeed: 3.0, // From JSON (camelCase, was 0.2)
      // color: 65535, // Removed, does not exist in HologramSettings
      // opacity: 0.7, // Removed, not in HologramSettings
    },
    camera: {
      fov: 75,
      near: 0.1,
      far: 2000,
      position: { x: 0, y: 10, z: 50 },
      lookAt: { x: 0, y: 0, z: 0 },
    },
    // sceneBackground: 0, // Removed, not in VisualisationSettings
    // icons: { // Removed, not in VisualisationSettings
    //   enabled: true,
    //   size: 1,
    //   opacity: 0.8,
    //   color: "#ffffff",
    // },
    // metrics: { // Removed, not in VisualisationSettings
    //   enabled: false,
    //   refreshRate: 1000,
    //   position: "top-right",
    // },
    // showStats: false, // Removed, not in VisualisationSettings; likely controlled by system.debug.enablePerformanceDebug
    // showAxes: false, // Removed, not in VisualisationSettings
    // showGrid: false, // Removed, not in VisualisationSettings
  },
  system: {
    websocket: {
      binaryChunkSize: 2048,
      binaryUpdateRate: 30,
      minUpdateRate: 5,
      maxUpdateRate: 60,
      motionThreshold: 0.05,
      motionDamping: 0.9,
      binaryMessageVersion: 1,
      compressionEnabled: false,
      compressionThreshold: 512,
      heartbeatInterval: 10000,
      heartbeatTimeout: 600000, // Added from JSON
      maxConnections: 100,
      maxMessageSize: 10485760, // Added from JSON
      reconnectAttempts: 5, // Added from JSON (was not present before under websocket)
      reconnectDelay: 1000, // Added from JSON (was not present before under websocket)
      updateRate: 60,
      // reconnectInterval: 2000, // Removed, does not exist in WebSocketSettings
      // maxReconnectAttempts: 10, // Removed, not in WebSocketSettings. 'reconnectAttempts' is used.
    },
    debug: {
      enabled: false,
      enableDataDebug: false,
      enableWebsocketDebug: false,
      logBinaryHeaders: false,
      logFullJson: false,
      logLevel: "info", // From JSON (camelCase, was 'warn')
      logFormat: "text", // From JSON (camelCase, was 'json')
      enablePhysicsDebug: false,
      enableNodeDebug: false,
      enableShaderDebug: false,
      enableMatrixDebug: false,
      enablePerformanceDebug: false,
      // showPerformance: false, // Removed, does not exist in DebugSettings
      // showDataUpdates: false, // Removed, not in DebugSettings
    },
    persistSettings: false, // From JSON (camelCase, was true)
    customBackendUrl: "",
    // apiEndpoint: "/api", // Removed, not in SystemSettings type
  },
  xr: {
    enabled: false, // Changed from null to boolean based on type
    clientSideEnableXR: false,
    displayMode: "immersive-vr", // From JSON (camelCase, was 'inline')
    roomScale: 1.0, // Changed from true to 1.0 based on type
    spaceType: "local-floor",
    quality: "medium",
    enableHandTracking: true,
    handMeshEnabled: true,
    handMeshColor: "#4287f5",
    handMeshOpacity: 0.3,
    handPointSize: 0.006,
    handRayEnabled: true,
    handRayColor: "#4287f5",
    handRayWidth: 0.003,
    gestureSmoothing: 0.7,
    enableHaptics: true,
    hapticIntensity: 0.3,
    dragThreshold: 0.08,
    pinchThreshold: 0.3,
    rotationThreshold: 0.08,
    interactionRadius: 0.15,
    movementSpeed: 1.0, // From JSON (camelCase, was 0.08)
    deadZone: 0.12,
    movementAxesHorizontal: 2, // From JSON (camelCase, was movementAxes: {horizontal: 2, vertical: 3})
    movementAxesVertical: 3,   // From JSON (camelCase, was movementAxes: {horizontal: 2, vertical: 3})
    enableLightEstimation: false,
    enablePlaneDetection: false,
    enableSceneUnderstanding: false,
    planeColor: "#4287f5",
    planeOpacity: 0.001,
    planeDetectionDistance: 3.0,
    showPlaneOverlay: false,
    snapToFloor: false,
    enablePassthroughPortal: false,
    passthroughOpacity: 0.8,
    passthroughBrightness: 1.1,
    passthroughContrast: 1.2,
    portalSize: 2.5,
    portalEdgeColor: "#4287f5",
    portalEdgeWidth: 0.02,
    controllerModel: "default",
    renderScale: 1.0,
    interactionDistance: 1.5, // From JSON (camelCase, was 1.0)
    locomotionMethod: "teleport",
    teleportRayColor: "#ffffff",
    controllerRayColor: "#ffffff",
    // handTracking: true, // Duplicate of enableHandTracking
    // mode: "inline", // Duplicate of displayMode
    // teleportEnabled: true, // Removed, not in XRSettings
    // showFloor: true, // Removed, not in XRSettings
    // handInteraction: true, // Removed, not in XRSettings
    // grabThreshold: 0.1, // Removed, not in XRSettings
    // controllerPointerSize: 0.01, // Removed, not in XRSettings
    // hapticFeedback: true, // Duplicate of enableHaptics
  },
  auth: {
    enabled: true, // From JSON (camelCase, was false)
    provider: "nostr", // From JSON (camelCase, was '')
    required: false,
  },
  ragflow: {
    agentId: "aa2e328812ef11f083dc0a0d6226f61b",
    timeout: 30,
    maxRetries: 3,
    chatId: "",
  },
  perplexity: {
    apiKey: "",
    model: "llama-3.1-sonar-small-128k-online",
    apiUrl: "",
    maxTokens: 4096,
    temperature: 0.5,
    topP: 0.9,
    presencePenalty: 0.0,
    frequencyPenalty: 0.0,
    timeout: 30,
    rateLimit: 100,
  },
  openai: {
    apiKey: "",
    baseUrl: "",
    timeout: 30,
    rateLimit: 100,
  },
  kokoro: {
    apiUrl: "http://pedantic_morse:8880",
    defaultVoice: "af_heart",
    defaultFormat: "mp3",
    defaultSpeed: 1.0,
    timeout: 30,
    stream: true,
    returnTimestamps: true,
    sampleRate: 24000,
  },
};
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/settings/config/settings.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/settings/config/settings.ts
```ts

export type SettingsPath = string | '';

export interface NodeSettings {
  baseColor: string;
  metalness: number;
  opacity: number;
  roughness: number;
  nodeSize: number; // Changed from sizeRange: [number, number]
  quality: 'low' | 'medium' | 'high';
  enableInstancing: boolean;
  enableHologram: boolean;
  enableMetadataShape: boolean;
  enableMetadataVisualisation: boolean;
}

export interface EdgeSettings {
  arrowSize: number;
  baseWidth: number;
  color: string;
  enableArrows: boolean;
  opacity: number;
  widthRange: [number, number];
  quality: 'low' | 'medium' | 'high';
  enableFlowEffect: boolean;
  flowSpeed: number;
  flowIntensity: number;
  glowStrength: number;
  distanceIntensity: number;
  useGradient: boolean;
  gradientColors: [string, string];
}

export interface PhysicsSettings {
  attractionStrength: number;
  boundsSize: number;
  collisionRadius: number;
  damping: number;
  enableBounds: boolean;
  enabled: boolean;
  iterations: number;
  maxVelocity: number;
  repulsionStrength: number;
  springStrength: number;
  repulsionDistance: number;
  massScale: number;
  boundaryDamping: number;
}

export interface RenderingSettings {
  ambientLightIntensity: number;
  backgroundColor: string;
  directionalLightIntensity: number;
  enableAmbientOcclusion: boolean;
  enableAntialiasing: boolean;
  enableShadows: boolean;
  environmentIntensity: number;
  shadowMapSize: string;
  shadowBias: number;
  context: 'desktop' | 'ar';
}

export interface AnimationSettings {
  enableMotionBlur: boolean;
  enableNodeAnimations: boolean;
  motionBlurStrength: number;
  selectionWaveEnabled: boolean;
  pulseEnabled: boolean;
  pulseSpeed: number;
  pulseStrength: number;
  waveSpeed: number;
}

export interface LabelSettings {
  desktopFontSize: number;
  enableLabels: boolean;
  textColor: string;
  textOutlineColor: string;
  textOutlineWidth: number;
  textResolution: number;
  textPadding: number;
  billboardMode: 'camera' | 'vertical';
}

export interface BloomSettings {
  edgeBloomStrength: number;
  enabled: boolean;
  environmentBloomStrength: number;
  nodeBloomStrength: number;
  radius: number;
  strength: number;
  threshold: number;
}

export interface HologramSettings {
  ringCount: number;
  ringColor: string;
  ringOpacity: number;
  sphereSizes: [number, number];
  ringRotationSpeed: number;
  enableBuckminster: boolean;
  buckminsterSize: number;
  buckminsterOpacity: number;
  enableGeodesic: boolean;
  geodesicSize: number;
  geodesicOpacity: number;
  enableTriangleSphere: boolean;
  triangleSphereSize: number;
  triangleSphereOpacity: number;
  globalRotationSpeed: number;
}

export interface WebSocketSettings {
  reconnectAttempts: number;
  reconnectDelay: number;
  binaryChunkSize: number;
  binaryUpdateRate?: number;
  minUpdateRate?: number;
  maxUpdateRate?: number;
  motionThreshold?: number;
  motionDamping?: number;
  binaryMessageVersion?: number;
  compressionEnabled: boolean;
  compressionThreshold: number;
  heartbeatInterval?: number;
  heartbeatTimeout?: number;
  maxConnections?: number;
  maxMessageSize?: number;
  updateRate: number;
}

export interface DebugSettings {
  enabled: boolean;
  logLevel?: 'debug' | 'info' | 'warn' | 'error'; // Added for client-side logging
  logFormat?: 'json' | 'text';
  enableDataDebug: boolean;
  enableWebsocketDebug: boolean;
  logBinaryHeaders: boolean;
  logFullJson: boolean;
  enablePhysicsDebug?: boolean;
  enableNodeDebug?: boolean;
  enableShaderDebug?: boolean;
  enableMatrixDebug?: boolean;
  enablePerformanceDebug?: boolean;
}

export interface XRSettings {
  enabled: boolean;
  clientSideEnableXR?: boolean; // Client-side XR toggle
  mode?: 'inline' | 'immersive-vr' | 'immersive-ar'; // Added from YAML
  roomScale?: number;
  spaceType?: 'local-floor' | 'bounded-floor' | 'unbounded';
  quality?: 'low' | 'medium' | 'high';
  enableHandTracking: boolean;
  handMeshEnabled?: boolean;
  handMeshColor?: string;
  handMeshOpacity?: number;
  handPointSize?: number;
  handRayEnabled?: boolean;
  handRayColor?: string;
  handRayWidth?: number;
  gestureSmoothing?: number;
  enableHaptics: boolean;
  hapticIntensity?: number;
  dragThreshold?: number;
  pinchThreshold?: number;
  rotationThreshold?: number;
  interactionRadius?: number;
  movementSpeed?: number;
  deadZone?: number;
  movementAxesHorizontal?: number;
  movementAxesVertical?: number;
  enableLightEstimation?: boolean;
  enablePlaneDetection?: boolean;
  enableSceneUnderstanding?: boolean;
  planeColor?: string;
  planeOpacity?: number;
  planeDetectionDistance?: number;
  showPlaneOverlay?: boolean;
  snapToFloor?: boolean;
  enablePassthroughPortal?: boolean;
  passthroughOpacity?: number;
  passthroughBrightness?: number;
  passthroughContrast?: number;
  portalSize?: number;
  portalEdgeColor?: string;
  portalEdgeWidth?: number;
  controllerModel?: string;
  renderScale?: number;
  interactionDistance?: number;
  locomotionMethod?: 'teleport' | 'continuous';
  teleportRayColor?: string;
  displayMode?: 'inline' | 'immersive-vr' | 'immersive-ar';
  controllerRayColor?: string;
}

export interface CameraSettings {
  fov: number;
  near: number;
  far: number;
  position: { x: number; y: number; z: number };
  lookAt?: { x: number; y: number; z: number }; // lookAt is often dynamic
}
export interface VisualisationSettings {
  nodes: NodeSettings;
  edges: EdgeSettings;
  physics: PhysicsSettings;
  rendering: RenderingSettings;
  animations: AnimationSettings;
  labels: LabelSettings;
  bloom: BloomSettings;
  hologram: HologramSettings;
  camera?: CameraSettings;
}

export interface SystemSettings {
  websocket: WebSocketSettings;
  debug: DebugSettings;
  persistSettings: boolean; // Added to control server-side persistence
  customBackendUrl?: string; // Add if missing
}

export interface RAGFlowSettings {
  apiKey?: string;
  agentId?: string;
  apiBaseUrl?: string;
  timeout?: number;
  maxRetries?: number;
  chatId?: string;
}

export interface PerplexitySettings {
  apiKey?: string;
  model?: string;
  apiUrl?: string;
  maxTokens?: number;
  temperature?: number;
  topP?: number;
  presencePenalty?: number;
  frequencyPenalty?: number;
  timeout?: number;
  rateLimit?: number;
}

export interface OpenAISettings {
  apiKey?: string;
  baseUrl?: string;
  timeout?: number;
  rateLimit?: number;
}

export interface KokoroSettings {
  apiUrl?: string;
  defaultVoice?: string;
  defaultFormat?: string;
  defaultSpeed?: number;
  timeout?: number;
  stream?: boolean;
  returnTimestamps?: boolean;
  sampleRate?: number;
}

export interface AuthSettings {
  enabled: boolean;
  provider: 'nostr' | string; // Allow other providers potentially
  required: boolean;
}

export interface Settings {
  visualisation: VisualisationSettings;
  system: SystemSettings;
  xr: XRSettings;
  auth: AuthSettings; // Make auth required
  ragflow?: RAGFlowSettings; // Add optional AI settings
  perplexity?: PerplexitySettings;
  openai?: OpenAISettings;
  kokoro?: KokoroSettings;
}

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/settings/config/settingsConfig.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/settings/config/settingsConfig.ts
```ts
/**
 * Utility function to format setting names for display
 * Converts camelCase or snake_case to Title Case with spaces
 */
export const formatSettingName = (name: string): string => {
  // Replace camelCase with spaces
  const spacedName = name.replace(/([A-Z])/g, ' $1')
    // Replace underscores with spaces
    .replace(/_/g, ' ')
    // Trim any extra spaces
    .trim();

  // Capitalize first letter of each word
  return spacedName
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
};
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/settings/config/settingsUIDefinition.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/settings/config/settingsUIDefinition.ts
```ts

export type SettingWidgetType =
  | 'toggle'
  | 'slider'
  | 'numberInput'
  | 'textInput'
  | 'colorPicker'
  | 'select'
  | 'radioGroup' // For a small set of mutually exclusive choices
  | 'rangeSlider' // For [number, number] arrays
  | 'buttonAction'
  | 'dualColorPicker'; // Custom type for [string, string] color arrays

export interface UISettingDefinition {
  label: string;
  type: SettingWidgetType;
  path: string; // Full path in the SettingsStore, e.g., "visualisation.nodes.baseColor"
  description?: string; // Tooltip text
  options?: Array<{ value: string | number; label: string }>; // For select
  min?: number; // For slider, numberInput, rangeSlider
  max?: number; // For slider, numberInput, rangeSlider
  step?: number; // For slider, numberInput, rangeSlider
  unit?: string; // e.g., "px", "ms"
  isAdvanced?: boolean; // To hide behind an "Advanced" toggle if needed
  isPowerUserOnly?: boolean; // Only visible/editable by power users
  action?: () => void; // For buttonAction type
}

export interface UISubsectionDefinition {
  label: string;
  settings: Record<string, UISettingDefinition>;
}

export interface UICategoryDefinition {
  label: string;
  icon?: string; // Lucide icon name
  subsections: Record<string, UISubsectionDefinition>;
}

export const settingsUIDefinition: Record<string, UICategoryDefinition> = {
  visualisation: {
    label: 'Visualisation',
    icon: 'Eye',
    subsections: {
      nodes: {
        label: 'Nodes',
        settings: {
          baseColor: { label: 'Base Color', type: 'colorPicker', path: 'visualisation.nodes.baseColor', description: 'Default color of graph nodes.' },
          metalness: { label: 'Metalness', type: 'slider', min: 0, max: 1, step: 0.01, path: 'visualisation.nodes.metalness', description: 'How metallic nodes appear.' },
          opacity: { label: 'Opacity', type: 'slider', min: 0, max: 1, step: 0.01, path: 'visualisation.nodes.opacity', description: 'Overall opacity of nodes.' },
          roughness: { label: 'Roughness', type: 'slider', min: 0, max: 1, step: 0.01, path: 'visualisation.nodes.roughness', description: 'Surface roughness of nodes.' },
          nodeSize: { label: 'Node Size', type: 'slider', min: 0.01, max: 0.2, step: 0.01, path: 'visualisation.nodes.nodeSize', description: 'Controls the overall size of the nodes.' },
          quality: { label: 'Quality', type: 'radioGroup', options: [{value: 'low', label: 'Low'}, {value: 'medium', label: 'Medium'}, {value: 'high', label: 'High'}], path: 'visualisation.nodes.quality', description: 'Render quality of nodes.' },
          enableInstancing: { label: 'Enable Instancing', type: 'toggle', path: 'visualisation.nodes.enableInstancing', description: 'Use instanced rendering for nodes (performance).' },
          enableHologram: { label: 'Enable Hologram Effect', type: 'toggle', path: 'visualisation.nodes.enableHologram', description: 'Apply hologram effect to nodes.' },
          enableMetadataShape: { label: 'Enable Metadata Shape', type: 'toggle', path: 'visualisation.nodes.enableMetadataShape', description: 'Use shapes based on metadata.' },
          enableMetadataVisualisation: { label: 'Enable Metadata Visualisation', type: 'toggle', path: 'visualisation.nodes.enableMetadataVisualisation', description: 'Show metadata as part of node visualisation.' },
        },
      },
      edges: {
        label: 'Edges',
        settings: {
          arrowSize: { label: 'Arrow Size', type: 'slider', min: 0.01, max: 0.5, step: 0.01, path: 'visualisation.edges.arrowSize', description: 'Size of the arrows on edges.' },
          baseWidth: { label: 'Base Width', type: 'slider', min: 0.01, max: 2, step: 0.01, path: 'visualisation.edges.baseWidth', description: 'Base width of edges.' },
          color: { label: 'Color', type: 'colorPicker', path: 'visualisation.edges.color', description: 'Default color of edges.' },
          enableArrows: { label: 'Enable Arrows', type: 'toggle', path: 'visualisation.edges.enableArrows', description: 'Show arrows on directed edges.' },
          opacity: { label: 'Opacity', type: 'slider', min: 0, max: 1, step: 0.01, path: 'visualisation.edges.opacity', description: 'Overall opacity of edges.' },
          widthRange: { label: 'Width Range', type: 'rangeSlider', min: 0.1, max: 5, step: 0.1, path: 'visualisation.edges.widthRange', description: 'Minimum and maximum width for edges.' },
          quality: { label: 'Quality', type: 'select', options: [{value: 'low', label: 'Low'}, {value: 'medium', label: 'Medium'}, {value: 'high', label: 'High'}], path: 'visualisation.edges.quality', description: 'Render quality of edges.' },
          enableFlowEffect: { label: 'Enable Flow Effect', type: 'toggle', path: 'visualisation.edges.enableFlowEffect', description: 'Animate a flow effect along edges.', isAdvanced: true },
          flowSpeed: { label: 'Flow Speed', type: 'slider', min: 0.1, max: 5, step: 0.1, path: 'visualisation.edges.flowSpeed', description: 'Speed of the flow effect.', isAdvanced: true },
          flowIntensity: { label: 'Flow Intensity', type: 'slider', min: 0, max: 10, step: 0.1, path: 'visualisation.edges.flowIntensity', description: 'Intensity of the flow effect.' },
          glowStrength: { label: 'Glow Strength', type: 'slider', min: 0, max: 5, step: 0.1, path: 'visualisation.edges.glowStrength', description: 'Strength of the edge glow effect.' },
          distanceIntensity: { label: 'Distance Intensity', type: 'slider', min: 0, max: 10, step: 0.1, path: 'visualisation.edges.distanceIntensity', description: 'Intensity based on distance for some edge effects.' },
          useGradient: { label: 'Use Gradient', type: 'toggle', path: 'visualisation.edges.useGradient', description: 'Use a gradient for edge colors.' },
          gradientColors: { label: 'Gradient Colors', type: 'dualColorPicker', path: 'visualisation.edges.gradientColors', description: 'Start and end colors for edge gradient.' },
        },
      },
      physics: {
        label: 'Physics',
        settings: {
          enabled: { label: 'Enable Physics', type: 'toggle', path: 'visualisation.physics.enabled', description: 'Enable physics simulation for graph layout.' },
          attractionStrength: { label: 'Attraction Strength', type: 'slider', min: 0, max: 1, step: 0.01, path: 'visualisation.physics.attractionStrength', description: 'Strength of attraction between connected nodes.' },
          boundsSize: { label: 'Bounds Size', type: 'slider', min: 1, max: 50, step: 0.5, path: 'visualisation.physics.boundsSize', description: 'Size of the simulation bounding box.' },
          collisionRadius: { label: 'Collision Radius', type: 'slider', min: 0.1, max: 5, step: 0.1, path: 'visualisation.physics.collisionRadius', description: 'Radius for node collision detection.' },
          damping: { label: 'Damping', type: 'slider', min: 0, max: 1, step: 0.01, path: 'visualisation.physics.damping', description: 'Damping factor to slow down node movement.' },
          enableBounds: { label: 'Enable Bounds', type: 'toggle', path: 'visualisation.physics.enableBounds', description: 'Confine nodes within the bounds size.' },
          iterations: { label: 'Iterations', type: 'slider', min: 10, max: 500, step: 10, path: 'visualisation.physics.iterations', description: 'Number of physics iterations per step.' },
          maxVelocity: { label: 'Max Velocity', type: 'slider', min: 0.001, max: 0.5, step: 0.001, path: 'visualisation.physics.maxVelocity', description: 'Maximum velocity of nodes.' },
          repulsionStrength: { label: 'Repulsion Strength', type: 'slider', min: 0, max: 2, step: 0.01, path: 'visualisation.physics.repulsionStrength', description: 'Strength of repulsion between nodes.' },
          springStrength: { label: 'Spring Strength', type: 'slider', min: 0, max: 1, step: 0.01, path: 'visualisation.physics.springStrength', description: 'Strength of springs (edges) pulling nodes together.' },
          repulsionDistance: { label: 'Repulsion Distance', type: 'slider', min: 0.1, max: 10, step: 0.1, path: 'visualisation.physics.repulsionDistance', description: 'Distance at which repulsion force acts.' },
          massScale: { label: 'Mass Scale', type: 'slider', min: 0.1, max: 10, step: 0.1, path: 'visualisation.physics.massScale', description: 'Scaling factor for node mass.' },
          boundaryDamping: { label: 'Boundary Damping', type: 'slider', min: 0, max: 1, step: 0.01, path: 'visualisation.physics.boundaryDamping', description: 'Damping when nodes hit boundaries.' },
        },
      },
      rendering: {
        label: 'Rendering',
        settings: {
          backgroundColor: { label: 'Background Color', type: 'colorPicker', path: 'visualisation.rendering.backgroundColor', description: 'Color of the viewport background.' },
          enableAntialiasing: { label: 'Enable Antialiasing', type: 'toggle', path: 'visualisation.rendering.enableAntialiasing', description: 'Smooth jagged edges (MSAA/FXAA).' },
          ambientLightIntensity: { label: 'Ambient Light Intensity', type: 'slider', min: 0, max: 2, step: 0.05, path: 'visualisation.rendering.ambientLightIntensity', description: 'Intensity of ambient light.' },
          directionalLightIntensity: { label: 'Directional Light Intensity', type: 'slider', min: 0, max: 2, step: 0.05, path: 'visualisation.rendering.directionalLightIntensity', description: 'Intensity of directional light.' },
          enableAmbientOcclusion: { label: 'Enable Ambient Occlusion', type: 'toggle', path: 'visualisation.rendering.enableAmbientOcclusion', description: 'Enable screen-space ambient occlusion (SSAO).', isAdvanced: true },
          enableShadows: { label: 'Enable Shadows', type: 'toggle', path: 'visualisation.rendering.enableShadows', description: 'Enable dynamic shadows.', isAdvanced: true },
          environmentIntensity: { label: 'Environment Intensity', type: 'slider', min: 0, max: 2, step: 0.05, path: 'visualisation.rendering.environmentIntensity', description: 'Intensity of environment lighting (IBL).' },
          shadowMapSize: { label: 'Shadow Map Size', type: 'select', options: [{value: '512', label: '512px'}, {value: '1024', label: '1024px'}, {value: '2048', label: '2048px'}, {value: '4096', label: '4096px'}], path: 'visualisation.rendering.shadowMapSize', description: 'Resolution of shadow maps.', isAdvanced: true },
          shadowBias: { label: 'Shadow Bias', type: 'slider', min: -0.01, max: 0.01, step: 0.0001, path: 'visualisation.rendering.shadowBias', description: 'Bias to prevent shadow acne.', isAdvanced: true },
          context: { label: 'Rendering Context', type: 'select', options: [{value: 'desktop', label: 'Desktop'}, {value: 'ar', label: 'AR'}], path: 'visualisation.rendering.context', description: 'Current rendering context.' },
        },
      },
      labels: {
        label: 'Labels',
        settings: {
          enableLabels: { label: 'Enable Labels', type: 'toggle', path: 'visualisation.labels.enableLabels', description: 'Show text labels for nodes.' },
          desktopFontSize: { label: 'Desktop Font Size', type: 'slider', min: 0.01, max: 0.05, step: 0.01, path: 'visualisation.labels.desktopFontSize', description: 'Font size for labels in desktop mode.' },
          textColor: { label: 'Text Color', type: 'colorPicker', path: 'visualisation.labels.textColor', description: 'Color of label text.' },
          textOutlineColor: { label: 'Outline Color', type: 'colorPicker', path: 'visualisation.labels.textOutlineColor', description: 'Color of label text outline.' },
          textOutlineWidth: { label: 'Outline Width', type: 'slider', min: 0, max: 0.01, step: 0.001, path: 'visualisation.labels.textOutlineWidth', description: 'Width of label text outline.' },
          textResolution: { label: 'Text Resolution', type: 'numberInput', min: 8, max: 128, step: 1, path: 'visualisation.labels.textResolution', description: 'Resolution of text rendering texture.' },
          textPadding: { label: 'Text Padding', type: 'slider', min: 0, max: 0.1, step: 0.01, path: 'visualisation.labels.textPadding', description: 'Padding around text labels.' },
          billboardMode: { label: 'Billboard Mode', type: 'select', options: [{value: 'camera', label: 'Camera Facing'}, {value: 'vertical', label: 'Vertical Lock'}], path: 'visualisation.labels.billboardMode', description: 'How labels orient themselves.' },
        },
      },
      bloom: {
        label: 'Bloom Effect',
        settings: {
          enabled: { label: 'Enable Bloom', type: 'toggle', path: 'visualisation.bloom.enabled', description: 'Enable post-processing bloom effect.' },
          strength: { label: 'Strength', type: 'slider', min: 0, max: 3, step: 0.01, path: 'visualisation.bloom.strength', description: 'Overall strength of the bloom effect.' },
          edgeBloomStrength: { label: 'Edge Bloom Strength', type: 'slider', min: 0, max: 5, step: 0.05, path: 'visualisation.bloom.edgeBloomStrength', description: 'Bloom strength for edges.' },
          environmentBloomStrength: { label: 'Environment Bloom Strength', type: 'slider', min: 0, max: 5, step: 0.05, path: 'visualisation.bloom.environmentBloomStrength', description: 'Bloom strength from environment.' },
          nodeBloomStrength: { label: 'Node Bloom Strength', type: 'slider', min: 0, max: 5, step: 0.05, path: 'visualisation.bloom.nodeBloomStrength', description: 'Bloom strength for nodes.' },
          radius: { label: 'Radius', type: 'slider', min: 0, max: 5, step: 0.05, path: 'visualisation.bloom.radius', description: 'Radius of the bloom effect.' },
          threshold: { label: 'Threshold', type: 'slider', min: 0, max: 1, step: 0.01, path: 'visualisation.bloom.threshold', description: 'Luminance threshold for bloom.' },
        },
      },
      hologram: {
        label: 'Hologram Effect',
        settings: {
          ringCount: { label: 'Ring Count', type: 'slider', min: 0, max: 10, step: 1, path: 'visualisation.hologram.ringCount', description: 'Number of rings in hologram effect.' },
          ringColor: { label: 'Ring Color', type: 'colorPicker', path: 'visualisation.hologram.ringColor', description: 'Color of hologram rings.' },
          ringOpacity: { label: 'Ring Opacity', type: 'slider', min: 0, max: 1, step: 0.01, path: 'visualisation.hologram.ringOpacity', description: 'Opacity of hologram rings.' },
          sphereSizes: { label: 'Sphere Sizes (Min/Max)', type: 'rangeSlider', min: 0.1, max: 20, step: 0.1, path: 'visualisation.hologram.sphereSizes', description: 'Min/max sizes for hologram spheres.' },
          ringRotationSpeed: { label: 'Ring Rotation Speed', type: 'slider', min: 0, max: 50, step: 0.5, path: 'visualisation.hologram.ringRotationSpeed', description: 'Rotation speed of hologram rings.' },
          enableBuckminster: { label: 'Enable Buckminster', type: 'toggle', path: 'visualisation.hologram.enableBuckminster', description: 'Enable Buckminster fullerene style hologram.' },
          buckminsterSize: { label: 'Buckminster Size', type: 'slider', min: 1, max: 20, step: 0.5, path: 'visualisation.hologram.buckminsterSize', description: 'Size of Buckminster hologram.' },
          buckminsterOpacity: { label: 'Buckminster Opacity', type: 'slider', min: 0, max: 1, step: 0.01, path: 'visualisation.hologram.buckminsterOpacity', description: 'Opacity of Buckminster hologram.' },
          enableGeodesic: { label: 'Enable Geodesic', type: 'toggle', path: 'visualisation.hologram.enableGeodesic', description: 'Enable geodesic dome style hologram.' },
          geodesicSize: { label: 'Geodesic Size', type: 'slider', min: 1, max: 20, step: 0.5, path: 'visualisation.hologram.geodesicSize', description: 'Size of geodesic hologram.' },
          geodesicOpacity: { label: 'Geodesic Opacity', type: 'slider', min: 0, max: 1, step: 0.01, path: 'visualisation.hologram.geodesicOpacity', description: 'Opacity of geodesic hologram.' },
          enableTriangleSphere: { label: 'Enable Triangle Sphere', type: 'toggle', path: 'visualisation.hologram.enableTriangleSphere', description: 'Enable triangle sphere style hologram.' },
          triangleSphereSize: { label: 'Triangle Sphere Size', type: 'slider', min: 1, max: 20, step: 0.5, path: 'visualisation.hologram.triangleSphereSize', description: 'Size of triangle sphere hologram.' },
          triangleSphereOpacity: { label: 'Triangle Sphere Opacity', type: 'slider', min: 0, max: 1, step: 0.01, path: 'visualisation.hologram.triangleSphereOpacity', description: 'Opacity of triangle sphere hologram.' },
          globalRotationSpeed: { label: 'Global Rotation Speed', type: 'slider', min: 0, max: 20, step: 0.1, path: 'visualisation.hologram.globalRotationSpeed', description: 'Global rotation speed for hologram effects.' },
        },
      },
      animations: {
        label: 'Animations',
        settings: {
          enableNodeAnimations: { label: 'Enable Node Animations', type: 'toggle', path: 'visualisation.animations.enableNodeAnimations', description: 'Enable generic node animations.' },
          enableMotionBlur: { label: 'Enable Motion Blur', type: 'toggle', path: 'visualisation.animations.enableMotionBlur', description: 'Enable motion blur effect.', isAdvanced: true },
          motionBlurStrength: { label: 'Motion Blur Strength', type: 'slider', min: 0, max: 1, step: 0.01, path: 'visualisation.animations.motionBlurStrength', description: 'Strength of motion blur.', isAdvanced: true },
          selectionWaveEnabled: { label: 'Enable Selection Wave', type: 'toggle', path: 'visualisation.animations.selectionWaveEnabled', description: 'Enable wave animation on selection.' },
          pulseEnabled: { label: 'Enable Pulse Animation', type: 'toggle', path: 'visualisation.animations.pulseEnabled', description: 'Enable pulsing animation on nodes.' },
          pulseSpeed: { label: 'Pulse Speed', type: 'slider', min: 0.1, max: 2, step: 0.05, path: 'visualisation.animations.pulseSpeed', description: 'Speed of pulse animation.' },
          pulseStrength: { label: 'Pulse Strength', type: 'slider', min: 0.1, max: 2, step: 0.05, path: 'visualisation.animations.pulseStrength', description: 'Strength of pulse animation.' },
          waveSpeed: { label: 'Wave Speed', type: 'slider', min: 0.1, max: 2, step: 0.05, path: 'visualisation.animations.waveSpeed', description: 'Speed of selection wave animation.' },
        },
      },
    },
  },
  system: {
    label: 'System',
    icon: 'Settings',
    subsections: {
      general: {
        label: 'General',
        settings: {
          persistSettings: { label: 'Persist Settings on Server', type: 'toggle', path: 'system.persistSettings', description: 'Save settings to your user profile on the server (if authenticated).'},
          customBackendUrl: { label: 'Custom Backend URL', type: 'textInput', path: 'system.customBackendUrl', description: 'Overrides the default backend URL. Requires app reload. Leave empty for default.', isPowerUserOnly: true },
        }
      },
      websocket: {
        label: 'WebSocket',
        settings: {
          updateRate: { label: 'Update Rate (Hz)', type: 'slider', min: 1, max: 60, step: 1, path: 'system.websocket.updateRate', description: 'Frequency of position updates from server.' },
          reconnectAttempts: { label: 'Reconnect Attempts', type: 'slider', min: 0, max: 10, step: 1, path: 'system.websocket.reconnectAttempts', description: 'Number of WebSocket reconnect attempts.' },
          reconnectDelay: { label: 'Reconnect Delay', type: 'slider', unit: 'ms', min: 500, max: 10000, step: 100, path: 'system.websocket.reconnectDelay', description: 'Delay between WebSocket reconnect attempts.' },
          binaryChunkSize: { label: 'Binary Chunk Size', type: 'slider', unit: 'bytes', min: 256, max: 8192, step: 256, path: 'system.websocket.binaryChunkSize', description: 'Chunk size for binary data transmission.' },
          compressionEnabled: { label: 'Compression Enabled', type: 'toggle', path: 'system.websocket.compressionEnabled', description: 'Enable WebSocket message compression.' },
          compressionThreshold: { label: 'Compression Threshold', type: 'slider', unit: 'bytes', min: 64, max: 4096, step: 64, path: 'system.websocket.compressionThreshold', description: 'Threshold for WebSocket compression.' },
        },
      },
      debug: {
        label: 'Client Debugging',
        settings: {
          enabled: { label: 'Enable Client Debug Mode', type: 'toggle', path: 'system.debug.enabled', description: 'Enable general client-side debug logging and features.' },
          logLevel: { label: 'Client Log Level', type: 'select', options: [{value: 'debug', label: 'Debug'}, {value: 'info', label: 'Info'}, {value: 'warn', label: 'Warn'}, {value: 'error', label: 'Error'}], path: 'system.debug.logLevel', description: 'Client console log level.', isPowerUserOnly: true },
          enableDataDebug: { label: 'Enable Data Debug', type: 'toggle', path: 'system.debug.enableDataDebug', description: 'Log detailed client data flow information.', isAdvanced: true },
          enableWebsocketDebug: { label: 'Enable WebSocket Debug', type: 'toggle', path: 'system.debug.enableWebsocketDebug', description: 'Log WebSocket communication details.', isAdvanced: true },
          logBinaryHeaders: { label: 'Log Binary Headers', type: 'toggle', path: 'system.debug.logBinaryHeaders', description: 'Log headers of binary messages.', isAdvanced: true },
          logFullJson: { label: 'Log Full JSON', type: 'toggle', path: 'system.debug.logFullJson', description: 'Log complete JSON payloads.', isAdvanced: true },
          enablePhysicsDebug: { label: 'Enable Physics Debug', type: 'toggle', path: 'system.debug.enablePhysicsDebug', description: 'Show physics debug visualizations.', isAdvanced: true },
          enableNodeDebug: { label: 'Enable Node Debug', type: 'toggle', path: 'system.debug.enableNodeDebug', description: 'Enable debug features for nodes.', isAdvanced: true },
          enableShaderDebug: { label: 'Enable Shader Debug', type: 'toggle', path: 'system.debug.enableShaderDebug', description: 'Enable shader debugging tools.', isAdvanced: true, isPowerUserOnly: true },
          enableMatrixDebug: { label: 'Enable Matrix Debug', type: 'toggle', path: 'system.debug.enableMatrixDebug', description: 'Log matrix transformations.', isAdvanced: true, isPowerUserOnly: true },
          enablePerformanceDebug: { label: 'Enable Performance Debug', type: 'toggle', path: 'system.debug.enablePerformanceDebug', description: 'Show performance metrics.', isAdvanced: true },
        },
      },
    },
  },
  xr: {
    label: 'XR',
    icon: 'Smartphone',
    subsections: {
      general: {
        label: 'General XR',
        settings: {
          clientSideEnableXR: { label: 'Enable XR Mode (Client)', type: 'toggle', path: 'xr.clientSideEnableXR', description: 'Toggle immersive XR mode. Requires a compatible headset and page reload.' },
          enabled: { label: 'XR Features Enabled (Server)', type: 'toggle', path: 'xr.enabled', description: 'Enable XR features on the server (requires server restart if changed).', isPowerUserOnly: true },
          displayMode: { label: 'XR Display Mode', type: 'select', options: [{value: 'inline', label: 'Inline (Desktop)'}, {value: 'immersive-vr', label: 'Immersive VR'}, {value: 'immersive-ar', label: 'Immersive AR'}], path: 'xr.displayMode', description: 'Preferred XR display mode.' },
          quality: { label: 'XR Quality', type: 'select', options: [{value: 'low', label: 'Low'}, {value: 'medium', label: 'Medium'}, {value: 'high', label: 'High'}], path: 'xr.quality', description: 'Overall rendering quality in XR.' },
          renderScale: { label: 'Render Scale', type: 'slider', min: 0.5, max: 2, step: 0.1, path: 'xr.renderScale', description: 'XR rendering resolution scale.' },
          interactionDistance: { label: 'Interaction Distance', type: 'slider', min: 0.1, max: 5, step: 0.1, path: 'xr.interactionDistance', description: 'Max distance for XR interactions.' },
          locomotionMethod: { label: 'Locomotion Method', type: 'select', options: [{value: 'teleport', label: 'Teleport'}, {value: 'continuous', label: 'Continuous'}], path: 'xr.locomotionMethod', description: 'Method for moving in XR.' },
          teleportRayColor: { label: 'Teleport Ray Color', type: 'colorPicker', path: 'xr.teleportRayColor', description: 'Color of the teleportation ray.' },
          controllerModel: { label: 'Controller Model Path', type: 'textInput', path: 'xr.controllerModel', description: 'Path to custom controller model (leave empty for default).', isAdvanced: true },
          roomScale: { label: 'Room Scale Factor', type: 'slider', min: 0.5, max: 2.0, step: 0.1, path: 'xr.roomScale', description: 'Scaling factor for room-scale XR experiences.'},
          spaceType: { label: 'Reference Space Type', type: 'select', options: [{value: 'local-floor', label: 'Local Floor'}, {value: 'bounded-floor', label: 'Bounded Floor'}, {value: 'unbounded', label: 'Unbounded'}], path: 'xr.spaceType', description: 'WebXR reference space type.'},
        },
      },
      handFeatures: {
        label: 'Hand Tracking & Interactions',
        settings: {
          handTracking: { label: 'Enable Hand Tracking', type: 'toggle', path: 'xr.handTracking', description: 'Enable hand tracking in XR.' },
          controllerRayColor: { label: 'Controller Ray Color', type: 'colorPicker', path: 'xr.controllerRayColor', description: 'Color of controller interaction rays.' },
          enableHaptics: { label: 'Enable Haptics', type: 'toggle', path: 'xr.enableHaptics', description: 'Enable haptic feedback in controllers.' },
          handMeshEnabled: { label: 'Show Hand Mesh', type: 'toggle', path: 'xr.handMeshEnabled', description: 'Render a mesh for tracked hands.', isAdvanced: true },
          handMeshColor: { label: 'Hand Mesh Color', type: 'colorPicker', path: 'xr.handMeshColor', description: 'Color of the hand mesh.', isAdvanced: true },
          handMeshOpacity: { label: 'Hand Mesh Opacity', type: 'slider', min: 0, max: 1, step: 0.01, path: 'xr.handMeshOpacity', description: 'Opacity of the hand mesh.', isAdvanced: true },
          handPointSize: { label: 'Hand Joint Point Size', type: 'slider', min: 0.001, max: 0.02, step: 0.001, path: 'xr.handPointSize', description: 'Size of points representing hand joints.', isAdvanced: true },
          handRayEnabled: { label: 'Enable Hand Rays', type: 'toggle', path: 'xr.handRayEnabled', description: 'Show rays originating from hands for interaction.', isAdvanced: true },
          handRayWidth: { label: 'Hand Ray Width', type: 'slider', min: 0.001, max: 0.01, step: 0.0005, path: 'xr.handRayWidth', description: 'Width of hand interaction rays.', isAdvanced: true },
          gestureSmoothing: { label: 'Gesture Smoothing', type: 'slider', min: 0, max: 1, step: 0.05, path: 'xr.gestureSmoothing', description: 'Smoothing factor for hand gestures.', isAdvanced: true },
          hapticIntensity: { label: 'Haptic Intensity', type: 'slider', min: 0, max: 1, step: 0.05, path: 'xr.hapticIntensity', description: 'Intensity of haptic feedback.' },
          dragThreshold: { label: 'Drag Threshold', type: 'slider', min: 0.01, max: 0.2, step: 0.01, path: 'xr.dragThreshold', description: 'Threshold for initiating a drag interaction.' },
          pinchThreshold: { label: 'Pinch Threshold', type: 'slider', min: 0.1, max: 0.9, step: 0.05, path: 'xr.pinchThreshold', description: 'Threshold for pinch gesture detection.' },
          rotationThreshold: { label: 'Rotation Threshold', type: 'slider', min: 0.01, max: 0.2, step: 0.01, path: 'xr.rotationThreshold', description: 'Threshold for rotation gestures.' },
          movementSpeed: { label: 'Movement Speed', type: 'slider', min: 0.01, max: 0.5, step: 0.01, path: 'xr.movementSpeed', description: 'Speed for continuous locomotion.' },
          deadZone: { label: 'Controller Dead Zone', type: 'slider', min: 0.01, max: 0.5, step: 0.01, path: 'xr.deadZone', description: 'Dead zone for controller analog sticks.' },
          interactionRadius: { label: 'Interaction Radius', type: 'slider', min: 0.05, max: 0.5, step: 0.01, path: 'xr.interactionRadius', description: 'Radius for direct hand interactions.' },
          movementAxesHorizontal: { label: 'Movement Horizontal Axis', type: 'slider', min: 0, max: 5, step: 1, path: 'xr.movementAxesHorizontal', description: 'Axis used for horizontal movement in XR.', isAdvanced: true },
          movementAxesVertical: { label: 'Movement Vertical Axis', type: 'slider', min: 0, max: 5, step: 1, path: 'xr.movementAxesVertical', description: 'Axis used for vertical movement in XR.', isAdvanced: true },
        }
      },
      environmentUnderstanding: {
        label: 'Environment Understanding',
        settings: {
          enableLightEstimation: { label: 'Enable Light Estimation', type: 'toggle', path: 'xr.enableLightEstimation', description: 'Enable light estimation for AR environments.', isAdvanced: true },
          enablePlaneDetection: { label: 'Enable Plane Detection', type: 'toggle', path: 'xr.enablePlaneDetection', description: 'Enable automatic detection of flat surfaces (planes) in AR.', isAdvanced: true },
          enableSceneUnderstanding: { label: 'Enable Scene Understanding', type: 'toggle', path: 'xr.enableSceneUnderstanding', description: 'Enable advanced scene understanding (meshes, semantics) in AR.', isAdvanced: true },
          planeColor: { label: 'Plane Color', type: 'colorPicker', path: 'xr.planeColor', description: 'Color of detected planes in AR.', isAdvanced: true },
          planeOpacity: { label: 'Plane Opacity', type: 'slider', min: 0, max: 1, step: 0.01, path: 'xr.planeOpacity', description: 'Opacity of detected planes in AR.', isAdvanced: true },
          planeDetectionDistance: { label: 'Plane Detection Distance', type: 'slider', min: 0.1, max: 10, step: 0.1, path: 'xr.planeDetectionDistance', description: 'Maximum distance for plane detection in AR.', isAdvanced: true },
          showPlaneOverlay: { label: 'Show Plane Overlay', type: 'toggle', path: 'xr.showPlaneOverlay', description: 'Show a visual overlay on detected planes.', isAdvanced: true },
          snapToFloor: { label: 'Snap to Floor', type: 'toggle', path: 'xr.snapToFloor', description: 'Automatically snap objects to detected floor planes.', isAdvanced: true },
        },
      },
      passthrough: {
        label: 'Passthrough',
        settings: {
          enablePassthroughPortal: { label: 'Enable Passthrough Portal', type: 'toggle', path: 'xr.enablePassthroughPortal', description: 'Enable a portal to the real world via passthrough camera.', isAdvanced: true },
          passthroughOpacity: { label: 'Passthrough Opacity', type: 'slider', min: 0, max: 1, step: 0.01, path: 'xr.passthroughOpacity', description: 'Opacity of the passthrough view.', isAdvanced: true },
          passthroughBrightness: { label: 'Passthrough Brightness', type: 'slider', min: 0, max: 2, step: 0.05, path: 'xr.passthroughBrightness', description: 'Brightness adjustment for passthrough.', isAdvanced: true },
          passthroughContrast: { label: 'Passthrough Contrast', type: 'slider', min: 0, max: 2, step: 0.05, path: 'xr.passthroughContrast', description: 'Contrast adjustment for passthrough.', isAdvanced: true },
          portalSize: { label: 'Portal Size', type: 'slider', min: 0.1, max: 10, step: 0.1, path: 'xr.portalSize', description: 'Size of the passthrough portal.', isAdvanced: true },
          portalEdgeColor: { label: 'Portal Edge Color', type: 'colorPicker', path: 'xr.portalEdgeColor', description: 'Color of the passthrough portal edge.', isAdvanced: true },
          portalEdgeWidth: { label: 'Portal Edge Width', type: 'slider', min: 0, max: 0.1, step: 0.001, path: 'xr.portalEdgeWidth', description: 'Width of the passthrough portal edge.', isAdvanced: true },
        },
      },
    },
  },
  ai: {
    label: 'AI Services',
    icon: 'Brain',
    subsections: {
      ragflow: {
        label: 'RAGFlow',
        settings: {
          apiKey: { label: 'API Key', type: 'textInput', path: 'ragflow.apiKey', description: 'Your RAGFlow API Key. Will be obscured.', isPowerUserOnly: true },
          agentId: { label: 'Agent ID', type: 'textInput', path: 'ragflow.agentId', description: 'RAGFlow Agent ID.', isPowerUserOnly: true },
          apiBaseUrl: { label: 'API Base URL', type: 'textInput', path: 'ragflow.apiBaseUrl', description: 'Custom RAGFlow API Base URL.', isPowerUserOnly: true, isAdvanced: true },
          timeout: { label: 'Timeout (s)', type: 'slider', unit: 's', min: 1, max: 300, step: 1, path: 'ragflow.timeout', description: 'API request timeout in seconds.' },
          maxRetries: { label: 'Max Retries', type: 'slider', min: 0, max: 10, step: 1, path: 'ragflow.maxRetries', description: 'Maximum retry attempts for API calls.' },
          chatId: { label: 'Chat ID', type: 'textInput', path: 'ragflow.chatId', description: 'Default RAGFlow Chat ID.', isPowerUserOnly: true, isAdvanced: true },
        },
      },
      perplexity: {
        label: 'Perplexity',
        settings: {
          apiKey: { label: 'API Key', type: 'textInput', path: 'perplexity.apiKey', description: 'Your Perplexity API Key. Will be obscured.', isPowerUserOnly: true },
          model: { label: 'Model', type: 'textInput', path: 'perplexity.model', description: 'Perplexity model name (e.g., llama-3.1-sonar-small-128k-online).' },
          apiUrl: { label: 'API URL', type: 'textInput', path: 'perplexity.apiUrl', description: 'Custom Perplexity API URL.', isPowerUserOnly: true, isAdvanced: true },
          maxTokens: { label: 'Max Tokens', type: 'slider', min: 1, max: 130000, step: 128, path: 'perplexity.maxTokens', description: 'Maximum tokens for API response.' }, // Adjusted max for sonar 128k
          temperature: { label: 'Temperature', type: 'slider', min: 0, max: 2, step: 0.1, path: 'perplexity.temperature', description: 'Sampling temperature.' },
          topP: { label: 'Top P', type: 'slider', min: 0, max: 1, step: 0.01, path: 'perplexity.topP', description: 'Nucleus sampling parameter.' },
          presencePenalty: { label: 'Presence Penalty', type: 'slider', min: -2, max: 2, step: 0.1, path: 'perplexity.presencePenalty', description: 'Penalty for new token presence.' },
          frequencyPenalty: { label: 'Frequency Penalty', type: 'slider', min: -2, max: 2, step: 0.1, path: 'perplexity.frequencyPenalty', description: 'Penalty for token frequency.' },
          timeout: { label: 'Timeout (s)', type: 'slider', unit: 's', min: 1, max: 300, step: 1, path: 'perplexity.timeout', description: 'API request timeout.' },
          rateLimit: { label: 'Rate Limit (req/min)', type: 'slider', min: 1, max: 1000, step: 1, path: 'perplexity.rateLimit', description: 'Requests per minute.', isAdvanced: true },
        },
      },
      openai: {
        label: 'OpenAI',
        settings: {
          apiKey: { label: 'API Key', type: 'textInput', path: 'openai.apiKey', description: 'Your OpenAI API Key. Will be obscured.', isPowerUserOnly: true },
          baseUrl: { label: 'Base URL', type: 'textInput', path: 'openai.baseUrl', description: 'Custom OpenAI Base URL (e.g., for Azure).', isPowerUserOnly: true, isAdvanced: true },
          timeout: { label: 'Timeout (s)', type: 'slider', unit: 's', min: 1, max: 300, step: 1, path: 'openai.timeout', description: 'API request timeout.' },
          rateLimit: { label: 'Rate Limit (req/min)', type: 'slider', min: 1, max: 1000, step: 1, path: 'openai.rateLimit', description: 'Requests per minute.', isAdvanced: true },
        },
      },
      kokoro: {
        label: 'Kokoro TTS',
        settings: {
          apiUrl: { label: 'API URL', type: 'textInput', path: 'kokoro.apiUrl', description: 'Kokoro TTS API URL.', isPowerUserOnly: true },
          defaultVoice: { label: 'Default Voice', type: 'textInput', path: 'kokoro.defaultVoice', description: 'Default voice for TTS.' },
          defaultFormat: { label: 'Default Format', type: 'select', options: [{value: 'mp3', label: 'MP3'}, {value: 'ogg', label: 'OGG Vorbis'}, {value: 'wav', label: 'WAV'}, {value: 'pcm', label: 'PCM'}], path: 'kokoro.defaultFormat', description: 'Default audio format.' },
          defaultSpeed: { label: 'Default Speed', type: 'slider', min: 0.25, max: 4.0, step: 0.05, path: 'kokoro.defaultSpeed', description: 'Default speech speed.' },
          timeout: { label: 'Timeout (s)', type: 'slider', unit: 's', min: 1, max: 300, step: 1, path: 'kokoro.timeout', description: 'API request timeout.' },
          stream: { label: 'Stream Audio', type: 'toggle', path: 'kokoro.stream', description: 'Enable audio streaming.' },
          returnTimestamps: { label: 'Return Timestamps', type: 'toggle', path: 'kokoro.returnTimestamps', description: 'Request word timestamps from TTS.', isAdvanced: true },
          sampleRate: { label: 'Sample Rate', type: 'select', options: [{value: '8000', label: '8000 Hz'}, {value: '16000', label: '16000 Hz'}, {value: '22050', label: '22050 Hz'}, {value: '24000', label: '24000 Hz'}, {value: '44100', label: '44100 Hz'}, {value: '48000', label: '48000 Hz'}], path: 'kokoro.sampleRate', description: 'Audio sample rate.' },
        },
      },
    },
  },
};
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/settings/types/settingsSchema.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/settings/types/settingsSchema.ts
```ts
/**
 * This file defines the schema for the application settings.
 * It provides type definitions, validation rules, and default values
 * for all configurable settings.
 */

export type ControlType =
  | 'text'
  | 'number'
  | 'checkbox'
  | 'select'
  | 'color'
  | 'slider'
  | 'button'
  | 'group';

export interface BaseSettingSchema {
  /** Unique identifier for this setting */
  id: string;

  /** Human-readable label */
  label: string;

  /** Optional detailed description */
  description?: string;

  /** Type of control used for this setting */
  controlType: ControlType;

  /** Whether this setting is advanced and should be hidden by default */
  advanced?: boolean;

  /** Whether this setting is read-only */
  readonly?: boolean;

  /** Tags for categorization and filtering */
  tags?: string[];
}

export interface TextSettingSchema extends BaseSettingSchema {
  controlType: 'text';
  defaultValue: string;
  placeholder?: string;
  validation?: {
    pattern?: string;
    minLength?: number;
    maxLength?: number;
    required?: boolean;
  };
}

export interface NumberSettingSchema extends BaseSettingSchema {
  controlType: 'number';
  defaultValue: number;
  min?: number;
  max?: number;
  step?: number;
  validation?: {
    required?: boolean;
    integer?: boolean;
  };
}

export interface CheckboxSettingSchema extends BaseSettingSchema {
  controlType: 'checkbox';
  defaultValue: boolean;
}

export interface SelectSettingSchema extends BaseSettingSchema {
  controlType: 'select';
  defaultValue: string | number;
  options: Array<{
    label: string;
    value: string | number;
    description?: string;
  }>;
  allowCustom?: boolean;
}

export interface ColorSettingSchema extends BaseSettingSchema {
  controlType: 'color';
  defaultValue: string;
  format?: 'hex' | 'rgb' | 'hsl';
  alpha?: boolean;
}

export interface SliderSettingSchema extends BaseSettingSchema {
  controlType: 'slider';
  defaultValue: number;
  min: number;
  max: number;
  step?: number;
  showValue?: boolean;
  unit?: string;
}

export interface ButtonSettingSchema extends BaseSettingSchema {
  controlType: 'button';
  action: string;
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
}

export interface GroupSettingSchema extends BaseSettingSchema {
  controlType: 'group';
  settings: SettingSchema[];
  collapsible?: boolean;
  defaultCollapsed?: boolean;
}

export type SettingSchema =
  | TextSettingSchema
  | NumberSettingSchema
  | CheckboxSettingSchema
  | SelectSettingSchema
  | ColorSettingSchema
  | SliderSettingSchema
  | ButtonSettingSchema
  | GroupSettingSchema;

export interface SettingsCategory {
  id: string;
  label: string;
  description?: string;
  icon?: string;
  subcategories?: {
    id: string;
    label: string;
    description?: string;
    settings: SettingSchema[];
  }[];
}

export function formatSettingLabel(label: string): string {
  // Replace underscores with spaces
  let formatted = label.replace(/_/g, ' ');

  // Capitalize first letter
  formatted = formatted.charAt(0).toUpperCase() + formatted.slice(1);

  // Capitalize after spaces
  formatted = formatted.replace(/\s([a-z])/g, function(match) {
    return ' ' + match.toUpperCase();
  });

  return formatted;
}

export function validateSetting(schema: SettingSchema, value: any): { valid: boolean; error?: string } {
  switch (schema.controlType) {
    case 'text': {
      if (typeof value !== 'string') {
        return { valid: false, error: 'Value must be a string' };
      }

      const validation = (schema as TextSettingSchema).validation;

      if (validation?.required && value.trim() === '') {
        return { valid: false, error: 'This field is required' };
      }

      if (validation?.minLength !== undefined && value.length < validation.minLength) {
        return { valid: false, error: `Must be at least ${validation.minLength} characters` };
      }

      if (validation?.maxLength !== undefined && value.length > validation.maxLength) {
        return { valid: false, error: `Must be at most ${validation.maxLength} characters` };
      }

      if (validation?.pattern && !new RegExp(validation.pattern).test(value)) {
        return { valid: false, error: 'Invalid format' };
      }

      return { valid: true };
    }
    case 'number': {
      if (typeof value !== 'number' || isNaN(value)) {
        return { valid: false, error: 'Value must be a number' };
      }

      const { min, max, validation } = schema as NumberSettingSchema;

      if (validation?.integer && !Number.isInteger(value)) {
        return { valid: false, error: 'Value must be an integer' };
      }

      if (min !== undefined && value < min) {
        return { valid: false, error: `Value must be at least ${min}` };
      }

      if (max !== undefined && value > max) {
        return { valid: false, error: `Value must be at most ${max}` };
      }

      return { valid: true };
    }
    case 'checkbox': {
      if (typeof value !== 'boolean') {
        return { valid: false, error: 'Value must be a boolean' };
      }

      return { valid: true };
    }
    case 'select': {
      const { options, allowCustom } = schema as SelectSettingSchema;

      // If custom values are allowed, just check type
      if (allowCustom) {
        if (typeof value !== 'string' && typeof value !== 'number') {
          return { valid: false, error: 'Value must be a string or number' };
        }
        return { valid: true };
      }

      // Otherwise, check if value is in options
      const isValid = options.some(option => option.value === value);
      if (!isValid) {
        return { valid: false, error: 'Value must be one of the available options' };
      }

      return { valid: true };
    }
    case 'color': {
      if (typeof value !== 'string') {
        return { valid: false, error: 'Value must be a string' };
      }

      // Simple validation for hex color
      const { format } = schema as ColorSettingSchema;

      if (format === 'hex' || !format) {
        const hexRegex = /^#([0-9A-F]{3}){1,2}$/i;
        if (!hexRegex.test(value)) {
          return { valid: false, error: 'Invalid hex color format' };
        }
      }

      return { valid: true };
    }
    case 'slider': {
      if (typeof value !== 'number' || isNaN(value)) {
        return { valid: false, error: 'Value must be a number' };
      }

      const { min, max } = schema as SliderSettingSchema;

      if (value < min) {
        return { valid: false, error: `Value must be at least ${min}` };
      }

      if (value > max) {
        return { valid: false, error: `Value must be at most ${max}` };
      }

      return { valid: true };
    }
    case 'button':
    case 'group':
      // These types don't have values to validate
      return { valid: true };
    default:
      return { valid: false, error: 'Unknown control type' };
  }
}

export function getDefaultValue(schema: SettingSchema): any {
  if ('defaultValue' in schema) {
    return schema.defaultValue;
  }

  if (schema.controlType === 'group') {
    const groupSchema = schema as GroupSettingSchema;
    const defaults: Record<string, any> = {};

    groupSchema.settings.forEach(setting => {
      defaults[setting.id] = getDefaultValue(setting);
    });

    return defaults;
  }

  return undefined;
}

export interface WebSocketSettings {
  host: string;
  port: string;
  path: string;
  secure: boolean;
}

export interface SystemSettings {
  websocket: WebSocketSettings;
  debug: {
    enabled: boolean;
    logLevel: 'debug' | 'info' | 'warn' | 'error';
    showStats: boolean;
  };
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/settings/types/settingsTypes.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/settings/types/settingsTypes.ts
```ts
export type SettingControlType = 'slider' | 'toggle' | 'color' | 'select' | 'number' | 'text';

export interface SettingControl {
  label: string;
  type: SettingControlType;
  options?: string[];
  min?: number;
  max?: number;
  step?: number;
  tooltip?: string;
}

export type SettingValue = string | number | boolean | string[] | number[];

export interface SettingsSectionProps {
  id: string;
  title: string;
  settings: Record<string, SettingControl | Record<string, SettingControl>>;
  advanced?: boolean;
}

export interface SettingsSubsectionProps {
  title: string;
  path: string;
  settings: Record<string, SettingControl> | SettingControl;
}

export interface SettingControlProps {
  path: string;
  setting: SettingControl;
  value: any;
  onChange: (value: any) => void;
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/settings/types/uiSetting.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/settings/types/uiSetting.ts
```ts
/**
 * Type definitions for UI settings as actually used in components
 */

/**
 * Interface for settings that can be controlled through UI components
 * This represents the runtime structure of settings as they appear in the components
 */
export interface UISetting {
  type: string;
  id?: string;
  label?: string;
  description?: string;
  help?: string;
  value?: any;
  min?: number;
  max?: number;
  step?: number;
  unit?: string;
  placeholder?: string;
  options?: Array<{ value: string; label: string }>;
  advanced?: boolean;
}

/**
 * Type guard to check if an object is a valid setting control
 */
export function isUISetting(obj: any): obj is UISetting {
  return obj && typeof obj === 'object' && 'type' in obj;
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/visualisation/components/ActionButtons.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/visualisation/components/ActionButtons.tsx
```tsx
import { useState } from 'react'
import { Button } from '../../../ui/Button' // Corrected path
import { Card, CardContent, CardHeader, CardTitle } from '../../../ui/Card' // Corrected path
import { createLogger } from '../../../utils/logger' // Corrected path from lib/utils to utils

const logger = createLogger('ActionButtons')

export function ActionButtons() {
  const [isRandomizing, setIsRandomizing] = useState(false)

  // Function to randomize node positions
  const handleRandomizeNodes = async () => {
    try {
      setIsRandomizing(true)

      // In the real implementation, this would call the visualisation controller
      // For now, we just simulate the action with a timeout
      logger.info('Randomizing node positions')

      // Simulate network request delay
      await new Promise(resolve => setTimeout(resolve, 1000))

      // Success message (in a real implementation, this would be after confirmation from the controller)
      logger.info('Node positions randomized successfully')
    } catch (error) {
      logger.error('Failed to randomize node positions:', error)
    } finally {
      setIsRandomizing(false)
    }
  }

  return (
    <Card className="settings-section mb-4">
      <CardHeader className="py-2 px-4">
        <CardTitle className="text-sm font-medium">Actions</CardTitle>
      </CardHeader>
      <CardContent className="p-2 pt-0">
        <div className="flex flex-wrap gap-2">
          <Button
            variant="secondary"
            size="sm"
            disabled={isRandomizing}
            onClick={handleRandomizeNodes}
          >
            {isRandomizing ? 'Randomizing...' : 'Randomly Distribute Nodes'}
          </Button>

          {/* More action buttons can be added here */}
        </div>
      </CardContent>
    </Card>
  )
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/visualisation/components/CameraController.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/visualisation/components/CameraController.tsx
```tsx
import { useEffect } from 'react';
import { useThree } from '@react-three/fiber';
import * as THREE from 'three'; // Use namespace import

interface CameraControllerProps {
  center: [number, number, number];
  size: number;
}

const CameraController: React.FC<CameraControllerProps> = ({ center, size }) => {
  const { camera } = useThree();

  useEffect(() => {
    // Ensure camera is PerspectiveCamera before accessing specific properties or methods
    if (camera instanceof THREE.PerspectiveCamera) {
        // Adjust position based on graph bounds
        camera.position.set(center[0], center[1] + 10, center[2] + size * 2);
        camera.lookAt(new THREE.Vector3(center[0], center[1], center[2])); // Use THREE.Vector3
        camera.updateProjectionMatrix();
    } else {
         console.warn("CameraController expects a PerspectiveCamera.");
         // Attempt basic adjustment anyway
         camera.position.set(center[0], center[1] + 10, center[2] + size * 2);
         camera.lookAt(new THREE.Vector3(center[0], center[1], center[2]));
    }
  }, [camera, center, size]);

  return null; // This component does not render anything itself
};

export default CameraController;

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/visualisation/components/HologramVisualisation.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/visualisation/components/HologramVisualisation.tsx
```tsx
import React, { useRef, useEffect } from 'react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls } from '@react-three/drei';
import { HologramManager } from '../renderers/HologramManager';
import { useSettingsStore } from '../../../store/settingsStore';

const HologramMeshMaterial: React.FC<{
  color?: string | number;
  emissiveColor?: string | number;
  emissiveIntensity?: number;
  transparent?: boolean;
  opacity?: number;
}> = ({
  color = '#00ffff',
  emissiveColor = '#00ffff',
  emissiveIntensity = 0.5,
  transparent = true,
  opacity = 0.7
}) => {
  const materialRef = useRef<any>(); // Using any type to avoid TypeScript errors

  useEffect(() => {
    if (materialRef.current) {
      const material = materialRef.current;
      // Set properties imperatively to avoid TypeScript errors
      material.color.set(color as any);
      material.emissive.set(emissiveColor as any);
      material.emissiveIntensity = emissiveIntensity;
      material.transparent = transparent;
      material.opacity = opacity;
    }
  }, [color, emissiveColor, emissiveIntensity, transparent, opacity]);

  // Using any type to avoid TypeScript errors with newer Three.js properties
  return <meshStandardMaterial ref={materialRef as any} {...{ toneMapped: false, wireframe: true } as any} />;
};

interface HologramVisualisationProps {
  position?: readonly [number, number, number];
  size?: number;
  standalone?: boolean;
  children?: React.ReactNode;
}

/**
 * HologramVisualisation - A component that renders a hologram visualisation
 * using the modern approach based on @react-three/fiber and @react-three/drei
 *
 * Can be used in two ways:
 * 1. As a standalone component with its own canvas (standalone=true)
 * 2. As a component inside an existing canvas (standalone=false)
 */
export const HologramVisualisation: React.FC<HologramVisualisationProps> = ({
  position = [0, 0, 0],
  size = 1,
  standalone = true,
  children
}) => {
  const settings = useSettingsStore(state => state.settings?.visualisation?.hologram);

  // Content that's rendered inside the hologram
  const HologramContent = () => (
    <group position={position} scale={[size, size, size]}> {/* Use array for scale, remove 'as any' */}
      {children || (
        <>
          {/* Default content if no children provided */}
          <HologramManager />

          {/* Optional additional content */}
          <mesh position={[0, 0, 0]}>
            <icosahedronGeometry args={[0.4, 1]} />
            <HologramMeshMaterial
              color={settings?.ringColor || '#00ffff'} // Use ringColor
              emissiveColor={settings?.ringColor || '#00ffff'} // Use ringColor
              emissiveIntensity={0.5}
              transparent={true}
              opacity={0.7}
            />
          </mesh>
        </>
      )}
    </group>
  );

  // For standalone use, provide a Canvas
  if (standalone) {
    return (
      <div className="w-full h-full" style={{ minHeight: '300px' }}>
        <Canvas
          camera={{ position: [0, 0, 5], fov: 50 }}
          gl={{ antialias: true, alpha: true }}
        >
          <ambientLight intensity={0.5} />
          <directionalLight position={[10, 10, 5]} intensity={1} />
          <HologramContent />
          <OrbitControls enableDamping dampingFactor={0.1} />
        </Canvas>
      </div>
    );
  }

  // For embedded use, just render the content
  return <HologramContent />;
};

/**
 * Hologram Overlay - Creates a floating hologram effect for UI elements
 * This component provides a hologram-styled container for regular React components
 */
export const HologramOverlay: React.FC<{
  children: React.ReactNode;
  className?: string;
  glowColor?: string;
}> = ({
  children,
  className = '',
  glowColor = '#00ffff'
}) => {
  return (
    <div
      className={`relative rounded-lg overflow-hidden ${className}`}
      style={{
        background: 'rgba(0, 10, 20, 0.7)',
        boxShadow: `0 0 15px ${glowColor}, inset 0 0 8px ${glowColor}`,
        border: `1px solid ${glowColor}`,
      }}
    >
      {/* Scanline effect */}
      <div
        className="absolute inset-0 pointer-events-none z-10"
        style={{
          background: 'linear-gradient(transparent 50%, rgba(0, 255, 255, 0.05) 50%)',
          backgroundSize: '100% 4px',
          animation: 'hologramScanline 1s linear infinite',
        }}
      />

      {/* Flickering effect */}
      <div
        className="absolute inset-0 pointer-events-none opacity-20 z-20"
        style={{
          animation: 'hologramFlicker 4s linear infinite',
        }}
      />

      {/* Content */}
      <div className="relative z-30 p-4 text-cyan-400">
        {children}
      </div>

      {/* CSS for animations */}
      <style>
        {`
          @keyframes hologramScanline {
            0% {
              transform: translateY(0%);
            }
            100% {
              transform: translateY(100%);
            }
          }

          @keyframes hologramFlicker {
            0% { opacity: 0.1; }
            5% { opacity: 0.2; }
            10% { opacity: 0.1; }
            15% { opacity: 0.3; }
            20% { opacity: 0.1; }
            25% { opacity: 0.2; }
            30% { opacity: 0.1; }
            35% { opacity: 0.15; }
            40% { opacity: 0.2; }
            45% { opacity: 0.15; }
            50% { opacity: 0.1; }
            55% { opacity: 0.2; }
            60% { opacity: 0.25; }
            65% { opacity: 0.15; }
            70% { opacity: 0.2; }
            75% { opacity: 0.1; }
            80% { opacity: 0.15; }
            85% { opacity: 0.1; }
            90% { opacity: 0.2; }
            95% { opacity: 0.15; }
            100% { opacity: 0.1; }
          }
        `}
      </style>
    </div>
  );
};

export const HologramExample: React.FC = () => {
  return (
    <div className="flex flex-col md:flex-row gap-6 p-6 min-h-screen bg-gray-900">
      {/* 3D Hologram */}
      <div className="flex-1 h-[500px] rounded-lg overflow-hidden">
        <HologramVisualisation standalone size={1.2} />
      </div>

      {/* UI Hologram */}
      <div className="flex-1 flex items-center justify-center">
        <HologramOverlay className="max-w-md">
          <h2 className="text-xl font-semibold mb-4">Hologram System Status</h2>
          <div className="space-y-3">
            <div className="flex justify-between">
              <span>Power Level:</span>
              <span>87%</span>
            </div>
            <div className="flex justify-between">
              <span>Signal Strength:</span>
              <span>Optimal</span>
            </div>
            <div className="flex justify-between">
              <span>Data Transmission:</span>
              <span>Active</span>
            </div>
            <div className="w-full h-2 bg-blue-900 mt-4 rounded-full overflow-hidden">
              <div
                className="h-full bg-cyan-400"
                style={{
                  width: '87%',
                  animation: 'hologramPulse 3s infinite'
                }}
              ></div>
            </div>
          </div>
        </HologramOverlay>
      </div>

      {/* Animation for progress bar */}
      <style>
        {`
          @keyframes hologramPulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
          }
        `}
      </style>
    </div>
  );
};

export default HologramVisualisation;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/visualisation/components/MetadataVisualizer.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/visualisation/components/MetadataVisualizer.tsx
```tsx
import React, { useRef, useEffect, useState, useMemo } from 'react';
import * as THREE from 'three'; // Use namespace import
import { useThree, useFrame } from '@react-three/fiber';
import { usePlatform } from '@/services/platformManager';
import { useSettingsStore } from '@/store/settingsStore';
import { createLogger } from '@/utils/logger';

const logger = createLogger('MetadataVisualizer');

function isVector3Instance(obj: any): obj is THREE.Vector3 {
  // Check if Vector3 constructor exists on THREE before using instanceof
  return typeof THREE.Vector3 === 'function' && obj instanceof THREE.Vector3;
}


export interface NodeMetadata {
  id: string;
  position: [number, number, number] | { x: number; y: number; z: number } | THREE.Vector3;
  label?: string;
  description?: string;
  fileSize?: number;
  type?: string;
  color?: string | number;
  icon?: string;
  priority?: number;
  [key: string]: any; // Allow additional properties
}

interface MetadataVisualizerProps {
  children?: React.ReactNode;
  renderLabels?: boolean;
  renderIcons?: boolean;
  renderMetrics?: boolean;
}

/**
 * MetadataVisualizer component using React Three Fiber
 * This is a modernized version of the original MetadataVisualizer class
 */
export const MetadataVisualizer: React.FC<MetadataVisualizerProps> = ({
  children,
  renderLabels = true,
  renderIcons = true,
  renderMetrics = false
}) => {
  const { scene, camera } = useThree();
  // Use THREE.Object3D as Group might not be resolving correctly
  const groupRef = useRef<THREE.Group>(null);
  const { isXRMode } = usePlatform();
  const labelSettings = useSettingsStore(state => state.settings?.visualisation?.labels);

  // Layer management for XR mode
  useEffect(() => {
    if (!groupRef.current) return;

    // Set layers based on XR mode
    const group = groupRef.current;
    if (isXRMode) {
      // In XR mode, use layer 1 to ensure labels are visible in XR
      group.traverse(obj => {
        obj.layers.set(1);
      });
    } else {
      // In desktop mode, use default layer
      group.traverse(obj => {
        obj.layers.set(0);
      });
    }
  }, [isXRMode]);

  // Render optimization - only update label positions at 30fps
  useFrame((state, delta) => {
    // Potential optimization logic here
  }, 2); // Lower priority than regular rendering

  return (
    // Use THREE.Group directly in JSX if needed, or keep as <group>
    <group ref={groupRef} name="metadata-container">
      {children}
      {/* {renderLabels && <LabelSystem />} */} {/* Commented out LabelSystem usage */}
      {renderIcons && <IconSystem />}
      {renderMetrics && <MetricsDisplay />}
    </group>
  );
};

const LabelSystem: React.FC = () => {
  const labelManagerRef = useTextLabelManager();
  const { labels } = labelManagerRef.current;
  const labelSettings = useSettingsStore(state => state.settings?.visualisation?.labels);

  // Don't render if labels are disabled
  // if (!labelSettings?.enabled) return null; // Commented out due to type error

  return (
    <group name="label-system">
      {labels.map(label => (
        <NodeLabel
          key={label.id}
          id={label.id}
          position={label.position}
          text={label.text}
          // color={labelSettings.color || '#ffffff'} // Commented out
          // size={labelSettings.size || 1} // Commented out
          // backgroundColor={labelSettings.backgroundColor} // Commented out
          // showDistance={labelSettings.showDistance} // Commented out
          // fadeDistance={labelSettings.fadeDistance} // Commented out
        />
      ))}
    </group>
  );
};

interface NodeLabelProps {
  id: string;
  position: [number, number, number] | { x: number; y: number; z: number } | THREE.Vector3;
  text: string;
  color?: string;
  size?: number;
  backgroundColor?: string;
  showDistance?: number;
  fadeDistance?: number;
}

const NodeLabel: React.FC<NodeLabelProps> = ({
  id,
  position,
  text,
  color = '#ffffff',
  size = 1,
  backgroundColor,
  showDistance = 0,
  fadeDistance = 0
}) => {
  // Skip rendering empty labels
  if (!text?.trim()) return null;

  const { camera } = useThree();
  const [opacity, setOpacity] = useState(1);

  // Convert position to tuple format with type guards
  const labelPos: [number, number, number] = useMemo(() => {
    if (isVector3Instance(position)) { // Use instanceof type guard
       // Explicit cast to help TS understand the type is narrowed
      const vec = position as THREE.Vector3;
      return [vec.x, vec.y, vec.z];
    } else if (Array.isArray(position)) {
      return position as [number, number, number]; // Assume it's a tuple if array
    } else if (typeof position === 'object' && position !== null && 'x' in position && 'y' in position && 'z' in position) {
      const posObj = position as { x: number; y: number; z: number };
      return [posObj.x, posObj.y, posObj.z];
    }
    logger.warn(`Invalid position format for label ${id}:`, position);
    return [0, 0, 0]; // Default position if format is unknown
  }, [position]);

  // Handle distance-based opacity
  useFrame(() => {
    if (!fadeDistance) return;

    // Calculate distance using tuple positions
    const dx = camera.position.x - labelPos[0];
    const dy = camera.position.y - labelPos[1];
    const dz = camera.position.z - labelPos[2];
    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

    if (distance > fadeDistance) {
      setOpacity(0);
    } else if (distance > showDistance) {
      // Linear fade from showDistance to fadeDistance
      const fadeRatio = 1 - ((distance - showDistance) / (fadeDistance - showDistance));
      setOpacity(Math.max(0, Math.min(1, fadeRatio)));
    } else {
      setOpacity(1);
    }
  });

  // Don't render if fully transparent
  if (opacity <= 0) return null;

  // Commenting out Billboard and Text usage due to import errors
  return null;
  /*
  return (
    <Billboard
      position={labelPos}
      follow={true}
      lockX={false}
      lockY={false}
      lockZ={false}
    >
      <Text
        fontSize={size}
        color={color}
        anchorX="center"
        anchorY="middle"
        outlineWidth={0.02}
        outlineColor="#000000"
        outlineOpacity={0.8}
        overflowWrap="normal"
        maxWidth={10}
        textAlign="center"
        renderOrder={10} // Ensure text renders on top of other objects
        material-depthTest={false} // Make sure text is always visible
        material-transparent={true}
        material-opacity={opacity}
      >
        {text}
        {backgroundColor && (
          <meshBasicMaterial
            // color={backgroundColor} // Commented out due to type error
            opacity={opacity * 0.7}
            transparent={true}
            side={THREE.DoubleSide} // Use THREE namespace
          />
        )}
      </Text>
    </Billboard>
  );
  */
};

const IconSystem: React.FC = () => {
  // Implement if needed
  return null;
};

const MetricsDisplay: React.FC = () => {
  // Implement if needed
  return null;
};

export function useTextLabelManager() {
  const labelManagerRef = useRef<{
    labels: Array<{
      id: string;
      text: string;
      position: [number, number, number];
    }>;
    updateLabel: (id: string, text: string, position: [number, number, number] | { x: number; y: number; z: number } | THREE.Vector3) => void;
    removeLabel: (id: string) => void;
    clearLabels: () => void;
  }>({
    labels: [],
    updateLabel: (id, text, position) => {
      const labels = labelManagerRef.current.labels;

      // Convert position to tuple format with type guards
      let pos: [number, number, number];
      if (isVector3Instance(position)) { // Use instanceof type guard
         // Explicit cast to help TS understand the type is narrowed
        const vec = position as THREE.Vector3;
        pos = [vec.x, vec.y, vec.z];
      } else if (Array.isArray(position)) {
        pos = position as [number, number, number];
      } else if (typeof position === 'object' && position !== null && 'x' in position && 'y' in position && 'z' in position) {
        const posObj = position as { x: number; y: number; z: number };
        pos = [posObj.x, posObj.y, posObj.z];
      } else {
        logger.warn(`Invalid position format for updateLabel ${id}:`, position);
        pos = [0, 0, 0]; // Default or handle error
      }

      const existingLabelIndex = labels.findIndex(label => label.id === id);

      if (existingLabelIndex >= 0) {
        // Update existing label
        labels[existingLabelIndex] = {
          ...labels[existingLabelIndex],
          text: text || labels[existingLabelIndex].text,
          position: pos
        };
      } else {
        // Add new label
        labels.push({ id, text, position: pos });
      }

      // Force update by creating a new array
      labelManagerRef.current.labels = [...labels];
    },
    removeLabel: (id) => {
      labelManagerRef.current.labels = labelManagerRef.current.labels.filter(
        label => label.id !== id
      );
    },
    clearLabels: () => {
      labelManagerRef.current.labels = [];
    }
  });

  return labelManagerRef;
}

export const createSDFFont = async (fontUrl: string, fontSize: number = 64) => {
  // This would be an implementation of SDF font generation
  // For now, we use drei's Text component which provides high-quality text
  return null;
};

export class MetadataVisualizerManager {
  private static instance: MetadataVisualizerManager;
  private labels: Map<string, { text: string; position: [number, number, number] }> = new Map();
  private updateCallback: (() => void) | null = null;

  private constructor() {}

  public static getInstance(): MetadataVisualizerManager {
    if (!MetadataVisualizerManager.instance) {
      MetadataVisualizerManager.instance = new MetadataVisualizerManager();
    }
    return MetadataVisualizerManager.instance;
  }

  public setUpdateCallback(callback: () => void): void {
    this.updateCallback = callback;
  }

  public updateNodeLabel(
    nodeId: string,
    text: string,
    position: [number, number, number] | { x: number; y: number; z: number } | THREE.Vector3
  ): void {
    try {
      // Convert position to tuple format with type guards
      let pos: [number, number, number];
      if (isVector3Instance(position)) { // Use instanceof type guard
         // Explicit cast to help TS understand the type is narrowed
        const vec = position as THREE.Vector3;
        pos = [vec.x, vec.y, vec.z];
      } else if (Array.isArray(position)) {
        pos = position as [number, number, number];
      } else if (typeof position === 'object' && position !== null && 'x' in position && 'y' in position && 'z' in position) {
        const posObj = position as { x: number; y: number; z: number };
        pos = [posObj.x, posObj.y, posObj.z];
      } else {
         logger.warn(`Invalid position format for updateNodeLabel ${nodeId}:`, position);
         pos = [0,0,0]; // Default or handle error
      }

      this.labels.set(nodeId, { text, position: pos });

      if (this.updateCallback) {
        this.updateCallback();
      }
    } catch (error) {
      logger.error('Error updating node label:', error);
    }
  }

  public clearLabel(nodeId: string): void {
    this.labels.delete(nodeId);

    if (this.updateCallback) {
      this.updateCallback();
    }
  }

  public clearAllLabels(): void {
    this.labels.clear();

    if (this.updateCallback) {
      this.updateCallback();
    }
  }

  public getAllLabels(): Array<{ id: string; text: string; position: [number, number, number] }> {
    return Array.from(this.labels.entries()).map(([id, label]) => ({
      id,
      text: label.text,
      position: label.position
    }));
  }

  public dispose(): void {
    this.labels.clear();
    this.updateCallback = null;

    // Reset singleton instance
    MetadataVisualizerManager.instance = null as any;
  }
}

export const metadataVisualizer = MetadataVisualizerManager.getInstance();

export default MetadataVisualizer;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/visualisation/managers/sceneManager.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/visualisation/managers/sceneManager.ts
```ts
import { createLogger, createErrorMetadata } from '@/utils/logger';
import { debugState } from '@/utils/debugState';
import * as THREE from 'three';
import { XRSettings } from '@/features/xr/types/xr';

const logger = createLogger('SceneManager');

/**
 * IMPORTANT: This is a stub implementation of SceneManager
 * The application has been migrated to use React Three Fiber
 * This stub exists only to satisfy imports and prevent runtime errors
 */

export class SceneManager {
  private static instance: SceneManager;
  private scene: any = {};
  private camera: THREE.PerspectiveCamera | null = null;
  private renderer: THREE.WebGLRenderer | null = null;
  private running: boolean = false;
  private renderCallbacks: any[] = [];
  private resizeCallbacks: any[] = [];
  private disposeCallbacks: any[] = [];

  private constructor() {
    logger.info('Using React Three Fiber for rendering - SceneManager is in compatibility mode');

    // Create minimal THREE.js objects to prevent errors
    try {
      this.scene = new THREE.Scene();
      // Create perspective camera specifically since XR systems need it
      this.camera = new THREE.PerspectiveCamera(
        75, // FOV
        window.innerWidth / window.innerHeight, // Aspect ratio
        0.1, // Near plane
        1000 // Far plane
      );
      this.camera.position.z = 5;
    } catch (error) {
      logger.error('Error creating THREE.js objects:', createErrorMetadata(error));
      // Fall back to mock objects if THREE.js fails to initialize
    }
  }

  public static getInstance(canvas?: HTMLCanvasElement): SceneManager {
    if (!SceneManager.instance) {
      SceneManager.instance = new SceneManager();
    }
    return SceneManager.instance;
  }

  public static cleanup(): void {
    if (SceneManager.instance) {
      logger.info('SceneManager cleanup called');
    }
  }

  // Stub methods that do nothing
  private initRenderer(canvas: HTMLCanvasElement): void {
    // Only try to initialize if we don't already have a renderer
    if (this.renderer) return;

    try {
      logger.info('Attempting to create WebGLRenderer (compatibility mode)');

      // Verify that the canvas is valid
      if (!canvas || !canvas.getContext) {
        throw new Error('Invalid canvas element or getContext is not a function');
      }

      // Try to create a renderer with minimal settings
      this.renderer = new THREE.WebGLRenderer({
        canvas,
        alpha: true,
        antialias: true,
        powerPreference: 'default'
      });

      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.renderer.setPixelRatio(window.devicePixelRatio);

    } catch (error) {
      logger.error('Failed to initialize renderer:', createErrorMetadata(error));

      // Create a mock renderer to prevent further errors
      this.renderer = {
        domElement: canvas,
        setSize: () => {},
        render: () => {},
        dispose: () => {}
      } as unknown as THREE.WebGLRenderer;
    }
  }

  private setupResizeHandler(): void {}
  public handleSettingsUpdate(settings: XRSettings): void {
    if (debugState.isEnabled()) {
      logger.info('SceneManager.start() called but using React Three Fiber instead');
    }
  }

  public stop(): void {}
  private render = (): void => {};
  public addRenderCallback(callback: () => void): () => void {
    return () => {};
  }
  public addResizeCallback(callback: () => void): () => void {
    // Store callback in array but don't actually use it
    this.resizeCallbacks.push(callback);
    // Return remove function
    return () => {
      const index = this.resizeCallbacks.indexOf(callback);
      if (index !== -1) {
        this.resizeCallbacks.splice(index, 1);
      }
    };
  }

  public start(): void {
    logger.info('SceneManager.start() called (compatibility mode - no action taken)');
    this.running = true;
  }

  public dispose(): void {
    logger.info('SceneManager.dispose() called (compatibility mode)');
    this.running = false;
  }

  // Getters
  public getScene(): any {
    return this.scene;
  }
  public getCamera = (): THREE.PerspectiveCamera | null => this.camera;
  public getRenderer = (): THREE.WebGLRenderer | null => this.renderer;
  public isRunning(): boolean {
    return this.running;
  }
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/visualisation/renderers/HologramManager.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/visualisation/renderers/HologramManager.tsx
```tsx
import React, { useRef, useEffect, useState } from 'react';
import * as THREE from 'three';
import { useFrame } from '@react-three/fiber';
import { useSettingsStore } from '@/store/settingsStore';
import { createLogger } from '@/utils/logger';
import { HologramMaterial } from './materials/HologramMaterial';

const logger = createLogger('HologramManager');

export const HologramRing: React.FC<{
  size?: number;
  color?: string | THREE.Color | number;
  opacity?: number;
  rotationAxis?: readonly [number, number, number];
  rotationSpeed?: number;
  segments?: number;
}> = ({
  size = 1,
  color = '#00ffff',
  opacity = 0.7,
  rotationAxis = [0, 1, 0],
  rotationSpeed = 0.5,
  segments = 64
}) => {
  // Use state for rotation instead of imperatively updating refs
  const [rotation, setRotation] = useState<[number, number, number]>([0, 0, 0]);

  // Animate ring rotation
  useFrame((_, delta) => {
    if (rotationSpeed > 0) {
      setRotation(prev => [
        prev[0] + delta * rotationSpeed * rotationAxis[0],
        prev[1] + delta * rotationSpeed * rotationAxis[1],
        prev[2] + delta * rotationSpeed * rotationAxis[2]
      ]);
    }
  });

  return (
    <mesh rotation={rotation}>
      <ringGeometry args={[size * 0.8, size, segments]} />
      <meshBasicMaterial color={color} transparent={true} opacity={opacity} wireframe={true} />
    </mesh>
  );
};

export const HologramSphere: React.FC<{
  size?: number;
  color?: string | THREE.Color | number;
  opacity?: number;
  detail?: number;
  wireframe?: boolean;
  rotationSpeed?: number;
}> = ({
  size = 1,
  color = '#00ffff',
  opacity = 0.5,
  detail = 1,
  wireframe = true, // Always true for wireframe effect
  rotationSpeed = 0.2
}) => {
  // Use state for rotation instead of imperatively updating refs
  const [rotationY, setRotationY] = useState(0);

  // Animate sphere rotation
  useFrame((_, delta) => {
    if (rotationSpeed > 0) {
      setRotationY(prev => prev + delta * rotationSpeed);
    }
  });

  return (
    <mesh rotation={[0, rotationY, 0]}>
      <icosahedronGeometry args={[size, detail]} />
      <meshBasicMaterial
        color={color}
        transparent={true}
        opacity={opacity}
        wireframe={true}
        toneMapped={false}
      />
    </mesh>
  );
};

export const HologramManager: React.FC<{
  position?: readonly [number, number, number];
  isXRMode?: boolean;
}> = ({
  position = [0, 0, 0],
  isXRMode = false
}) => {
  const settings = useSettingsStore(state => state.settings?.visualisation?.hologram);
  const groupRef = useRef<THREE.Group>(null);

  // Parse sphere sizes from settings
  const sphereSizes: number[] = React.useMemo(() => {
    const sizesSetting: unknown = settings?.sphereSizes; // Start with unknown

    if (typeof sizesSetting === 'string') {
      // Explicitly cast after check
      const strSetting = sizesSetting as string;
      return strSetting.split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n));
    } else if (Array.isArray(sizesSetting)) {
      // Filter for numbers within the array
      const arrSetting = sizesSetting as unknown[]; // Cast to unknown array first
      return arrSetting.filter((n): n is number => typeof n === 'number' && !isNaN(n));
    }
    // Default value if setting is missing or invalid
    return [40, 80];
  }, [settings?.sphereSizes]);

  // Set layers for bloom effect
  useEffect(() => {
    const group = groupRef.current;
    if (group) {
      // Use type assertion to get around TypeScript issues
      (group as any).layers.set(0); // Default layer
      (group as any).layers.enable(1); // Bloom layer

      // Apply to all children
      (group as any).traverse((child: any) => {
        if (child.layers) {
          child.layers.set(0);
          child.layers.enable(1);
        }
      });
    }
  }, []);

  const quality = isXRMode ? 'high' : 'medium';
  const color: string | number = settings?.ringColor || '#00ffff'; // Use ringColor instead of color
  const opacity = settings?.ringOpacity !== undefined ? settings.ringOpacity : 0.7;
  const rotationSpeed = settings?.ringRotationSpeed !== undefined ? settings.ringRotationSpeed : 0.5;
  const enableTriangleSphere = settings?.enableTriangleSphere !== false;
  const triangleSphereSize = settings?.triangleSphereSize || 60;
  const triangleSphereOpacity = settings?.triangleSphereOpacity || 0.3;

  return (
    <group ref={groupRef} position={position as any}>
      {/* Render rings based on settings */}
      {sphereSizes.map((size, index) => (
        <HologramRing
          key={`ring-${index}`}
          size={size / 100} // Convert to meters
          color={color}
          opacity={opacity}
          rotationAxis={[
            Math.cos(index * Math.PI / 3),
            Math.sin(index * Math.PI / 3),
            0.5
          ]}
          rotationSpeed={rotationSpeed * (0.8 + index * 0.2)}
          segments={quality === 'high' ? 64 : 32}
        />
      ))}

      {/* Render triangle sphere if enabled */}
      {enableTriangleSphere && (
        <HologramSphere
          size={triangleSphereSize / 100} // Convert to meters
          color={color}
          opacity={triangleSphereOpacity}
          detail={quality === 'high' ? 2 : 1}
          wireframe={true}
        />
      )}
    </group>
  );
};

export const Hologram: React.FC<{
  position?: readonly [number, number, number];
  color?: string | THREE.Color | number;
  size?: number;
  children?: React.ReactNode;
}> = ({
  position = [0, 0, 0],
  color = '#00ffff',
  size = 1,
  children
}) => {
  return (
    <group position={position as any} scale={size}>
      {children}
      <HologramManager />
    </group>
  );
};

export class HologramManagerClass {
  private scene: any; // THREE.Scene
  private group: any; // THREE.Group
  private ringInstances: any[] = []; // THREE.Mesh[]
  private sphereInstances: any[] = []; // THREE.Mesh[]
  private isXRMode: boolean = false;
  private settings: any;

  constructor(scene: any, settings: any) {
    this.scene = scene;
    this.settings = settings;
    this.group = new THREE.Group();

    // Enable bloom layer
    this.group.layers.set(0);
    this.group.layers.enable(1);

    this.createHolograms();
    this.scene.add(this.group);
  }

  private createHolograms() {
    // Clear existing holograms
    const group = this.group;
    while (group.children.length > 0) {
      const child = group.children[0];
      group.remove(child);

      // Handle geometry and material disposal
      if (child.geometry) child.geometry.dispose();
      if (child.material) {
        if (Array.isArray(child.material)) {
          child.material.forEach((m: any) => m && m.dispose());
        } else {
          child.material.dispose();
        }
      }
    }

    this.ringInstances = [];
    this.sphereInstances = [];

    // Quality based on XR mode
    const quality = this.isXRMode ? 'high' : 'medium';
    const segments = quality === 'high' ? 64 : 32;

    // Extract settings
    const hologramSettings = this.settings?.visualisation?.hologram || {};
    const color = hologramSettings.color || 0x00ffff;
    const opacity = hologramSettings.ringOpacity !== undefined ? hologramSettings.ringOpacity : 0.7;
    const sphereSizes = Array.isArray(hologramSettings.sphereSizes)
      ? hologramSettings.sphereSizes
      : [40, 80];

    // Create ring instances using type assertions for THREE classes
    sphereSizes.forEach((size, index) => {
      // Use any type to bypass TypeScript checks
      const geometry = new (THREE as any).RingGeometry(size * 0.8 / 100, size / 100, segments);
      const material = new (THREE as any).MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: opacity,
        side: (THREE as any).DoubleSide,
        depthWrite: false
      });

      const ring = new (THREE as any).Mesh(geometry, material);

      // Set random rotation
      ring.rotation.x = Math.PI / 3 * index;
      ring.rotation.y = Math.PI / 6 * index;

      // Enable bloom layer
      ring.layers.set(0);
      ring.layers.enable(1);

      this.ringInstances.push(ring);
      group.add(ring);
    });

    // Create triangle sphere if enabled
    if (hologramSettings.enableTriangleSphere) {
      const size = hologramSettings.triangleSphereSize || 60;
      const sphereOpacity = hologramSettings.triangleSphereOpacity || 0.3;
      const detail = quality === 'high' ? 2 : 1;

      // Use any type to bypass TypeScript checks
      const geometry = new (THREE as any).IcosahedronGeometry(size / 100, detail);
      const material = new (THREE as any).MeshBasicMaterial({
        color: color,
        wireframe: true,
        transparent: true,
        opacity: sphereOpacity,
        side: (THREE as any).DoubleSide,
        depthWrite: false
      });

      const sphere = new (THREE as any).Mesh(geometry, material);

      // Enable bloom layer
      sphere.layers.set(0);
      sphere.layers.enable(1);

      this.sphereInstances.push(sphere);
      group.add(sphere);
    }
  }

  setXRMode(enabled: boolean) {
    this.isXRMode = enabled;
    this.createHolograms();
  }

  update(deltaTime: number) {
    // Get rotation speed from settings
    const rotationSpeed = this.settings?.visualisation?.hologram?.ringRotationSpeed || 0.5;

    // Update ring rotations
    this.ringInstances.forEach((ring: any, index: number) => {
      // Each ring rotates at a different speed
      const speed = rotationSpeed * (1.0 + index * 0.2);
      ring.rotation.y += deltaTime * speed;
    });

    // Update sphere rotations
    this.sphereInstances.forEach((sphere: any) => {
      sphere.rotation.y += deltaTime * rotationSpeed * 0.5;
    });
  }

  updateSettings(newSettings: any) {
    this.settings = newSettings;
    this.createHolograms();
  }

  getGroup() {
    return this.group;
  }

  dispose() {
    this.scene.remove(this.group);

    // Dispose geometries and materials
    this.ringInstances.forEach((ring: any) => {
      if (ring.geometry) ring.geometry.dispose();
      if (ring.material) {
        if (Array.isArray(ring.material)) {
          ring.material.forEach((m: any) => m && m.dispose());
        } else {
          ring.material.dispose();
        }
      }
    });

    this.sphereInstances.forEach((sphere: any) => {
      if (sphere.geometry) sphere.geometry.dispose();
      if (sphere.material) {
        if (Array.isArray(sphere.material)) {
          sphere.material.forEach((m: any) => m && m.dispose());
        } else {
          sphere.material.dispose();
        }
      }
    });

    this.ringInstances = [];
    this.sphereInstances = [];
  }
}

export default HologramManager;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/visualisation/renderers/TextRenderer.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/visualisation/renderers/TextRenderer.tsx
```tsx
import React, { useRef, useEffect, useState, useMemo } from 'react';
import { useThree } from '@react-three/fiber';
import { Text, Billboard } from '@react-three/drei';
import { Vector3, Group, DoubleSide } from 'three';
import { useSettingsStore } from '@/store/settingsStore';
import { createLogger, createErrorMetadata } from '@/utils/logger';

interface LabelSettings {
  enabled?: boolean; // Made optional to align with store type
  desktopFontSize: number;
  textColor: string;
  textOutlineColor?: string;
  textOutlineWidth?: number;
  textPadding?: number;
  textResolution?: number;
  billboardMode?: string;
  // Properties used by Label component's logic, not directly from store's main label config
  showDistance?: number;
  fadeDistance?: number;
  backgroundColor?: string;
}

const logger = createLogger('TextRenderer');

export interface LabelData {
  id: string;
  text: string;
  position: Vector3;
}

interface TextRendererProps {
  labels?: LabelData[];
}

export const TextRenderer: React.FC<TextRendererProps> = ({ labels = [] }) => {
  const { camera } = useThree();
  const groupRef = useRef<Group>(null);
  const settings = useSettingsStore(state => state.settings?.visualisation?.labels as LabelSettings | undefined);

  if (!settings || !settings.enabled) {
    return null;
  }

  return (
    <group ref={groupRef}>
      {labels.map((label) => (
        <Label
          key={label.id}
          text={label.text}
          position={label.position}
          settings={settings} // Pass the settings object from the store
        />
      ))}
    </group>
  );
};

interface LabelProps {
  text: string;
  position: Vector3;
  settings: LabelSettings; // This prop will receive the object from the store
}

const Label: React.FC<LabelProps> = ({ text, position, settings }) => {
  // Skip rendering empty labels
  if (!text.trim()) return null;

  const textColor = settings.textColor; // Use textColor from settings
  const fontSize = settings.desktopFontSize; // Use desktopFontSize from settings
  const showDistance = settings.showDistance || 0;
  const fadeDistance = settings.fadeDistance || 0;
  const backgroundColor = settings.backgroundColor;

  // Calculate distance to camera to handle fade effect
  const { camera } = useThree();
  const [opacity, setOpacity] = useState(1);

  useEffect(() => {
    if (!fadeDistance) return;

    const updateOpacity = () => {
      const distance = camera.position.distanceTo(position);

      if (distance > fadeDistance) {
        setOpacity(0);
      } else if (distance > showDistance) {
        // Linear fade from showDistance to fadeDistance
        const fadeRatio = 1 - ((distance - showDistance) / (fadeDistance - showDistance));
        setOpacity(Math.max(0, Math.min(1, fadeRatio)));
      } else {
        setOpacity(1);
      }
    };

    updateOpacity();

    // Add event listener for camera movements
    window.addEventListener('camerachange', updateOpacity);
    return () => {
      window.removeEventListener('camerachange', updateOpacity);
    };
  }, [camera, position, showDistance, fadeDistance]);

  // Don't render if fully transparent
  if (opacity <= 0) return null;

  return (
    <Billboard
      position={position}
      follow={true}
      lockX={false}
      lockY={false}
      lockZ={false}
    >
      <Text
        fontSize={fontSize}
        color={textColor}
        anchorX="center"
        anchorY="middle"
        outlineWidth={0.02}
        outlineColor="#000000"
        outlineOpacity={0.8}
        overflowWrap="normal"
        maxWidth={10}
        textAlign="center"
        renderOrder={10} // Ensure text renders on top of other objects
        material-depthTest={false} // Make sure text is always visible
        material-transparent={true}
        material-opacity={opacity}
      >
        {text}
        {backgroundColor && (
          <meshBasicMaterial
            color={backgroundColor}
            opacity={opacity * 0.7}
            transparent={true}
            side={DoubleSide}
          />
        )}
      </Text>
    </Billboard>
  );
};

export class TextRendererManager {
  private static instance: TextRendererManager;
  private labels: Map<string, LabelData> = new Map();
  private updateCallback: (() => void) | null = null;

  private constructor() {
    // Private constructor for singleton
  }

  public static getInstance(): TextRendererManager {
    if (!TextRendererManager.instance) {
      TextRendererManager.instance = new TextRendererManager();
    }
    return TextRendererManager.instance;
  }

  public setUpdateCallback(callback: () => void): void {
    this.updateCallback = callback;
  }

  public updateLabel(id: string, text: string, position: Vector3, preserveText: boolean = false): void {
    try {
      const existingLabel = this.labels.get(id);

      // Skip processing if text is empty but preserveText is true and we already have a label
      if (text.trim() === '' && preserveText && existingLabel) {
        existingLabel.position.copy(position);
        this.triggerUpdate();
        return;
      }

      if (!existingLabel) {
        this.labels.set(id, {
          id,
          text: text || '',
          position: position.clone()
        });
      } else {
        // Only update text if non-empty text is provided
        if (text.trim() !== '') {
          existingLabel.text = text;
        }
        // Always update position
        existingLabel.position.copy(position);
      }

      this.triggerUpdate();
    } catch (error) {
      logger.error('Error updating label:', createErrorMetadata(error));
    }
  }

  public removeLabel(id: string): void {
    try {
      this.labels.delete(id);
      this.triggerUpdate();
    } catch (error) {
      logger.error('Error removing label:', createErrorMetadata(error));
    }
  }

  public getAllLabels(): LabelData[] {
    return Array.from(this.labels.values());
  }

  public clearLabels(): void {
    this.labels.clear();
    this.triggerUpdate();
  }

  private triggerUpdate(): void {
    if (this.updateCallback) {
      this.updateCallback();
    }
  }
}

export const useTextRenderer = () => {
  const textRendererManager = useMemo(() => TextRendererManager.getInstance(), []);
  const [labels, setLabels] = useState<LabelData[]>([]);

  useEffect(() => {
    textRendererManager.setUpdateCallback(() => {
      setLabels([...textRendererManager.getAllLabels()]);
    });

    return () => {
      textRendererManager.setUpdateCallback(null);
    };
  }, [textRendererManager]);

  return {
    labels,
    updateLabel: textRendererManager.updateLabel.bind(textRendererManager),
    removeLabel: textRendererManager.removeLabel.bind(textRendererManager),
    clearLabels: textRendererManager.clearLabels.bind(textRendererManager)
  };
};

export default TextRenderer;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/visualisation/renderers/materials/HologramMaterial.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/visualisation/renderers/materials/HologramMaterial.tsx
```tsx
import React, { useRef, useEffect, useState } from 'react';
import * as THREE from 'three';
import { useFrame } from '@react-three/fiber';

/**
 * HologramMaterial - A simplified implementation of hologram effects
 * with better compatibility with the latest Three.js and R3F versions
 *
 * Note: Using ts-nocheck due to type compatibility issues between Three.js versions.
 * This component works correctly at runtime despite TypeScript errors.
 */
interface HologramMaterialProps {
  color?: string | number | THREE.Color;
  opacity?: number;
  pulseIntensity?: number;
  edgeOnly?: boolean;
  wireframe?: boolean;
  context?: 'desktop' | 'ar';
  onUpdate?: (material: any) => void;
}

export const HologramMaterial: React.FC<HologramMaterialProps> = ({
  color = '#00ffff',
  opacity = 0.7,
  pulseIntensity = 0.2,
  edgeOnly = false,
  wireframe = false,
  context = 'desktop',
  onUpdate
}) => {
  // Create separate refs for different material types
  const materialRef = useRef<any>(null);
  const [currentTime, setCurrentTime] = useState(0);

  // Update material each frame with animation effects
  useFrame((_, delta) => {
    setCurrentTime(prev => prev + delta);

    // Apply pulse effect
    const pulse = Math.sin(currentTime * 2.0) * 0.5 + 0.5;
    const pulseEffect = pulse * pulseIntensity;

    // Update material if it exists
    if (materialRef.current) {
      const mat = materialRef.current;

      // Update opacity with pulse
      if (mat.opacity !== undefined) {
        mat.opacity = opacity * (1.0 + pulseEffect * 0.3);
      }

      // Update color with pulse
      if (mat.color !== undefined) {
        const brightenFactor = edgeOnly
          ? 0.5 + pulseEffect * 0.5
          : 0.8 + pulseEffect * 0.3;

        // Create pulsing color effect
        mat.color.setStyle(typeof color === 'string' ? color : '#00ffff');
        mat.color.r *= brightenFactor;
        mat.color.g *= brightenFactor;
        mat.color.b *= brightenFactor;
      }

      // Force material update
      mat.needsUpdate = true;

      // Notify parent about updates
      if (onUpdate) {
        onUpdate(mat);
      }
    }
  });

  if (edgeOnly || wireframe) {
    // For edge-only mode, use a simple material with wireframe
    return (
      <meshBasicMaterial
        ref={materialRef}
        wireframe={true}
        transparent={true}
        opacity={opacity}
        side={context === 'ar' ? THREE.FrontSide : THREE.DoubleSide}
        depthWrite={false}
      >
        <color attach="color" args={[typeof color === 'string' ? color : '#00ffff']} />
      </meshBasicMaterial>
    );
  }

  // For full hologram mode, use standard material with custom properties
  return (
    <meshPhysicalMaterial
      ref={materialRef}
      transparent={true}
      opacity={opacity}
      metalness={0.2}
      roughness={0.2}
      transmission={0.9}
      ior={1.5}
      side={context === 'ar' ? THREE.FrontSide : THREE.DoubleSide}
      depthWrite={false}
    >
      <color attach="color" args={[typeof color === 'string' ? color : '#00ffff']} />
    </meshPhysicalMaterial>
  );
};

/**
 * Class-based wrapper for non-React usage
 * Simplified for better compatibility
 */
export class HologramMaterialClass {
  public material: any;
  private baseOpacity: number;
  private baseColor: string;
  private pulseIntensity: number;
  private currentTime: number = 0;
  private isEdgeOnlyMode: boolean;
  private updateCallback: (() => void) | null = null;

  // Provide compatible uniforms structure for backward compatibility
  public uniforms: {
    time: { value: number };
    opacity: { value: number };
    color: { value: any };
    pulseIntensity: { value: number };
    interactionPoint: { value: any };
    interactionStrength: { value: number };
    isEdgeOnly: { value: boolean };
  };

  constructor(settings?: any, context: 'ar' | 'desktop' = 'desktop') {
    // Extract settings
    const isAR = context === 'ar';
    const opacity = settings?.visualisation?.hologram?.opacity ?? 0.7;
    const colorValue = settings?.visualisation?.hologram?.color ?? '#00ffff';
    const colorObj = new THREE.Color().setStyle(typeof colorValue === 'string' ? colorValue : '#00ffff');
    const pulseIntensity = isAR ? 0.1 : 0.2;
    const edgeOnly = false;

    this.baseOpacity = opacity;
    this.baseColor = typeof colorValue === 'string' ? colorValue : '#00ffff';
    this.pulseIntensity = pulseIntensity;
    this.isEdgeOnlyMode = edgeOnly;

    // Create appropriate material
    if (edgeOnly) {
      this.material = new THREE.MeshBasicMaterial();
      this.material.color.setStyle(this.baseColor);
      this.material.wireframe = true;
      this.material.transparent = true;
      this.material.opacity = opacity;
      this.material.side = isAR ? THREE.FrontSide : THREE.DoubleSide;
      this.material.depthWrite = false;
    } else {
      // Use MeshPhysicalMaterial
      this.material = new THREE.MeshPhysicalMaterial();
      this.material.color.setStyle(this.baseColor);
      this.material.metalness = 0.1;
      this.material.roughness = 0.2;
      this.material.transmission = 0.95;
      this.material.transparent = true;
      this.material.opacity = opacity;
      this.material.side = isAR ? THREE.FrontSide : THREE.DoubleSide;
      this.material.depthWrite = false;
      this.material.ior = 1.5;
    }

    // Initialize uniforms for API compatibility
    this.uniforms = {
      time: { value: 0 },
      opacity: { value: opacity },
      color: { value: colorObj },
      pulseIntensity: { value: pulseIntensity },
      interactionPoint: { value: new THREE.Vector3() },
      interactionStrength: { value: 0.0 },
      isEdgeOnly: { value: edgeOnly }
    };
  }

  public update(deltaTime: number): void {
    // Update time
    this.currentTime += deltaTime;
    this.uniforms.time.value = this.currentTime;

    // Apply pulse effect
    const pulse = Math.sin(this.currentTime * 2.0) * 0.5 + 0.5;
    const pulseEffect = pulse * this.pulseIntensity;

    // Update material properties
    if (this.material) {
      // Update opacity
      if (this.material.opacity !== undefined) {
        this.material.opacity = this.baseOpacity * (1.0 + pulseEffect * 0.3);
      }

      // Update color
      if (this.material.color !== undefined) {
        const brightenFactor = this.isEdgeOnlyMode
          ? 0.5 + pulseEffect * 0.5
          : 0.8 + pulseEffect * 0.3;

        // Create pulsing color effect
        const color = new THREE.Color().setStyle(this.baseColor);
        color.r *= brightenFactor;
        color.g *= brightenFactor;
        color.b *= brightenFactor;
        this.material.color.copy(color);
      }

      // Force material update
      this.material.needsUpdate = true;
    }

    // Handle interaction effect
    if (this.uniforms.interactionStrength.value > 0.01) {
      this.uniforms.interactionStrength.value *= 0.95; // Decay interaction effect
    }

    // Trigger update callback if exists
    if (this.updateCallback) {
      this.updateCallback();
    }
  }

  public handleInteraction(position: THREE.Vector3): void {
    this.uniforms.interactionPoint.value.copy(position);
    this.uniforms.interactionStrength.value = 1.0;
  }

  public setEdgeOnly(enabled: boolean): void {
    // Store the state
    this.isEdgeOnlyMode = enabled;
    this.uniforms.isEdgeOnly.value = enabled;

    // Create a new material based on mode
    const oldMaterial = this.material;

    if (enabled) {
      // Switch to wireframe material
      const newMaterial = new THREE.MeshBasicMaterial();
      newMaterial.color.setStyle(this.baseColor);
      newMaterial.wireframe = true;
      newMaterial.transparent = true;
      newMaterial.opacity = this.baseOpacity * 0.8;
      newMaterial.side = oldMaterial.side;
      newMaterial.depthWrite = false;

      // Replace material
      if (oldMaterial && oldMaterial.dispose) {
        oldMaterial.dispose();
      }
      this.material = newMaterial;
      this.pulseIntensity = 0.15;

    } else {
      // Switch to physical material
      const newMaterial = new THREE.MeshPhysicalMaterial();
      newMaterial.color.setStyle(this.baseColor);
      newMaterial.metalness = 0.1;
      newMaterial.roughness = 0.2;
      newMaterial.transmission = 0.95;
      newMaterial.transparent = true;
      newMaterial.opacity = this.baseOpacity;
      newMaterial.side = oldMaterial.side;
      newMaterial.depthWrite = false;
      newMaterial.ior = 1.5;

      // Replace material
      if (oldMaterial && oldMaterial.dispose) {
        oldMaterial.dispose();
      }
      this.material = newMaterial;
      this.pulseIntensity = 0.1;
    }

    // Update uniform for API compatibility
    this.uniforms.pulseIntensity.value = this.pulseIntensity;
  }

  public getMaterial(): any {
    return this.material;
  }

  public setUpdateCallback(callback: () => void): void {
    this.updateCallback = callback;
  }

  public clone(): HologramMaterialClass {
    // Create settings object from current state
    const settings = {
      visualisation: {
        hologram: {
          opacity: this.baseOpacity,
          color: this.baseColor
        }
      }
    };

    // Create new instance
    const clone = new HologramMaterialClass(
      settings,
      this.material.side === THREE.FrontSide ? 'ar' : 'desktop'
    );

    // Copy current state
    clone.isEdgeOnlyMode = this.isEdgeOnlyMode;
    clone.setEdgeOnly(this.isEdgeOnlyMode);

    return clone;
  }

  public dispose(): void {
    if (this.material && this.material.dispose) {
      this.material.dispose();
    }
  }
}

export const HologramComponent: React.FC<{
  children?: React.ReactNode;
  position?: [number, number, number];
  rotation?: [number, number, number];
  scale?: number | [number, number, number];
  color?: string | number | THREE.Color;
  opacity?: number;
  edgeOnly?: boolean;
  rings?: boolean;
  rotationSpeed?: number;
}> = ({
  children,
  position = [0, 0, 0],
  rotation = [0, 0, 0],
  scale = 1,
  color = '#00ffff',
  opacity = 0.7,
  edgeOnly = false,
  rings = true,
  rotationSpeed = 0.5
}) => {
  // Ref for the group to apply rotation animation
  const groupRef = useRef<THREE.Group>(null);

  // Animate rotation
  useFrame((_, delta) => {
    if (groupRef.current && rotationSpeed > 0) {
      // Apply manual rotation to avoid type errors
      const rotation = groupRef.current.rotation;
      if (rotation) {
        rotation.y += delta * rotationSpeed;
      }
    }
  });

  return (
    <group position={position} rotation={rotation} scale={scale}>
      {/* Main hologram content */}
      <group ref={groupRef}>
        {children || (
          // Default sphere if no children provided
          <mesh>
            <icosahedronGeometry args={[1, 1]} />
            <HologramMaterial color={color} opacity={opacity} edgeOnly={edgeOnly} />
          </mesh>
        )}

        {/* Rings (optional) */}
        {rings && (
          <>
            <mesh rotation={[Math.PI/2, 0, 0]}>
              <ringGeometry args={[0.8, 1, 32]} />
              <HologramMaterial color={color} opacity={opacity * 0.8} pulseIntensity={0.3} />
            </mesh>
            <mesh rotation={[0, Math.PI/3, Math.PI/3]}>
              <ringGeometry args={[1.2, 1.4, 32]} />
              <HologramMaterial color={color} opacity={opacity * 0.6} pulseIntensity={0.2} />
            </mesh>
          </>
        )}
      </group>
    </group>
  );
};

export default HologramComponent;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/visualisation/types/visualisationTypes.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/visualisation/types/visualisationTypes.ts
```ts
import { XRSettings } from '../../xr/types/xr';

export interface VisualisationSettings {
  nodes: {
    color: string;
    defaultSize: number;
    opacity: number;
  };
  edges: {
    color: string;
    width: number;
    opacity: number;
  };
  xr: XRSettings;
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/visualisation/utils/animations.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/visualisation/utils/animations.ts
```ts
/**
 * Animation System
 *
 * This file provides animation utilities and presets for UI components.
 * It's designed to create consistent animations throughout the application.
 */

import { useEffect, useState } from 'react';

export const timingFunctions = {
  linear: 'linear',
  easeIn: 'cubic-bezier(0.4, 0, 1, 1)',
  easeOut: 'cubic-bezier(0, 0, 0.2, 1)',
  easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
  // Custom spring-like curve for natural motion
  spring: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
  // Bounce effect
  bounce: 'cubic-bezier(0.175, 0.885, 0.32, 1.5)',
};

export const timingPresets = {
  fast: 150,
  normal: 250,
  slow: 350,
  verySlow: 500,
};

export const animationVariants = {
  // Fade animations
  fade: {
    in: {
      from: { opacity: 0 },
      to: { opacity: 1 },
    },
    out: {
      from: { opacity: 1 },
      to: { opacity: 0 },
    },
  },

  // Slide animations
  slideUp: {
    in: {
      from: { transform: 'translateY(10px)', opacity: 0 },
      to: { transform: 'translateY(0)', opacity: 1 },
    },
    out: {
      from: { transform: 'translateY(0)', opacity: 1 },
      to: { transform: 'translateY(-10px)', opacity: 0 },
    },
  },

  slideDown: {
    in: {
      from: { transform: 'translateY(-10px)', opacity: 0 },
      to: { transform: 'translateY(0)', opacity: 1 },
    },
    out: {
      from: { transform: 'translateY(0)', opacity: 1 },
      to: { transform: 'translateY(10px)', opacity: 0 },
    },
  },

  slideLeft: {
    in: {
      from: { transform: 'translateX(10px)', opacity: 0 },
      to: { transform: 'translateX(0)', opacity: 1 },
    },
    out: {
      from: { transform: 'translateX(0)', opacity: 1 },
      to: { transform: 'translateX(-10px)', opacity: 0 },
    },
  },

  slideRight: {
    in: {
      from: { transform: 'translateX(-10px)', opacity: 0 },
      to: { transform: 'translateX(0)', opacity: 1 },
    },
    out: {
      from: { transform: 'translateX(0)', opacity: 1 },
      to: { transform: 'translateX(10px)', opacity: 0 },
    },
  },

  // Scale animations
  scale: {
    in: {
      from: { transform: 'scale(0.95)', opacity: 0 },
      to: { transform: 'scale(1)', opacity: 1 },
    },
    out: {
      from: { transform: 'scale(1)', opacity: 1 },
      to: { transform: 'scale(0.95)', opacity: 0 },
    },
  },

  // Panel animations
  panel: {
    in: {
      from: { transform: 'translateX(100%)', opacity: 0 },
      to: { transform: 'translateX(0)', opacity: 1 },
    },
    out: {
      from: { transform: 'translateX(0)', opacity: 1 },
      to: { transform: 'translateX(100%)', opacity: 0 },
    },
  },

  // Shake animation for error or attention
  shake: {
    keyframes: [
      { transform: 'translateX(0)' },
      { transform: 'translateX(-5px)' },
      { transform: 'translateX(5px)' },
      { transform: 'translateX(-5px)' },
      { transform: 'translateX(5px)' },
      { transform: 'translateX(-5px)' },
      { transform: 'translateX(0)' }
    ],
  },
};

/**
 * CSS transition string creator for inline styles
 * @param properties CSS properties to animate
 * @param duration Animation duration in ms
 * @param timingFunction Easing function
 * @param delay Delay before animation starts (in ms)
 * @returns CSS transition string
 */
export function createTransition(
  properties: string[] = ['all'],
  duration: number = timingPresets.normal,
  timingFunction: string = timingFunctions.easeInOut,
  delay: number = 0
): string {
  return properties
    .map(prop => `${prop} ${duration}ms ${timingFunction} ${delay}ms`)
    .join(', ');
}

/**
 * Hook to create animated transitions on mount/unmount
 * @param visible Whether the element is visible
 * @param duration Animation duration in ms
 * @param delay Delay before animation starts (in ms)
 * @returns Whether to render the element at all
 */
export function useAnimatedVisibility(
  visible: boolean,
  duration: number = timingPresets.normal,
  delay: number = 0
): { shouldRender: boolean; animationState: 'entering' | 'entered' | 'exiting' | 'exited' } {
  const [shouldRender, setShouldRender] = useState(visible);
  const [animationState, setAnimationState] = useState<'entering' | 'entered' | 'exiting' | 'exited'>(
    visible ? 'entered' : 'exited'
  );

  useEffect(() => {
    let timeoutId: number;

    if (visible) {
      setShouldRender(true);
      // Wait one frame to trigger enter animation
      requestAnimationFrame(() => {
        setAnimationState('entering');
        timeoutId = window.setTimeout(() => {
          setAnimationState('entered');
        }, duration);
      });
    } else {
      setAnimationState('exiting');
      timeoutId = window.setTimeout(() => {
        setAnimationState('exited');
        setShouldRender(false);
      }, duration);
    }

    return () => {
      clearTimeout(timeoutId);
    };
  }, [visible, duration]);

  return { shouldRender, animationState };
}

/**
 * Hook to perform performance-aware animations
 * Reduces animation complexity on low-end devices
 */
export function usePerformanceAwareAnimation(
  preferredAnimation: 'fade' | 'slide' | 'scale' | 'none' = 'fade'
): 'fade' | 'slide' | 'scale' | 'none' {
  const [reducedMotion, setReducedMotion] = useState(false);
  const [lowPerformance, setLowPerformance] = useState(false);

  useEffect(() => {
    // Check for reduced motion preference
    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
    setReducedMotion(mediaQuery.matches);

    const handleChange = (e: MediaQueryListEvent) => {
      setReducedMotion(e.matches);
    };

    mediaQuery.addEventListener('change', handleChange);

    // Detect low performance devices (simple heuristic)
    if (
      navigator.hardwareConcurrency <= 2 || // CPU cores
      ('deviceMemory' in navigator && (navigator as any).deviceMemory <= 2) // RAM in GB, not available in all browsers
    ) {
      // Set low performance mode to reduce animations and effects
      setLowPerformance(true);
    }

    return () => {
      mediaQuery.removeEventListener('change', handleChange);
    };
  }, []);

  // Return appropriate animation based on device capabilities
  if (reducedMotion) return 'none';
  if (lowPerformance) return 'fade'; // Simplest animation for low-end devices
  return preferredAnimation;
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/xr/components/XRController.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/xr/components/XRController.tsx
```tsx
import React, { useState, useCallback } from 'react'
import { useXRCore } from '../providers/XRCoreProvider'
import HandInteractionSystem, { GestureRecognitionResult } from '../systems/HandInteractionSystem'
import { useSettingsStore } from '../../../store/settingsStore'
import { createLogger } from '../../../utils/logger'

const logger = createLogger('XRController')

/**
 * XRController component manages Quest 3 AR functionality and hand tracking.
 * Uses the enhanced XRCoreProvider for robust session management.
 */
const XRController: React.FC = () => {
  const { isSessionActive, sessionType, controllers } = useXRCore()
  const settings = useSettingsStore(state => state.settings)
  const [handsVisible, setHandsVisible] = useState(false)
  const [handTrackingEnabled, setHandTrackingEnabled] = useState(settings?.xr?.enableHandTracking !== false)

  // Log session state changes (Quest 3 AR focused)
  React.useEffect(() => {
    if (settings?.system?.debug?.enabled) {
      if (isSessionActive && sessionType === 'immersive-ar') {
        logger.info('Quest 3 AR session is now active')
      } else if (isSessionActive) {
        logger.info('XR session active but not Quest 3 AR mode')
      } else {
        logger.info('XR session is not active')
      }
    }
  }, [isSessionActive, sessionType, settings?.system?.debug?.enabled])

  // Log controller information
  React.useEffect(() => {
    if (isSessionActive && controllers && controllers.length > 0 && settings?.system?.debug?.enabled) {
      logger.info(`Quest 3 controllers active: ${controllers.length}`)
      controllers.forEach((controller, index) => {
        logger.info(`Controller ${index}: Three.js XRTargetRaySpace object`)
      })
    }
  }, [controllers, isSessionActive, settings?.system?.debug?.enabled])

  // Handle gesture recognition (Quest 3 optimized)
  const handleGestureRecognized = useCallback((gesture: GestureRecognitionResult) => {
    if (settings?.system?.debug?.enabled) {
      logger.info(`Quest 3 gesture recognized: ${gesture.gesture} (${gesture.confidence.toFixed(2)}) with ${gesture.hand} hand`)
    }
  }, [settings?.system?.debug?.enabled])

  // Handle hand visibility changes
  const handleHandsVisible = useCallback((visible: boolean) => {
    setHandsVisible(visible)

    if (settings?.system?.debug?.enabled) {
      logger.info(`Quest 3 hands visible: ${visible}`)
    }
  }, [settings?.system?.debug?.enabled])

  // Only render if XR enabled and preferably in Quest 3 AR mode
  if (settings?.xr?.enabled === false) {
    return null
  }

  // Prioritize Quest 3 AR mode
  const isQuest3AR = isSessionActive && sessionType === 'immersive-ar'

  return (
    <group name="quest3-ar-controller-root">
      <HandInteractionSystem
        enabled={handTrackingEnabled && (isQuest3AR || isSessionActive)}
        onGestureRecognized={handleGestureRecognized}
        onHandsVisible={handleHandsVisible}
      />
    </group>
  )
}

export default XRController
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/xr/components/XRScene.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/xr/components/XRScene.tsx
```tsx
import React from 'react'
import { Canvas } from '@react-three/fiber'
import { XR, Controllers, Hands } from '@react-three/xr'
import { Environment, OrbitControls } from '@react-three/drei'
import GraphManager from '../../graph/components/GraphManager'; // Changed to default import
import { useSettingsStore } from '../../../store/settingsStore'; // Corrected path

export const XRScene = () => {
  const settings = useSettingsStore(state => state.settings)
  const xrSettings = settings?.xr

  return (
    <Canvas
      camera={{ position: [0, 1.6, 3], fov: 50 }}
      shadows
    >
      <XR>
        <Controllers />
        <Hands />

        {/* AR-specific lighting */}
        <ambientLight intensity={0.5} />
        <directionalLight
          position={[10, 10, 5]}
          intensity={1}
          castShadow
        />

        {/* Environment for better AR visualisation */}
        <Environment preset="city" />

        {/* Main graph visualisation */}
        <GraphManager />

        {/* Optional orbit controls for non-AR mode */}
        {!xrSettings?.enabled && (
          <OrbitControls
            enablePan={true}
            enableZoom={true}
            enableRotate={true}
            target={[0, 0, 0]}
          />
        )}
      </XR>
    </Canvas>
  )
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/xr/components/XRVisualisationConnector.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/xr/components/XRVisualisationConnector.tsx
```tsx
import React, { useEffect, useState, useCallback } from 'react';
import { useXRCore } from '../providers/XRCoreProvider';
import { MetadataVisualizer, useTextLabelManager } from '../../visualisation/components/MetadataVisualizer';
import { useHandTracking } from '../systems/HandInteractionSystem';
import { useSettingsStore } from '../../../store/settingsStore';
import { createLogger } from '../../../utils/logger';

const logger = createLogger('XRVisualisationConnector');

/**
 * XRVisualisationConnector connects the Quest 3 AR hand interaction system
 * with the visualisation system and platform manager.
 *
 * This component acts as the dependency injector between these systems.
 * It uses the enhanced XRCoreProvider for robust session management.
 */
const XRVisualisationConnector: React.FC = () => {
  const { isSessionActive: isXRMode, sessionType } = useXRCore();
  const settings = useSettingsStore(state => state.settings);
  const handTracking = useHandTracking();
  const labelManager = useTextLabelManager();
  const [interactionEnabled, setInteractionEnabled] = useState(true);

  // Handle platform changes (Quest 3 AR focused)
  useEffect(() => {
    // Configure interactivity based on Quest 3 AR mode
    const isQuest3AR = isXRMode && sessionType === 'immersive-ar';
    setInteractionEnabled(isQuest3AR && settings?.xr?.enableHandTracking !== false);

    // Debug logging
    if (isQuest3AR) {
      if (settings?.system?.debug?.enabled) {
        logger.info('Quest 3 AR mode active, configuring visualisation for hand interaction');
      }
    }
  }, [isXRMode, sessionType, settings?.xr?.enableHandTracking, settings?.system?.debug?.enabled]);

  // Handle hand gesture interactions with visualisations
  useEffect(() => {
    if (!interactionEnabled) return;

    // Example: Use pinch gesture state to interact with labels
    const { pinchState, handPositions, isLeftHandVisible, isRightHandVisible } = handTracking;

    // Update visualisation system based on hand state using tuple positions
    // This is just a stub - real implementation would have more logic
    if (pinchState.left || pinchState.right) {
      // Use tuple based positions for hand interactions
      const leftPos = handPositions.left;
      const rightPos = handPositions.right;

      if (pinchState.left && leftPos) {
        logger.debug(`Left hand pinch at [${leftPos[0]}, ${leftPos[1]}, ${leftPos[2]}]`);
      }

      if (pinchState.right && rightPos) {
        logger.debug(`Right hand pinch at [${rightPos[0]}, ${rightPos[1]}, ${rightPos[2]}]`);
      }
    }

    return () => {
      // Cleanup if needed
    };
  }, [handTracking.pinchState, handTracking.handPositions, interactionEnabled]);

  // Render the visualisation system with the appropriate settings
  return (
    <MetadataVisualizer
      renderLabels={settings?.visualisation?.labels?.enableLabels !== false} // Use correct property name
      // renderIcons={settings?.visualisation?.icons?.enabled !== false} // Property 'icons' does not exist
      // renderMetrics={settings?.visualisation?.metrics?.enabled} // Property 'metrics' does not exist
    />
  );
};

export default XRVisualisationConnector;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/xr/components/ui/XRControlPanel.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/xr/components/ui/XRControlPanel.tsx
```tsx
import { useRef, useState, useEffect } from 'react';
import { Object3D, Group, Vector3 } from 'three';
import { useThree, useFrame } from '@react-three/fiber';
import { Interactive } from '@react-three/xr';
import { useSettingsStore } from '../../../../store/settingsStore';
import { createLogger } from '../../../../utils/logger';

const logger = createLogger('XRControlPanel');

interface XRControlPanelProps {
  /**
   * Distance from controller to position the panel
   * @default 0.3
   */
  distance?: number;

  /**
   * Size of the panel
   * @default {width: 0.3, height: 0.2}
   */
  size?: {
    width: number;
    height: number;
  };

  /**
   * Whether to show the panel
   * @default true
   */
  visible?: boolean;

  /**
   * Controller to attach the panel to (0 = right, 1 = left)
   * @default 0
   */
  controller?: number;

  /**
   * Whether the panel should face the user
   * @default true
   */
  faceUser?: boolean;
}

/**
 * XRControlPanel provides an interactive interface for controlling settings in XR mode.
 * It's attached to a controller and follows its movement while providing touch/pointer interaction.
 */
const XRControlPanel = ({
  distance = 0.3,
  size = { width: 0.3, height: 0.2 },
  visible = true,
  controller = 0,
  faceUser = true,
}: XRControlPanelProps) => {
  const groupRef = useRef<Group>(null);
  const { camera } = useThree();
  const [hovered, setHovered] = useState(false);
  const [selectedTab, setSelectedTab] = useState('visualisation');

  const { settings } = useSettingsStore();

  // Position the panel relative to the controller
  useFrame((state, delta) => {
    if (!groupRef.current) return;

    // If we have controller data, position the panel relative to it
    const controllers = (state as any).controllers;
    if (controllers && controllers[controller]) {
      const controllerObj = controllers[controller];

      // Get controller position and orientation
      const position = new Vector3();
      controllerObj.getWorldPosition(position);

      const quaternion = controllerObj.getWorldQuaternion();

      // Position the panel in front of the controller
      const forward = new Vector3(0, 0, -1).applyQuaternion(quaternion);
      position.addScaledVector(forward, distance);

      groupRef.current.position.copy(position);

      // Either match controller orientation or face the user
      if (faceUser) {
        // Make the panel face the user
        groupRef.current.lookAt(camera.position);
      } else {
        // Match controller orientation
        groupRef.current.quaternion.copy(quaternion);
      }
    }
  });

  // Handle tab selection
  const handleTabSelect = (tab: string) => {
    setSelectedTab(tab);
    logger.debug(`Selected XR panel tab: ${tab}`);
  };

  if (!visible) return null;

  return (
    <group ref={groupRef}>
      {/* Panel background */}
      <Interactive
        onSelect={() => {}}
        onHover={() => setHovered(true)}
        onBlur={() => setHovered(false)}
      >
        <mesh position={[0, 0, 0]}>
          <planeGeometry args={[size.width, size.height]} />
          <meshStandardMaterial
            color={hovered ? '#2a2a2a' : '#1a1a1a'}
            transparent
            opacity={0.8}
          />
        </mesh>
      </Interactive>

      {/* Tab buttons at the top */}
      <group position={[0, size.height / 2 - 0.02, 0.001]}>
        {/* Visualisation tab */}
        <Interactive onSelect={() => handleTabSelect('visualisation')}>
          <mesh position={[-size.width / 4, 0, 0]}>
            <planeGeometry args={[size.width / 3.5, 0.03]} />
            <meshStandardMaterial
              color={selectedTab === 'visualisation' ? '#4a86e8' : '#333333'}
            />
          </mesh>
        </Interactive>

        {/* XR tab */}
        <Interactive onSelect={() => handleTabSelect('xr')}>
          <mesh position={[size.width / 4, 0, 0]}>
            <planeGeometry args={[size.width / 3.5, 0.03]} />
            <meshStandardMaterial
              color={selectedTab === 'xr' ? '#4a86e8' : '#333333'}
            />
          </mesh>
        </Interactive>
      </group>

      {/* Panel content - dynamically render based on selected tab */}
      <group position={[0, 0, 0.001]}>
        {selectedTab === 'visualisation' && (
          <group>
            {/* Simple visualisation controls */}
            <mesh position={[0, 0.05, 0]} scale={[0.9, 0.1, 1]}>
              <planeGeometry />
              <meshStandardMaterial color="#333333" />
            </mesh>
            <mesh position={[0, -0.05, 0]} scale={[0.9, 0.1, 1]}>
              <planeGeometry />
              <meshStandardMaterial color="#333333" />
            </mesh>
          </group>
        )}

        {selectedTab === 'xr' && (
          <group>
            {/* Simple XR controls */}
            <mesh position={[0, 0, 0]} scale={[0.9, 0.15, 1]}>
              <planeGeometry />
              <meshStandardMaterial color="#333333" />
            </mesh>
          </group>
        )}
      </group>
    </group>
  );
};

export default XRControlPanel;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/xr/hooks/useSafeXRHooks.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/xr/hooks/useSafeXRHooks.tsx
```tsx
import React from 'react';
import { createLogger } from '../../../utils/logger';

const logger = createLogger('safeXRHooks');

const emptyXRState = {
  isPresenting: false,
  controllers: [],
  player: null,
  session: null,
  hoverState: {},
};

/**
 * A safe version of useXR that won't throw errors when used outside XR context
 * This allows XR components to be rendered anywhere without errors
 */
export function useSafeXR() {
  try {
    // Try to dynamically import @react-three/xr hooks
    // This is needed because direct import at the top level would still cause errors
    const { useXR } = require('@react-three/xr');

    // If we get here, we can safely use the hook
    return useXR();
  } catch (error) {
    // If accessing the XR hook fails, return default values
    // to prevent component errors
    logger.debug('Using safe XR fallback - component outside XR context');
    return emptyXRState;
  }
}

/**
 * A safe wrapper for creating XR-dependent components
 * that won't throw errors when used outside XR context
 */
export function withSafeXR<P extends object>(
  Component: React.ComponentType<P>,
  componentName: string = 'Component'
): React.FC<P> {
  const WrappedComponent: React.FC<P> = (props) => {
    try {
      // Try to render component normally
      return <Component {...props} />;
    } catch (error) {
      // If an XR-related error occurs, don't render the component
      logger.debug(`${componentName} not rendered - XR context error`);
      return null;
    }
  };

  // Set a display name for better debugging
  WrappedComponent.displayName = `withSafeXR(${componentName})`;

  return WrappedComponent;
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/xr/hooks/useXRContextCheck.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/xr/hooks/useXRContextCheck.tsx
```tsx
import { useCallback, useEffect, useState } from 'react';
import { createLogger } from '../../../utils/logger';

const logger = createLogger('useXRContextCheck');

/**
 * A hook that safely checks if the current component is being rendered
 * within a valid XR context, without causing errors when outside it.
 *
 * @returns {boolean} isInXRContext - True if in valid XR context, false otherwise
 */
export const useXRContextCheck = (): boolean => {
  const [isInXRContext, setIsInXRContext] = useState<boolean>(false);

  useEffect(() => {
    // Check if we're in an XR context by checking for the '__r3f' property
    // which is added by react-three-fiber to elements in its render tree
    try {
      // If we can access THREE.WebXRManager or find XR elements in the DOM,
      // we're likely in an XR context
      const isInContext = typeof window !== 'undefined' &&
        ((document.querySelector('[data-xr-canvas="true"]') !== null) ||
         (document.querySelector('canvas.__r3f') !== null));

      setIsInXRContext(isInContext);
    } catch (error) {
      // If any error occurs during detection, assume we're not in XR context
      setIsInXRContext(false);
      logger.debug('XR context detection error, assuming outside context');
    }
  }, []);

  return isInXRContext;
};

export default useXRContextCheck;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/xr/managers/xrInitializer.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/xr/managers/xrInitializer.ts
```ts
import * as THREE from 'three';
import { createLogger, createErrorMetadata } from '@/utils/logger';
import { debugState } from '@/utils/debugState';
import { XRSessionManager, XRControllerEvent } from './xrSessionManager';
import { XRSettings } from '../types/xr';
import { SceneManager } from '../../visualisation/managers/sceneManager';

const logger = createLogger('XRInitializer');

export class XRInitializer {
  private static instance: XRInitializer;
  private xrSessionManager: XRSessionManager;
  private sceneManager: SceneManager;
  private scene: THREE.Scene;
  private camera: THREE.PerspectiveCamera;
  private teleportMarker: THREE.Mesh | null = null;
  private floorPlane: THREE.Mesh | null = null;
  private settings: XRSettings | null = null;
  private raycaster: THREE.Raycaster = new THREE.Raycaster();
  private controllerIntersections: Map<THREE.XRTargetRaySpace, THREE.Intersection[]> = new Map();

  // Teleportation state
  private isTeleporting: boolean = false;
  private teleportPosition: THREE.Vector3 = new THREE.Vector3();

  // Movement state
  private movementEnabled: boolean = true;
  private movementSpeed: number = 1.0;

  // Controller handlers
  private controllerSelectStartUnsubscribe: (() => void) | null = null;
  private controllerSelectEndUnsubscribe: (() => void) | null = null;
  private controllerSqueezeStartUnsubscribe: (() => void) | null = null;
  private controllerSqueezeEndUnsubscribe: (() => void) | null = null;

  private constructor(xrSessionManager: XRSessionManager) {
    this.xrSessionManager = xrSessionManager;
    this.sceneManager = SceneManager.getInstance();
    this.scene = this.sceneManager.getScene();

    // Get camera and ensure it's a PerspectiveCamera
    const camera = this.sceneManager.getCamera();

    if (!camera || !(camera instanceof THREE.PerspectiveCamera)) {
      logger.warn('PerspectiveCamera not available from SceneManager, creating default camera');
      this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      this.camera.position.z = 5;
    } else {
      // We have a valid PerspectiveCamera
      this.camera = camera as THREE.PerspectiveCamera;
    }

    // Setup XR interactions
    this.setupXRInteractions();
  }

  public static getInstance(xrSessionManager: XRSessionManager): XRInitializer {
    if (!XRInitializer.instance) {
      XRInitializer.instance = new XRInitializer(xrSessionManager);
    }
    return XRInitializer.instance;
  }

  // Initialize XR capabilities with current settings
  public initialize(settings: XRSettings): void {
    this.settings = settings;

    // The XRSettings interface was updated, so we access properties directly.
    // We also need to check if settings itself is null before accessing its properties.
    if (settings) {
      this.movementEnabled = true; // Assuming movement is enabled if XR settings are present
      this.movementSpeed = settings.movementSpeed || 1.0;

      // Setup floor if enabled
      if (settings.showFloor) {
        this.createFloor();
      } else if (this.floorPlane) {
        this.scene.remove(this.floorPlane);
        this.floorPlane.geometry.dispose();
        (this.floorPlane.material as THREE.Material).dispose();
        this.floorPlane = null;
      }

      // Setup teleport marker if teleport is enabled
      if (settings.teleportEnabled) {
        this.createTeleportMarker();
      } else if (this.teleportMarker) {
        this.scene.remove(this.teleportMarker);
        this.teleportMarker.geometry.dispose();
        (this.teleportMarker.material as THREE.Material).dispose();
        this.teleportMarker = null;
      }
    }

    if (debugState.isEnabled()) {
      logger.info('XR initializer initialized with settings');
    }
  }

  // Setup all XR interactions
  private setupXRInteractions(): void {
    // Register for controller events
    this.controllerSelectStartUnsubscribe = this.xrSessionManager.onSelectStart(
      this.handleControllerSelectStart.bind(this)
    );

    this.controllerSelectEndUnsubscribe = this.xrSessionManager.onSelectEnd(
      this.handleControllerSelectEnd.bind(this)
    );

    this.controllerSqueezeStartUnsubscribe = this.xrSessionManager.onSqueezeStart(
      this.handleControllerSqueezeStart.bind(this)
    );

    this.controllerSqueezeEndUnsubscribe = this.xrSessionManager.onSqueezeEnd(
      this.handleControllerSqueezeEnd.bind(this)
    );

    // Add render callback for continuous interaction checks
    this.sceneManager.addRenderCallback(this.update.bind(this));

    if (debugState.isEnabled()) {
      logger.info('XR interactions setup complete');
    }
  }

  // Create floor plane for reference and teleportation
  private createFloor(): void {
    if (this.floorPlane) {
      return;
    }

    const geometry = new THREE.PlaneGeometry(20, 20);
    const material = new THREE.MeshBasicMaterial({
      color: 0x808080,
      transparent: true,
      opacity: 0.2,
      side: THREE.DoubleSide
    });

    this.floorPlane = new THREE.Mesh(geometry, material);
    this.floorPlane.rotation.x = -Math.PI / 2;
    this.floorPlane.position.y = 0;
    this.floorPlane.receiveShadow = true;
    this.floorPlane.name = 'xr-floor';

    this.scene.add(this.floorPlane);

    if (debugState.isEnabled()) {
      logger.info('XR floor plane created');
    }
  }

  // Create teleport marker for showing valid teleport locations
  private createTeleportMarker(): void {
    if (this.teleportMarker) {
      return;
    }

    const geometry = new THREE.RingGeometry(0.15, 0.2, 32);
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ff00,
      transparent: true,
      opacity: 0.6,
      side: THREE.DoubleSide
    });

    this.teleportMarker = new THREE.Mesh(geometry, material);
    this.teleportMarker.rotation.x = -Math.PI / 2;
    this.teleportMarker.visible = false;
    this.teleportMarker.name = 'teleport-marker';

    this.scene.add(this.teleportMarker);

    if (debugState.isEnabled()) {
      logger.info('Teleport marker created');
    }
  }

  // Update loop for continuous interactions
  private update(): void {
    if (!this.xrSessionManager.isSessionActive()) {
      return;
    }

    // Get controllers
    const controllers = this.xrSessionManager.getControllers();

    // Update controller interactions
    controllers.forEach(controller => {
      this.updateControllerInteractions(controller);
    });
  }

  // Check for intersections with objects
  private updateControllerInteractions(controller: THREE.XRTargetRaySpace): void {
    // Skip if there's no session
    if (!this.xrSessionManager.isSessionActive()) {
      return;
    }

    // Initialize raycaster from controller
    const tempMatrix = new THREE.Matrix4();
    tempMatrix.identity().extractRotation(controller.matrixWorld);

    this.raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

    // Store intersections for this controller
    const intersections: THREE.Intersection[] = [];

    // Check for floor intersection if teleport is enabled
    if (this.floorPlane && this.settings?.teleportEnabled) {
      const floorIntersects = this.raycaster.intersectObject(this.floorPlane);

      if (floorIntersects.length > 0) {
        intersections.push(...floorIntersects);

        // Update teleport marker position if currently teleporting
        if (this.isTeleporting && this.teleportMarker) {
          this.teleportPosition.copy(floorIntersects[0].point);
          this.teleportMarker.position.copy(this.teleportPosition);
          this.teleportMarker.visible = true;
        }
      } else if (this.isTeleporting && this.teleportMarker) {
        // Hide marker if not pointing at floor
        this.teleportMarker.visible = false;
      }
    }

    // Store intersections for this controller
    this.controllerIntersections.set(controller, intersections);
  }

  // Handle controller select start event (trigger press)
  private handleControllerSelectStart(event: XRControllerEvent): void {
    const { controller } = event;

    // Start teleportation if enabled
    if (this.settings?.teleportEnabled) {
      this.isTeleporting = true;

      // Show teleport marker if there's a valid intersection
      const intersections = this.controllerIntersections.get(controller) || [];
      if (intersections.length > 0 && this.floorPlane && this.teleportMarker) {
        const floorIntersect = intersections.find(
          i => i.object === this.floorPlane
        );

        if (floorIntersect) {
          this.teleportPosition.copy(floorIntersect.point);
          this.teleportMarker.position.copy(this.teleportPosition);
          this.teleportMarker.visible = true;
        }
      }
    }
  }

  // Handle controller select end event (trigger release)
  private handleControllerSelectEnd(event: XRControllerEvent): void {
    // Complete teleportation if in progress
    if (this.isTeleporting && this.teleportMarker && this.teleportMarker.visible) {
      // Get camera position but keep y-height the same
      const cameraPosition = new THREE.Vector3();
      cameraPosition.setFromMatrixPosition(this.camera.matrixWorld);

      // Calculate teleport offset (where we want camera to end up)
      const offsetX = this.teleportPosition.x - cameraPosition.x;
      const offsetZ = this.teleportPosition.z - cameraPosition.z;

      // Find camera rig/offset parent - in WebXR the camera is often a child of a rig
      let cameraRig = this.camera.parent;
      if (cameraRig) {
        // Apply offset to camera rig's position
        cameraRig.position.x += offsetX;
        cameraRig.position.z += offsetZ;
      } else {
        // Fallback to moving camera directly if no rig
        this.camera.position.x += offsetX;
        this.camera.position.z += offsetZ;
      }

      // Hide teleport marker
      this.teleportMarker.visible = false;

      if (debugState.isDataDebugEnabled()) {
        logger.debug('Teleported to', { x: this.teleportPosition.x, z: this.teleportPosition.z });
      }
    }

    // Reset teleport state
    this.isTeleporting = false;
  }

  // Handle controller squeeze start event (grip press)
  private handleControllerSqueezeStart(event: XRControllerEvent): void {
    // Placeholder for future interactions
    // Could be used for grabbing objects, scaling the environment, etc.
  }

  // Handle controller squeeze end event (grip release)
  private handleControllerSqueezeEnd(event: XRControllerEvent): void {
    // Placeholder for future interactions
  }

  // Update settings for XR
  public updateSettings(settings: XRSettings): void {
    this.settings = settings;

    // The XRSettings interface was updated, so we access properties directly.
    // We also need to check if settings itself is null before accessing its properties.
    if (settings) {
      this.movementSpeed = settings.movementSpeed || 1.0;

      // Update floor visibility
      if (settings.showFloor) {
        if (!this.floorPlane) {
          this.createFloor();
        }
      } else if (this.floorPlane) {
        this.scene.remove(this.floorPlane);
        this.floorPlane.geometry.dispose();
        (this.floorPlane.material as THREE.Material).dispose();
        this.floorPlane = null;
      }

      // Update teleport marker
      if (settings.teleportEnabled) {
        if (!this.teleportMarker) {
          this.createTeleportMarker();
        }
      } else if (this.teleportMarker) {
        this.scene.remove(this.teleportMarker);
        this.teleportMarker.geometry.dispose();
        (this.teleportMarker.material as THREE.Material).dispose();
        this.teleportMarker = null;
      }
    }
  }

  // Clean up all XR-related resources
  public dispose(): void {
    // Unsubscribe from controller events
    if (this.controllerSelectStartUnsubscribe) {
      this.controllerSelectStartUnsubscribe();
      this.controllerSelectStartUnsubscribe = null;
    }

    if (this.controllerSelectEndUnsubscribe) {
      this.controllerSelectEndUnsubscribe();
      this.controllerSelectEndUnsubscribe = null;
    }

    if (this.controllerSqueezeStartUnsubscribe) {
      this.controllerSqueezeStartUnsubscribe();
      this.controllerSqueezeStartUnsubscribe = null;
    }

    if (this.controllerSqueezeEndUnsubscribe) {
      this.controllerSqueezeEndUnsubscribe();
      this.controllerSqueezeEndUnsubscribe = null;
    }

    // Remove floor and teleport marker
    if (this.floorPlane) {
      this.scene.remove(this.floorPlane);
      this.floorPlane.geometry.dispose();
      (this.floorPlane.material as THREE.Material).dispose();
      this.floorPlane = null;
    }

    if (this.teleportMarker) {
      this.scene.remove(this.teleportMarker);
      this.teleportMarker.geometry.dispose();
      (this.teleportMarker.material as THREE.Material).dispose();
      this.teleportMarker = null;
    }

    // Clear intersections map
    this.controllerIntersections.clear();

    if (debugState.isEnabled()) {
      logger.info('XR initializer disposed');
    }
  }
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/xr/managers/xrSessionManager.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/xr/managers/xrSessionManager.ts
```ts
import * as THREE from 'three';
import { VRButton } from 'three/examples/jsm/webxr/VRButton.js';
import { XRControllerModelFactory } from 'three/examples/jsm/webxr/XRControllerModelFactory.js';
import { createLogger, createErrorMetadata } from '@/utils/logger';
import { debugState } from '@/utils/debugState'; // Assuming debugState.ts exists in utils
import { SceneManager } from '@/features/visualisation/managers/sceneManager'; // Correct path
import { GestureRecognitionResult } from '@/features/xr/systems/HandInteractionSystem'; // Correct path
import { Settings } from '@/features/settings/config/settings'; // Correct path, assuming Settings is defined here

const logger = createLogger('XRSessionManager');

export interface XRControllerEvent {
  controller: THREE.XRTargetRaySpace;
  inputSource: XRInputSource;
  data?: any;
}

type XRControllerEventHandler = (event: XRControllerEvent) => void;

type GestureEventHandler = (gesture: GestureRecognitionResult) => void;
type HandVisibilityHandler = (visible: boolean) => void;
type XRSessionStateHandler = (state: string) => void;
type HandTrackingHandler = (enabled: boolean) => void;

export class XRSessionManager {
  private static instance: XRSessionManager;
  private sceneManager: SceneManager;
  private renderer: THREE.WebGLRenderer | null = null;
  private camera: THREE.PerspectiveCamera | null = null;
  private scene: THREE.Scene | null = null;
  private controllers: THREE.XRTargetRaySpace[] = [];
  private controllerGrips: THREE.Object3D[] = [];
  private controllerModelFactory: XRControllerModelFactory | null = null;
  private vrButton: HTMLElement | null = null;
  private sessionActive: boolean = false;
  private settings: Settings | null = null;

  // Event handlers
  private selectStartHandlers: XRControllerEventHandler[] = [];
  private selectEndHandlers: XRControllerEventHandler[] = [];
  private squeezeStartHandlers: XRControllerEventHandler[] = [];
  private squeezeEndHandlers: XRControllerEventHandler[] = [];

  // New event handlers for hand interactions
  private gestureRecognizedHandlers: GestureEventHandler[] = [];
  private handsVisibilityChangedHandlers: HandVisibilityHandler[] = [];
  private handTrackingStateHandlers: HandTrackingHandler[] = [];

  private constructor(sceneManager: SceneManager, externalRenderer?: THREE.WebGLRenderer) {
    this.sceneManager = sceneManager;
    // Allow using an external renderer (from React Three Fiber) or try to get one from SceneManager
    this.renderer = externalRenderer || sceneManager.getRenderer();

    // Get camera and ensure it's a PerspectiveCamera
    const camera = sceneManager.getCamera();
    if (!camera || !(camera instanceof THREE.PerspectiveCamera)) {
      logger.warn('PerspectiveCamera not available from SceneManager, creating default camera');
      this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      this.camera.position.z = 5;
    } else {
      this.camera = camera as THREE.PerspectiveCamera;
    }

    // Get scene
    this.scene = sceneManager.getScene();
    if (!this.scene) {
      logger.warn('Scene not found in SceneManager, creating default scene');
      this.scene = new THREE.Scene();
    }

    // Log warning instead of throwing error so application can continue
    if (!this.renderer) {
      logger.warn('XRSessionManager: No renderer provided. XR functionality will be limited.');
    }

    try {
      // Initialize controller model factory
      this.controllerModelFactory = new XRControllerModelFactory();
    } catch (error) {
      logger.error('Failed to create XRControllerModelFactory:', createErrorMetadata(error));
      this.controllerModelFactory = null;
    }
  }

  public static getInstance(sceneManager: SceneManager, externalRenderer?: THREE.WebGLRenderer): XRSessionManager {
    if (!XRSessionManager.instance) {
      XRSessionManager.instance = new XRSessionManager(sceneManager, externalRenderer);
    } else if (externalRenderer && !XRSessionManager.instance.renderer) {
      // If instance exists but has no renderer, we can update it with the external renderer
      XRSessionManager.instance.renderer = externalRenderer;
      logger.info('Updated XRSessionManager with external renderer');
    }
    return XRSessionManager.instance;
  }

  public initialize(settings: Settings): void {
    if (!this.renderer || !this.scene) {
      logger.error('Cannot initialize XR: renderer or scene is missing');
      return;
    }

    this.settings = settings;

    try {
      // Check if WebXR is supported
      if ('xr' in navigator && this.renderer) {
        // Set up renderer for XR
        this.renderer.xr.enabled = true;

        // Set reference space type based on settings (assuming teleport implies room scale)
        const refSpace = settings.xr?.locomotionMethod === 'teleport' ? 'local-floor' : 'local';
        this.renderer.xr.setReferenceSpaceType(refSpace);

        if (debugState.isEnabled()) {
          logger.info(`Set XR reference space to ${refSpace}`);
        }

        // Create VR button
        this.createVRButton();

        // Create controllers
        this.setupControllers();

        if (debugState.isEnabled()) {
          logger.info('XR session manager initialized successfully');
        }
      } else if (debugState.isEnabled()) {
        logger.warn('WebXR not supported in this browser');
      }
    } catch (error) {
      logger.error('Failed to initialize XR:', createErrorMetadata(error));
    }
  }

  private createVRButton(): void {
    if (!this.renderer || !navigator.xr) {
      logger.warn('WebXR not supported or renderer not available for VR button creation.');
      return;
    }

    const button = document.createElement('button');
    button.id = 'xr-button';
    button.style.position = 'absolute';
    button.style.bottom = '20px';
    button.style.right = '20px';
    button.style.padding = '12px 24px';
    button.style.border = '1px solid #fff';
    button.style.borderRadius = '4px';
    button.style.background = 'rgba(0,0,0,0.5)';
    button.style.color = '#fff';
    button.style.font = 'normal 18px sans-serif';
    button.style.textAlign = 'center';
    button.style.opacity = '0.7';
    button.style.outline = 'none';
    button.style.zIndex = '100';
    button.style.cursor = 'pointer';

    const showEnterXR = (supported: boolean, modeText: string) => {
      button.textContent = supported ? `ENTER ${modeText}` : `${modeText} NOT SUPPORTED`;
      button.disabled = !supported;
    };

    const showExitXR = () => {
      button.textContent = 'EXIT XR';
      button.disabled = false;
    };

    const currentRenderer = this.renderer; // Capture renderer for async operations

    const startSession = async (mode: XRSessionMode, sessionInit: XRSessionInit = {}) => {
      try {
        const session = await navigator.xr!.requestSession(mode, sessionInit);
        await currentRenderer.xr.setSession(session);
        // showExitXR() will be called by sessionstart listener
      } catch (e) {
        logger.error(`Failed to start ${mode} session:`, createErrorMetadata(e));
        // Attempt to reset button text to a valid enter state
        const arSupported = await navigator.xr!.isSessionSupported('immersive-ar').catch(() => false);
        const vrSupported = await navigator.xr!.isSessionSupported('immersive-vr').catch(() => false);
        if (this.vrButton && !currentRenderer.xr.isPresenting) { // Check if button still exists and not presenting
            if (arSupported) showEnterXR(true, 'AR');
            else if (vrSupported) showEnterXR(true, 'VR');
            else showEnterXR(false, 'XR');
        }
      }
    };

    button.onclick = async () => {
      if (currentRenderer.xr.isPresenting) {
        try {
          // sessionend event will trigger button text update via listener
          await currentRenderer.xr.getSession()?.end();
        } catch (e) {
          logger.error('Failed to end XR session:', createErrorMetadata(e));
        }
      } else {
        try {
          const arSupported = await navigator.xr!.isSessionSupported('immersive-ar');
          if (arSupported) {
            logger.info('Attempting to start AR session.');
            await startSession('immersive-ar', {
              requiredFeatures: ['local-floor'],
              optionalFeatures: ['hand-tracking', 'hit-test', 'anchors', 'plane-detection', 'light-estimation'],
            });
          } else {
            logger.info('AR not supported, attempting to start VR session.');
            const vrSupported = await navigator.xr!.isSessionSupported('immersive-vr');
            if (vrSupported) {
              await startSession('immersive-vr', {
                requiredFeatures: ['local-floor'],
                optionalFeatures: ['hand-tracking'],
              });
            } else {
              showEnterXR(false, 'XR');
              logger.warn('Neither AR nor VR is supported.');
            }
          }
        } catch (e) {
          logger.error('Error during session support check or start:', createErrorMetadata(e));
          showEnterXR(false, 'XR'); // Ensure button reflects error state
        }
      }
    };

    // Initial button state determination
    const setInitialButtonState = async () => {
        try {
            const arSupported = await navigator.xr!.isSessionSupported('immersive-ar');
            if (arSupported) {
                showEnterXR(true, 'AR');
            } else {
                const vrSupported = await navigator.xr!.isSessionSupported('immersive-vr');
                showEnterXR(vrSupported, vrSupported ? 'VR' : 'XR');
            }
        } catch (e) {
            logger.error('Error checking XR support for initial button state:', createErrorMetadata(e));
            showEnterXR(false, 'XR');
        }
    };

    setInitialButtonState(); // Call async function to set initial state

    this.vrButton = button;
    document.body.appendChild(this.vrButton);

    // Session event listeners
    currentRenderer.xr.addEventListener('sessionstart', () => {
      this.sessionActive = true;
      showExitXR();
      if (debugState.isEnabled()) {
        logger.info('XR session started. Environment Blend Mode:', currentRenderer.xr.getSession()?.environmentBlendMode);
      }
    });

    currentRenderer.xr.addEventListener('sessionend', () => {
      this.sessionActive = false;
      // Reset button to initial state after a short delay
      setTimeout(() => {
        if (this.vrButton && !currentRenderer.xr.isPresenting) { // Check button exists and not already re-entered XR
            setInitialButtonState();
        }
      }, 100);
      if (debugState.isEnabled()) {
        logger.info('XR session ended');
      }
    });
  }

  private setupControllers(): void {
    if (!this.renderer || !this.scene) return;

    try {
      // Create controllers
      for (let i = 0; i < 2; i++) {
        // Controller
        const controller = this.renderer.xr.getController(i);
        controller.addEventListener('selectstart', (event) => this.handleSelectStart(event, i));
        controller.addEventListener('selectend', (event) => this.handleSelectEnd(event, i));
        controller.addEventListener('squeezestart', (event) => this.handleSqueezeStart(event, i));
        controller.addEventListener('squeezeend', (event) => this.handleSqueezeEnd(event, i));
        controller.addEventListener('connected', (event) => {
          if (debugState.isEnabled()) {
            logger.info(`Controller ${i} connected:`, {
              handedness: (event as any).data?.handedness,
              targetRayMode: (event as any).data?.targetRayMode
            });
          }
        });
        controller.addEventListener('disconnected', () => {
          if (debugState.isEnabled()) {
            logger.info(`Controller ${i} disconnected`);
          }
        });

        this.scene.add(controller);
        this.controllers.push(controller as THREE.XRTargetRaySpace);

        // Controller grip
        const controllerGrip = this.renderer.xr.getControllerGrip(i);
        if (this.controllerModelFactory) {
          controllerGrip.add(this.controllerModelFactory.createControllerModel(controllerGrip));
        }
        this.scene.add(controllerGrip);
        this.controllerGrips.push(controllerGrip);

        // Add visual indicators for the controllers
        const geometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 0, -1)
        ]);

        const line = new THREE.Line(geometry);
        line.name = 'controller-line';
        line.scale.z = 5;

        controller.add(line);
        controller.userData.selectPressed = false;
        controller.userData.squeezePressed = false;
      }

      if (debugState.isEnabled()) {
        logger.info('XR controllers set up successfully');
      }
    } catch (error) {
      logger.error('Failed to set up XR controllers:', createErrorMetadata(error));
    }
  }

  // Event handlers
  private handleSelectStart(event: any, controllerId: number): void {
    if (controllerId >= this.controllers.length) return;

    const controller = this.controllers[controllerId];
    controller.userData.selectPressed = true;

    const inputSource = event.data;
    if (debugState.isDataDebugEnabled()) {
      logger.debug(`Controller ${controllerId} select start`);
    }

    this.selectStartHandlers.forEach(handler => {
      try {
        handler({ controller, inputSource, data: event.data });
      } catch (error) {
        logger.error('Error in selectStart handler:', createErrorMetadata(error));
      }
    });
  }

  private handleSelectEnd(event: any, controllerId: number): void {
    if (controllerId >= this.controllers.length) return;

    const controller = this.controllers[controllerId];
    controller.userData.selectPressed = false;

    const inputSource = event.data;
    if (debugState.isDataDebugEnabled()) {
      logger.debug(`Controller ${controllerId} select end`);
    }

    this.selectEndHandlers.forEach(handler => {
      try {
        handler({ controller, inputSource, data: event.data });
      } catch (error) {
        logger.error('Error in selectEnd handler:', createErrorMetadata(error));
      }
    });
  }

  private handleSqueezeStart(event: any, controllerId: number): void {
    if (controllerId >= this.controllers.length) return;

    const controller = this.controllers[controllerId];
    controller.userData.squeezePressed = true;

    const inputSource = event.data;
    if (debugState.isDataDebugEnabled()) {
      logger.debug(`Controller ${controllerId} squeeze start`);
    }

    this.squeezeStartHandlers.forEach(handler => {
      try {
        handler({ controller, inputSource, data: event.data });
      } catch (error) {
        logger.error('Error in squeezeStart handler:', createErrorMetadata(error));
      }
    });
  }

  private handleSqueezeEnd(event: any, controllerId: number): void {
    if (controllerId >= this.controllers.length) return;

    const controller = this.controllers[controllerId];
    controller.userData.squeezePressed = false;

    const inputSource = event.data;
    if (debugState.isDataDebugEnabled()) {
      logger.debug(`Controller ${controllerId} squeeze end`);
    }

    this.squeezeEndHandlers.forEach(handler => {
      try {
        handler({ controller, inputSource, data: event.data });
      } catch (error) {
        logger.error('Error in squeezeEnd handler:', createErrorMetadata(error));
      }
    });
  }

  // Event subscription methods
  public onSelectStart(handler: XRControllerEventHandler): () => void {
    this.selectStartHandlers.push(handler);
    return () => {
      this.selectStartHandlers = this.selectStartHandlers.filter(h => h !== handler);
    };
  }

  public onSelectEnd(handler: XRControllerEventHandler): () => void {
    this.selectEndHandlers.push(handler);
    return () => {
      this.selectEndHandlers = this.selectEndHandlers.filter(h => h !== handler);
    };
  }

  public onSqueezeStart(handler: XRControllerEventHandler): () => void {
    this.squeezeStartHandlers.push(handler);
    return () => {
      this.squeezeStartHandlers = this.squeezeStartHandlers.filter(h => h !== handler);
    };
  }

  public onSqueezeEnd(handler: XRControllerEventHandler): () => void {
    this.squeezeEndHandlers.push(handler);
    return () => {
      this.squeezeEndHandlers = this.squeezeEndHandlers.filter(h => h !== handler);
    };
  }

  // New event subscription methods for hand interactions
  public onGestureRecognized(handler: GestureEventHandler): () => void {
    this.gestureRecognizedHandlers.push(handler);
    return () => {
      this.gestureRecognizedHandlers = this.gestureRecognizedHandlers.filter(h => h !== handler);
    };
  }

  public onHandsVisibilityChanged(handler: HandVisibilityHandler): () => void {
    this.handsVisibilityChangedHandlers.push(handler);
    return () => {
      this.handsVisibilityChangedHandlers = this.handsVisibilityChangedHandlers.filter(h => h !== handler);
    };
  }

  // Method to notify gesture events
  public notifyGestureRecognized(gesture: GestureRecognitionResult): void {
    this.gestureRecognizedHandlers.forEach(handler => {
      try {
        handler(gesture);
      } catch (error) {
        logger.error('Error in gesture recognition handler:', createErrorMetadata(error));
      }
    });
  }

  // Method to notify hand visibility changes
  public notifyHandsVisibilityChanged(visible: boolean): void {
    this.handsVisibilityChangedHandlers.forEach(handler => {
      try {
        handler(visible);
      } catch (error) {
        logger.error('Error in hand visibility handler:', createErrorMetadata(error));
      }
    });
  }

  // XR state methods
  public isSessionActive(): boolean {
    return this.sessionActive;
  }

  public getControllers(): THREE.XRTargetRaySpace[] {
    return this.controllers;
  }

  public getControllerGrips(): THREE.Object3D[] {
    return this.controllerGrips;
  }

  public getRenderer(): THREE.WebGLRenderer | null {
    return this.renderer;
  }

  public updateSettings(settings: Settings): void {
    this.settings = settings;

    // Update reference space if settings changed
    if (this.renderer && settings.xr) {
      this.renderer.xr.setReferenceSpaceType(
        settings.xr.locomotionMethod === 'teleport' ? 'local-floor' : 'local'
      );
    }
  }

  public dispose(): void {
    try {
      // End active session first
      if (this.sessionActive && this.renderer?.xr.isPresenting) {
        const session = this.renderer.xr.getSession();
        if (session) {
          session.end().catch(error => {
            logger.error('Error ending XR session during disposal:', error);
          });
        }
      }

      // Remove controllers from scene and clear event listeners
      this.controllers.forEach((controller, index) => {
        try {
          // Remove from scene
          if (controller.parent) {
            controller.removeFromParent();
          }

          // Clear controller-specific data
          if (controller.userData) {
            controller.userData.selectPressed = false;
            controller.userData.squeezePressed = false;
          }

          // Remove visual indicators (lines, etc.)
          const line = controller.getObjectByName('controller-line');
          if (line) {
            controller.remove(line);
            // Properly dispose of geometry and material if it's a Line object
            if (line instanceof THREE.Line) {
              if (line.geometry) line.geometry.dispose();
              if (line.material) {
                if (Array.isArray(line.material)) {
                  line.material.forEach(mat => mat.dispose());
                } else {
                  line.material.dispose();
                }
              }
            }
          }
        } catch (error) {
          logger.error(`Error disposing controller ${index}:`, error);
        }
      });

      // Remove controller grips and their models
      this.controllerGrips.forEach((grip, index) => {
        try {
          if (grip.parent) {
            grip.removeFromParent();
          }

          // Dispose of controller models created by XRControllerModelFactory
          grip.traverse((child) => {
            if (child instanceof THREE.Mesh) {
              if (child.geometry) child.geometry.dispose();
              if (child.material) {
                if (Array.isArray(child.material)) {
                  child.material.forEach(mat => mat.dispose());
                } else {
                  child.material.dispose();
                }
              }
            }
          });
        } catch (error) {
          logger.error(`Error disposing controller grip ${index}:`, error);
        }
      });

      // Remove VR button safely
      if (this.vrButton) {
        try {
          if (this.vrButton.parentNode) {
            this.vrButton.parentNode.removeChild(this.vrButton);
          }
        } catch (error) {
          logger.error('Error removing VR button:', error);
        }
      }

      // Clear all event listeners and handler arrays
      this.selectStartHandlers.length = 0;
      this.selectEndHandlers.length = 0;
      this.squeezeStartHandlers.length = 0;
      this.squeezeEndHandlers.length = 0;
      this.gestureRecognizedHandlers.length = 0;
      this.handsVisibilityChangedHandlers.length = 0;
      this.handTrackingStateHandlers.length = 0;

      // Clear arrays
      this.controllers.length = 0;
      this.controllerGrips.length = 0;

      // Clear factory reference
      this.controllerModelFactory = null;

      // Clear renderer XR session listeners if renderer exists
      if (this.renderer?.xr) {
        try {
          // Note: We can't remove specific listeners without references,
          // but setting to null will prevent new events from being processed
          this.renderer.xr.enabled = false;
        } catch (error) {
          logger.error('Error disabling XR on renderer:', error);
        }
      }

      // Clear object references
      this.renderer = null;
      this.camera = null;
      this.scene = null;
      this.vrButton = null;
      this.settings = null;

      // Reset state flags
      this.sessionActive = false;

      if (debugState.isEnabled()) {
        logger.info('XR session manager disposed with complete resource cleanup');
      }
    } catch (error) {
      logger.error('Error during XR session manager disposal:', error);
    }
  }
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/xr/providers/SafeXRProvider.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/xr/providers/SafeXRProvider.tsx
```tsx
import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';
import { useSettingsStore } from '../../../store/settingsStore';
import { createLogger } from '../../../utils/logger';

const logger = createLogger('SafeXRProvider');

interface XRContextProps {
  isXRCapable: boolean;
  isXRSupported: boolean;
}

const XRContext = createContext<XRContextProps>({
  isXRCapable: false,
  isXRSupported: false,
});

export const useXR = () => useContext(XRContext);

interface SafeXRProviderProps {
  children: ReactNode;
}

const SafeXRProvider: React.FC<SafeXRProviderProps> = ({ children }) => {
  const [isXRCapable, setIsXRCapable] = useState(false);
  const [isXRSupported, setIsXRSupported] = useState(false);
  const { settings } = useSettingsStore();

  useEffect(() => {
    const checkXRSupport = async () => {
      try {
        if ('xr' in navigator) {
          const supported = await (navigator.xr as any).isSessionSupported('immersive-vr');
          setIsXRSupported(supported);
          setIsXRCapable(true);
          logger.info('XR is capable and immersive VR is supported.');
        } else {
          setIsXRCapable(false);
          setIsXRSupported(false);
          logger.warn('XR is not available in this browser.');
        }
      } catch (error) {
        setIsXRCapable(false);
        setIsXRSupported(false);
        logger.error('Error checking XR support:', error);
      }
    };

    checkXRSupport();
  }, []);

  useEffect(() => {
      const debugEnabled = settings?.system?.debug?.enabled === true
    if (debugEnabled) {
      logger.info(`XR capability changed: capable=${isXRCapable}, supported=${isXRSupported}`);
    }
  }, [isXRCapable, isXRSupported, settings?.system?.debug?.enabled]);

  return (
    <XRContext.Provider value={{ isXRCapable, isXRSupported }}>
      {children}
    </XRContext.Provider>
  );
};

export default SafeXRProvider;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/xr/providers/XRContextWrapper.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/xr/providers/XRContextWrapper.tsx
```tsx
import React from 'react';
import { useXR } from '@react-three/xr';
import { createLogger } from '@/utils/logger';

const logger = createLogger('XRContextWrapper');

/**
 * A higher-order component (HOC) that safely wraps components that use XR features.
 * This prevents "XR features can only be used inside the <XR> component" errors by
 * checking if we're in a valid XR context before rendering the wrapped component.
 */
export const withXRContext = <P extends object>(
  Component: React.ComponentType<P>,
  componentName: string = 'Component'
): React.FC<P> => {
  const WrappedComponent: React.FC<P> = (props) => {
    try {
      // This will throw an error if we're outside an XR context
      const xr = useXR();

      // If we get here, the XR context is valid
      return <Component {...props} />;
    } catch (error) {
      // If we're here, we're outside an XR context
      logger.debug(`Not rendering ${componentName} - outside XR context`);
      return null;
    }
  };

  // Set a display name for better debugging
  WrappedComponent.displayName = `withXRContext(${componentName})`;

  return WrappedComponent;
};

export default withXRContext;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/xr/providers/XRCoreProvider.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/xr/providers/XRCoreProvider.tsx
```tsx
import React, { createContext, useContext, useEffect, useState, ReactNode, useCallback, useRef } from 'react';
import { XRSessionManager } from '../managers/xrSessionManager';
import { SceneManager } from '../../visualisation/managers/sceneManager';
import { useSettingsStore } from '../../../store/settingsStore';
import { createLogger } from '../../../utils/logger';
import * as THREE from 'three';

const logger = createLogger('XRCoreProvider');

interface XRCoreContextProps {
  isXRCapable: boolean;
  isXRSupported: boolean;
  isSessionActive: boolean;
  sessionType: XRSessionMode | null;
  isPresenting: boolean;
  controllers: THREE.XRTargetRaySpace[];
  controllerGrips: THREE.Object3D[];
  handsVisible: boolean;
  handTrackingEnabled: boolean;
  sessionManager: XRSessionManager | null;
  // Session management methods
  startSession: (mode?: XRSessionMode) => Promise<void>;
  endSession: () => Promise<void>;
  // Event subscription methods
  onSessionStart: (callback: (session: XRSession) => void) => () => void;
  onSessionEnd: (callback: () => void) => () => void;
  onControllerConnect: (callback: (controller: THREE.XRTargetRaySpace) => void) => () => void;
  onControllerDisconnect: (callback: (controller: THREE.XRTargetRaySpace) => void) => () => void;
}

const XRCoreContext = createContext<XRCoreContextProps>({
  isXRCapable: false,
  isXRSupported: false,
  isSessionActive: false,
  sessionType: null,
  isPresenting: false,
  controllers: [],
  controllerGrips: [],
  handsVisible: false,
  handTrackingEnabled: false,
  sessionManager: null,
  startSession: async () => {},
  endSession: async () => {},
  onSessionStart: () => () => {},
  onSessionEnd: () => () => {},
  onControllerConnect: () => () => {},
  onControllerDisconnect: () => () => {},
});

export const useXRCore = () => useContext(XRCoreContext);

interface XRCoreProviderProps {
  children: ReactNode;
  sceneManager?: SceneManager;
  renderer?: THREE.WebGLRenderer;
}

const XRCoreProvider: React.FC<XRCoreProviderProps> = ({
  children,
  sceneManager: externalSceneManager,
  renderer: externalRenderer
}) => {
  // Basic XR capability state
  const [isXRCapable, setIsXRCapable] = useState(false);
  const [isXRSupported, setIsXRSupported] = useState(false);

  // Session state
  const [isSessionActive, setIsSessionActive] = useState(false);
  const [sessionType, setSessionType] = useState<XRSessionMode | null>(null);
  const [isPresenting, setIsPresenting] = useState(false);

  // Controller and hand tracking state
  const [controllers, setControllers] = useState<THREE.XRTargetRaySpace[]>([]);
  const [controllerGrips, setControllerGrips] = useState<THREE.Object3D[]>([]);
  const [handsVisible, setHandsVisible] = useState(false);
  const [handTrackingEnabled, setHandTrackingEnabled] = useState(false);

  // Session manager and event handlers
  const sessionManagerRef = useRef<XRSessionManager | null>(null);
  const sessionStartCallbacksRef = useRef<Set<(session: XRSession) => void>>(new Set());
  const sessionEndCallbacksRef = useRef<Set<() => void>>(new Set());
  const controllerConnectCallbacksRef = useRef<Set<(controller: THREE.XRTargetRaySpace) => void>>(new Set());
  const controllerDisconnectCallbacksRef = useRef<Set<(controller: THREE.XRTargetRaySpace) => void>>(new Set());

  // Cleanup tracking
  const cleanupFunctionsRef = useRef<Set<() => void>>(new Set());

  const { settings } = useSettingsStore();

  // Initialize XR capability detection (Quest 3 AR focused)
  useEffect(() => {
    const checkXRSupport = async () => {
      try {
        if ('xr' in navigator) {
          // Prioritize AR support for Quest 3
          const arSupported = await (navigator.xr as any).isSessionSupported('immersive-ar');

          setIsXRSupported(arSupported);
          setIsXRCapable(true);

          if (arSupported) {
            if (settings?.system?.debug?.enabled) {
              logger.info('Quest 3 AR mode detected and supported');
            }
          } else {
            logger.warn('Quest 3 AR mode not supported - immersive-ar session required');
          }
        } else {
          setIsXRCapable(false);
          setIsXRSupported(false);
          logger.warn('WebXR not available - Quest 3 browser required');
        }
      } catch (error) {
        setIsXRCapable(false);
        setIsXRSupported(false);
        logger.error('Error checking XR support:', error);
      }
    };

    checkXRSupport();
  }, [settings?.system?.debug?.enabled]);

  // Initialize session manager when XR is supported and dependencies are available
  useEffect(() => {
    if (!isXRSupported || sessionManagerRef.current) return;

    try {
      // Use external scene manager or create a default one
      let sceneManager = externalSceneManager;
      if (!sceneManager) {
        // Create a minimal scene manager for XR if none provided
        logger.warn('No SceneManager provided, XR functionality may be limited');
        return;
      }

      // Initialize XR session manager
      const sessionManager = XRSessionManager.getInstance(sceneManager, externalRenderer);
      sessionManager.initialize(settings);
      sessionManagerRef.current = sessionManager;

      // Set up session event listeners
      const handleSessionStart = () => {
        setIsSessionActive(true);
        setIsPresenting(true);

        // Get current session to determine type
        const session = sessionManager.getRenderer()?.xr.getSession();
        if (session) {
          // XRSession doesn't expose mode directly, so we'll track it via the session request
          // For now, we'll detect based on environment blend mode or other properties
          const environmentBlendMode = session.environmentBlendMode;
          if (environmentBlendMode === 'additive' || environmentBlendMode === 'alpha-blend') {
            setSessionType('immersive-ar');
          } else {
            setSessionType('immersive-vr');
          }

          // Notify callbacks
          sessionStartCallbacksRef.current.forEach(callback => {
            try {
              callback(session);
            } catch (error) {
              logger.error('Error in session start callback:', error);
            }
          });
        }

        logger.info('XR session started');
      };

      const handleSessionEnd = () => {
        // Clean up all XR resources
        performCompleteCleanup();

        setIsSessionActive(false);
        setIsPresenting(false);
        setSessionType(null);
        setControllers([]);
        setControllerGrips([]);
        setHandsVisible(false);
        setHandTrackingEnabled(false);

        // Notify callbacks
        sessionEndCallbacksRef.current.forEach(callback => {
          try {
            callback();
          } catch (error) {
            logger.error('Error in session end callback:', error);
          }
        });

        logger.info('XR session ended and resources cleaned up');
      };

      // Get renderer for event subscription
      const renderer = sessionManager.getRenderer();
      if (renderer) {
        renderer.xr.addEventListener('sessionstart', handleSessionStart);
        renderer.xr.addEventListener('sessionend', handleSessionEnd);

        // Store cleanup functions
        cleanupFunctionsRef.current.add(() => {
          renderer.xr.removeEventListener('sessionstart', handleSessionStart);
          renderer.xr.removeEventListener('sessionend', handleSessionEnd);
        });
      }

      // Set up controller tracking
      const updateControllerState = () => {
        if (sessionManager) {
          setControllers([...sessionManager.getControllers()]);
          setControllerGrips([...sessionManager.getControllerGrips()]);
        }
      };

      // Update controller state periodically during session
      const controllerUpdateInterval = setInterval(() => {
        if (isSessionActive) {
          updateControllerState();
        }
      }, 100);

      cleanupFunctionsRef.current.add(() => {
        clearInterval(controllerUpdateInterval);
      });

      logger.info('XR Core Provider initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize XR session manager:', error);
    }
  }, [isXRSupported, settings, externalSceneManager, externalRenderer]);

  // Complete cleanup function
  const performCompleteCleanup = useCallback(() => {
    try {
      // Run all registered cleanup functions
      cleanupFunctionsRef.current.forEach(cleanup => {
        try {
          cleanup();
        } catch (error) {
          logger.error('Error during cleanup:', error);
        }
      });

      // Dispose session manager resources
      if (sessionManagerRef.current) {
        sessionManagerRef.current.dispose();
      }

      // Clear event handler sets
      sessionStartCallbacksRef.current.clear();
      sessionEndCallbacksRef.current.clear();
      controllerConnectCallbacksRef.current.clear();
      controllerDisconnectCallbacksRef.current.clear();
      cleanupFunctionsRef.current.clear();

      logger.info('Complete XR resource cleanup performed');
    } catch (error) {
      logger.error('Error during complete cleanup:', error);
    }
  }, []);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      performCompleteCleanup();
    };
  }, [performCompleteCleanup]);

  // Session management methods (Quest 3 AR focused)
  const startSession = useCallback(async (mode: XRSessionMode = 'immersive-ar') => {
    if (!sessionManagerRef.current || !isXRSupported) {
      throw new Error('Quest 3 AR not supported or session manager not initialized');
    }

    try {
      // Quest 3 AR optimized session configuration
      const sessionInit: XRSessionInit = {
        requiredFeatures: ['local-floor'],
        optionalFeatures: [
          'hand-tracking',      // Quest 3 hand tracking
          'hit-test',           // AR hit testing
          'anchors',            // AR anchors
          'plane-detection',    // Quest 3 plane detection
          'light-estimation',   // AR lighting estimation
          'depth-sensing',      // Quest 3 depth sensing
          'mesh-detection'      // Quest 3 mesh detection
        ],
      };

      if (settings?.system?.debug?.enabled) {
        logger.info(`Starting Quest 3 ${mode} session with AR features`);
      }

      const session = await navigator.xr!.requestSession(mode, sessionInit);
      const renderer = sessionManagerRef.current.getRenderer();
      if (renderer) {
        await renderer.xr.setSession(session);
      }
    } catch (error) {
      logger.error(`Failed to start Quest 3 ${mode} session:`, error);
      throw error;
    }
  }, [isXRSupported, settings?.system?.debug?.enabled]);

  const endSession = useCallback(async () => {
    if (!sessionManagerRef.current) return;

    try {
      const renderer = sessionManagerRef.current.getRenderer();
      const session = renderer?.xr.getSession();
      if (session) {
        await session.end();
      }
    } catch (error) {
      logger.error('Failed to end XR session:', error);
      throw error;
    }
  }, []);

  // Event subscription methods
  const onSessionStart = useCallback((callback: (session: XRSession) => void) => {
    sessionStartCallbacksRef.current.add(callback);
    return () => {
      sessionStartCallbacksRef.current.delete(callback);
    };
  }, []);

  const onSessionEnd = useCallback((callback: () => void) => {
    sessionEndCallbacksRef.current.add(callback);
    return () => {
      sessionEndCallbacksRef.current.delete(callback);
    };
  }, []);

  const onControllerConnect = useCallback((callback: (controller: THREE.XRTargetRaySpace) => void) => {
    controllerConnectCallbacksRef.current.add(callback);
    return () => {
      controllerConnectCallbacksRef.current.delete(callback);
    };
  }, []);

  const onControllerDisconnect = useCallback((callback: (controller: THREE.XRTargetRaySpace) => void) => {
    controllerDisconnectCallbacksRef.current.add(callback);
    return () => {
      controllerDisconnectCallbacksRef.current.delete(callback);
    };
  }, []);

  const contextValue: XRCoreContextProps = {
    isXRCapable,
    isXRSupported,
    isSessionActive,
    sessionType,
    isPresenting,
    controllers,
    controllerGrips,
    handsVisible,
    handTrackingEnabled,
    sessionManager: sessionManagerRef.current,
    startSession,
    endSession,
    onSessionStart,
    onSessionEnd,
    onControllerConnect,
    onControllerDisconnect,
  };

  return (
    <XRCoreContext.Provider value={contextValue}>
      {children}
    </XRCoreContext.Provider>
  );
};

export default XRCoreProvider;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/xr/systems/HandInteractionSystem.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/xr/systems/HandInteractionSystem.tsx
```tsx
import React, { useRef, useEffect, useState } from 'react';
import * as THREE from 'three'; // Add this line
import { Group, Line, Raycaster, BufferGeometry, Vector3, Matrix4, LineBasicMaterial, Object3D } from 'three';
import { useFrame, useThree } from '@react-three/fiber';
import { Interactive } from '@react-three/xr';
import { usePlatform } from '../../../services/platformManager';
import { useSettingsStore } from '../../../store/settingsStore';
import { createLogger } from '../../../utils/logger';
import { GestureState, XRInteractionMode, InteractableObject } from '../types/xr';

const logger = createLogger('HandInteraction');

type XRHandedness = 'left' | 'right' | 'none';

type InteractionEventType = 'select' | 'hover' | 'unhover' | 'squeeze' | 'move';
type InteractionDistance = 'near' | 'far';
type InteractionEvent = {
  type: InteractionEventType,
  distance: InteractionDistance,
  controller?: Object3D,
  hand?: XRHandedness,
  point?: [number, number, number]
};

export interface GestureRecognitionResult {
  gesture: string;
  confidence: number;
  hand: XRHandedness;
}

interface HandInteractionSystemProps {
  children?: React.ReactNode;
  onGestureRecognized?: (gesture: GestureRecognitionResult) => void;
  onHandsVisible?: (visible: boolean) => void;
  enabled?: boolean;
  interactionMode?: XRInteractionMode;
  interactionDistance?: number;
  hapticFeedback?: boolean;
}

/**
 * Modern hand interaction system for WebXR
 * Uses React Three Fiber for Quest hand tracking
 */
export const HandInteractionSystem: React.FC<HandInteractionSystemProps> = ({
  children,
  onGestureRecognized,
  onHandsVisible,
  enabled = true,
  interactionMode = 'both',
  interactionDistance = 1.5,
  hapticFeedback = true
}) => {
  const { scene, gl, camera } = useThree();
  const { isPresenting, session, controllers, player } = useSafeXR();
  const platform = usePlatform();
  const settings = useSettingsStore(state => state.settings.xr);
  const handTrackingEnabled = settings.handTracking && enabled;

  // State for hands and interaction
  const [handsVisible, setHandsVisible] = useState(false);
  const [visualizeHands, setVisualizeHands] = useState(false);
  const [interactables, setInteractables] = useState<InteractableObject[]>([]);
  const [selectedObject, setSelectedObject] = useState<Object3D | null>(null);
  const [hoveredObject, setHoveredObject] = useState<Object3D | null>(null);

  // References for hand state
  const leftHandRef = useRef<Group | null>(null);
  const rightHandRef = useRef<Group | null>(null);
  const leftControllerRef = useRef<Group | null>(null);
  const rightControllerRef = useRef<Group | null>(null);
  const leftRayRef = useRef<Line | null>(null);
  const rightRayRef = useRef<Line | null>(null);

  // Gesture state reference
  const gestureStateRef = useRef<GestureState>({
    left: { pinch: false, grip: false, point: false, thumbsUp: false },
    right: { pinch: false, grip: false, point: false, thumbsUp: false }
  });

  // Raycaster for interaction
  const raycasterRef = useRef<Raycaster>(new Raycaster());

  // Initialize raycaster with proper settings
  useEffect(() => {
    if (raycasterRef.current) {
      raycasterRef.current.near = 0.01;
      raycasterRef.current.far = interactionDistance;
      (raycasterRef.current.params as any).Line = { threshold: 0.2 };
      (raycasterRef.current.params as any).Points = { threshold: 0.2 };
    }
  }, [interactionDistance]);

  // Collect all interactable objects in the scene
  useEffect(() => {
    // In a real implementation, this would scan the scene for objects with interactable components
    // For now, we'll just have an empty array that would be populated by components
  }, [scene]);

  // Map to store joint objects
  const jointsRef = useRef<Map<string, Object3D>>(new Map());

  // Initialize hand tracking
  useEffect(() => {
    if (!handTrackingEnabled) return;

    // Create hand groups if they don't exist
    if (!leftHandRef.current) {
      leftHandRef.current = new Group();
      (leftHandRef.current as any).name = 'left-hand';
      scene.add(leftHandRef.current);
    }

    // Create controller rays if they don't exist
    if (!leftRayRef.current) {
      const geometry = new BufferGeometry();
      // Manually create points instead of using Vector3 constructor
      const points = [
        { x: 0, y: 0, z: 0 },
        { x: 0, y: 0, z: -interactionDistance }
      ];
      const rayGeometry = (geometry as any).setFromPoints(
        points.map(p => new (THREE as any).Vector3(p.x, p.y, p.z))
      );
      const rayMaterial = new (THREE as any).LineBasicMaterial({
        color: settings.controllerRayColor || 0x00ff00,
        opacity: 0.7,
        transparent: true
      });
      leftRayRef.current = new (THREE as any).Line(rayGeometry, rayMaterial);
    }

    if (!rightHandRef.current) {
      rightHandRef.current = new Group();
      (rightHandRef.current as any).name = 'right-hand';
      scene.add(rightHandRef.current);
    }

    // Create right controller ray
    if (!rightRayRef.current) {
      const geometry = new BufferGeometry();
      // Manually create points instead of using Vector3 constructor
      const points = [
        { x: 0, y: 0, z: 0 },
        { x: 0, y: 0, z: -interactionDistance }
      ];
      const rayGeometry = (geometry as any).setFromPoints(
        points.map(p => new (THREE as any).Vector3(p.x, p.y, p.z))
      );
      const rayMaterial = new (THREE as any).LineBasicMaterial({
        color: settings.controllerRayColor || 0x00ff00,
        opacity: 0.7,
        transparent: true
      });
      rightRayRef.current = new (THREE as any).Line(rayGeometry, rayMaterial);
    }
    logger.info('Hand tracking system initialized');

    // Return cleanup function
    return () => {
      if (leftHandRef.current) {
        scene.remove(leftHandRef.current);
        leftHandRef.current = null;
      }

      if (rightHandRef.current) {
        scene.remove(rightHandRef.current);
        rightHandRef.current = null;
      }

      if (leftRayRef.current) {
        scene.remove(leftRayRef.current);
        leftRayRef.current = null;
      }

      if (rightRayRef.current) {
        scene.remove(rightHandRef.current);
        rightHandRef.current = null;
      }

      jointsRef.current.clear();
      logger.info('Hand tracking system disposed');
    };
  }, [handTrackingEnabled, scene, interactionDistance, settings.controllerRayColor]);

  // Update controller references when WebXR session changes
  useEffect(() => {
    if (!isPresenting || !platform.isWebXRSupported) return;

    // Attach to XR controllers if available
    if (controllers && controllers.length > 0) {
      controllers.forEach(controller => {
        if (controller.inputSource.handedness === 'left') {
          leftControllerRef.current = controller.controller;
          if (leftRayRef.current) {
            controller.controller.add(leftRayRef.current);
          }
        } else if (controller.inputSource.handedness === 'right') {
          rightControllerRef.current = controller.controller;
          if (rightRayRef.current) {
            controller.controller.add(rightRayRef.current);
          }
        }
      });
    }

    // Set up controller event listeners
    const handleControllerEvent = (event: any, type: InteractionEventType, hand: XRHandedness) => {
      handleInteractionEvent({
        type,
        distance: 'far',
        controller: hand === 'left' ? leftControllerRef.current as Object3D : rightControllerRef.current as Object3D,
        hand,
        point: event.intersections?.[0]?.point
      });
    };

    // Return cleanup function that removes event listeners
    return () => {
      // In a real implementation, we would remove event listeners here
    };
  }, [isPresenting, platform.isWebXRSupported, controllers, hapticFeedback]);

  // Handle various interaction events from controllers or hand tracking
  const handleInteractionEvent = (event: InteractionEvent) => {
    // Process different event types
    switch (event.type) {
      case 'select':
        // Handle selection (trigger press)
        if (hoveredObject) {
          setSelectedObject(hoveredObject);

          // Trigger haptic feedback if enabled
          if (hapticFeedback && event.controller && session) {
            const gamepad = (event.controller as any).inputSource?.gamepad;
            if (gamepad && gamepad.hapticActuators && gamepad.hapticActuators[0]) {
              gamepad.hapticActuators[0].pulse(0.5, 100);
            }
          }

          logger.info(`Selected object: ${hoveredObject.name}`);
        }
        break;

      case 'hover':
        // Handle hover state (ray pointing at object)
        if (event.point && event.controller) {
          setHoveredObject(event.controller);
          logger.debug(`Hovering object at ${event.point[0]}, ${event.point[1]}, ${event.point[2]}`);
        }
        break;

      case 'unhover':
        // Clear hover state
        setHoveredObject(null);
        break;

      case 'squeeze':
        // Handle grip button press
        if (selectedObject) {
          logger.info(`Squeezing object: ${selectedObject.name}`);

          // Trigger stronger haptic feedback for squeeze
          if (hapticFeedback && event.controller && session) {
            const gamepad = (event.controller as any).inputSource?.gamepad;
            if (gamepad && gamepad.hapticActuators && gamepad.hapticActuators[0]) {
              gamepad.hapticActuators[0].pulse(0.8, 150);
            }
          }
        }
        break;

      case 'move':
        // Handle movement of selected object
        if (selectedObject && event.controller) {
          // In a real implementation, this would update the position/rotation of the selected object
          logger.debug(`Moving selected object with controller`);
        }
        break;
    }
  };

  // Perform gesture recognition on hand joints
  const recognizeGestures = (handedness: XRHandedness, joints: Map<string, Object3D>) => {
    if (joints.size === 0) return;

    // Get key finger joints for gesture recognition
    const thumbTip = joints.get('thumb-tip');
    const indexTip = joints.get('index-finger-tip');
    const indexMiddle = joints.get('index-finger-phalanx-intermediate');
    const middleTip = joints.get('middle-finger-tip');
    const ringTip = joints.get('ring-finger-tip');
    const pinkyTip = joints.get('pinky-finger-tip');
    const wrist = joints.get('wrist');

    if (!thumbTip || !indexTip || !wrist) return;

    // Check thumb-index pinch
    // Calculate distance using tuple positions
    const thumbPos = [(thumbTip as any).position.x, (thumbTip as any).position.y, (thumbTip as any).position.z] as const;
    const indexPos = [(indexTip as any).position.x, (indexTip as any).position.y, (indexTip as any).position.z] as const;
    const dx = thumbPos[0] - indexPos[0];
    const dy = thumbPos[1] - indexPos[1];
    const dz = thumbPos[2] - indexPos[2];
    const thumbToIndexDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);
    const isPinching = thumbToIndexDistance < 0.03; // 3cm threshold

    // Check point gesture (index extended, others curled)
    const isPointing = false; // Simplified - would check index extension and other fingers curled

    // Check grip gesture (all fingers curled)
    const isGripping = false; // Simplified - would check all fingers curled

    // Check thumbs up gesture
    const isThumbsUp = false; // Simplified - would check thumb orientation

    // Update gesture state
    const previousState = gestureStateRef.current[handedness];
    gestureStateRef.current[handedness] = {
      pinch: isPinching,
      grip: isGripping,
      point: isPointing,
      thumbsUp: isThumbsUp
    };

    // Notify about gesture changes
    if (isPinching && !previousState.pinch && onGestureRecognized) {
      onGestureRecognized({
        gesture: 'pinch',
        confidence: 0.9,
        hand: handedness
      });

      // Trigger interaction event for pinch
      handleInteractionEvent({ type: 'select', distance: 'near', hand: handedness });
    }
  };

  // Process hand data on each frame
  useFrame(({ clock }) => {
    if (!handTrackingEnabled || !isPresenting) return;

    // Process controller raycasting for far interaction
    if (interactionMode !== 'hands-only' && (leftControllerRef.current || rightControllerRef.current)) {
      // Perform raycasting from controllers to detect interactive objects
      if (leftControllerRef.current) {
        const origin = (raycasterRef.current.ray.origin as any);
        origin.setFromMatrixPosition((leftControllerRef.current as any).matrixWorld);

        const direction = (raycasterRef.current.ray.direction as any);
        direction.set(0, 0, -1);
        direction.applyMatrix4(
          new (THREE as any).Matrix4().extractRotation((leftControllerRef.current as any).matrixWorld)
        );

        const intersects = raycasterRef.current.intersectObjects(
          interactables.map(obj => obj.object),
          false
        );

        if (intersects.length > 0) {
          handleInteractionEvent({
            type: 'hover',
            distance: 'far',
            controller: leftControllerRef.current as Object3D,
            hand: 'left',
            point: [
              (intersects[0].point as any).x,
              (intersects[0].point as any).y,
              (intersects[0].point as any).z
            ]
          });
        }
      }

      // Same for right controller
      if (rightControllerRef.current) {
        // Similar raycasting logic for right controller
      }
    }

    // Process hand tracking for near interaction
    if (interactionMode !== 'controllers-only' && (leftHandRef.current || rightHandRef.current)) {
      // Process joints and recognize gestures for left hand
      if (leftHandRef.current && (leftHandRef.current as any).children.length > 0) {
        const leftJoints = new Map<string, Object3D>();
        (leftHandRef.current as any).children.forEach((joint: any) => {
          leftJoints.set(joint.name, joint);
        });

        recognizeGestures('left', leftJoints);
      }

      // Process joints and recognize gestures for right hand
      if (rightHandRef.current && (rightHandRef.current as any).children.length > 0) {
        const rightJoints = new Map<string, Object3D>();
        (rightHandRef.current as any).children.forEach((joint: any) => {
          rightJoints.set(joint.name, joint);
        });

        recognizeGestures('right', rightJoints);
      }
    }
  });

  // Toggle hand visualisation for debugging
  const toggleHandVisualisation = () => {
    setVisualizeHands(!visualizeHands);
  };

  if (!handTrackingEnabled) return null;

  return (
    // Only the container group is rendered - the actual implementation is done in useFrame
    <group name="hand-interaction-system">
      {children}
    </group>
  );
};

export const useHandTracking = () => {
  const { isPresenting } = useSafeXR();

  const [pinchState, setPinchState] = useState<{left: boolean, right: boolean}>({
    left: false,
    right: false
  });

  // Hand positions state
  const [handPositions, setHandPositions] = useState<{
    left: [number, number, number] | null,
    right: [number, number, number] | null
  }>({
    left: null,
    right: null
  });

  // Gesture state
  const [gestureState, setGestureState] = useState<GestureState>({
    left: { pinch: false, grip: false, point: false, thumbsUp: false },
    right: { pinch: false, grip: false, point: false, thumbsUp: false }
  });

  // Update hand positions and gestures state from the system
  useFrame(() => {
    // If we're not in XR mode, don't try to update anything
    if (!isPresenting) {
      return;
    }
    // This would be implemented to sync with the hand tracking system
    // and update the hook's state based on the HandInteractionSystem
  });

  return {
    pinchState,
    handPositions,
    gestureState,
    isLeftHandVisible: !!handPositions.left,
    isRightHandVisible: !!handPositions.right
  };
};

export const HandInteractable: React.FC<{
  children?: React.ReactNode,
  id?: string,
  onHover?: () => void,
  onUnhover?: () => void,
  onSelect?: () => void,
  position?: [number, number, number],
  scale?: [number, number, number]
}> = ({
  children,
  id,
  onHover,
  onUnhover,
  onSelect,
  position = [0, 0, 0],
  scale = [1, 1, 1]
}) => {
  const [isHovered, setIsHovered] = useState(false);

  const handlePointerOver = () => {
    setIsHovered(true);
    if (onHover) onHover();
  };

  const handlePointerOut = () => {
    setIsHovered(false);
    if (onUnhover) onUnhover();
  };

  const handleClick = () => {
    if (onSelect) onSelect();
  };

  return (
    <group
      position={position}
      name={id || 'interactable'}
      scale={scale}
      onPointerOver={handlePointerOver}
      onPointerOut={handlePointerOut}
      onClick={handleClick}
    >
      {children}
      {isHovered && (
        // Create a simpler hover indicator without material props
        <group name="hover-indicator" scale={[1.05, 1.05, 1.05]}>
          {/* Using a primitive mesh for hover effects to avoid TypeScript errors */}
          {React.createElement('mesh', {
            children: [React.createElement('sphereGeometry', { args: [1, 16, 16] })]
          })}
        </group>
      )}
    </group>
  );
};

/**
 * This is a stub implementation for the Quest-specific XR features.
 * In a real implementation, this would integrate with the WebXR API
 * and Quest hand tracking capabilities.
 *
 * Key features that would be implemented:
 * 1. Hand tracking using WebXR Hand Input API
 * 2. Gesture recognition (pinch, grip, point)
 * 3. Proper integration with react-three/fiber and react-three/xr
 * 4. AR passthrough mode specific to Quest devices
 * 5. Performance optimizations for XR
 */

import { useSafeXR, withSafeXR } from '../hooks/useSafeXRHooks';

const SafeHandInteractionSystem = withSafeXR(HandInteractionSystem, 'HandInteractionSystem');

export default SafeHandInteractionSystem;

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/xr/types/webxr-extensions.d.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/xr/types/webxr-extensions.d.ts
```ts

declare module '@react-three/xr' {
  import { Object3D, Group } from 'three';
  import { ReactNode } from 'react';

  // Event types
  export interface XREvent extends Event {
    target: any;
  }

  export type XRHandedness = 'left' | 'right' | 'none';

  // React hooks
  export function useXR(): {
    player: Group;
    isPresenting: boolean;
    session: XRSession | null;
    controllers: Array<XRController>;
    hands: { left: XRHand, right: XRHand } | null;
    hoverState: any;
  };

  // Interactive component
  export interface InteractiveProps {
    onHover?: (event: any) => void;
    onBlur?: (event: any) => void;
    onSelect?: (event: any) => void;
    onMove?: (event: any) => void;
    onSqueeze?: (event: any) => void;
    onSqueezeEnd?: (event: any) => void;
    onSelectEnd?: (event: any) => void;
    onSelectStart?: (event: any) => void;
    onSqueezeStart?: (event: any) => void;
    children?: ReactNode;
  }

  export const Interactive: React.FC<InteractiveProps>;
  export const Hands: React.FC<any>;
  export const XR: React.FC<any>;
  export const Controllers: React.FC<any>;
  export const useController: (handedness: XRHandedness) => XRController | null;
}

interface XRHand extends Map<XRHandJoint, XRJointSpace> {
  // Additional methods and properties
  get(joint: XRHandJoint): XRJointSpace | undefined;
  keys(): IterableIterator<XRHandJoint>;
  values(): IterableIterator<XRJointSpace>;
}

interface XRJointSpace extends XRSpace {
  // Remove readonly modifier conflict
  jointName: XRHandJoint;
  space: XRSpace;
  // Remove readonly modifier conflict
  radius: number | undefined;
  pose?: XRPose;
}

type XRHandJointType =
  | 'wrist'
  | 'thumb-metacarpal'
  | 'thumb-phalanx-proximal'
  | 'thumb-phalanx-distal'
  | 'thumb-tip'
  | 'index-finger-metacarpal'
  | 'index-finger-phalanx-proximal'
  | 'index-finger-phalanx-intermediate'
  | 'index-finger-phalanx-distal'
  | 'index-finger-tip'
  | 'middle-finger-metacarpal'
  | 'middle-finger-phalanx-proximal'
  | 'middle-finger-phalanx-intermediate'
  | 'middle-finger-phalanx-distal'
  | 'middle-finger-tip'
  | 'ring-finger-metacarpal'
  | 'ring-finger-phalanx-proximal'
  | 'ring-finger-phalanx-intermediate'
  | 'ring-finger-phalanx-distal'
  | 'ring-finger-tip'
  | 'pinky-finger-metacarpal'
  | 'pinky-finger-phalanx-proximal'
  | 'pinky-finger-phalanx-intermediate'
  | 'pinky-finger-phalanx-distal'
  | 'pinky-finger-tip';

interface XRSession {
  // Avoid readonly modifier conflict
  supportedModules?: string[];
  // Match type signature from @types/webxr
  // updateTargetFrameRate(rate: number): Promise<void>;
}

interface XRFrame {
  // Match type signature from @types/webxr
  // getJointPose(joint: XRJointSpace, baseSpace: XRSpace): XRJointPose | undefined;
}

interface XRInputSource {
  // Avoid readonly modifier conflict
}

interface XRController {
  grip: THREE.Group;
  controller: THREE.Group;
  inputSource: XRInputSource;
  targetRayMode: 'gaze' | 'tracked-pointer' | 'screen';
}

interface XRJointPose extends XRPose {
  // Avoid readonly modifier conflict
}

interface XRInputSourceArray {
  length: number;
  [Symbol.iterator](): IterableIterator<XRInputSource>;
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/features/xr/types/xr.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/features/xr/types/xr.ts
```ts
import { Object3D, Vector3, Quaternion } from 'three'; // Import specific types needed

export type XRSessionState = 'inactive' | 'active' | 'ending' | 'cooldown';

export type XRControllerType = 'none' | 'hands' | 'touch' | 'gamepad' | 'gaze';

export type XRReferenceSpaceType = 'local' | 'local-floor' | 'bounded-floor' | 'unbounded' | 'viewer';

export type XRInteractionType = 'select' | 'grab' | 'drag' | 'scale' | 'rotate' | 'pinch' | 'scroll';

export type XRInteractionMode = 'controllers-only' | 'hands-only' | 'both';

export interface InteractableObject {
  object: Object3D;
  id: string;
  interactable: boolean;
  handlers?: Record<string, (event: any) => void>;
}

export type XRHandJoint =
  | 'wrist'
  | 'thumb-metacarpal'
  | 'thumb-phalanx-proximal'
  | 'thumb-phalanx-distal'
  | 'thumb-tip'
  | 'index-finger-metacarpal'
  | 'index-finger-phalanx-proximal'
  | 'index-finger-phalanx-intermediate'
  | 'index-finger-phalanx-distal'
  | 'index-finger-tip'
  | 'middle-finger-metacarpal'
  | 'middle-finger-phalanx-proximal'
  | 'middle-finger-phalanx-intermediate'
  | 'middle-finger-phalanx-distal'
  | 'middle-finger-tip'
  | 'ring-finger-metacarpal'
  | 'ring-finger-phalanx-proximal'
  | 'ring-finger-phalanx-intermediate'
  | 'ring-finger-phalanx-distal'
  | 'ring-finger-tip'
  | 'pinky-finger-metacarpal'
  | 'pinky-finger-phalanx-proximal'
  | 'pinky-finger-phalanx-intermediate'
  | 'pinky-finger-phalanx-distal'
  | 'pinky-finger-tip';

export interface XRInputSource {
  handedness: 'none' | 'left' | 'right';
  targetRayMode: 'gaze' | 'tracked-pointer' | 'screen';
  targetRaySpace: any; // XRSpace in WebXR
  gripSpace?: any; // XRSpace in WebXR
  gamepad?: Gamepad;
  profiles: string[];
  hand?: any; // XRHand in WebXR
}

export interface XRHitTestResult {
  hitMatrix: Float32Array;
  distance: number;
  objectId?: string;
}

export interface GestureState {
  left: {
    pinch: boolean;
    grip: boolean;
    point: boolean;
    thumbsUp: boolean;
  };
  right: {
    pinch: boolean;
    grip: boolean;
    point: boolean;
    thumbsUp: boolean;
  };
}

export interface XRControllerState {
  isConnected: boolean;
  isTriggerPressed: boolean;
  isGripPressed: boolean;
  isThumbstickPressed: boolean;
  thumbstickX: number;
  thumbstickY: number;
  triggerValue: number;
  gripValue: number;
  position: Vector3;
  rotation: Quaternion;
  hapticActuator?: any;
}

export interface XRSettings {
  isAREnabled: boolean;
  interactionMode: 'grab' | 'point' | 'touch';
  scale: number;
  position: [number, number, number];
  rotation: [number, number, number];
  handTrackingEnabled?: boolean; // Added setting for hand tracking
  movementSpeed?: number;
  showFloor?: boolean;
  teleportEnabled?: boolean;
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/hooks/useContainerSize.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/hooks/useContainerSize.ts
```ts
import { useState, useLayoutEffect, RefObject } from 'react';

export function useContainerSize(ref: RefObject<HTMLElement>) {
  const [size, setSize] = useState({ width: 0, height: 0 });

  useLayoutEffect(() => {
    if (!ref.current) return;
    const updateSize = () => {
      const rect = ref.current.getBoundingClientRect();
      setSize({ width: rect.width, height: rect.height });
    };
    updateSize();
    const observer = new ResizeObserver(updateSize);
    observer.observe(ref.current);
    return () => observer.disconnect();
  }, [ref]);

  return size;
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/hooks/useWindowSize.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/hooks/useWindowSize.ts
```ts
import { useState, useEffect } from 'react';

export interface WindowSize {
  width: number;
  height: number;
  pixelRatio: number;
}

/**
 * Hook that tracks window dimensions and device pixel ratio.
 * This provides a centralized source of truth for window size used across the app.
 */
export function useWindowSize(): WindowSize {
  // Initialize with current window dimensions and pixel ratio
  const [windowSize, setWindowSize] = useState<WindowSize>({
    width: window.innerWidth,
    height: window.innerHeight,
    pixelRatio: window.devicePixelRatio || 1
  });

  useEffect(() => {
    // Handler to call on window resize
    function handleResize() {
      // Set window dimensions in state
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
        pixelRatio: window.devicePixelRatio || 1
      });
    }

    // Add event listener
    window.addEventListener('resize', handleResize);

    // Call handler right away so state gets updated with initial window size
    handleResize();

    // Remove event listener on cleanup
    return () => window.removeEventListener('resize', handleResize);
  }, []); // Empty array ensures effect runs only on mount and unmount

  return windowSize;
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/services/WebSocketService.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/services/WebSocketService.ts
```ts
import { createLogger, createErrorMetadata } from '../utils/logger';
import { debugState } from '../utils/debugState';
import { useSettingsStore } from '../store/settingsStore'; // Keep alias here for now, fix later if needed
import { graphDataManager } from '../features/graph/managers/graphDataManager';

const logger = createLogger('WebSocketService');

export interface WebSocketAdapter {
  send: (data: ArrayBuffer) => void;
  isReady: () => boolean;
}

export interface WebSocketMessage {
  type: string;
  data?: any;
}

type MessageHandler = (message: WebSocketMessage) => void;
type BinaryMessageHandler = (data: ArrayBuffer) => void;
type ConnectionStatusHandler = (connected: boolean) => void;

class WebSocketService {
  private static instance: WebSocketService;
  private socket: WebSocket | null = null;
  private messageHandlers: MessageHandler[] = [];
  private binaryMessageHandlers: BinaryMessageHandler[] = [];
  private connectionStatusHandlers: ConnectionStatusHandler[] = [];
  private reconnectInterval: number = 2000;
  private maxReconnectAttempts: number = 10;
  private reconnectAttempts: number = 0;
  private reconnectTimeout: number | null = null;
  private isConnected: boolean = false;
  private isServerReady: boolean = false;
  private url: string;

  private constructor() {
    // Default WebSocket URL
    this.url = this.determineWebSocketUrl();

    // Update URL when settings change
    this.updateFromSettings();

    // Subscribe to store changes and manually check customBackendUrl
    let previousCustomBackendUrl = useSettingsStore.getState().settings.system.customBackendUrl;
    useSettingsStore.subscribe((state) => {
      const newCustomBackendUrl = state.settings.system.customBackendUrl;
      if (newCustomBackendUrl !== previousCustomBackendUrl) {
        if (debugState.isEnabled()) {
          logger.info(`customBackendUrl setting changed from "${previousCustomBackendUrl}" to "${newCustomBackendUrl}", re-evaluating WebSocket URL.`);
        }
        previousCustomBackendUrl = newCustomBackendUrl; // Update for next comparison
        this.updateFromSettings(); // Sets this.url based on the latest state
        if (this.isConnected || (this.socket && this.socket.readyState === WebSocket.CONNECTING)) {
          logger.info('Reconnecting WebSocket due to customBackendUrl change.');
          this.close();
          setTimeout(() => {
            this.connect().catch(error => {
              logger.error('Failed to reconnect WebSocket after URL change:', createErrorMetadata(error));
            });
          }, 100);
        }
      }
    });
  }

  private updateFromSettings(): void {
    const settings = useSettingsStore.getState().settings;
    let newUrl = this.determineWebSocketUrl(); // Default to relative path

    if (settings.system?.websocket) {
      this.reconnectInterval = settings.system.websocket.reconnectDelay || 2000;
      this.maxReconnectAttempts = settings.system.websocket.reconnectAttempts || 10;
    }

    if (settings.system?.customBackendUrl && settings.system.customBackendUrl.trim() !== '') {
      const customUrl = settings.system.customBackendUrl.trim();
      const protocol = customUrl.startsWith('https://') ? 'wss://' : 'ws://';
      const hostAndPath = customUrl.replace(/^(https?:\/\/)?/, '');
      newUrl = `${protocol}${hostAndPath.replace(/\/$/, '')}/wss`; // Ensure /wss and handle trailing slash
      if (debugState.isEnabled()) {
        logger.info(`Using custom backend WebSocket URL: ${newUrl}`);
      }
    } else {
      if (debugState.isEnabled()) {
        logger.info(`Using default WebSocket URL: ${newUrl}`);
      }
    }
    this.url = newUrl;
  }

  public static getInstance(): WebSocketService {
    if (!WebSocketService.instance) {
      WebSocketService.instance = new WebSocketService();
    }
    return WebSocketService.instance;
  }

  private determineWebSocketUrl(): string {
    // Always use a relative path. Nginx handles proxying in dev,
    // and the browser resolves it correctly in production.
    const url = '/wss'; // Changed from /ws to /wss
    if (debugState.isEnabled()) { // Log only if debug is enabled
        logger.info(`Determined WebSocket URL (relative): ${url}`);
    }
    return url;
  }

  /**
   * Set a custom backend URL for WebSocket connections
   * @param backendUrl The backend URL (e.g., 'http://192.168.0.51:8000' or just '192.168.0.51:8000')
   */
  public setCustomBackendUrl(backendUrl: string | null): void {
    if (!backendUrl) {
      // Reset to default URL
      this.url = this.determineWebSocketUrl();
      if (debugState.isEnabled()) {
        logger.info(`Reset to default WebSocket URL: ${this.url}`);
      }
      return;
    }

    // Determine protocol (ws or wss)
    const protocol = backendUrl.startsWith('https://') ? 'wss://' : 'ws://';
    // Extract host and port
    const hostWithProtocol = backendUrl.replace(/^(https?:\/\/)?/, '');
    // Set the WebSocket URL
    this.url = `${protocol}${hostWithProtocol}/wss`; // Changed from /ws to /wss

    if (debugState.isEnabled()) {
      logger.info(`Set custom WebSocket URL: ${this.url}`);
    }

    // If already connected, reconnect with new URL
    if (this.isConnected && this.socket) {
      if (debugState.isEnabled()) {
        logger.info('Reconnecting with new WebSocket URL');
      }
      this.close();
      this.connect().catch(error => {
        logger.error('Failed to reconnect with new URL:', createErrorMetadata(error));
      });
    }
  }

  public async connect(): Promise<void> {
    // Don't try to connect if already connecting or connected
    if (this.socket && (this.socket.readyState === WebSocket.CONNECTING || this.socket.readyState === WebSocket.OPEN)) {
      return;
    }

    try {
      if (debugState.isEnabled()) {
        logger.info(`Connecting to WebSocket at ${this.url}`);
      }

      // Create a new WebSocket connection
      this.socket = new WebSocket(this.url);

      // Handle WebSocket events
      this.socket.onopen = this.handleOpen.bind(this);
      this.socket.onmessage = this.handleMessage.bind(this);
      this.socket.onclose = this.handleClose.bind(this);
      this.socket.onerror = this.handleError.bind(this);

      // Create a promise that resolves when the connection opens or rejects on error
      return new Promise<void>((resolve, reject) => {
        if (!this.socket) {
          reject(new Error('Socket initialization failed'));
          return;
        }

        // Resolve when the socket successfully opens
        this.socket.addEventListener('open', () => resolve(), { once: true });

        // Reject if there's an error before the socket opens
        this.socket.addEventListener('error', (event) => {
          // Only reject if the socket hasn't opened yet
          if (this.socket && this.socket.readyState !== WebSocket.OPEN) {
            reject(new Error('WebSocket connection failed'));
          }
        }, { once: true });
      });
    } catch (error) {
      logger.error('Error establishing WebSocket connection:', createErrorMetadata(error));
      throw error;
    }
  }

  private handleOpen(event: Event): void {
    this.isConnected = true;
    this.reconnectAttempts = 0;
    if (debugState.isEnabled()) {
      logger.info('WebSocket connection established');
    }
    this.notifyConnectionStatusHandlers(true);
  }

  private handleMessage(event: MessageEvent): void {
    // Check for binary data first
    if (event.data instanceof Blob) {
      if (debugState.isDataDebugEnabled()) {
        logger.debug('Received binary blob data');
      }
      // Convert Blob to ArrayBuffer
      event.data.arrayBuffer().then(buffer => {
        // Process the ArrayBuffer, with possible decompression
        this.processBinaryData(buffer);
      }).catch(error => {
        logger.error('Error converting Blob to ArrayBuffer:', createErrorMetadata(error));
      });
      return;
    }

    if (event.data instanceof ArrayBuffer) {
      if (debugState.isDataDebugEnabled()) {
        logger.debug(`Received binary ArrayBuffer data: ${event.data.byteLength} bytes`);
      }
      // Process the ArrayBuffer directly, with possible decompression
      this.processBinaryData(event.data);
      return;
    }

    // If not binary, try to parse as JSON
    try {
      const message = JSON.parse(event.data) as WebSocketMessage;

      if (debugState.isDataDebugEnabled()) {
        logger.debug(`Received WebSocket message: ${message.type}`, message.data);
      }

      // Special handling for connection_established message
      if (message.type === 'connection_established') {
        this.isServerReady = true;
        if (debugState.isEnabled()) {
          logger.info('Server connection established and ready');
        }
      }

      // Notify all message handlers
      this.messageHandlers.forEach(handler => {
        try {
          handler(message);
        } catch (error) {
          logger.error('Error in message handler:', createErrorMetadata(error));
        }
      });
    } catch (error) {
      logger.error('Error parsing WebSocket message:', createErrorMetadata(error));
    }
  }

  // Make the function async to handle graphDataManager processing
  private async processBinaryData(data: ArrayBuffer): Promise<void> {
    try {
      if (debugState.isDataDebugEnabled()) {
        logger.debug(`Processing binary data: ${data.byteLength} bytes`);
      }

      // Pass binary data to graphDataManager for processing in the worker
      try {
        await graphDataManager.updateNodePositions(data);
      } catch (error) {
        logger.error('Error processing binary data in graphDataManager:', createErrorMetadata(error));
      }

      // Notify binary message handlers
      this.binaryMessageHandlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          logger.error('Error in binary message handler:', createErrorMetadata(error));
        }
      });
    } catch (error) {
      logger.error('Error processing binary data:', createErrorMetadata(error));
    }
  }

  private handleClose(event: CloseEvent): void {
    this.isConnected = false;
    this.isServerReady = false;

    if (debugState.isEnabled()) {
      logger.info(`WebSocket connection closed: ${event.code} ${event.reason}`);
    }

    this.notifyConnectionStatusHandlers(false);

    // Attempt to reconnect if it wasn't a normal closure
    if (event.code !== 1000 && event.code !== 1001) {
      this.attemptReconnect();
    }
  }

  private handleError(event: Event): void {
    logger.error('WebSocket error:', { event });
    // The close handler will be called after this, which will handle reconnection
  }

  private attemptReconnect(): void {
    // Clear any existing reconnect timeout
    if (this.reconnectTimeout) {
      window.clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = null;
    }

    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      const delay = this.reconnectInterval * Math.pow(1.5, this.reconnectAttempts - 1);

      if (debugState.isEnabled()) {
        logger.info(`Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
      }

      this.reconnectTimeout = window.setTimeout(() => {
        this.connect().catch(error => {
          logger.error('Reconnect attempt failed:', createErrorMetadata(error));
        });
      }, delay);
    } else { // Added missing else block
      logger.error(`Maximum reconnect attempts (${this.maxReconnectAttempts}) reached. Giving up.`);
    }
  }

  public sendMessage(type: string, data?: any): void {
    if (!this.isConnected || !this.socket) {
      logger.warn('Cannot send message: WebSocket not connected');
      return;
    }

    try {
      const message: WebSocketMessage = { type, data };
      this.socket.send(JSON.stringify(message));

      if (debugState.isDataDebugEnabled()) {
        logger.debug(`Sent message: ${type}`);
      }
    } catch (error) {
      logger.error('Error sending WebSocket message:', createErrorMetadata(error));
    }
  }

  public sendRawBinaryData(data: ArrayBuffer): void {
    if (!this.isConnected || !this.socket) {
      logger.warn('Cannot send binary data: WebSocket not connected');
      return;
    }

    try {
      this.socket.send(data);

      if (debugState.isDataDebugEnabled()) {
        logger.debug(`Sent binary data: ${data.byteLength} bytes`);
      }
    } catch (error) {
      logger.error('Error sending binary data:', createErrorMetadata(error));
    }
  }

  public onMessage(handler: MessageHandler): () => void {
    this.messageHandlers.push(handler);
    return () => {
      this.messageHandlers = this.messageHandlers.filter(h => h !== handler);
    };
  }

  public onBinaryMessage(handler: BinaryMessageHandler): () => void {
    this.binaryMessageHandlers.push(handler);
    return () => {
      this.binaryMessageHandlers = this.binaryMessageHandlers.filter(h => h !== handler);
    };
  }

  public onConnectionStatusChange(handler: ConnectionStatusHandler): () => void {
    this.connectionStatusHandlers.push(handler);
    // Immediately notify of current status
    handler(this.isConnected);
    return () => {
      this.connectionStatusHandlers = this.connectionStatusHandlers.filter(h => h !== handler);
    };
  }

  private notifyConnectionStatusHandlers(connected: boolean): void {
    this.connectionStatusHandlers.forEach(handler => {
      try {
        handler(connected);
      } catch (error) {
        logger.error('Error in connection status handler:', createErrorMetadata(error));
      }
    });
  }

  public isReady(): boolean {
    return this.isConnected && this.isServerReady;
  }

  public close(): void {
    if (this.socket) {
      // Clear reconnection timeout
      if (this.reconnectTimeout) {
        window.clearTimeout(this.reconnectTimeout);
        this.reconnectTimeout = null;
      }

      try {
        // Close the socket with a normal closure
        this.socket.close(1000, 'Normal closure');
        if (debugState.isEnabled()) {
          logger.info('WebSocket connection closed by client');
        }
      } catch (error) {
        logger.error('Error closing WebSocket:', createErrorMetadata(error));
      } finally {
        this.socket = null;
        this.isConnected = false;
        this.isServerReady = false;
        this.notifyConnectionStatusHandlers(false);
      }
    }
  }
}

export default WebSocketService;

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/services/api.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/services/api.ts
```ts
import { createLogger, createErrorMetadata } from '../utils/logger';
import { debugState } from '../utils/debugState';
import { RagflowChatRequestPayload, RagflowChatResponsePayload } from '../types/ragflowTypes';

const logger = createLogger('ApiService');

/**
 * API Service for making requests to the backend
 */
class ApiService {
  private static instance: ApiService;
  private baseUrl: string;

  private constructor() {
    this.baseUrl = '/api';
  }

  public static getInstance(): ApiService {
    if (!ApiService.instance) {
      ApiService.instance = new ApiService();
    }
    return ApiService.instance;
  }

  /**
   * Set the base URL for API requests
   * @param url The new base URL
   */
  public setBaseUrl(url: string): void {
    this.baseUrl = url;
    logger.info(`API base URL set to: ${url}`);
  }

  /**
   * Get the current base URL
   */
  public getBaseUrl(): string {
    return this.baseUrl;
  }

  /**
   * Make a GET request to the API
   * @param endpoint The API endpoint
   * @param headers Optional request headers
   * @returns The response data
   */
  public async get<T>(endpoint: string, headers: Record<string, string> = {}): Promise<T> {
    try {
      const url = `${this.baseUrl}${endpoint}`;

      if (debugState.isEnabled()) {
        logger.debug(`Making GET request to ${url}`);
      }

      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          ...headers
        }
      });

      if (!response.ok) {
        throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();

      if (debugState.isEnabled()) {
        logger.debug(`GET request to ${endpoint} succeeded`);
      }

      return data;
    } catch (error) {
      logger.error(`GET request to ${endpoint} failed:`, createErrorMetadata(error));
      throw error;
    }
  }

  /**
   * Make a POST request to the API
   * @param endpoint The API endpoint
   * @param data The request body data
   * @param headers Optional request headers
   * @returns The response data
   */
  public async post<T>(endpoint: string, data: any, headers: Record<string, string> = {}): Promise<T> {
    try {
      const url = `${this.baseUrl}${endpoint}`;

      if (debugState.isEnabled()) {
        logger.debug(`Making POST request to ${url}`);
      }

      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...headers
        },
        body: JSON.stringify(data)
      });

      if (!response.ok) {
        throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
      }

      const responseData = await response.json();

      if (debugState.isEnabled()) {
        logger.debug(`POST request to ${endpoint} succeeded`);
      }

      return responseData;
    } catch (error) {
      logger.error(`POST request to ${endpoint} failed:`, createErrorMetadata(error));
      throw error;
    }
  }

  /**
   * Make a PUT request to the API
   * @param endpoint The API endpoint
   * @param data The request body data
   * @param headers Optional request headers
   * @returns The response data
   */
  public async put<T>(endpoint: string, data: any, headers: Record<string, string> = {}): Promise<T> {
    try {
      const url = `${this.baseUrl}${endpoint}`;

      if (debugState.isEnabled()) {
        logger.debug(`Making PUT request to ${url}`);
      }

      const response = await fetch(url, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          ...headers
        },
        body: JSON.stringify(data)
      });

      if (!response.ok) {
        throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
      }

      const responseData = await response.json();

      if (debugState.isEnabled()) {
        logger.debug(`PUT request to ${endpoint} succeeded`);
      }

      return responseData;
    } catch (error) {
      logger.error(`PUT request to ${endpoint} failed:`, createErrorMetadata(error));
      throw error;
    }
  }

  /**
   * Make a DELETE request to the API
   * @param endpoint The API endpoint
   * @param headers Optional request headers
   * @returns The response data
   */
  public async delete<T>(endpoint: string, headers: Record<string, string> = {}): Promise<T> {
    try {
      const url = `${this.baseUrl}${endpoint}`;

      if (debugState.isEnabled()) {
        logger.debug(`Making DELETE request to ${url}`);
      }

      const response = await fetch(url, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          ...headers
        }
      });

      if (!response.ok) {
        throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();

      if (debugState.isEnabled()) {
        logger.debug(`DELETE request to ${endpoint} succeeded`);
      }

      return data;
    } catch (error) {
      logger.error(`DELETE request to ${endpoint} failed:`, createErrorMetadata(error));
      throw error;
    }
  }

  public async sendRagflowChatMessage(
    payload: RagflowChatRequestPayload,
    headers: Record<string, string> = {} // For auth
  ): Promise<RagflowChatResponsePayload> {
    try {
      const url = `${this.baseUrl}/ragflow/chat`; // Path defined in Rust backend, /api is prepended by baseUrl
      if (debugState.isEnabled()) {
        logger.debug(`Making POST request to ${url} for RAGFlow chat`);
      }
      // Assume headers (like auth) will be passed in or handled globally by apiService
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...headers, // Include auth headers
        },
        body: JSON.stringify(payload),
      });
      if (!response.ok) {
            const errorData = await response.json().catch(() => ({ message: response.statusText, error: response.statusText }));
            throw new Error(`RAGFlow chat API request failed with status ${response.status}: ${errorData.error || errorData.message}`);
          }
          const responseData = await response.json();
          if (debugState.isEnabled()) {
            logger.debug(`POST request to ${url} (RAGFlow chat) succeeded`);
          }
          return responseData as RagflowChatResponsePayload;
        } catch (error) {
          logger.error(`POST request to /ragflow/chat failed:`, createErrorMetadata(error));
          throw error;
        }
      }
}

export const apiService = ApiService.getInstance();

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/services/nostrAuthService.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/services/nostrAuthService.ts
```ts
import { apiService } from './api';
import { createLogger, createErrorMetadata } from '../utils/logger';
import { Event, UnsignedEvent, nip19 } from 'nostr-tools';
import { v4 as uuidv4 } from 'uuid'; // Import uuid
import type {} from '../types/nip07'; // Import the types to ensure Window augmentation

const logger = createLogger('NostrAuthService');


export interface SimpleNostrUser {
  pubkey: string; // hex pubkey
  npub?: string; // npub format
  isPowerUser: boolean; // Keep for UI rendering decisions
}

export interface BackendNostrUser {
  pubkey: string;
  npub?: string;
  isPowerUser: boolean; // Server determines this based on POWER_USER_PUBKEYS
  // Add other fields the backend might send if needed
}

export interface AuthResponse {
  user: BackendNostrUser;
  token: string;
  expiresAt: number; // Unix timestamp (seconds)
  features?: string[]; // Optional features list from backend
}

export interface VerifyResponse {
  valid: boolean;
  user?: BackendNostrUser;
  features?: string[];
}

export interface AuthEventPayload {
  id: string;
  pubkey: string;
  content: string;
  sig: string;
  created_at: number; // Unix timestamp
  kind: number;
  tags: string[][];
}

export interface AuthState {
  authenticated: boolean;
  user?: SimpleNostrUser;
  error?: string;
}

type AuthStateListener = (state: AuthState) => void;


class NostrAuthService {
  private static instance: NostrAuthService;
  private sessionToken: string | null = null;
  private currentUser: SimpleNostrUser | null = null;
  private authStateListeners: AuthStateListener[] = [];
  private initialized = false;

  private constructor() {}

  public static getInstance(): NostrAuthService {
    if (!NostrAuthService.instance) {
      NostrAuthService.instance = new NostrAuthService();
    }
    return NostrAuthService.instance;
  }

  /**
   * Checks if a NIP-07 provider (window.nostr) is available.
   */
  public hasNip07Provider(): boolean {
    return typeof window !== 'undefined' && window.nostr !== undefined;
  }

  /**
   * Initializes the service, checking for stored sessions.
   */
  public async initialize(): Promise<void> {
    if (this.initialized) return;
    logger.debug('Initializing NostrAuthService...');

    const storedToken = localStorage.getItem('nostr_session_token');
    const storedUserJson = localStorage.getItem('nostr_user'); // Stores SimpleNostrUser

    if (storedToken && storedUserJson) {
      let storedUser: SimpleNostrUser | null = null;
      try {
        storedUser = JSON.parse(storedUserJson);
      } catch (parseError) {
        logger.error('Failed to parse stored user data:', createErrorMetadata(parseError));
        this.clearSession();
      }

      if (storedUser) {
        logger.info(`Verifying stored session for pubkey: ${storedUser.pubkey}`);
        try {
          // Verify token with backend
          const verificationResponse = await apiService.post<VerifyResponse>('/auth/nostr/verify', {
            pubkey: storedUser.pubkey,
            token: storedToken
          });

          if (verificationResponse.valid) { // Check only for token validity
            this.sessionToken = storedToken;
            if (verificationResponse.user) { // If backend provides updated user info
              this.currentUser = {
                pubkey: verificationResponse.user.pubkey,
                npub: verificationResponse.user.npub || this.hexToNpub(verificationResponse.user.pubkey),
                isPowerUser: verificationResponse.user.isPowerUser,
              };
              logger.info('Token verified and user details updated from backend.');
            } else if (storedUser) {
              // Token is valid, but backend didn't return user info.
              // Trust the locally stored user info for this session.
              this.currentUser = storedUser; // storedUser is confirmed non-null here
              logger.info('Token verified, using stored user details as backend did not provide them on verify.');
            } else {
              // This case should ideally not be reached if storedUser was parsed correctly.
              logger.error('Token verified but no user details available from backend or local storage. Clearing session.');
              this.clearSession();
              this.notifyListeners({ authenticated: false, error: 'User details missing after verification' });
              return; // Exit early
            }
            this.storeCurrentUser(); // Store potentially updated or re-confirmed user
            this.notifyListeners(this.getCurrentAuthState());
            logger.info('Restored and verified session from local storage.');
          } else {
            // Session invalid (verificationResponse.valid is false)
            logger.warn('Stored session token is invalid (verification failed), clearing session.');
            this.clearSession();
            this.notifyListeners({ authenticated: false });
          }
        } catch (error) {
          logger.error('Failed to verify stored session with backend:', createErrorMetadata(error));
          this.clearSession();
          this.notifyListeners({ authenticated: false, error: 'Session verification failed' });
        }
      }
    } else {
      logger.info('No stored session found.');
      this.notifyListeners({ authenticated: false });
    }
    this.initialized = true;
    logger.debug('NostrAuthService initialized.');
  }

  /**
   * Initiates the NIP-07 login flow.
   */
  public async login(): Promise<AuthState> {
    logger.info('Attempting NIP-07 login...');
    if (!this.hasNip07Provider()) {
      const errorMsg = 'Nostr NIP-07 provider (e.g., Alby) not found. Please install a compatible extension.';
      logger.error(errorMsg);
      this.notifyListeners({ authenticated: false, error: errorMsg });
      throw new Error(errorMsg);
    }

    try {
      // 1. Get public key from NIP-07 provider
      const pubkey = await window.nostr!.getPublicKey();
      if (!pubkey) {
        throw new Error('Could not get public key from NIP-07 provider.');
      }
      logger.info(`Got pubkey via NIP-07: ${pubkey}`);

      // 2. Construct NIP-42 Authentication Event (Kind 22242)
      const challenge = uuidv4(); // Use uuidv4 to generate the challenge
      // TODO: Make relayUrl configurable or obtained from the provider if possible
      const relayUrl = 'wss://relay.damus.io';

      // Prepare the unsigned event structure expected by NIP-07 signEvent
      const unsignedNip07Event = {
        created_at: Math.floor(Date.now() / 1000),
        kind: 22242,
        tags: [
          ['relay', relayUrl],
          ['challenge', challenge]
        ],
        content: 'Authenticate to LogseqSpringThing' // Customize as needed
      };

      // 3. Sign the event using NIP-07 provider
      logger.debug('Requesting signature via NIP-07 for event:', unsignedNip07Event);
      const signedEvent: Event = await window.nostr!.signEvent(unsignedNip07Event);
      logger.debug('Event signed successfully via NIP-07.');

      // 4. Prepare payload for backend
      const eventPayload: AuthEventPayload = {
        id: signedEvent.id,
        pubkey: signedEvent.pubkey, // pubkey is added by the signer
        content: signedEvent.content,
        sig: signedEvent.sig,
        created_at: signedEvent.created_at,
        kind: signedEvent.kind,
        tags: signedEvent.tags,
      };

      // 5. Send the signed event to the backend API
      logger.info(`Sending auth event to backend for pubkey: ${pubkey}`);
      const response = await apiService.post<AuthResponse>('/auth/nostr', eventPayload);
      logger.info(`Backend auth successful for pubkey: ${response.user.pubkey}`);

      // 6. Store session and update state
      this.sessionToken = response.token;
      this.currentUser = {
        pubkey: response.user.pubkey,
        npub: response.user.npub || this.hexToNpub(response.user.pubkey),
        isPowerUser: response.user.isPowerUser,
      };

      this.storeSessionToken(response.token);
      this.storeCurrentUser(); // Store SimpleNostrUser

      const newState = this.getCurrentAuthState();
      this.notifyListeners(newState);
      return newState;

    } catch (error: any) {
      const errorMeta = createErrorMetadata(error);
      logger.error(`NIP-07 login failed. Details: ${JSON.stringify(errorMeta, null, 2)}`);
      let errorMessage = 'Login failed';
      if (error?.response?.data?.error) { // Check for backend error structure
        errorMessage = error.response.data.error;
      } else if (error?.message) {
        errorMessage = error.message;
      } else if (typeof error === 'string') {
        errorMessage = error;
      }

      // Refine common error messages
      if (errorMessage.includes('User rejected') || errorMessage.includes('extension rejected')) {
        errorMessage = 'Login request rejected in Nostr extension.';
      } else if (errorMessage.includes('401') || errorMessage.includes('Invalid signature')) {
        errorMessage = 'Authentication failed: Invalid signature or credentials.';
      } else if (errorMessage.includes('Could not get public key')) {
        errorMessage = 'Failed to get public key from Nostr extension.';
      }

      const errorState: AuthState = { authenticated: false, error: errorMessage };
      this.notifyListeners(errorState);
      // Re-throw the error so UI components can potentially handle it too
      throw new Error(errorMessage);
    }
  }

  /**
   * Logs the user out.
   */
  public async logout(): Promise<void> {
    logger.info('Attempting logout...');
    const token = this.sessionToken;
    const user = this.currentUser;

    // Clear local state immediately for faster UI update
    const wasAuthenticated = this.isAuthenticated();
    this.clearSession();
    if (wasAuthenticated) {
        this.notifyListeners({ authenticated: false }); // Notify UI immediately only if state changed
    }


    if (token && user) {
      try {
        logger.info(`Calling server logout for pubkey: ${user.pubkey}`);
        // Server expects DELETE with pubkey and token in body
        await apiService.delete<any>('/auth/nostr', {
          pubkey: user.pubkey,
          token: token
        });
        logger.info('Server logout successful.');
      } catch (error) {
        // Log the error but don't re-throw, as client-side logout is already done
        logger.error('Server logout call failed:', createErrorMetadata(error));
        // Optionally notify listeners about the server error?
        // this.notifyListeners({ authenticated: false, error: 'Server logout failed but client session cleared' });
      }
    } else {
      logger.warn('Logout called but no active session found locally.');
    }
  }

  // --- State Management & Helpers ---

  private storeSessionToken(token: string): void {
    localStorage.setItem('nostr_session_token', token);
  }

  private storeCurrentUser(): void {
    if (this.currentUser) {
      localStorage.setItem('nostr_user', JSON.stringify(this.currentUser));
    } else {
      localStorage.removeItem('nostr_user');
    }
  }

  private clearSession(): void {
    this.sessionToken = null;
    this.currentUser = null;
    localStorage.removeItem('nostr_session_token');
    localStorage.removeItem('nostr_user');
  }

  public onAuthStateChanged(listener: AuthStateListener): () => void {
    this.authStateListeners.push(listener);
    if (this.initialized) { // Notify immediately if already initialized
      listener(this.getCurrentAuthState());
    }
    // Return unsubscribe function
    return () => {
      this.authStateListeners = this.authStateListeners.filter(l => l !== listener);
    };
  }

  private notifyListeners(state: AuthState): void {
    this.authStateListeners.forEach(listener => {
      try {
        listener(state);
      } catch (error) {
        logger.error('Error in auth state listener:', createErrorMetadata(error));
      }
    });
  }

  public getCurrentUser(): SimpleNostrUser | null {
    return this.currentUser;
  }

  public getSessionToken(): string | null {
    return this.sessionToken;
  }

  public isAuthenticated(): boolean {
    return !!this.sessionToken && !!this.currentUser;
  }

  public getCurrentAuthState(): AuthState {
    return {
      authenticated: this.isAuthenticated(),
      user: this.currentUser ? { ...this.currentUser } : undefined, // Return a copy
      error: undefined // Reset error on state check, or manage error state separately
    };
  }

  // --- NIP-19 Helpers ---

  public hexToNpub(pubkey: string): string | undefined {
    if (!pubkey) return undefined;
    try {
      return nip19.npubEncode(pubkey);
    } catch (error) {
      logger.warn(`Failed to convert hex to npub: ${pubkey}`, createErrorMetadata(error));
      return undefined;
    }
  }

  public npubToHex(npub: string): string | undefined {
    if (!npub) return undefined;
    try {
      const decoded = nip19.decode(npub);
      if (decoded.type === 'npub') {
        return decoded.data;
      }
      throw new Error('Invalid npub format');
    } catch (error) {
      logger.warn(`Failed to convert npub to hex: ${npub}`, createErrorMetadata(error));
      return undefined;
    }
  }
}

export const nostrAuth = NostrAuthService.getInstance();

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/services/platformManager.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/services/platformManager.ts
```ts
import { create } from 'zustand';
import { createLogger } from '../utils/logger';
import { XRSessionState } from '../features/xr/types/xr';

const logger = createLogger('PlatformManager');

export type PlatformType = 'desktop' | 'mobile' | 'quest' | 'quest2' | 'quest3' | 'pico' | 'unknown';
export type XRDeviceType = 'quest' | 'pico' | 'desktop-xr' | 'mobile-xr' | 'none';

export interface PlatformCapabilities {
  xrSupported: boolean;
  handTrackingSupported: boolean;
  arSupported: boolean;
  vrSupported: boolean;
  performanceTier: 'low' | 'medium' | 'high';
  maxTextureSize: number;
  hasTouchscreen: boolean;
  hasPointer: boolean;
  hasKeyboard: boolean;
  hasGamepad: boolean;
  memoryLimited: boolean;
}

export type PlatformEventType =
  | 'platformchange'
  | 'xrmodechange'
  | 'xrsessionstatechange'
  | 'deviceorientationchange'
  | 'handtrackingavailabilitychange';

interface PlatformState {
  // Platform details
  platform: PlatformType;
  xrDeviceType: XRDeviceType;
  capabilities: PlatformCapabilities;
  userAgent: string;
  isXRMode: boolean;
  xrSessionState: XRSessionState;
  isWebXRSupported: boolean;

  // Event listeners storage
  listeners: Map<PlatformEventType, Set<Function>>;

  // Initialization
  initialized: boolean;
  initialize: () => Promise<void>;

  // Platform detection
  detectPlatform: () => void;
  isQuest: () => boolean;
  isPico: () => boolean;
  isDesktop: () => boolean;
  isMobile: () => boolean;
  isXRSupported: () => boolean;

  // XR mode management
  setXRMode: (enabled: boolean) => void;
  setXRSessionState: (state: XRSessionState) => void;

  // Event handling
  dispatchEvent: (event: PlatformEventType, data: any) => void;
  addEventListener: (event: PlatformEventType, callback: Function) => void;
  removeEventListener: (event: PlatformEventType, callback: Function) => void;
  removeAllListeners: (event?: PlatformEventType) => void;
}

export const usePlatformStore = create<PlatformState>()((set, get) => ({
  // Default initial state
  platform: 'unknown',
  xrDeviceType: 'none',
  capabilities: {
    xrSupported: false,
    handTrackingSupported: false,
    arSupported: false,
    vrSupported: false,
    performanceTier: 'medium',
    maxTextureSize: 2048,
    hasTouchscreen: false,
    hasPointer: true,
    hasKeyboard: true,
    hasGamepad: false,
    memoryLimited: false
  },
  userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : '',
  isXRMode: false,
  xrSessionState: 'inactive',
  isWebXRSupported: typeof navigator !== 'undefined' && !!navigator.xr,
  initialized: false,

  // Event listeners
  listeners: new Map<PlatformEventType, Set<Function>>(),

  initialize: async () => {
    logger.info('Initializing platform manager');

    // Detect platform first
    get().detectPlatform();

    // Check for XR support
    if (typeof navigator !== 'undefined' && navigator.xr) {
      // Test for VR support
      try {
        const vrSupported = await navigator.xr.isSessionSupported('immersive-vr');
        // Test for AR support (Oculus Quest)
        const arSupported = await navigator.xr.isSessionSupported('immersive-ar');

        set(state => ({
          capabilities: {
            ...state.capabilities,
            xrSupported: vrSupported || arSupported,

            vrSupported,
            arSupported
          }
        }));

        logger.info('XR support detected', { vrSupported, arSupported });
      } catch (error) {
        logger.error('Error checking XR support:', error);
      }
    }

    // Check for hand tracking support
    if (typeof navigator !== 'undefined' && navigator.xr) {
      try {
        // Note: This might need further detection based on device
        const handTrackingSupported = get().isQuest();

        set(state => ({
          capabilities: {
            ...state.capabilities,
            handTrackingSupported
          }
        }));
      } catch (error) {
        logger.error('Error checking hand tracking support:', error);
      }
    }

    // Set up event listeners
    if (typeof window !== 'undefined') {
      window.addEventListener('resize', () => {
        get().detectPlatform();
      });
    }

    // Update WebXR support
    const isWebXRSupported = typeof navigator !== 'undefined' && !!navigator.xr;

    set({
      initialized: true,
      isWebXRSupported
    });

    logger.info('Platform manager initialized', {
      platform: get().platform,
      xrDeviceType: get().xrDeviceType,
      capabilities: get().capabilities
    });
  },

  detectPlatform: () => {
    const userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : '';
    let platform: PlatformType = 'unknown';
    let xrDeviceType: XRDeviceType = 'none';

    // Check for Quest
    if (userAgent.includes('Quest')) {
      if (userAgent.includes('Quest 3')) {
        platform = 'quest3';
      } else if (userAgent.includes('Quest 2')) {
        platform = 'quest2';
      } else {
        platform = 'quest';
      }
      xrDeviceType = 'quest';
    }
    // Check for Pico
    else if (userAgent.includes('Pico') || userAgent.includes('PICO')) {
      platform = 'pico';
      xrDeviceType = 'pico';
    }
    // Check for mobile
    else if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {
      platform = 'mobile';
      xrDeviceType = 'mobile-xr';
    }
    // Default to desktop
    else {
      platform = 'desktop';
      xrDeviceType = 'desktop-xr';
    }

    // Determine performance tier based on platform
    let performanceTier: 'low' | 'medium' | 'high' = 'medium';
    let maxTextureSize = 2048;
    let memoryLimited = false;

    switch (platform) {
      case 'quest3':
        performanceTier = 'high';
        maxTextureSize = 4096;
        memoryLimited = true;
        break;
      case 'quest2':
        performanceTier = 'medium';
        maxTextureSize = 2048;
        memoryLimited = true;
        break;
      case 'quest':
        performanceTier = 'low';
        maxTextureSize = 2048;
        memoryLimited = true;
        break;
      case 'pico':
        performanceTier = 'medium';
        maxTextureSize = 2048;
        memoryLimited = true;
        break;
      case 'mobile':
        performanceTier = 'low';
        maxTextureSize = 2048;
        memoryLimited = true;
        break;
      case 'desktop':
        performanceTier = 'high';
        maxTextureSize = 8192;
        memoryLimited = false;
        break;
    }

    // Detect features
    const hasTouchscreen = typeof navigator !== 'undefined' &&
      ('maxTouchPoints' in navigator ? navigator.maxTouchPoints > 0 : 'ontouchstart' in window);

    // Update state with detected platform
    const prevPlatform = get().platform;
    set(state => ({
      platform,
      xrDeviceType,
      userAgent,
      capabilities: {
        ...state.capabilities,
        performanceTier,
        maxTextureSize,
        memoryLimited,
        hasTouchscreen,
        hasPointer: platform === 'desktop' || platform === 'mobile',
        hasKeyboard: platform === 'desktop',
        hasGamepad: platform.startsWith('quest') || platform === 'pico'
      }
    }));

    // Emit platform change event if changed
    if (prevPlatform !== platform) {
      get().dispatchEvent('platformchange', { platform });
    }

    return platform;
  },

  isQuest: () => {
    const platform = get().platform;
    return platform === 'quest' || platform === 'quest2' || platform === 'quest3';
  },

  isPico: () => {
    return get().platform === 'pico';
  },

  isDesktop: () => {
    return get().platform === 'desktop';
  },

  isMobile: () => {
    return get().platform === 'mobile';
  },

  isXRSupported: () => {
    return get().capabilities.xrSupported;
  },

  setXRMode: (enabled: boolean) => {
    const prev = get().isXRMode;
    if (prev !== enabled) {
      set({ isXRMode: enabled });
      get().dispatchEvent('xrmodechange', { enabled });
      logger.info(`XR mode ${enabled ? 'enabled' : 'disabled'}`);
    }
  },

  setXRSessionState: (state: XRSessionState) => {
    const prev = get().xrSessionState;
    if (prev !== state) {
      set({ xrSessionState: state });
      get().dispatchEvent('xrsessionstatechange', { state });
      logger.info(`XR session state changed to ${state}`);
    }
  },

  // Internal helper to dispatch events
  dispatchEvent: (event: PlatformEventType, data: any) => {
    const listeners = get().listeners;
    if (!listeners.has(event)) return;

    listeners.get(event)?.forEach(callback => {
      try {
        callback(data);
      } catch (error) {
        logger.error(`Error in ${event} listener:`, error);
      }
    });
  },

  // Event handling
  addEventListener: (event: PlatformEventType, callback: Function) => {
    const listeners = get().listeners;

    if (!listeners.has(event)) {
      listeners.set(event, new Set());
    }

    listeners.get(event)?.add(callback);
    set({ listeners });

    // Immediately call the callback with current state for some events
    if (event === 'platformchange') {
      callback({ platform: get().platform });
    } else if (event === 'xrmodechange') {
      callback({ enabled: get().isXRMode });
    } else if (event === 'xrsessionstatechange') {
      callback({ state: get().xrSessionState });
    }
  },

  removeEventListener: (event: PlatformEventType, callback: Function) => {
    const listeners = get().listeners;
    if (listeners.has(event)) {
      listeners.get(event)?.delete(callback);
      set({ listeners });
    }
  },

  removeAllListeners: (event?: PlatformEventType) => {
    const listeners = get().listeners;

    if (event) {
      listeners.delete(event);
    } else {
      listeners.clear();
    }

    set({ listeners });
  }
}));

export function usePlatform() {
  return usePlatformStore();
}

export class PlatformManager {
  private static instance: PlatformManager;

  private constructor() {}

  public static getInstance(): PlatformManager {
    if (!PlatformManager.instance) {
      PlatformManager.instance = new PlatformManager();
    }
    return PlatformManager.instance;
  }

  public get platform(): PlatformType {
    return usePlatformStore.getState().platform;
  }

  public get isXRMode(): boolean {
    return usePlatformStore.getState().isXRMode;
  }

  public get xrSessionState(): XRSessionState {
    return usePlatformStore.getState().xrSessionState;
  }

  public set xrSessionState(state: XRSessionState) {
    usePlatformStore.getState().setXRSessionState(state);
  }

  public async initialize(settings: any): Promise<void> {
    return usePlatformStore.getState().initialize();
  }

  public isQuest(): boolean {
    return usePlatformStore.getState().isQuest();
  }

  public isPico(): boolean {
    return usePlatformStore.getState().isPico();
  }

  public isDesktop(): boolean {
    return usePlatformStore.getState().isDesktop();
  }

  public isWebXRSupported(): boolean {
    return usePlatformStore.getState().isWebXRSupported;
  }

  public isMobile(): boolean {
    return usePlatformStore.getState().isMobile();
  }

  public isXRSupported(): boolean {
    return usePlatformStore.getState().isXRSupported();
  }

  public setXRMode(enabled: boolean): void {
    usePlatformStore.getState().setXRMode(enabled);
  }

  public getCapabilities(): PlatformCapabilities {
    return usePlatformStore.getState().capabilities;
  }

  public on(event: PlatformEventType, callback: Function): void {
    usePlatformStore.getState().addEventListener(event, callback);
  }

  public off(event: PlatformEventType, callback: Function): void {
    usePlatformStore.getState().removeEventListener(event, callback);
  }

  public removeAllListeners(event?: PlatformEventType): void {
    usePlatformStore.getState().removeAllListeners(event);
  }
}

export const platformManager = PlatformManager.getInstance();
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/services/settingsService.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/services/settingsService.ts
```ts
import { Settings } from '../features/settings/config/settings';
import { apiService } from './api';
import { createLogger, createErrorMetadata } from '../utils/logger';
import { convertSnakeToCamelCase, convertCamelToSnakeCase } from '../utils/caseConversion';
import { debugState } from '../utils/debugState';

const logger = createLogger('SettingsService');

/**
 * Service for managing settings API interactions
 */
class SettingsService {
  private static instance: SettingsService;

  private constructor() {}

  public static getInstance(): SettingsService {
    if (!SettingsService.instance) {
      SettingsService.instance = new SettingsService();
    }
    return SettingsService.instance;
  }

  /**
   * Fetch settings from the server
   * @returns The settings from the server, converted to camelCase
   */
  public async fetchSettings(): Promise<Settings | null> {
    try {
      // Fetch settings from the server
      const rawSettings = await apiService.get<Record<string, any>>('/user-settings');

      // Server sends camelCase for this endpoint, so no conversion needed here.
      const settings = rawSettings as Settings;

      if (debugState.isEnabled()) {
        logger.info('Fetched settings from server (already camelCase):', { settings });
      }

      return settings;
    } catch (error) {
      logger.error('Failed to fetch settings:', createErrorMetadata(error));
      return null;
    }
  }

  /**
   * Save settings to the server
   * @param settings The settings to save, in camelCase
   * @param authHeaders Optional authentication headers
   * @returns The updated settings from the server, converted to camelCase
   */
  public async saveSettings(
    settings: Settings,
    authHeaders: Record<string, string> = {}
  ): Promise<Settings | null> {
    try {
      // Convert settings to snake_case for the server
      const settingsToSend = convertCamelToSnakeCase(settings); // Convert to snake_case for the server

      if (debugState.isEnabled()) {
        logger.info('Saving settings to server (camelCase):', { settingsToSend });
      }

      // Send settings to the server
      const rawUpdatedSettings = await apiService.post<Record<string, any>>(
        '/user-settings/sync',
        settingsToSend,
        authHeaders
      );

      // Server sends camelCase for this endpoint's response, so no conversion needed here.
      const updatedSettings = rawUpdatedSettings as Settings;

      if (debugState.isEnabled()) {
        logger.info('Settings saved successfully (response already camelCase):', { updatedSettings });
      }

      return updatedSettings;
    } catch (error) {
      logger.error('Failed to save settings:', createErrorMetadata(error));
      return null;
    }
  }

  /**
   * Clear the settings cache on the server
   * @param authHeaders Authentication headers
   * @returns Whether the operation was successful
   */
  public async clearSettingsCache(authHeaders: Record<string, string>): Promise<boolean> {
    try {
      await apiService.post('/user-settings/clear-cache', {}, authHeaders);
      logger.info('Settings cache cleared successfully');
      return true;
    } catch (error) {
      logger.error('Failed to clear settings cache:', createErrorMetadata(error));
      return false;
    }
  }
}

export const settingsService = SettingsService.getInstance();

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/store/settingsStore.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/store/settingsStore.ts
```ts
import { create } from 'zustand'
import { persist, createJSONStorage } from 'zustand/middleware'
import { defaultSettings } from '../features/settings/config/defaultSettings'
import { Settings, SettingsPath } from '../features/settings/config/settings'
import { createLogger, createErrorMetadata } from '../utils/logger'
import { debugState } from '../utils/debugState'
import { deepMerge } from '../utils/deepMerge';
import { settingsService } from '../services/settingsService';
import { produce } from 'immer';
import { toast } from '../ui/useToast'; // Import toast

const logger = createLogger('SettingsStore')

interface SettingsState {
  settings: Settings
  initialized: boolean
  authenticated: boolean
  user: { isPowerUser: boolean; pubkey: string } | null
  isPowerUser: boolean // Direct access to power user state
  subscribers: Map<string, Set<() => void>>

  // Actions
  initialize: () => Promise<Settings>
  setAuthenticated: (authenticated: boolean) => void
  setUser: (user: { isPowerUser: boolean; pubkey: string } | null) => void
  get: <T>(path: SettingsPath) => T
  set: <T>(path: SettingsPath, value: T) => void
  subscribe: (path: SettingsPath, callback: () => void, immediate?: boolean) => () => void;
  unsubscribe: (path: SettingsPath, callback: () => void) => void;
  updateSettings: (updater: (draft: Settings) => void) => void;
  notifyViewportUpdate: (path: SettingsPath) => void; // For real-time viewport updates
}

export const useSettingsStore = create<SettingsState>()(
  persist(
    (set, get) => ({
      settings: defaultSettings,
      initialized: false,
      authenticated: false,
      user: null,
      isPowerUser: false,
      subscribers: new Map(),

      initialize: async () => {
        try {
          if (debugState.isEnabled()) {
            logger.info('Initializing settings')
          }

          // Load settings from localStorage via zustand persist
          const currentSettings = get().settings

          // Fetch settings from server if available
          try {
            // Use the settings service to fetch settings
            const serverSettings = await settingsService.fetchSettings()

            if (serverSettings) {
              if (debugState.isEnabled()) {
                logger.info('Fetched settings from server:', { serverSettings })
              }

              // Merge server settings with defaults and current settings using deep merge
              // This ensures all nested objects are properly merged
              const mergedSettings = deepMerge(defaultSettings, currentSettings, serverSettings)

              if (debugState.isEnabled()) {
                logger.info('Deep merged settings:', { mergedSettings })
              }

              set({
                settings: mergedSettings,
                initialized: true
              })

              if (debugState.isEnabled()) {
                logger.info('Settings loaded from server and merged')
              }

              return mergedSettings
            }
          } catch (error) {
            logger.warn('Failed to fetch settings from server:', createErrorMetadata(error))
            // Continue with local settings if server fetch fails
          }

          // Mark as initialized
          set({ initialized: true })

          if (debugState.isEnabled()) {
            logger.info('Settings initialized from local storage')
          }

          return currentSettings
        } catch (error) {
          logger.error('Failed to initialize settings:', createErrorMetadata(error))

          // Fall back to default settings
          set({
            settings: defaultSettings,
            initialized: true
          })

          return defaultSettings
        }
      },

      setAuthenticated: (authenticated: boolean) => set({ authenticated }),

      setUser: (user: { isPowerUser: boolean; pubkey: string } | null) => set({
        user,
        isPowerUser: user?.isPowerUser || false
      }),

      notifyViewportUpdate: (path: SettingsPath) => {
        // This method will be called for settings that need immediate viewport updates
        const callbacks = get().subscribers.get('viewport.update')
        if (callbacks) {
          Array.from(callbacks).forEach(callback => {
            try {
              callback()
            } catch (error) {
              logger.error(`Error in viewport update subscriber:`, createErrorMetadata(error))
            }
          })
        }
      },

      get: <T>(path: SettingsPath): T => {
        const settings = get().settings

        if (!path || path === '') {
          return settings as unknown as T
        }

        // Navigate the settings object using the path
        let current: any = settings
        const pathParts = path.split('.')

        for (const part of pathParts) {
          if (current === undefined || current === null) {
            return undefined as unknown as T
          }
          current = current[part]
        }

        return current as T
      },

      set: <T>(path: SettingsPath, value: T) => {
        set(state => {
          // If setting the entire object
          if (!path || path === '') {
            return { settings: value as unknown as Settings }
          }

          // Create a deep copy of the settings object
          const newSettings = JSON.parse(JSON.stringify(state.settings))

          // Navigate to the correct location and update
          const pathParts = path.split('.')
          let current = newSettings

          // Navigate to the parent of the setting we want to update
          for (let i = 0; i < pathParts.length - 1; i++) {
            const part = pathParts[i]
            if (current[part] === undefined || current[part] === null) {
              // Create the path if it doesn't exist
              current[part] = {}
            }
            current = current[part]
          }

          // Update the value
          const finalPart = pathParts[pathParts.length - 1]
          current[finalPart] = value

          // Return the updated settings
          return { settings: newSettings }
        })

        // Check if this is a visualization setting that needs immediate viewport update
        const needsImmediateUpdate = path.startsWith('visualisation.') ||
                                    path.startsWith('xr.') ||
                                    path === 'system.debug.enablePhysicsDebug' ||
                                    path === 'system.debug.enableNodeDebug' ||
                                    path === 'system.debug.enablePerformanceDebug'

        if (needsImmediateUpdate) {
          // Trigger immediate viewport update
          get().notifyViewportUpdate(path)
        }

        // Notify subscribers
        const notifySubscribers = async () => {
          const state = get()

          // Build a list of paths to notify
          // e.g. for path 'visualisation.bloom.enabled':
          // '', 'visualisation', 'visualisation.bloom', 'visualisation.bloom.enabled'
          const pathsToNotify = ['']
          const pathParts = path.split('.')
          let currentPath = ''

          for (const part of pathParts) {
            currentPath = currentPath ? `${currentPath}.${part}` : part
            pathsToNotify.push(currentPath)
          }

          // Notify subscribers for each path
          for (const notifyPath of pathsToNotify) {
            const callbacks = state.subscribers.get(notifyPath)
            if (callbacks) {
              // Convert Set to Array to avoid TypeScript iteration issues
              Array.from(callbacks).forEach(callback => {
                try {
                  callback()
                } catch (error) {
                  logger.error(`Error in settings subscriber for path ${notifyPath}:`, createErrorMetadata(error))
                }
              })
            }
          }

          // Save to server if appropriate
          if (state.initialized && state.settings.system?.persistSettings !== false) {
            try {
              // Prepare authentication headers
              const headers: Record<string, string> = {};

              // Add Nostr authentication if available
              try {
                // Import nostrAuth dynamically to avoid circular dependencies
                const { nostrAuth } = await import('../services/nostrAuthService')

                if (nostrAuth.isAuthenticated()) {
                  const user = nostrAuth.getCurrentUser()
                  const token = nostrAuth.getSessionToken()

                  if (user && token) {
                    headers['X-Nostr-Pubkey'] = user.pubkey
                    headers['Authorization'] = `Bearer ${token}`
                    logger.info('Using Nostr authentication for settings sync')
                  } else {
                    logger.warn('Nostr auth is authenticated but missing user or token')
                  }
                } else {
                  logger.info('Not authenticated with Nostr, proceeding without auth')
                }
              } catch (error) {
                logger.warn('Error getting Nostr authentication:', createErrorMetadata(error))
                // Proceed without auth header if there's an error
              }

              // Use the settings service to save settings
              const updatedSettings = await settingsService.saveSettings(state.settings, headers);

              if (updatedSettings) { // Check if response is not null (success)
                if (debugState.isEnabled()) {
                  logger.info('Settings saved to server successfully');
                }
                toast({ title: "Settings Saved", description: "Your settings have been synced with the server." });
                // Optionally, merge serverResponse back into store if server can modify settings during save
                // For now, assume client is authoritative for UI settings it sends.
                // If server can modify settings, you might do:
                // set(s => ({ ...s, settings: deepMerge(s.settings, updatedSettings) }));
              } else {
                // saveSettings would have returned null or thrown an error handled by catch
                // throw new Error('Server responded with an error or no data.'); // This will be caught below
                // The toast for failure will be handled in the catch block
              }
            } catch (error) {
              const errorMeta = createErrorMetadata(error);
              logger.error('Failed to save settings to server:', errorMeta);
              toast({ variant: "destructive", title: "Save Failed", description: `Could not save settings to server. ${errorMeta.message || 'Check console.'}` });
            }
          }
        }

        // Debounce saving settings
        if (typeof window !== 'undefined') {
          if (window.settingsSaveTimeout) {
            clearTimeout(window.settingsSaveTimeout)
          }
          window.settingsSaveTimeout = setTimeout(notifySubscribers, 300)
        } else {
          // If running server-side, notify immediately
          notifySubscribers()
        }
      },

      subscribe: (path: SettingsPath, callback: () => void, immediate: boolean = true) => {
        set(state => {
          const subscribers = new Map(state.subscribers)

          if (!subscribers.has(path)) {
            subscribers.set(path, new Set())
          }

          subscribers.get(path)!.add(callback)

          return { subscribers }
        })

        // Call callback immediately if requested and initialized
        if (immediate && get().initialized) {
          callback()
        }

        // Return unsubscribe function
        return () => get().unsubscribe(path, callback)
      },

      unsubscribe: (path: SettingsPath, callback: () => void) => {
        set(state => {
          const subscribers = new Map(state.subscribers)

          if (subscribers.has(path)) {
            const callbacks = subscribers.get(path)!
            callbacks.delete(callback)

            if (callbacks.size === 0) {
              subscribers.delete(path)
            }
          }

          return { subscribers }
        })
      },

      // Corrected updateSettings implementation using Immer
      updateSettings: (updater) => {
        // Correct usage: produce takes the current state and the updater function
        set((state) => produce(state, (draft) => {
          // Apply the updater function to the draft state
          updater(draft.settings); // Pass only the settings part of the draft to the updater
        }));

        // Trigger save/notification logic (remains the same)
        const notifySubscribers = async () => {
          const state = get();
          // Notify all subscribers for simplicity, or refine later
          const allCallbacks = new Set<() => void>();
          state.subscribers.forEach(callbacks => {
            callbacks.forEach(cb => allCallbacks.add(cb));
          });

          Array.from(allCallbacks).forEach(callback => {
            try {
              callback();
            } catch (error) {
              logger.error(`Error in settings subscriber during updateSettings:`, createErrorMetadata(error));
            }
          });

          // Save to server if appropriate (copied from set, consider refactoring)
          if (state.initialized && state.settings.system?.persistSettings !== false) {
            try {
              const headers: Record<string, string> = {};
              try {
                const { nostrAuth } = await import('../services/nostrAuthService');
                if (nostrAuth.isAuthenticated()) {
                  const user = nostrAuth.getCurrentUser();
                  const token = nostrAuth.getSessionToken();
                  if (user && token) {
                    headers['X-Nostr-Pubkey'] = user.pubkey;
                    headers['Authorization'] = `Bearer ${token}`;
                  }
                }
              } catch (error) {
                logger.warn('Error getting Nostr authentication for updateSettings:', createErrorMetadata(error));
              }

              const updatedSettings = await settingsService.saveSettings(state.settings, headers);
              if (updatedSettings) {
                if (debugState.isEnabled()) {
                  logger.info('Settings saved to server successfully via updateSettings');
                }
                toast({ title: "Settings Saved", description: "Your settings have been synced with the server." });
              } else {
                // Failure toast handled in catch
              }
            } catch (error) {
              const errorMeta = createErrorMetadata(error);
              logger.error('Failed to save settings to server via updateSettings:', errorMeta);
              toast({ variant: "destructive", title: "Save Failed", description: `Could not save settings to server (updateSettings). ${errorMeta.message || 'Check console.'}` });
            }
          }
        };

        // Debounce saving settings (copied from set)
        if (typeof window !== 'undefined') {
          if (window.settingsSaveTimeout) {
            clearTimeout(window.settingsSaveTimeout);
          }
          window.settingsSaveTimeout = setTimeout(notifySubscribers, 300);
        } else {
          notifySubscribers();
        }
      },

      // The subscribe and unsubscribe functions below were duplicated and are removed by this change.
    }),
    {
      name: 'graph-viz-settings',
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        settings: state.settings,
        authenticated: state.authenticated,
        user: state.user,
        isPowerUser: state.isPowerUser
      })
    }
  )
)

declare global {
  interface Window {
    settingsSaveTimeout: ReturnType<typeof setTimeout>;
  }
}

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/styles/globals.css
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/styles/globals.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 217.2 91.2% 59.8%;
    --primary-foreground: 210 40% 98%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 224.3 76.3% 48%;
    --radius: 0.5rem;
  }
}

@layer base {
  * {
    @apply border-border;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html, body, #root {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
  }

  body {
    @apply bg-background text-foreground;
    font-feature-settings: "rlig" 1, "calt" 1;
    min-height: 100%;
    display: flex;
    flex-direction: column;
  }

  #root {
    display: flex;
    flex-direction: column;
    min-height: 100%;
  }
}

/* Control Panel Styles */
.settings-panel {
  @apply fixed right-4 top-4 z-40 w-80 rounded-lg bg-card p-4 text-card-foreground shadow-lg;
}

.settings-section {
  @apply mb-4 rounded-md border border-border bg-card p-2;
}

.section-header {
  @apply flex items-center justify-between border-b border-border pb-2;
}

.section-content {
  @apply mt-2 space-y-2;
}

.settings-subsection {
  @apply pt-2;
}

.settings-subsection-header {
  @apply text-sm font-medium text-muted-foreground;
}

.setting-control {
  @apply flex items-center justify-between gap-2 py-1;
}

.detached-panel {
  @apply absolute cursor-move rounded-md border border-border bg-card shadow-lg;
}

/* Custom scrollbar styles */
@layer utilities {
  /* Hide scrollbar for Chrome, Safari and Opera */
  .no-scrollbar::-webkit-scrollbar {
    display: none;
  }

  /* Hide scrollbar for IE, Edge and Firefox */
  .no-scrollbar {
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
  }

  /* Custom scrollbar for settings panels */
  .settings-panel-scroll {
    scrollbar-width: thin;
    scrollbar-color: rgba(100, 116, 139, 0.5) transparent;
  }

  .settings-panel-scroll::-webkit-scrollbar {
    width: 6px;
  }

  .settings-panel-scroll::-webkit-scrollbar-track {
    background: transparent;
  }

  .settings-panel-scroll::-webkit-scrollbar-thumb {
    background-color: rgba(100, 116, 139, 0.5);
    border-radius: 20px;
  }
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/styles/index.css
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/styles/index.css
```css
@import '@radix-ui/themes/styles.css';

/* Hardcode control panel background for visibility */
.settings-panel,
.h-full.flex.flex-col.bg-background,
.w-full.h-full.flex.flex-col.min-h-0,
/* Force all text on the control panel background to be white for visibility */
.settings-panel,
.h-full.flex.flex-col.bg-background,
.w-full.h-full.flex.flex-col.min-h-0,
.bg-background {
  color: #fff !important;
}

.settings-panel * {
  color: #fff !important;
}
.bg-background {
  background: #18181b !important;
}
@tailwind base;
@tailwind components;
@tailwind utilities;

@import './tokens.css';
@import './globals.css';
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/styles/tokens.css
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/styles/tokens.css
```css
/**
 * Design Tokens
 *
 * This file contains the design tokens for the application.
 * These variables provide a consistent visual language across the UI.
 */

:root {
  /* Base Colors */
  --color-primary: hsl(222.2, 47.4%, 11.2%);
  --color-primary-foreground: hsl(210, 40%, 98%);

  --color-secondary: hsl(210, 40%, 96.1%);
  --color-secondary-foreground: hsl(222.2, 47.4%, 11.2%);

  --color-accent: hsl(210, 40%, 90%);
  --color-accent-foreground: hsl(222.2, 47.4%, 11.2%);

  --color-destructive: hsl(0, 84.2%, 60.2%);
  --color-destructive-foreground: hsl(210, 40%, 98%);

  --color-muted: hsl(210, 40%, 96.1%);
  --color-muted-foreground: hsl(215.4, 16.3%, 46.9%);

  --color-card: hsl(0, 0%, 100%);
  --color-card-foreground: hsl(222.2, 47.4%, 11.2%);

  --color-popover: hsl(0, 0%, 100%);
  --color-popover-foreground: hsl(222.2, 47.4%, 11.2%);

  --color-border: hsl(214.3, 31.8%, 91.4%);
  --color-input: hsl(214.3, 31.8%, 91.4%);

  --color-background: hsl(0, 0%, 100%);
  --color-foreground: hsl(222.2, 47.4%, 11.2%);

  /* Typography */
  --font-family-sans: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
  --font-family-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;

  --font-size-xs: 0.75rem;    /* 12px */
  --font-size-sm: 0.875rem;   /* 14px */
  --font-size-base: 1rem;     /* 16px */
  --font-size-lg: 1.125rem;   /* 18px */
  --font-size-xl: 1.25rem;    /* 20px */
  --font-size-2xl: 1.5rem;    /* 24px */
  --font-size-3xl: 1.875rem;  /* 30px */
  --font-size-4xl: 2.25rem;   /* 36px */

  --font-weight-light: 300;
  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 600;
  --font-weight-bold: 700;

  --line-height-tight: 1.25;
  --line-height-normal: 1.5;
  --line-height-loose: 1.75;

  /* Spacing */
  --space-1: 0.25rem;  /* 4px */
  --space-2: 0.5rem;   /* 8px */
  --space-3: 0.75rem;  /* 12px */
  --space-4: 1rem;     /* 16px */
  --space-5: 1.25rem;  /* 20px */
  --space-6: 1.5rem;   /* 24px */
  --space-8: 2rem;     /* 32px */
  --space-10: 2.5rem;  /* 40px */
  --space-12: 3rem;    /* 48px */
  --space-16: 4rem;    /* 64px */
  --space-20: 5rem;    /* 80px */
  --space-24: 6rem;    /* 96px */

  /* Layout */
  --width-xs: 20rem;   /* 320px */
  --width-sm: 24rem;   /* 384px */
  --width-md: 28rem;   /* 448px */
  --width-lg: 32rem;   /* 512px */
  --width-xl: 36rem;   /* 576px */
  --width-2xl: 42rem;  /* 672px */
  --width-3xl: 48rem;  /* 768px */
  --width-4xl: 56rem;  /* 896px */
  --width-5xl: 64rem;  /* 1024px */
  --width-6xl: 72rem;  /* 1152px */
  --width-7xl: 80rem;  /* 1280px */

  /* Borders */
  --radius-sm: 0.125rem;  /* 2px */
  --radius-md: 0.25rem;   /* 4px */
  --radius-lg: 0.5rem;    /* 8px */
  --radius-xl: 0.75rem;   /* 12px */
  --radius-2xl: 1rem;     /* 16px */
  --radius-3xl: 1.5rem;   /* 24px */
  --radius-full: 9999px;

  /* Shadows */
  --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
  --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  --shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  --shadow-inner: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);

  /* Z-index */
  --z-0: 0;
  --z-10: 10;
  --z-20: 20;
  --z-30: 30;
  --z-40: 40;
  --z-50: 50;
  --z-tooltip: 100;
  --z-fixed: 200;
  --z-modal: 300;

  /* Transitions */
  --transition-fast: 150ms;
  --transition-normal: 250ms;
  --transition-slow: 350ms;
  --transition-very-slow: 500ms;

  --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);
  --ease-in: cubic-bezier(0.4, 0, 1, 1);
  --ease-out: cubic-bezier(0, 0, 0.2, 1);
  --ease-linear: linear;
}

/* Dark Theme */
.dark {
  --primary: 210 40% 98%;
  --primary-foreground: 222.2 47.4% 11.2%;

  --secondary: 217.2 32.6% 17.5%;
  --secondary-foreground: 210 40% 98%;

  --accent: 217.2 32.6% 17.5%;
  --accent-foreground: 210 40% 98%;

  --destructive: 0 62.8% 30.6%;
  --destructive-foreground: 210 40% 98%;

  --muted: 217.2 32.6% 17.5%;
  --muted-foreground: 215 20.2% 65.1%;

  --card: 222.2 84% 4.9%;
  --card-foreground: 210 40% 98%;

  --popover: 222.2 84% 4.9%;
  --popover-foreground: 210 40% 98%;

  --border: 217.2 32.6% 17.5%;
  --input: 217.2 32.6% 17.5%;

  --background: 222.2 84% 4.9%;
  --foreground: 210 40% 98%;
  /* --ring is not explicitly defined for dark in original tokens.css,
     it will fall back to :root from globals.css or needs to be added if different for dark theme.
     For now, assuming it can use the :root definition from globals.css:
     --ring: 224.3 76.3% 48%;
     If a specific dark theme ring color is needed, it should be added here.
     Example: --ring: [dark theme HSL values];
  */
}

/* High Contrast Theme */
.high-contrast {
  --color-primary: hsl(0, 0%, 100%);
  --color-primary-foreground: hsl(0, 0%, 0%);

  --color-secondary: hsl(0, 0%, 15%);
  --color-secondary-foreground: hsl(0, 0%, 100%);

  --color-accent: hsl(0, 0%, 20%);
  --color-accent-foreground: hsl(0, 0%, 100%);

  --color-destructive: hsl(0, 100%, 50%);
  --color-destructive-foreground: hsl(0, 0%, 100%);

  --color-muted: hsl(0, 0%, 15%);
  --color-muted-foreground: hsl(0, 0%, 80%);

  --color-card: hsl(0, 0%, 0%);
  --color-card-foreground: hsl(0, 0%, 100%);

  --color-popover: hsl(0, 0%, 0%);
  --color-popover-foreground: hsl(0, 0%, 100%);

  --color-border: hsl(0, 0%, 50%);
  --color-input: hsl(0, 0%, 30%);

  --color-background: hsl(0, 0%, 0%);
  --color-foreground: hsl(0, 0%, 100%);
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/types/binaryProtocol.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/types/binaryProtocol.ts
```ts
/**
 * Binary protocol types for WebSocket communication
 *
 * This aligns with the server's binary protocol format (src/utils/binary_protocol.rs)
 */

export interface Vec3 {
  x: number;
  y: number;
  z: number;
}

export interface BinaryNodeData {
  nodeId: number;
  position: Vec3;
  velocity: Vec3;
}

/**
 * Node binary format:
 * - Node ID: 4 bytes (uint32)
 * - Position: 12 bytes (3 float32 values)
 * - Velocity: 12 bytes (3 float32 values)
 * Total: 28 bytes per node
 */
export const BINARY_NODE_SIZE = 28;
export const BINARY_NODE_ID_OFFSET = 0;
export const BINARY_POSITION_OFFSET = 4;
export const BINARY_VELOCITY_OFFSET = 16;

/**
 * Parse binary data buffer into an array of BinaryNodeData objects
 */
export function parseBinaryNodeData(buffer: ArrayBuffer): BinaryNodeData[] {
  if (!buffer || buffer.byteLength === 0) {
    return [];
  }

  // Make a copy of the buffer to avoid any issues with shared references
  const safeBuffer = buffer.slice(0);
  const view = new DataView(safeBuffer);
  const nodes: BinaryNodeData[] = [];

  try {
    // Check if data length is not a multiple of the expected size
    if (safeBuffer.byteLength % BINARY_NODE_SIZE !== 0) {
      console.warn(`Binary data length (${safeBuffer.byteLength} bytes) is not a multiple of ${BINARY_NODE_SIZE}. This may indicate compressed data.`);
      console.warn(`First few bytes: ${new Uint8Array(safeBuffer.slice(0, Math.min(16, safeBuffer.byteLength))).join(', ')}`);

      // Check for zlib header (0x78 followed by compression level byte)
      const header = new Uint8Array(safeBuffer.slice(0, Math.min(4, safeBuffer.byteLength)));
      if (header[0] === 0x78 && (header[1] === 0x01 || header[1] === 0x5E || header[1] === 0x9C || header[1] === 0xDA)) {
        console.error("Data appears to be zlib compressed but decompression failed or wasn't attempted");
      }
    }

    // Calculate how many complete nodes we can process
    const completeNodes = Math.floor(safeBuffer.byteLength / BINARY_NODE_SIZE);

    if (completeNodes === 0) {
      console.warn(`Received binary data with insufficient length: ${safeBuffer.byteLength} bytes (needed at least ${BINARY_NODE_SIZE} bytes per node)`);
      return [];
    }

    for (let i = 0; i < completeNodes; i++) {
      const offset = i * BINARY_NODE_SIZE;

      // Bounds check to prevent errors on corrupted data
      if (offset + BINARY_NODE_SIZE > safeBuffer.byteLength) {
        break;
      }

      // Read node ID (uint32, 4 bytes)
      const nodeId = view.getUint32(offset + BINARY_NODE_ID_OFFSET, true);

      // Read position (3 float32 values, 12 bytes)
      const position: Vec3 = {
        x: view.getFloat32(offset + BINARY_POSITION_OFFSET, true),
        y: view.getFloat32(offset + BINARY_POSITION_OFFSET + 4, true),
        z: view.getFloat32(offset + BINARY_POSITION_OFFSET + 8, true)
      };

      // Read velocity (3 float32 values, 12 bytes)
      const velocity: Vec3 = {
        x: view.getFloat32(offset + BINARY_VELOCITY_OFFSET, true),
        y: view.getFloat32(offset + BINARY_VELOCITY_OFFSET + 4, true),
        z: view.getFloat32(offset + BINARY_VELOCITY_OFFSET + 8, true)
      };

      // Basic validation to detect corrupted data
      const isValid =
        !isNaN(position.x) && isFinite(position.x) &&
        !isNaN(position.y) && isFinite(position.y) &&
        !isNaN(position.z) && isFinite(position.z) &&
        !isNaN(velocity.x) && isFinite(velocity.x) &&
        !isNaN(velocity.y) && isFinite(velocity.y) &&
        !isNaN(velocity.z) && isFinite(velocity.z);

      if (isValid) {
        nodes.push({ nodeId, position, velocity });
      } else {
        console.warn(`Skipping corrupted node data at offset ${offset} (nodeId: ${nodeId})`);
      }
    }
  } catch (error) {
    console.error('Error parsing binary data:', error);
    // Return any nodes we've successfully parsed
  }

  return nodes;
}

/**
 * Create a binary buffer from an array of BinaryNodeData objects
 */
export function createBinaryNodeData(nodes: BinaryNodeData[]): ArrayBuffer {
  const buffer = new ArrayBuffer(nodes.length * BINARY_NODE_SIZE);
  const view = new DataView(buffer);

  nodes.forEach((node, i) => {
    const offset = i * BINARY_NODE_SIZE;

    // Write node ID (uint32, 4 bytes)
    view.setUint32(offset + BINARY_NODE_ID_OFFSET, node.nodeId, true);

    // Write position (3 float32 values, 12 bytes)
    view.setFloat32(offset + BINARY_POSITION_OFFSET, node.position.x, true);
    view.setFloat32(offset + BINARY_POSITION_OFFSET + 4, node.position.y, true);
    view.setFloat32(offset + BINARY_POSITION_OFFSET + 8, node.position.z, true);

    // Write velocity (3 float32 values, 12 bytes)
    view.setFloat32(offset + BINARY_VELOCITY_OFFSET, node.velocity.x, true);
    view.setFloat32(offset + BINARY_VELOCITY_OFFSET + 4, node.velocity.y, true);
    view.setFloat32(offset + BINARY_VELOCITY_OFFSET + 8, node.velocity.z, true);
  });

  return buffer;
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/types/getalby-sdk.d.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/types/getalby-sdk.d.ts
```ts
declare module '@getalby/sdk' {
  export class WebLNProvider {
    constructor();
    getPublicKey(): Promise<string>;
    signEvent(event: any): Promise<any>;
  }
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/types/lucide-react.d.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/types/lucide-react.d.ts
```ts
declare module 'lucide-react' {
  import { FC, SVGProps } from 'react';

  export interface IconProps extends SVGProps<SVGSVGElement> {
    size?: string | number;
    color?: string;
    strokeWidth?: string | number;
  }

  export type Icon = FC<IconProps>;

  // Export all icons that are used in the project
  export const X: Icon;
  export const Minimize: Icon;
  export const Maximize: Icon;
  export const Check: Icon;
  export const ChevronDown: Icon;
  export const ChevronUp: Icon;
  export const Dock: Icon;
  export const Eye: Icon;
  export const EyeOff: Icon;
  export const Circle: Icon;
  export const CircleDashed: Icon;
  export const BrushIcon: Icon;
  export const MoveHorizontal: Icon;

  // Additional icons used in PanelManager
  export const Settings: Icon;
  export const LayoutGrid: Icon;
  export const RefreshCw: Icon;
  export const Terminal: Icon;
  export const Smartphone: Icon;
  export const MonitorSmartphone: Icon;
  export const Info: Icon;
  export const Home: Icon;
  export const ZoomIn: Icon;
  export const ZoomOut: Icon;
  export const RotateCw: Icon;
  export const PanelLeft: Icon;
  export const PanelRight: Icon;
  export const Trash: Icon;
  export const Send: Icon;
  export const Download: Icon;
  export const Anchor: Icon;

  // Add any other icons that might be used in your project
  // This is not an exhaustive list, just including the ones I've seen so far
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/types/nip07.d.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/types/nip07.d.ts
```ts

import type { Event as NostrEvent, UnsignedEvent } from 'nostr-tools';

type Nip07Event = Omit<UnsignedEvent, 'pubkey'>; // pubkey is added by the signer

interface NostrProvider {
  getPublicKey(): Promise<string>; // Returns hex public key
  signEvent(event: Nip07Event): Promise<NostrEvent>; // Returns the full signed event

  // Optional NIP-44 methods
  nip44?: {
    encrypt(pubkey: string, plaintext: string): Promise<string>; // returns ciphertext
    decrypt(pubkey: string, ciphertext: string): Promise<string>; // returns plaintext
  };

  // Optional NIP-04 methods (Deprecated but might exist)
  nip04?: {
    encrypt(pubkey: string, plaintext: string): Promise<string>;
    decrypt(pubkey: string, ciphertext: string): Promise<string>;
  };

  // Optional: Get Relays method (Not in core NIP-07 spec but common)
  getRelays?(): Promise<{ [url: string]: { read: boolean; write: boolean } }>;
}

declare global {
  interface Window {
    nostr?: NostrProvider;
  }
}

export {};
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/types/node-env.d.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/types/node-env.d.ts
```ts

declare const process: {
  env: {
    NODE_ENV: 'development' | 'production' | 'test';
    [key: string]: string | undefined;
  };
};

declare function require(id: string): any;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/types/ragflowTypes.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/types/ragflowTypes.ts
```ts
export interface RagflowChatRequestPayload {
  question: string;
  sessionId?: string;
  stream?: boolean; // Added stream parameter
}

export interface RagflowChatResponsePayload {
  answer: string;
  sessionId: string;
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/types/react-syntax-highlighter.d.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/types/react-syntax-highlighter.d.ts
```ts
declare module 'react-syntax-highlighter' {
  import { ComponentType, ReactNode } from 'react';

  export interface SyntaxHighlighterProps {
    language?: string;
    style?: any;
    children?: string;
    className?: string;
    showLineNumbers?: boolean;
    [key: string]: any;
  }

  export const Prism: ComponentType<SyntaxHighlighterProps>;
  export const Light: ComponentType<SyntaxHighlighterProps>;
}

declare module 'react-syntax-highlighter/dist/esm/styles/prism' {
  const vscDarkPlus: any;
  const dracula: any;
  const atomDark: any;
  const materialDark: any;
  const materialLight: any;
  const nord: any;
  const okaidia: any;
  const solarizedlight: any;
  const tomorrow: any;
  const vs: any;
  const xonokai: any;

  export {
    vscDarkPlus,
    dracula,
    atomDark,
    materialDark,
    materialLight,
    nord,
    okaidia,
    solarizedlight,
    tomorrow,
    vs,
    xonokai
  };
}

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/types/tailwind-merge.d.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/types/tailwind-merge.d.ts
```ts
declare module 'tailwind-merge' {
  /**
   * Merges multiple Tailwind CSS class lists into a single class list.
   * @param classLists - Array of class lists to merge.
   * @returns - Merged class list.
   */
  export function twMerge(...classLists: (string | undefined | null | false)[]): string;

  /**
   * Creates a custom instance of twMerge with custom configuration.
   * @param config - Configuration object.
   * @returns - A custom twMerge function.
   */
  export function twMergeConfig(config: Record<string, unknown>): typeof twMerge;
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/types/webxr-extensions.d.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/types/webxr-extensions.d.ts
```ts
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/ui/Button.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/ui/Button.tsx
```tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../utils/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/ui/Card.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/ui/Card.tsx
```tsx
import * as React from "react"

import { cn } from "../utils/utils" // Corrected path

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border border-border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/ui/Collapsible.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/ui/Collapsible.tsx
```tsx
import * as React from "react"
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

import { cn } from "../utils/utils" // Corrected path

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = React.forwardRef<
  React.ElementRef<typeof CollapsiblePrimitive.CollapsibleContent>,
  React.ComponentPropsWithoutRef<typeof CollapsiblePrimitive.CollapsibleContent>
>(({ className, ...props }, ref) => (
  <CollapsiblePrimitive.CollapsibleContent
    ref={ref}
    className={cn(
      "data-[state=closed]:animate-collapsible-up data-[state=open]:animate-collapsible-down overflow-hidden transition-all",
      className
    )}
    {...props}
  />
))
CollapsibleContent.displayName = "CollapsibleContent"

export { Collapsible, CollapsibleTrigger, CollapsibleContent }
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/ui/Input.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/ui/Input.tsx
```tsx
import * as React from "react"

import { cn } from "../utils/utils" // Corrected path

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/ui/Label.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/ui/Label.tsx
```tsx
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../utils/utils" // Corrected path

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = "Label"

export { Label }
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/ui/RadioGroup.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/ui/RadioGroup.tsx
```tsx
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "../utils/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/ui/Select.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/ui/Select.tsx
```tsx
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "../utils/utils" // Corrected path

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border border-border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/ui/Slider.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/ui/Slider.tsx
```tsx
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "../utils/utils" // Corrected path

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track
      className="relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20"
      style={{ height: '10px', width: '100%', backgroundColor: 'blue', display: 'block', opacity: 1, visibility: 'visible' }}
    >
      <SliderPrimitive.Range
        className="absolute h-full bg-primary"
        style={{ height: '100%', backgroundColor: 'green', display: 'block', opacity: 1, visibility: 'visible' }}
      />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb
      className="block h-4 w-4 rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50"
      style={{ height: '20px', width: '20px', backgroundColor: 'orange', display: 'block', opacity: 1, visibility: 'visible', border: '2px solid red' }}
    />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/ui/Switch.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/ui/Switch.tsx
```tsx
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "../utils/utils" // Corrected path

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/ui/Tabs.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/ui/Tabs.tsx
```tsx
import React, { useState, ReactNode } from 'react';
import { cn } from '../utils/cn'; // Assuming you have a utility for class names

interface Tab {
  label: string;
  content: ReactNode;
  icon?: ReactNode; // Optional icon for the tab
}

interface TabsProps {
  tabs: Tab[];
  initialTab?: number;
  className?: string;
  tabListClassName?: string;
  tabButtonClassName?: string;
  activeTabButtonClassName?: string;
  tabContentClassName?: string;
}

const Tabs: React.FC<TabsProps> = ({
  tabs,
  initialTab = 0,
  className,
  tabListClassName,
  tabButtonClassName,
  activeTabButtonClassName,
  tabContentClassName,
}) => {
  const [activeTab, setActiveTab] = useState(initialTab);

  if (!tabs || tabs.length === 0) {
    return null; // Don't render anything if no tabs are provided
  }

  return (
    // Added default dark theme classes
    <div className={cn('flex flex-col h-full min-h-0', className)}>
      {/* Tab List */}
      <div
        className={cn(
          'flex border-b border-border overflow-x-auto', // Reverted p-2
          tabListClassName
        )}
      >
        {tabs.map((tab, index) => (
          <button
            key={index}
            onClick={() => setActiveTab(index)}
            style={{ backgroundColor: 'yellow', color: 'black', padding: '10px', border: '2px solid red', display: 'block', visibility: 'visible', opacity: 1, zIndex: 9999 }}
            className={cn(
              // Base styles for dark theme button appearance
              'appearance-none border-none bg-transparent', // Restore bg-transparent
              'flex items-center px-4 py-2', // Adjusted padding
              'text-sm font-medium', // Consistent font styling
              'text-muted-foreground hover:text-foreground', // Restore text colors
              'focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 focus:ring-offset-background', // Focus ring for accessibility
              'whitespace-nowrap transition-colors duration-150 ease-in-out', // Smooth transition
              // Remove default bottom border, apply only to active
              tabButtonClassName, // Allow overrides
              // Active tab styles
              activeTab === index && 'border-b-2 border-primary text-foreground', // Restore active text color
              activeTab === index && activeTabButtonClassName // Allow overrides for active state
            )}
            aria-selected={activeTab === index}
            role="tab"
          >
            {tab.icon && <span className="mr-2">{tab.icon}</span>}
            {tab.label}
          </button>
        ))}
      </div>

      {/* Tab Content - Added default dark theme classes */}
      <div
        className={cn('flex-1 min-h-0 overflow-y-auto p-4 space-y-6', tabContentClassName)}
        role="tabpanel"
      >
        {tabs[activeTab]?.content}
      </div>
    </div>
  );
};

export default Tabs;

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/ui/ThemeProvider.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/ui/ThemeProvider.tsx
```tsx
import { createContext, useContext, useEffect, useState } from "react"

type Theme = "dark" | "light" | "system"

type ThemeProviderProps = {
  children: React.ReactNode
  defaultTheme?: Theme
  storageKey?: string
}

type ThemeProviderState = {
  theme: Theme
  setTheme: (theme: Theme) => void
}

const initialState: ThemeProviderState = {
  theme: "system",
  setTheme: () => null,
}

const ThemeProviderContext = createContext<ThemeProviderState>(initialState)

export function ThemeProvider({
  children,
  defaultTheme = "system",
  storageKey = "ui-theme",
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(
    () => (localStorage.getItem(storageKey) as Theme) || defaultTheme
  )

  useEffect(() => {
    const root = window.document.documentElement

    root.classList.remove("light", "dark")

    if (theme === "system") {
      const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
        .matches
        ? "dark"
        : "light"

      root.classList.add(systemTheme)
      return
    }

    root.classList.add(theme)
  }, [theme])

  const value = {
    theme,
    setTheme: (theme: Theme) => {
      localStorage.setItem(storageKey, theme)
      setTheme(theme)
    },
  }

  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  )
}

export const useTheme = () => {
  const context = useContext(ThemeProviderContext)

  if (context === undefined)
    throw new Error("useTheme must be used within a ThemeProvider")

  return context
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/ui/ThemeSelector.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/ui/ThemeSelector.tsx
```tsx
import React from 'react';
import { useTheme } from './ThemeProvider';
import { Button } from './Button';
import { Check } from 'lucide-react';

const ThemeSelector = () => {
  const { theme, setTheme } = useTheme();

  return (
    <div className="space-y-4">
      <div className="flex flex-col space-y-2">
        <h3 className="text-sm font-medium">Theme</h3>
        <div className="flex flex-wrap gap-2">
          <Button
            variant={theme === 'light' ? 'default' : 'outline'}
            size="sm"
            onClick={() => setTheme('light')}
            className="flex items-center"
          >
            Light
            {theme === 'light' && <Check className="h-3 w-3 ml-1" />}
          </Button>

          <Button
            variant={theme === 'dark' ? 'default' : 'outline'}
            size="sm"
            onClick={() => setTheme('dark')}
            className="flex items-center"
          >
            Dark
            {theme === 'dark' && <Check className="h-3 w-3 ml-1" />}
          </Button>

          <Button
            variant={theme === 'system' ? 'default' : 'outline'}
            size="sm"
            onClick={() => setTheme('system')}
            className="flex items-center"
          >
            System
            {theme === 'system' && <Check className="h-3 w-3 ml-1" />}
          </Button>
        </div>
      </div>

      <div className="mt-4 p-3 bg-muted rounded-md">
        <div className="text-sm text-muted-foreground">
          Theme changes are saved automatically and will persist between sessions.
        </div>
      </div>
    </div>
  );
};

export default ThemeSelector;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/ui/Toast.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/ui/Toast.tsx
```tsx
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "../utils/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/ui/Toaster.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/ui/Toaster.tsx
```tsx
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "./Toast"
import { useToast } from "./useToast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/ui/Tooltip.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/ui/Tooltip.tsx
```tsx
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "../utils/utils"

const TooltipProvider = TooltipPrimitive.Provider

const TooltipRoot = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

interface TooltipProps {
  children: React.ReactNode;
  content: string;
  side?: "top" | "right" | "bottom" | "left";
  align?: "start" | "center" | "end";
}

const Tooltip = ({ children, content, side = "top", align = "center" }: TooltipProps) => {
  return (
    <TooltipRoot>
      <TooltipTrigger asChild>
        {children}
      </TooltipTrigger>
      <TooltipContent side={side} align={align}>
        {content}
      </TooltipContent>
    </TooltipRoot>
  );
};

export { TooltipRoot, TooltipTrigger, TooltipContent, TooltipProvider, Tooltip }

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/ui/formGroup/FormGroup.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/ui/formGroup/FormGroup.tsx
```tsx
import { ReactNode } from 'react';
import { createLogger } from '../../utils/logger';

const logger = createLogger('FormGroup');

interface FormGroupProps {
  /** Form group label */
  label: string;

  /** Unique identifier for the form group */
  id?: string;

  /** Form group children (typically form controls) */
  children: ReactNode;

  /** Optional help text */
  helpText?: string;

  /** Error message to display */
  error?: string;

  /** Whether the field is required */
  required?: boolean;

  /** Whether this is an advanced setting */
  advanced?: boolean;

  /** Additional CSS classes */
  className?: string;
}

/** FormGroup provides consistent layout and styling for form controls */
const FormGroup = ({
  label,
  id,
  children,
  helpText,
  error,
  required = false,
  advanced = false,
  className = '',
}: FormGroupProps) => {
  return (
    <div
      className={`form-group space-y-2 mb-4 ${advanced ? 'advanced-setting' : ''} ${className}`}
      data-testid={`form-group-${id || label.toLowerCase().replace(/\s+/g, '-')}`}
    >
      <div className="flex justify-between items-center">
        <label
          htmlFor={id}
          className={`text-sm font-medium ${error ? 'text-destructive' : ''}`}
        >
          {label}
          {required && <span className="text-destructive ml-1">*</span>}
          {advanced && <span className="text-muted-foreground ml-2 text-xs">(Advanced)</span>}
        </label>
      </div>

      <div className="control-wrapper">{children}</div>

      {(helpText || error) && (
        <div className="text-xs">
          {error ? (
            <p className="text-destructive">{error}</p>
          ) : helpText ? (
            <p className="text-muted-foreground">{helpText}</p>
          ) : null}
        </div>
      )}
    </div>
  );
};

interface FormGroupControlProps {
  /** Control children */
  children: ReactNode;

  /** Additional CSS classes */
  className?: string;
}

/** Container for form controls with consistent styling */
const FormGroupControl = ({ children, className = '' }: FormGroupControlProps) => (
  <div className={`w-full ${className}`}>{children}</div>
);

interface FormGroupRowProps {
  /** Row children */
  children: ReactNode;

  /** Additional CSS classes */
  className?: string;
}

/** Row layout for horizontal form controls */
const FormGroupRow = ({ children, className = '' }: FormGroupRowProps) => (
  <div className={`flex flex-wrap items-center gap-2 ${className}`}>{children}</div>
);

interface FormGroupColumnProps {
  /** Column children */
  children: ReactNode;

  /** Column width (12 = full width) */
  width?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;

  /** Additional CSS classes */
  className?: string;
}

/** Column layout for vertical form controls */
const FormGroupColumn = ({
  children,
  width = 12,
  className = ''
}: FormGroupColumnProps) => {
  const widthClass = `w-${width}/12`;

  return (
    <div className={`${widthClass} ${className}`}>{children}</div>
  );
};

export {
  FormGroup,
  FormGroupControl,
  FormGroupRow,
  FormGroupColumn
};
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/ui/markdown/MarkdownRenderer.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/ui/markdown/MarkdownRenderer.tsx
```tsx
import { useState } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism';
import { cn } from '@/utils/cn';
import { Button } from '@/ui/Button';
import { Download, Check, Settings, Terminal, Anchor } from 'lucide-react';

const InteractiveCodeBlock = ({ language, code, className }) => {
  const [editable, setEditable] = useState(false);
  const [value, setValue] = useState(code);
  const [copied, setCopied] = useState(false);
  const [executing, setExecuting] = useState(false);
  const [output, setOutput] = useState(null);

  const handleEdit = () => {
    setEditable(true);
  };

  const handleSave = () => {
    setEditable(false);
  };

  const handleCopy = () => {
    navigator.clipboard.writeText(value);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const handleExecute = () => {
    setExecuting(true);
    // Simulate code execution
    setTimeout(() => {
      setOutput(`Executed ${language} code successfully!`);
      setExecuting(false);
    }, 1000);
  };

  const isExecutable = ['javascript', 'js', 'typescript', 'ts', 'python', 'py'].includes(language);

  return (
    <div className="relative group">
      {editable ? (
        <div className="relative">
          <textarea
            value={value}
            onChange={(e) => setValue(e.target.value)}
            className="w-full h-full p-4 bg-muted text-sm font-mono rounded-md"
            rows={value.split('\n').length + 1}
          />
          <div className="absolute top-2 right-2 flex space-x-1">
            <Button
              variant="ghost"
              size="icon"
              className="h-6 w-6 bg-background/80"
              onClick={handleSave}
              aria-label="Save"
            >
              {/* Using Check for Save */}
              <Check className="h-3 w-3" />
            </Button>
          </div>
        </div>
      ) : (
        <div className="relative">
          <SyntaxHighlighter
            style={vscDarkPlus}
            language={language}
            className={cn("rounded-md", className)}
            showLineNumbers={true}
          >
            {value}
          </SyntaxHighlighter>

          <div className="absolute top-2 right-2 flex space-x-1 opacity-0 group-hover:opacity-100 transition-opacity">
            <Button
              variant="ghost"
              size="icon"
              className="h-6 w-6 bg-background/80"
              onClick={handleCopy}
              aria-label="Copy code"
            >
              {/* Using Download for Copy */}
              {copied ? <Check className="h-3 w-3" /> : <Download className="h-3 w-3" />}
            </Button>
            <Button
              variant="ghost"
              size="icon"
              className="h-6 w-6 bg-background/80"
              onClick={handleEdit}
              aria-label="Edit code"
            >
              {/* Using Settings for Edit */}
              <Settings className="h-3 w-3" />
            </Button>
            {isExecutable && (
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 bg-background/80"
                onClick={handleExecute}
                aria-label="Execute code"
                disabled={executing}
              >
                {/* Using Terminal for Play */}
                <Terminal className="h-3 w-3" />
              </Button>
            )}
          </div>
        </div>
      )}

      {output && (
        <div className="mt-2 p-3 bg-muted/50 rounded-md border border-border">
          <div className="text-xs font-medium mb-1">Output:</div>
          <div className="text-sm font-mono">{output}</div>
        </div>
      )}
    </div>
  );
};

const InteractiveLink = ({ href, children }) => {
  const isExternal = href.startsWith('http');

  return (
    <a
      href={href}
      target={isExternal ? "_blank" : undefined}
      rel={isExternal ? "noopener noreferrer" : undefined}
      className="text-primary hover:underline inline-flex items-center"
    >
      {children}
      {/* Using Anchor for ExternalLink */}
      {isExternal && <Anchor className="ml-1 h-3 w-3" />}
    </a>
  );
};

const MarkdownRenderer = ({ content, className }) => {
  return (
    <div className={cn("markdown-content prose prose-invert max-w-none", className)}>
      <ReactMarkdown
        remarkPlugins={[remarkGfm]}
        components={{
          h1: ({ node, ...props }) => <h1 className="text-2xl font-bold mt-6 mb-4" {...props} />,
          h2: ({ node, ...props }) => <h2 className="text-xl font-bold mt-5 mb-3" {...props} />,
          h3: ({ node, ...props }) => <h3 className="text-lg font-bold mt-4 mb-2" {...props} />,
          h4: ({ node, ...props }) => <h4 className="text-base font-bold mt-3 mb-2" {...props} />,
          p: ({ node, ...props }) => <p className="my-2" {...props} />,
          a: ({ node, href, children, ...props }) => <InteractiveLink href={href} {...props}>{children}</InteractiveLink>,
          ul: ({ node, ...props }) => <ul className="list-disc pl-6 my-2" {...props} />,
          ol: ({ node, ...props }) => <ol className="list-decimal pl-6 my-2" {...props} />,
          li: ({ node, ...props }) => <li className="my-1" {...props} />,
          blockquote: ({ node, ...props }) => (
            <blockquote className="border-l-4 border-primary pl-4 italic my-4" {...props} />
          ),
          code: ({ node, className, children, ...props }) => { // Removed 'inline' from destructuring
            const match = /language-(\w+)/.exec(className || '');
            const language = match ? match[1] : '';
            const codeContent = String(children).replace(/\n$/, '');

            // Check for special comment to make code block interactive
            const isInteractive = codeContent.includes('// @interactive') ||
                                  codeContent.includes('# @interactive');

            const isBlock = className && /language-(\w+)/.test(className);

            return isBlock ? (
              isInteractive ? (
                <InteractiveCodeBlock
                  language={language}
                  code={codeContent.replace(/\/\/ @interactive|# @interactive/g, '')}
                  className="my-4"
                />
              ) : (
                <SyntaxHighlighter
                  style={vscDarkPlus}
                  language={language}
                  className="rounded-md my-4"
                  showLineNumbers={true}
                  {...props}
                >
                  {codeContent}
                </SyntaxHighlighter>
              )
            ) : (
              <code className="bg-muted px-1 py-0.5 rounded text-sm" {...props}>
                {children}
              </code>
            );
          },
          table: ({ node, ...props }) => (
            <div className="overflow-x-auto my-4">
              <table className="min-w-full divide-y divide-border" {...props} />
            </div>
          ),
          thead: ({ node, ...props }) => <thead className="bg-muted" {...props} />,
          tbody: ({ node, ...props }) => <tbody className="divide-y divide-border" {...props} />,
          tr: ({ node, ...props }) => <tr className="hover:bg-muted/50" {...props} />,
          th: ({ node, ...props }) => (
            <th className="px-4 py-2 text-left text-xs font-medium uppercase tracking-wider" {...props} />
          ),
          td: ({ node, ...props }) => <td className="px-4 py-2 text-sm" {...props} />,
          hr: ({ node, ...props }) => <hr className="my-6 border-border" {...props} />,
          img: ({ node, ...props }) => (
            <img
              className="max-w-full h-auto rounded-md my-4 hover:opacity-90 transition-opacity"
              loading="lazy"
              {...props}
              alt={props.alt || ''}
            />
          ),
        }}
      >
        {content}
      </ReactMarkdown>
    </div>
  );
};

export default MarkdownRenderer;
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/ui/useToast.tsx
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/ui/useToast.tsx
```tsx
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "./Toast" // Corrected path (assuming Toast.tsx is in the same directory)

const TOAST_LIMIT = 5
const TOAST_REMOVE_DELAY = 5000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
  duration?: number
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_VALUE
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: string
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: string
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case actionTypes.ADD_TOAST:
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case actionTypes.UPDATE_TOAST:
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case actionTypes.DISMISS_TOAST: {
      const { toastId } = action

      if (toastId) {
        toastTimeouts.forEach((_, id) => {
          if (id === toastId) {
            toastTimeouts.delete(id)
          }
        })

        return {
          ...state,
          toasts: state.toasts.map((t) =>
            t.id === toastId
              ? {
                  ...t,
                  open: false,
                }
              : t
          ),
        }
      }

      return {
        ...state,
        toasts: state.toasts.map((t) => ({
          ...t,
          open: false,
        })),
      }
    }

    case actionTypes.REMOVE_TOAST:
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: actionTypes.UPDATE_TOAST,
      toast: { ...props, id },
    })

  const dismiss = () => dispatch({ type: actionTypes.DISMISS_TOAST, toastId: id })

  dispatch({
    type: actionTypes.ADD_TOAST,
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: actionTypes.DISMISS_TOAST, toastId }),
    remove: (toastId?: string) => dispatch({ type: actionTypes.REMOVE_TOAST, toastId }),
  }
}

export { useToast, toast }
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/utils/binaryUtils.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/utils/binaryUtils.ts
```ts
/**
 * Utility functions for binary data handling
 *
 * Note: Binary decompression is now handled by the graph worker.
 * This file is kept for potential future binary utilities.
 */
import { createLogger } from './logger';

const logger = createLogger('BinaryUtils');


export {};
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/utils/caseConversion.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/utils/caseConversion.ts
```ts
/**
 * Utility functions for converting between different case styles (snake_case, camelCase)
 * Used primarily for API communication where server uses snake_case and client uses camelCase
 */

/**
 * Converts a snake_case string to camelCase
 * @param str The snake_case string to convert
 * @returns The camelCase version of the string
 */
export function snakeToCamel(str: string): string {
  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
}

/**
 * Converts a camelCase string to snake_case
 * @param str The camelCase string to convert
 * @returns The snake_case version of the string
 */
export function camelToSnake(str: string): string {
  return str.replace(/([A-Z])/g, (_, letter) => `_${letter.toLowerCase()}`);
}

/**
 * Recursively converts all keys in an object from snake_case to camelCase
 * @param obj The object with snake_case keys
 * @returns A new object with all keys converted to camelCase
 */
export function convertSnakeToCamelCase<T extends Record<string, any>>(obj: T): Record<string, any> {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(item => convertSnakeToCamelCase(item)) as any;
  }

  return Object.keys(obj).reduce((result, key) => {
    const camelKey = snakeToCamel(key);
    const value = obj[key];

    result[camelKey] = typeof value === 'object' && value !== null
      ? convertSnakeToCamelCase(value)
      : value;

    return result;
  }, {} as Record<string, any>);
}

/**
 * Recursively converts all keys in an object from camelCase to snake_case
 * @param obj The object with camelCase keys
 * @returns A new object with all keys converted to snake_case
 */
export function convertCamelToSnakeCase<T extends Record<string, any>>(obj: T): Record<string, any> {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(item => convertCamelToSnakeCase(item)) as any;
  }

  return Object.keys(obj).reduce((result, key) => {
    const snakeKey = camelToSnake(key);
    const value = obj[key];

    result[snakeKey] = typeof value === 'object' && value !== null
      ? convertCamelToSnakeCase(value)
      : value;

    return result;
  }, {} as Record<string, any>);
}

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/utils/cn.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/utils/cn.ts
```ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/utils/debugState.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/utils/debugState.ts
```ts
import { createLogger } from './logger';

const logger = createLogger('DebugState');

class DebugState {
  private debugEnabled: boolean = false;
  private dataDebugEnabled: boolean = false;
  private performanceDebugEnabled: boolean = false;

  constructor() {
    // Initialize from localStorage if available
    this.loadFromStorage();
  }

  private loadFromStorage(): void {
    if (typeof window !== 'undefined') {
      try {
        this.debugEnabled = localStorage.getItem('debug.enabled') === 'true';
        this.dataDebugEnabled = localStorage.getItem('debug.data') === 'true';
        this.performanceDebugEnabled = localStorage.getItem('debug.performance') === 'true';
      } catch (e) {
        logger.warn('Failed to load debug state from localStorage');
      }
    }
  }

  private saveToStorage(): void {
    if (typeof window !== 'undefined') {
      try {
        localStorage.setItem('debug.enabled', this.debugEnabled.toString());
        localStorage.setItem('debug.data', this.dataDebugEnabled.toString());
        localStorage.setItem('debug.performance', this.performanceDebugEnabled.toString());
      } catch (e) {
        logger.warn('Failed to save debug state to localStorage');
      }
    }
  }

  public isEnabled(): boolean {
    return this.debugEnabled;
  }

  public enableDebug(enable: boolean = true): void {
    this.debugEnabled = enable;
    this.saveToStorage();
    logger.info(`Debug mode ${enable ? 'enabled' : 'disabled'}`);
  }

  public isDataDebugEnabled(): boolean {
    return this.debugEnabled && this.dataDebugEnabled;
  }

  public enableDataDebug(enable: boolean = true): void {
    this.dataDebugEnabled = enable;
    this.saveToStorage();
    logger.info(`Data debug mode ${enable ? 'enabled' : 'disabled'}`);
  }

  public isPerformanceDebugEnabled(): boolean {
    return this.debugEnabled && this.performanceDebugEnabled;
  }

  public enablePerformanceDebug(enable: boolean = true): void {
    this.performanceDebugEnabled = enable;
    this.saveToStorage();
    logger.info(`Performance debug mode ${enable ? 'enabled' : 'disabled'}`);
  }
}

export const debugState = new DebugState();
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/utils/deepMerge.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/utils/deepMerge.ts
```ts
/**
 * Deep merge utility for merging nested objects
 * This is used to properly merge settings objects with nested properties
 */

/**
 * Checks if a value is an object (but not null, array, or function)
 */
export function isObject(item: any): boolean {
  return (
    item !== null &&
    typeof item === 'object' &&
    !Array.isArray(item) &&
    !(item instanceof Date) &&
    !(item instanceof RegExp) &&
    !(item instanceof Map) &&
    !(item instanceof Set)
  );
}

/**
 * Deep merges multiple objects together
 * Later objects in the arguments list take precedence over earlier ones
 */
export function deepMerge<T extends Record<string, any>>(...objects: (T | undefined)[]): T {
  // Filter out undefined objects
  const validObjects = objects.filter(obj => obj !== undefined) as T[];

  // Return empty object if no valid objects
  if (validObjects.length === 0) {
    return {} as T;
  }

  // Return the first object if only one is provided
  if (validObjects.length === 1) {
    return { ...validObjects[0] };
  }

  // Start with a copy of the first object
  const result = { ...validObjects[0] };

  // Merge each subsequent object
  for (let i = 1; i < validObjects.length; i++) {
    const obj = validObjects[i];

    // Skip if undefined
    if (!obj) continue;

    // Merge each property
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        const value = obj[key];

        // If both values are objects, recursively merge them
        if (isObject(result[key]) && isObject(value)) {
          result[key] = deepMerge(result[key], value);
        }
        // Otherwise, use the value from the current object
        else {
          result[key] = value;
        }
      }
    }
  }

  return result;
}

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/utils/logger.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/utils/logger.ts
```ts
/**
 * Simple logger utility with color-coded console output and log storage
 */

type LogLevel = 'debug' | 'info' | 'warn' | 'error';

interface LogEntry {
  timestamp: string;
  level: LogLevel;
  namespace: string;
  message: string;
  args: any[];
}

interface LoggerOptions {
  disabled?: boolean;
  level?: LogLevel;
  maxLogEntries?: number; // Optional limit for stored logs
}

const LOG_LEVEL_PRIORITY: Record<LogLevel, number> = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
};

const LOG_COLORS = {
  debug: '#8c8c8c', // gray
  info: '#4c9aff',  // blue
  warn: '#ffab00',  // orange
  error: '#ff5630', // red
};

const logStorage: LogEntry[] = [];
const DEFAULT_MAX_LOG_ENTRIES = 1000;

export function createLogger(namespace: string, options: LoggerOptions = {}) {
  const { disabled = false, level = 'info', maxLogEntries = DEFAULT_MAX_LOG_ENTRIES } = options;
  const levelPriority = LOG_LEVEL_PRIORITY[level];

  function shouldLog(msgLevel: LogLevel): boolean {
    if (disabled) return false;
    return LOG_LEVEL_PRIORITY[msgLevel] >= levelPriority;
  }

  function formatMessage(message: any): string {
    if (typeof message === 'string') return message;
    if (message instanceof Error) {
      return message.stack ? message.stack : message.message;
    }
    try {
      // Attempt to stringify complex objects, handle potential circular references
      return JSON.stringify(message, (key, value) => {
        if (typeof value === 'object' && value !== null) {
          // Basic circular reference check (can be improved)
          if (value === message && key !== '') return '[Circular Reference]';
        }
        return value;
      }, 2);
    } catch (e) {
      return String(message);
    }
  }

  // Function to format arguments, handling Errors specifically
  function formatArgs(args: any[]): any[] {
      return args.map(arg => {
        if (arg instanceof Error) {
          return { message: arg.message, name: arg.name, stack: arg.stack }; // Serialize error
        }
        // Add more type handling if needed (e.g., Functions, DOM elements)
        return arg;
      });
  }


  function createLogMethod(logLevel: LogLevel) {
    return function(message: any, ...args: any[]) {
      if (!shouldLog(logLevel)) return;

      const color = LOG_COLORS[logLevel];
      const now = new Date();
      const timestamp = now.toISOString();
      const consoleTimestamp = now.toISOString().split('T')[1].slice(0, -1);
      const prefix = `%c[${consoleTimestamp}] [${namespace}]`;

      const formattedArgs = formatArgs(args);
      const formattedMessage = formatMessage(message);

      // Store the log entry
      logStorage.push({
        timestamp,
        level: logLevel,
        namespace,
        message: formattedMessage, // Store the formatted message
        args: formattedArgs, // Store formatted args
      });

      // Trim log storage if it exceeds the limit
      if (logStorage.length > maxLogEntries) {
        logStorage.shift(); // Remove the oldest entry
      }

      // Output to console
      console[logLevel === 'debug' ? 'log' : logLevel](
        `${prefix} ${formattedMessage}`,
        `color: ${color}; font-weight: bold;`,
        ...args // Log original args to console for better interactivity
      );
    };
  }

  // Function to retrieve stored logs
  function getLogs(): LogEntry[] {
    // Return a copy to prevent external modification
    return [...logStorage];
  }

  return {
    debug: createLogMethod('debug'),
    info: createLogMethod('info'),
    warn: createLogMethod('warn'),
    error: createLogMethod('error'),
    getLogs, // Expose the getLogs method
  };
}

export function createErrorMetadata(error: unknown): Record<string, any> {
  if (error instanceof Error) {
    return {
      message: error.message,
      name: error.name,
      stack: error.stack,
      // Potentially add other known properties of custom errors if any
    };
  }
  // If it's not an Error instance, try to get more details
  if (typeof error === 'object' && error !== null) {
    // Attempt to serialize the object.
    try {
      // Using Object.getOwnPropertyNames to include non-enumerable properties if error is an object
      const errorKeys = Object.getOwnPropertyNames(error);
      const serializableError = errorKeys.reduce((acc, key) => {
        acc[key] = (error as any)[key];
        return acc;
      }, {} as Record<string, any>);

      const serializedErrorString = JSON.stringify(serializableError, null, 2); // Pretty print
      return {
        message: `Non-Error object encountered. Details: ${serializedErrorString.substring(0, 500)}${serializedErrorString.length > 500 ? '...' : ''}`, // Truncate for sanity
        originalErrorType: 'Object', // Indicate it was an object
        // Consider if including the full 'error' object is too verbose or has circular refs
        // For now, relying on the stringified version.
      };
    } catch (e) {
      // JSON.stringify failed (e.g., circular references not caught by custom serializer)
      return {
        message: `Non-Error object (serialization failed): ${String(error)}`,
        originalErrorType: typeof error,
      };
    }
  }
  // Fallback for primitives or other types
  return {
    message: `Unknown error type: ${String(error)}`,
    originalErrorType: typeof error,
  };
}

export function createDataMetadata(data: Record<string, any>): Record<string, any> {
  return {
    ...data,
    timestamp: new Date().toISOString(),
  };
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/utils/objectPath.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/utils/objectPath.ts
```ts
/**
 * Utility functions for working with object paths
 * Uses dot notation to access nested properties (e.g., "visualisation.nodes.baseColor")
 */

type NestedObject = Record<string, any>;

/**
 * Gets a value from a nested object using a dot notation path
 * @param obj The object to get the value from
 * @param path The path to the value, using dot notation (e.g., "visualisation.nodes.baseColor")
 * @param defaultValue A default value to return if the path doesn't exist
 * @returns The value at the path, or the default value if not found
 */
export function get(obj: NestedObject, path: string, defaultValue?: any): any {
  if (!path || !obj) {
    return defaultValue;
  }

  const keys = path.split('.');
  let current = obj;

  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];

    // Handle array indices in path
    if (key.includes('[') && key.includes(']')) {
      const arrayKey = key.substring(0, key.indexOf('['));
      const indexStr = key.substring(key.indexOf('[') + 1, key.indexOf(']'));
      const index = parseInt(indexStr, 10);

      if (current[arrayKey] === undefined ||
          !Array.isArray(current[arrayKey]) ||
          current[arrayKey][index] === undefined) {
        return defaultValue;
      }

      current = current[arrayKey][index];
      continue;
    }

    if (current[key] === undefined) {
      return defaultValue;
    }

    current = current[key];
  }

  return current;
}

/**
 * Sets a value in a nested object using a dot notation path
 * Creates the object structure if it doesn't exist
 * @param obj The object to set the value in
 * @param path The path to set, using dot notation (e.g., "visualisation.nodes.baseColor")
 * @param value The value to set
 */
export function set(obj: NestedObject, path: string, value: any): void {
  if (!path || !obj) {
    return;
  }

  const keys = path.split('.');
  let current = obj;

  for (let i = 0; i < keys.length - 1; i++) {
    const key = keys[i];

    // Handle array indices in path
    if (key.includes('[') && key.includes(']')) {
      const arrayKey = key.substring(0, key.indexOf('['));
      const indexStr = key.substring(key.indexOf('[') + 1, key.indexOf(']'));
      const index = parseInt(indexStr, 10);

      if (current[arrayKey] === undefined) {
        current[arrayKey] = [];
      }

      if (!Array.isArray(current[arrayKey])) {
        current[arrayKey] = [];
      }

      if (current[arrayKey][index] === undefined) {
        current[arrayKey][index] = {};
      }

      current = current[arrayKey][index];
      continue;
    }

    if (current[key] === undefined || typeof current[key] !== 'object' || current[key] === null) {
      current[key] = {};
    }

    current = current[key];
  }

  // Handle the last key
  const lastKey = keys[keys.length - 1];

  // Check if last key is an array index
  if (lastKey.includes('[') && lastKey.includes(']')) {
    const arrayKey = lastKey.substring(0, lastKey.indexOf('['));
    const indexStr = lastKey.substring(lastKey.indexOf('[') + 1, lastKey.indexOf(']'));
    const index = parseInt(indexStr, 10);

    if (current[arrayKey] === undefined) {
      current[arrayKey] = [];
    }

    if (!Array.isArray(current[arrayKey])) {
      current[arrayKey] = [];
    }

    current[arrayKey][index] = value;
  } else {
    current[lastKey] = value;
  }
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/src/utils/utils.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/src/utils/utils.ts
```ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge" // Already installed in package.json

/**
 * Merges class names with Tailwind CSS classes
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

/**
 * Format a setting name for display (convert camelCase to Title Case)
 */
export function formatSettingName(name: string): string {
  // Handle special case acronyms (e.g., "XR" should remain uppercase)
  if (name === 'xr') return 'XR';

  // Replace camelCase with spaces
  const spacedName = name.replace(/([A-Z])/g, ' $1').trim();

  // Capitalize first letter of each word
  return spacedName.charAt(0).toUpperCase() + spacedName.slice(1);
}

/**
 * Check if a value is defined (not undefined and not null)
 */
export function isDefined<T>(value: T | undefined | null): value is T {
  return value !== undefined && value !== null;
}

/**
 * Debounce a function call
 */
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: ReturnType<typeof setTimeout> | null = null;

  return function(...args: Parameters<T>) {
    if (timeout) {
      clearTimeout(timeout);
    }

    timeout = setTimeout(() => {
      func(...args);
    }, wait);
  };
}

/**
 * Truncate a string to the specified length
 */
export function truncate(str: string, length: number): string {
  if (str.length <= length) {
    return str;
  }

  return str.slice(0, length) + '...';
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/tailwind.config.js
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/tailwind.config.js
```js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      animation: {
        "collapsible-down": "collapsible-down 0.2s ease-out",
        "collapsible-up": "collapsible-up 0.2s ease-out",
      },
      keyframes: {
        "collapsible-down": {
          "0%": { height: "0" },
          "100%": { height: "var(--radix-collapsible-content-height)" },
        },
        "collapsible-up": {
          "0%": { height: "var(--radix-collapsible-content-height)" },
          "100%": { height: "0" },
        },
      },
    },
  },
  plugins: [],
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/tsconfig.json
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/tsconfig.json
```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@/components/*": ["src/components/*"],
      "@/features/*": ["src/features/*"],
      "@/ui/*": ["src/ui/*"],
      "@/services/*": ["src/services/*"],
      "@/utils/*": ["src/utils/*"],
      "@/types/*": ["src/types/*"],
      "@/contexts/*": ["src/contexts/*"],
      "@/store/*": ["src/store/*"]
    },
    "jsx": "react-jsx",
    "esModuleInterop": true,
    "lib": ["es2020", "dom", "dom.iterable"],
    "moduleResolution": "node",
    "skipLibCheck": true,
    "target": "es2020",
    "module": "es2020",
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true,
    "typeRoots": ["./node_modules/@types"]
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "src/**/*.js", "src/**/*.jsx", "src/types/react-three-fiber.d.ts"],
  "exclude": ["node_modules"]
}

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/vite-start.js
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/vite-start.js
```js
#!/usr/bin/env node

const originalConsole = {
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error,
  debug: console.debug
};

function prefixLog(prefix, originalFn) {
  return function(...args) {
    if (typeof args[0] === 'string') {
      originalFn(prefix + args[0], ...args.slice(1));
    } else {
      originalFn(prefix, ...args);
    }
  };
}

console.log = prefixLog('[VITE] ', originalConsole.log);
console.info = prefixLog('[VITE] ', originalConsole.info);
console.warn = prefixLog('[VITE] ', originalConsole.warn);
console.error = prefixLog('[VITE] ', originalConsole.error);
console.debug = prefixLog('[VITE] ', originalConsole.debug);

require('vite/cli');

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: client/vite.config.ts
full_filepath: /mnt/mldata/githubs/logseqSpringThing/client/vite.config.ts
```ts

import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  optimizeDeps: {
    include: ['@getalby/sdk']
  },
  build: {
    outDir: 'dist',
    emptyOutDir: true,
  },
  server: {
    host: '0.0.0.0',
    // Use the VITE_DEV_SERVER_PORT from env (should be 5173 now)
    port: parseInt(process.env.VITE_DEV_SERVER_PORT || '5173'),
    strictPort: true,
    hmr: {
      // HMR port is internal (24678), client connects via Nginx (3001)
      port: parseInt(process.env.VITE_HMR_PORT || '24678'),
      // Let client infer host from window.location
      protocol: 'ws',
      clientPort: 3001, // Client connects to Nginx port
      path: '/ws' // Explicitly set the path Nginx proxies
    },
    // Proxy is now handled by Nginx, remove proxy config from Vite
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});


```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/api/index.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/api/index.md
```md
# API Documentation

This section contains documentation for the API endpoints used by the system.

## API Types

- [REST API](rest.md)
- [WebSocket API](websocket.md)
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/api/rest.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/api/rest.md
```md
# REST API Reference

## Overview
The REST API provides endpoints for graph data management, content operations, and system status.

## Base URL
```
http://localhost:4000/api
```
Default is http://localhost:4000/api when running locally via Docker with Nginx. The actual backend runs on port 3001 (or as configured in settings.yaml/env) and is proxied by Nginx. For production, it's typically https://www.visionflow.info/api (or your configured domain).

## Authentication

All API requests primarily use Nostr authentication.

#### Login
```http
POST /api/auth/nostr
```

**Request Body:**
```json
{
  "id": "event_id_hex_string",
  "pubkey": "user_hex_pubkey",
  "created_at": 1678886400, // Unix timestamp (seconds)
  "kind": 22242,
  "tags": [
    ["relay", "wss://some.relay.com"],
    ["challenge", "a_random_challenge_string"]
  ],
  "content": "LogseqXR Authentication",
  "sig": "event_signature_hex_string"
}
```
Refers to `src/services/nostr_service.rs::AuthEvent`.

**Response:**
```json
{
  "user": {
    "pubkey": "user_hex_pubkey",
    "npub": "user_npub_string", // Optional
    "isPowerUser": true // boolean
  },
  "token": "session_token_string",
  "expiresAt": 1234567890, // Unix timestamp (seconds)
  "features": ["feature1", "feature2"] // List of enabled features for the user
}
```
Matches `AuthResponse` from `src/handlers/nostr_handler.rs`.

#### Verify Token
```http
POST /api/auth/nostr/verify
```

**Request Body:**
```json
{
  "pubkey": "user_hex_pubkey",
  "token": "session_token_string"
}
```
Matches `ValidateRequest` from `src/handlers/nostr_handler.rs`.

**Response Body:**
```json
{
  "valid": true, // boolean
  "user": { // Optional
    "pubkey": "user_hex_pubkey",
    "npub": "user_npub_string",
    "isPowerUser": false
  },
  "features": ["feature1"] // List of enabled features if valid
}
```
Matches `VerifyResponse` from `src/handlers/nostr_handler.rs`.

#### Logout
```http
DELETE /api/auth/nostr
```

**Request Body:**
```json
{
  "pubkey": "user_hex_pubkey",
  "token": "session_token_string"
}
```
Matches `ValidateRequest` from `src/handlers/nostr_handler.rs`.

## Graph API

### Get Graph Data
```http
GET /api/graph/data
```

Returns `GraphResponse` from `src/handlers/api_handler/graph/mod.rs`:
```json
{
  "nodes": [
    // Array of crate::models::node::Node
  ],
  "edges": [
    // Array of crate::models::edge::Edge
  ],
  "metadata": {
    // HashMap<String, crate::models::metadata::Metadata>
  }
}
```
Note: The `Node` model used in this response is defined in `src/models/node.rs` and uses a `u32` for the `id` field.

### Get Paginated Graph Data
```http
GET /api/graph/data/paginated
```

**Query Parameters:**
- `page`: Page number (integer, default: 1)
- `pageSize`: Items per page (integer, default: 100, camelCase)
- `sort`: Sort field (string, optional)
- `filter`: Filter expression (string, optional)

**Response:**
```json
{
  "nodes": [...],
  "edges": [...],
  "metadata": {},
  "totalPages": 0,
  "currentPage": 1,
  "totalItems": 0,
  "pageSize": 100
}

### Update Graph
```http
POST /api/graph/update
```

This endpoint triggers a full re-fetch of files from the source (e.g., GitHub) by `FileService`, updates the `MetadataStore`, and then rebuilds the entire graph structure in `GraphService`. It does not accept client-side graph data for partial updates.

### Refresh Graph
```http
POST /api/graph/refresh
```
This endpoint rebuilds the graph structure in `GraphService` using the currently existing `MetadataStore` on the server. It does not re-fetch files.

## Files API

### Process Files
```http
POST /api/files/process
```

Triggers fetching and processing of Markdown files.

**Response:**
```json
{
  "status": "success",
  "processed_files": ["file1.md", "file2.md"]
}
```

### Get File Content
```http
GET /api/files/get_content/{filename}
```

### Upload Content
```http
POST /api/files/upload
```

The endpoint `/api/files/upload` is not defined in `src/handlers/api_handler/files/mod.rs`. This section should be removed or marked as "Not Implemented / Deprecated".
(Marking as Not Implemented for now)
**This endpoint is not implemented.**

## Settings API

### Get Public Settings
```http
GET /api/user-settings
```

Returns `UISettings` (camelCase) as defined in `src/models/ui_settings.rs`, derived from the server's `AppFullSettings`. This endpoint does not require authentication.

### Get User-Specific Settings
```http
GET /api/user-settings/sync
```

Requires authentication.
**GET Response:** Returns `UISettings`. For power users, these are global settings. For regular users, these are their persisted settings.
**POST Request Body:** `ClientSettingsPayload` from `src/models/client_settings_payload.rs` (camelCase).
**POST Response:** The updated `UISettings`.

### Get Visualisation Settings by Category
```http
GET /api/visualisation/settings/{category}
```

The handler `get_visualisation_settings` (mapped to `/api/visualisation/get_settings/{category}` in `src/handlers/api_handler/visualisation/mod.rs`) actually returns the entire `AppFullSettings` struct, not just a category. The path parameter `{category}` is not used by this specific handler.
The handler `get_category_settings` (mapped to `/api/visualisation/settings/{category}`) does return a specific category.
The documentation path `/api/visualisation/settings/{category}` matches `get_category_settings`. This endpoint returns a specific category as a JSON object.

### Update API Keys
```http
POST /api/auth/nostr/api-keys
```

**Request Body:**
```json
{
  "perplexity": "optional_api_key_string",
  "openai": "optional_api_key_string",
  "ragflow": "optional_api_key_string"
}
```
Matches `ApiKeysRequest` from `src/handlers/nostr_handler.rs`.

**Response:**
```json
{
  "pubkey": "user_hex_pubkey",
  "npub": "user_npub_string", // Optional
  "isPowerUser": true // boolean
}
```
Returns `UserResponseDTO`.

## AI Services

### RAGFlow Chat
```http
POST /api/ragflow/chat
```

**Request Body:**
```json
{
  "question": "Your question here",
  "sessionId": "optional-previous-session-id-string",
  "stream": false // Optional boolean
}
```
Matches `RagflowChatRequest` from `src/models/ragflow_chat.rs`.

**Response:**
```json
{
  "answer": "The response from RAGFlow AI",
  "sessionId": "session-id-string"
}
```
Matches `RagflowChatResponse` from `src/models/ragflow_chat.rs`.


## System Status

### Health Check
```http
GET /api/health
```

**Response:**
```json
{
  "status": "healthy",
  "metadata_count": 123,
  "nodes_count": 456,
  "edges_count": 789
}
```

### Physics Simulation Status
```http
GET /api/health/physics
```

**Response:**
```json
{
  "status": "string (e.g., 'running', 'idle', 'error')",
  "details": "string (e.g., 'Simulation is active with X nodes' or error message)",
  "timestamp": 1234567890 // Unix timestamp
}
```
Returns `PhysicsSimulationStatus` from `src/handlers/health_handler.rs`.


## Error Responses

Error responses are often simple JSON like `{"error": "message string"}` or `{"status": "error", "message": "message string"}`.
The structured format `{"error": {"code": ..., "message": ..., "details": ...}}` is not consistently used across all handlers.

### Common HTTP Status Codes for Errors
- `400 Bad Request`: Invalid parameters or request payload.
- `401 Unauthorized`: Invalid or missing authentication token.
- `403 Forbidden`: Valid token but insufficient permissions for the requested operation.
- `404 Not Found`: The requested resource or endpoint does not exist.
- `422 Unprocessable Entity`: The request was well-formed but could not be processed (e.g., semantic errors in Nostr event).
- `500 Internal Server Error`: A generic error occurred on the server.
- `503 Service Unavailable`: The server is temporarily unable to handle the request (e.g., during maintenance or if a dependent service is down).

## Related Documentation
- [WebSocket API](./websocket.md)
- [Development Setup](../development/setup.md)
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/api/websocket.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/api/websocket.md
```md
# WebSocket API Reference

## Overview
The WebSocket implementation in LogseqXR provides real-time graph updates using an optimized binary protocol.

## Connection

Connect to: `wss://your-domain/wss` (Note: The actual path is `/wss` as handled by `src/handlers/socket_flow_handler.rs`)

### Connection Flow
1. Client connects to WebSocket endpoint (`/wss`)
2. Server sends: `{"type": "connection_established", "timestamp": <timestamp>}`
3. Client sends authentication (if required, typically handled via HTTP session before WebSocket upgrade)
4. Client sends: `{"type": "requestInitialData"}`
5. Server begins binary updates (configured by `binary_update_rate`)
6. Server sends: `{"type": "updatesStarted", "timestamp": <timestamp>}`
7. Server sends: `{"type": "loading", "message": "Calculating initial layout..."}` (if applicable)

## Authentication

Authentication for WebSocket connections in LogseqXR is primarily handled during the initial HTTP handshake that upgrades to a WebSocket connection. This means that user authentication (e.g., via Nostr) should occur before or during the establishment of the WebSocket connection, typically through standard HTTP mechanisms (like cookies or authorization headers). The server's `socket_flow_handler.rs` does not process an explicit `{"type": "auth", "token": "..."}` message over the WebSocket itself.

## Message Types

### Control Messages

#### 1. Connection Established
```json
{
  "type": "connection_established",
  "timestamp": 1679417762000
}
```

#### 2. Request Initial Data
```json
{
  "type": "requestInitialData"
}
```

#### 3. Updates Started
```json
{
  "type": "updatesStarted",
  "timestamp": 1679417763000
}
```

#### 4. Loading State
```json
{
  "type": "loading",
  "message": "Calculating initial layout..."
}
```

### Binary Messages - Position Updates

Position updates are transmitted as binary messages in both directions:

- **Each node update is 28 bytes**.
- Format: **Node ID (u32, 4 bytes)**, Position (3x f32, 12 bytes), Velocity (3x f32, 12 bytes). Total: 28 bytes per node.
- Position and Velocity are three consecutive `f32` values (x, y, z).
- Server-side `BinaryNodeData` (defined in `src/utils/socket_flow_messages.rs`) includes additional fields like `mass`, `flags`, and `padding` for physics simulation, but these are **not** part of the **28-byte** wire format sent to the client.
- The client-side `BinaryNodeData` (defined in `client/src/types/binaryProtocol.ts`) and the server-side `WireNodeDataItem` in `binary_protocol.rs` correctly reflect the **28-byte** wire format: `nodeId`, `position`, `velocity`.
- Server-side compression (zlib) is applied... Client-side decompression is handled by the `graph.worker.ts` off the main UI thread.

#### Server → Client Updates

The server continuously sends position updates to all connected clients:

1. Updates are pre-computed by the server's continuous physics engine
2. Only nodes that changed significantly are included
3. Update frequency varies based on graph activity (5-60 updates/sec)
4. Each update can contain multiple node positions in a single binary message
5. When the physics simulation stabilizes, update frequency is reduced

#### Client → Server Updates

Clients can send position updates back to the server:

1. Position updates use the same binary format as server messages
2. Updates are processed by the server's physics system
3. Changes are validated and broadcast to all other connected clients
4. Modifications that violate physics constraints may be adjusted by the server

### Position Synchronization Protocol

The bidirectional synchronization protocol ensures consistent graph state:

1. Server maintains the authoritative graph state
2. Any client can send position updates during user interaction
3. Server processes updates and applies physics constraints
4. All clients receive the same set of position updates
5. Late-joining clients receive the complete current graph state


## Control Messages (JSON) - Revisited

The `socket_flow_handler.rs` primarily handles the following JSON messages:

**Server -> Client:**
- `{"type": "connection_established", "timestamp": <timestamp>}`
- `{"type": "updatesStarted", "timestamp": <timestamp>}`
- `{"type": "loading", "message": "Calculating initial layout..."}`
- `{"type": "pong"}` (in response to client's ping)

**Client -> Server:**
- `{"type": "ping"}`
- `{"type": "requestInitialData"}`: This message implicitly starts the binary update stream if the server is ready.
- `{"type": "subscribe_position_updates", "binary": true, "interval": <number>}`: While not a distinct message type in the server's `Message` enum (`src/utils/socket_flow_messages.rs`), the `requestInitialData` handler in `socket_flow_handler.rs` implicitly starts the binary update stream. The client can send a `subscribe_position_updates` message to configure the stream, but the server's primary trigger is `requestInitialData`.
- `{"type": "enableRandomization", "enabled": <boolean>}`: This message is acknowledged by the server, but server-side randomization has been removed. The client is responsible for any randomization effects.

## Optimization Features

- Zlib compression for binary messages larger than `compression_threshold` (default 512 bytes, configurable).
- Fixed-size binary format (28 bytes per node update) for efficient parsing.
- Minimal overhead for binary messages (no explicit headers per node update within a batch).
- Consistent use of `THREE.Vector3` for positions and velocities on the client-side.

## Error Handling

The `socket_flow_handler.rs` does not explicitly send these structured JSON error messages.
- Errors encountered during WebSocket communication (e.g., deserialization issues, unexpected message types) are typically logged on the server-side.
- The WebSocket connection might be closed by the server if unrecoverable errors occur.
- Clients should implement their own timeout and error detection logic for the WebSocket connection itself (e.g., detecting a closed connection).

## Rate Limiting

This section refers to the server's dynamic management of binary position update frequency and client-side handling, rather than strict message rate limiting (e.g., X messages per second).

- **Server-Side Update Rate:** The server dynamically adjusts the rate of binary position updates based on graph activity and physics simulation stability. This is controlled by settings in `settings.yaml` under `system.websocket`:
    - `min_update_rate`: Minimum updates per second when the graph is stable.
    - `max_update_rate`: Maximum updates per second during high activity.
    - `motion_threshold`: Sensitivity to node movement for determining activity.
- **Client-Side Throttling:** The client (`client/src/features/graph/managers/graphDataManager.ts`) implements a `lastBinaryUpdateTime` check to avoid processing updates too rapidly if they arrive faster than the client can render, effectively throttling the application of received binary messages.
- **Debug Logging:** `socket_flow_handler.rs` includes a `DEBUG_LOG_SAMPLE_RATE` to control how frequently detailed debug logs about message handling are produced, which is a diagnostic aid rather than a rate limit.

## Diagnostics

### Common Issues

1. Connection Issues
   - Mixed Content: Ensure WebSocket uses WSS with HTTPS
   - CORS: Check server configuration for cross-origin
   - Proxy/Firewall: Verify WebSocket ports are open

2. Binary Protocol Issues
   - Message Size: Verify 28 bytes per node
   - Data Integrity: Validate Vector3 data

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/client/architecture.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/client/architecture.md
```md
# Client Architecture Overview

This document provides a high-level overview of the LogseqSpringThing client architecture, its major components, and their interactions.

## System Architecture

The client is built as a modern TypeScript application that follows a component-based architecture. It integrates with React Three Fiber (R3F) and Three.js for 3D rendering, WebXR for VR/AR capabilities, and communicates with the Rust backend server through REST APIs and WebSocket connections.

```mermaid
graph TB
    subgraph Client Architecture
        AppInitializer[App Initializer]

        subgraph UILayer [User Interface Layer]
            TwoPaneLayout[TwoPaneLayout.tsx]
            GraphViewportUI[GraphViewport.tsx]
            RightPaneControlPanel[RightPaneControlPanel.tsx]
            SettingsPanelRedesign[SettingsPanelRedesign.tsx]
            ConversationPane[ConversationPane.tsx]
            NarrativeGoldminePanel[NarrativeGoldminePanel.tsx]
        end

        subgraph StateManagement [State Management]
            SettingsStore[useSettingsStore (Zustand)]
            GraphDataManager[GraphDataManager]
        end

        subgraph APILayer [API Layer]
            NostrAuthService[nostrAuthService.ts]
            APIService[api.ts]
        end

        Rendering[Rendering Engine (R3F/Three.js)]
        WebSocketClient[WebSocketClient (WebSocketService.ts)]
        XRModule[XR Module]

        AppInitializer --> TwoPaneLayout
        AppInitializer --> SettingsStore
        AppInitializer --> GraphDataManager
        AppInitializer --> NostrAuthService
        AppInitializer --> APIService
        AppInitializer --> Rendering
        AppInitializer --> WebSocketClient
        AppInitializer --> XRModule

        TwoPaneLayout --> GraphViewportUI
        TwoPaneLayout --> RightPaneControlPanel
        TwoPaneLayout --> ConversationPane
        TwoPaneLayout --> NarrativeGoldminePanel
        RightPaneControlPanel --> SettingsPanelRedesign

        SettingsPanelRedesign --> SettingsStore
        ConversationPane --> APIService
        NarrativeGoldminePanel --> APIService

        SettingsStore --> Rendering
        GraphDataManager --> Rendering
        SettingsStore --> APIService
        GraphDataManager --> WebSocketClient

        NostrAuthService --> APIService
        GraphDataManager --> WebSocketClient

        XRModule --> Rendering
        XRModule --> SettingsStore
        WebSocketClient --> GraphDataManager
    end

    subgraph ServerInterface [Server Interface]
        RESTAPI[REST API]
        WebSocketServer[WebSocket Server]
        AuthHandler[Authentication Handler]

        APIService --> RESTAPI
        WebSocketClient --> WebSocketServer
        NostrAuthService --> AuthHandler
        APIService --> AuthHandler
    end
```

## Key Components

### User Interface Layer
The UI layer is built with React and TypeScript.
- [`TwoPaneLayout.tsx`](../../client/src/app/TwoPaneLayout.tsx) serves as the primary layout, dividing the screen into a main visualisation area and a control panel area.
- [`RightPaneControlPanel.tsx`](../../client/src/app/components/RightPaneControlPanel.tsx) hosts the authentication UI and the main settings panel: `SettingsPanelRedesign.tsx`. The `ConversationPane` and `NarrativeGoldminePanel` are rendered alongside it within the main `TwoPaneLayout`.
- [`GraphViewport.tsx`](../../client/src/features/graph/components/GraphViewport.tsx) is responsible for the main 3D graph visualisation area.

### State Management
State management is primarily handled by **Zustand**, a lightweight and flexible state management solution. The main state stores are:
- `useSettingsStore` ([`client/src/store/settingsStore.ts`](../../client/src/store/settingsStore.ts)) - Manages application settings with validation and persistence.
- `GraphDataManager` ([`client/src/features/graph/managers/graphDataManager.ts`](../../client/src/features/graph/managers/graphDataManager.ts)) - Manages the graph data structure (nodes, edges, metadata) and handles real-time updates from the WebSocket.
State changes are propagated through Zustand's subscription mechanism, allowing components to react efficiently to specific state slices.

### API Layer
The API layer handles communication with the server through REST endpoints and manages authentication:
- Authentication and authorization: [`nostrAuthService.ts`](../../client/src/services/nostrAuthService.ts) handles Nostr-based authentication.
- General API communication: [`api.ts`](../../client/src/services/api.ts) provides functions for interacting with other REST endpoints (graph data, files, settings).

### Rendering Engine
The rendering engine is built on **React Three Fiber (`@react-three/fiber`)** and **Three.js**, providing high-performance visualisation of graph data. Key components include:
- [`GraphCanvas.tsx`](../../client/src/features/graph/components/GraphCanvas.tsx): The main R3F canvas where the 3D scene is rendered.
- [`GraphManager.tsx`](../../client/src/features/graph/components/GraphManager.tsx): Manages the rendering of nodes and edges, handling their positions and visual properties.
- [`GraphViewport.tsx`](../../client/src/features/graph/components/GraphViewport.tsx): Manages the camera, scene controls, and post-processing effects.
- Node and edge rendering, often utilizing instancing for performance.
- Text rendering with SDF fonts ([`TextRenderer.tsx`](../../client/src/features/visualisation/renderers/TextRenderer.tsx)).
- Custom shaders like [`HologramMaterial.tsx`](../../client/src/features/visualisation/renderers/materials/HologramMaterial.tsx) for unique visual effects.
- Metadata visualisation ([`MetadataVisualizer.tsx`](../../client/src/features/visualisation/components/MetadataVisualizer.tsx)).
- Camera controls and scene management ([`CameraController.tsx`](../../client/src/features/visualisation/components/CameraController.tsx)).

### WebSocket Client
The WebSocket client ([`client/src/services/WebSocketService.ts`](../../client/src/services/WebSocketService.ts)) provides real-time communication with the server for:
- Live position updates using a custom binary protocol.
- Graph data synchronization.
- Control messages and event notifications (e.g., `connection_established`, `loading`).

### XR Module
The XR module, located under [`client/src/features/xr/`](../../client/src/features/xr/), integrates WebXR capabilities for VR/AR experiences:
- Key Components:
    - [`XRController.tsx`](../../client/src/features/xr/components/XRController.tsx): Manages the overall XR state and setup.
    - [`HandInteractionSystem.tsx`](../../client/src/features/xr/systems/HandInteractionSystem.tsx): Handles hand tracking and interactions.
    - [`xrSessionManager.ts`](../../client/src/features/xr/managers/xrSessionManager.ts): Manages WebXR sessions.
    - [`xrInitializer.ts`](../../client/src/features/xr/managers/xrInitializer.ts): Handles the initial setup for XR.
- Spatial UI elements.
- XR-specific rendering optimizations.

## High-Level Data Flow

```mermaid
flowchart TB
    subgraph Input
        UserInput[User Input (UI/XR)]
        ServerData[Server Data (REST/WS)]
    end

    subgraph Processing
        State[State Management (Zustand)]
        GraphProcessing[Graph Data Processing]
        RenderingLogic[Rendering Logic]
    end

    subgraph Output
        Visualisation[3D Visualisation]
        UIUpdate[UI Update]
        ServerUpdate[Server Update (WS/REST)]
    end

    UserInput --> State
    ServerData --> State

    State --> GraphProcessing
    GraphProcessing --> RenderingLogic
    RenderingLogic --> Visualisation

    State --> UIUpdate
    State --> ServerUpdate
```

## Core Technology Stack

- **TypeScript** - Primary development language
- **React** - Frontend UI library
- **React Three Fiber (`@react-three/fiber`)** - React renderer for Three.js
- **Three.js** - Core 3D rendering engine
- **WebGL** - Hardware-accelerated graphics
- **WebXR** - VR/AR integration
- **Zustand** - Lightweight state management
- **WebSockets** - Real-time communication
- **Tailwind CSS** - Utility-first CSS framework
- **Vite** - Frontend build tool
- **Custom Shaders** - GLSL shaders for specialized rendering effects (e.g., `HologramMaterial.tsx`)

## Key Architectural Patterns

1. **Component-Based Architecture** - Leveraging React's component model for modular and reusable UI elements.
2. **State Management with Zustand** - Centralized and reactive state management for application settings and graph data.
3. **Composition over Inheritance** - Building complex behaviors by combining simpler components and hooks.
4. **Service Layer** - Abstracting API calls and WebSocket communication into dedicated service modules ([`api.ts`](../../client/src/services/api.ts), [`WebSocketService.ts`](../../client/src/services/WebSocketService.ts), [`nostrAuthService.ts`](../../client/src/services/nostrAuthService.ts)).
5. **React Context API** - Used for dependency injection and sharing global state that doesn't fit well into Zustand or is more localized. Examples include:
    - [`ApplicationModeContext.tsx`](../../client/src/contexts/ApplicationModeContext.tsx)
    - [`WindowSizeContext.tsx`](../../client/src/contexts/WindowSizeContext.tsx)
    - [`control-panel-context.tsx`](../../client/src/features/settings/components/control-panel-context.tsx)

## Cross-Cutting Concerns

- **Logging** - Centralized logging system with multiple levels
- **Error Handling** - Comprehensive error capture and recovery
- **Performance Monitoring** - Resource and performance monitoring
- **Caching** - Strategic caching of data and assets

## Application Lifecycle

```mermaid
stateDiagram-v2
    [*] --> Initialization
    Initialization --> Loading: Configure
    Loading --> Running: Assets Loaded
    Running --> XR: Enter XR Mode
    XR --> Running: Exit XR Mode
    Running --> [*]: Shutdown

    Running --> Error: Exception
    Error --> Running: Recover
    Error --> Shutdown: Fatal Error
    Shutdown --> [*]
```

## Communication with Server

The client communicates with the server through two primary channels:

1. **REST API** - For configuration, authentication, and data operations
2. **WebSocket** - For real-time updates and streaming data

This dual-channel approach allows for efficient communication patterns based on the nature of the data being exchanged.

## Related Documentation

- [Components](components.md) - Detailed component relationships
- [State Management](state.md) - State management approach
- [WebSocket Communication](websocket.md) - WebSocket protocol details
- [XR Integration](xr.md) - WebXR implementation details
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/client/components.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/client/components.md
```md
# Client Components

This document details the client component architecture, describing the relationships between major components, their responsibilities, and dependencies.

## Component Overview

The client is organized into a modular component architecture with clear separation of concerns. Each component has well-defined responsibilities and interfaces.

```mermaid
flowchart TB
    subgraph CoreServices [Core Services & Stores]
        APIService[api.ts]
        SettingsStore[settingsStore.ts (Zustand)]
        NostrAuthSvc[nostrAuthService.ts]
        Logger[logger.ts]
        Utils[utils/*]
    end

    subgraph AppInit [Application Initialization]
        AppInitializer[AppInitializer.tsx]
        Main[main.tsx]
    end

    subgraph MainUILayout [Main UI Layout & Panels]
        TwoPaneLayout[TwoPaneLayout.tsx]
        RightPaneCtrlPanel[RightPaneControlPanel.tsx]
        ConversationPane[ConversationPane.tsx]
        NarrativeGoldminePanel[NarrativeGoldminePanel.tsx]
    end

    subgraph SettingsUI [Settings UI Components]
        SettingsPanelRedesign[SettingsPanelRedesign.tsx]
        TabsUI[Tabs.tsx (generic UI)]
        SettingsSection[SettingsSection.tsx]
        SettingControlComp[SettingControlComponent.tsx]
    end

    subgraph AuthUI [Authentication UI]
        AuthUIHandler[AuthUIHandler.tsx]
        NostrAuthSection[NostrAuthSection.tsx]
    end

    subgraph RenderingEngine [Rendering Engine (R3F/Three.js)]
        GraphCanvas[GraphCanvas.tsx]
        GraphManager[GraphManager.tsx]
        GraphViewport[GraphViewport.tsx]
        CameraController[CameraController.tsx]
        TextRenderer[TextRenderer.tsx]
        MetadataVisualizer[MetadataVisualizer.tsx]
        HologramManager[HologramManager.tsx]
    end

    subgraph Network [Network & Data Management]
        WebSocketSvc[WebSocketService.ts]
        GraphDataMgr[GraphDataManager.ts]
    end

    subgraph XRModule [XR Module]
        XRController[XRController.tsx]
        XRScene[XRScene.tsx]
        XRVisualisationConnector[XRVisualisationConnector.tsx]
        HandInteractionSystem[HandInteractionSystem.tsx]
        XRInitializer[xrInitializer.ts]
        XRSessionManager[xrSessionManager.ts]
    end

    subgraph GenericUI [Generic UI Components]
        MarkdownRenderer[MarkdownRenderer.tsx]
        Button[Button.tsx]
        Input[Input.tsx]
        %% Add other generic UI components as needed
    end

    %% Initialization Flow
    Main --> AppInitializer
    AppInitializer --> SettingsStore
    AppInitializer --> NostrAuthSvc
    AppInitializer --> WebSocketSvc
    AppInitializer --> GraphDataMgr
    AppInitializer --> TwoPaneLayout
    AppInitializer --> AuthUIHandler
    AppInitializer --> XRController

    %% UI Structure
    TwoPaneLayout --> GraphViewport %% For displaying the graph
    TwoPaneLayout --> RightPaneCtrlPanel
    TwoPaneLayout --> ConversationPane
    TwoPaneLayout --> NarrativeGoldminePanel

    RightPaneCtrlPanel --> NostrAuthSection
    RightPaneCtrlPanel --> SettingsPanelRedesign

    SettingsPanelRedesign --> TabsUI
    TabsUI --> SettingsSection %% SettingsPanelRedesign renders SettingsSections directly or via Tabs
    SettingsSection --> SettingControlComp

    %% Data Flow & Dependencies
    SettingsStore --> SettingControlComp
    SettingsStore --> GraphManager %% Settings affect rendering
    SettingsStore --> HologramManager
    SettingsStore --> TextRenderer

    AuthUIHandler --> NostrAuthSvc
    NostrAuthSvc --> APIService

    ConversationPane --> APIService
    NarrativeGoldminePanel --> APIService

    WebSocketSvc --> GraphDataMgr
    GraphDataMgr --> GraphManager
    GraphDataMgr --> APIService %% For fetching initial data via REST

    %% Rendering Dependencies
    GraphCanvas --> GraphManager
    GraphCanvas --> GraphViewport
    GraphCanvas --> CameraController
    GraphManager --> TextRenderer
    GraphManager --> MetadataVisualizer
    GraphManager --> HologramManager

    %% XR Dependencies
    XRController --> XRScene
    XRController --> XRInitializer
    XRController --> XRSessionManager
    XRScene --> XRVisualisationConnector
    XRVisualisationConnector --> GraphManager %% XR needs to interact with graph elements
    XRVisualisationConnector --> HandInteractionSystem
    HandInteractionSystem --> GraphManager %% Hand interactions can modify graph

    %% Cross-cutting
    Logger -.-> APIService
    Logger -.-> WebSocketSvc
    Logger -.-> GraphManager
    Logger -.-> XRController
    Utils -.-> SettingsStore
    Utils -.-> GraphDataMgr
```

## Core Components

### API Service ([`client/src/services/api.ts`](../../client/src/services/api.ts))
Provides a centralized interface for communicating with the server REST API.

**Responsibilities:**
- Build API URLs for different endpoints.
- Handle authentication headers (often in conjunction with `nostrAuthService.ts`).
- Provide helper functions for API requests (e.g., fetching graph data, user settings, interacting with AI services).

**Key Dependencies:**
- `nostrAuthService.ts` for obtaining auth tokens.
- Type definitions for request/response payloads.

### State Management
Manages application state and provides reactive updates using Zustand.

**Key Components:**
- `SettingsStore` ([`client/src/store/settingsStore.ts`](../../client/src/store/settingsStore.ts)) - Manages application settings.
- `GraphDataManager` ([`client/src/features/graph/managers/graphDataManager.ts`](../../client/src/features/graph/managers/graphDataManager.ts)) - Manages graph data state and updates.

**Responsibilities:**
- Store and validate application settings.
- Track graph data (nodes, edges) and their positions.
- Propagate state changes to subscribers via Zustand's subscription mechanism.

### Core Components - Event Emitter
A dedicated global `eventEmitter.ts` is **not** used in this project. Communication and event handling are achieved through:
- **Zustand Store Subscriptions**: Components subscribe to `settingsStore` or `graphDataManager` (if it exposes an observable/subscription pattern) for reactive updates to specific state slices.
- **React Context API**: Contexts like `ApplicationModeContext`, `WindowSizeContext`, and `control-panel-context` are used to share state and functions down the component tree.
- **Direct Prop Passing**: Standard React mechanism for parent-child component communication.
- **WebSocket Messages**: `WebSocketService` handles messages from the server, which are then typically processed by `GraphDataManager` or other relevant services/stores to update application state. Callbacks registered with `WebSocketService` (e.g., `onMessage`, `onBinaryMessage`) act as event handlers for server-sent events.

### Logger ([`client/src/utils/logger.ts`](../../client/src/utils/logger.ts))
Provides centralized logging with different levels.

**Responsibilities:**
- Log messages with appropriate severity (debug, info, warn, error).
- Add metadata to log messages (timestamps, component source).
- Control log output based on environment or debug settings.

## Rendering Components

### Graph Canvas ([`client/src/features/graph/components/GraphCanvas.tsx`](../../client/src/features/graph/components/GraphCanvas.tsx))
The main entry point for the React Three Fiber (R3F) scene. It sets up the WebGL renderer, camera, and basic scene elements.

### Graph Manager ([`client/src/features/graph/components/GraphManager.tsx`](../../client/src/features/graph/components/GraphManager.tsx))
Manages the rendering of nodes and edges within the 3D scene. It handles instanced meshes for performance and orchestrates updates based on graph data from `GraphDataManager`. This component effectively serves as the "Node Manager" and "Edge Manager".

### Graph Viewport ([`client/src/features/graph/components/GraphViewport.tsx`](../../client/src/features/graph/components/GraphViewport.tsx))
Manages the camera, lighting, and post-processing effects for the 3D scene.

### Text Renderer ([`client/src/features/visualisation/renderers/TextRenderer.tsx`](../../client/src/features/visualisation/renderers/TextRenderer.tsx))
Renders text labels in 3D space using SDF fonts, typically associated with nodes.

### Metadata Visualizer ([`client/src/features/visualisation/components/MetadataVisualizer.tsx`](../../client/src/features/visualisation/components/MetadataVisualizer.tsx))
Displays metadata associated with nodes in the 3D scene, potentially as interactive elements.

### Hologram Manager ([`client/src/features/visualisation/renderers/HologramManager.tsx`](../../client/src/features/visualisation/renderers/HologramManager.tsx))
Manages the rendering of holographic effects for nodes, using custom shaders like `HologramMaterial.tsx`.

### Camera Controller ([`client/src/features/visualisation/components/CameraController.tsx`](../../client/src/features/visualisation/components/CameraController.tsx))
Handles camera controls (orbit, pan, zoom) and interactions within the 3D scene.

### Edge Manager
Edge rendering logic is primarily integrated within [`GraphManager.tsx`](../../client/src/features/graph/components/GraphManager.tsx), which handles the creation, updating, and styling of edge geometries and materials based on data from `GraphDataManager`.

## Network Components

### WebSocket Service ([`client/src/services/WebSocketService.ts`](../../client/src/services/WebSocketService.ts))
Manages WebSocket connection, message serialization/deserialization (including binary protocol), and communication with the server.

### Graph Data Manager ([`client/src/features/graph/managers/graphDataManager.ts`](../../client/src/features/graph/managers/graphDataManager.ts))
Manages graph data loading (initial fetch via REST, subsequent updates via WebSocket), state, and provides an interface for other components to access and interact with graph data.

## XR Components

### XR Controller ([`client/src/features/xr/components/XRController.tsx`](../../client/src/features/xr/components/XRController.tsx))
The main component for managing WebXR sessions and interactions.

### XR Scene ([`client/src/features/xr/components/XRScene.tsx`](../../client/src/features/xr/components/XRScene.tsx))
A wrapper component for the R3F scene when in XR mode.

### XR Visualisation Connector ([`client/src/features/xr/components/XRVisualisationConnector.tsx`](../../client/src/features/xr/components/XRVisualisationConnector.tsx))
Connects the main 3D visualisation components (like `GraphManager`) to the XR environment, adapting interactions and rendering for XR.

### Hand Interaction System ([`client/src/features/xr/systems/HandInteractionSystem.tsx`](../../client/src/features/xr/systems/HandInteractionSystem.tsx))
Handles WebXR hand tracking and interactions, including gesture recognition and mapping them to application actions.

### XR Initializer ([`client/src/features/xr/managers/xrInitializer.ts`](../../client/src/features/xr/managers/xrInitializer.ts))
Initializes WebXR capabilities and sessions, checking for browser support.

### XR Session Manager ([`client/src/features/xr/managers/xrSessionManager.ts`](../../client/src/features/xr/managers/xrSessionManager.ts))
Manages WebXR sessions and their lifecycle (start, end, events).

### Safe XR Provider ([`client/src/features/xr/providers/SafeXRProvider.tsx`](../../client/src/features/xr/providers/SafeXRProvider.tsx))
Provides a safe context for WebXR hooks and components, handling browser compatibility checks.

## UI Components

### Right Pane Control Panel ([`client/src/app/components/RightPaneControlPanel.tsx`](../../client/src/app/components/RightPaneControlPanel.tsx))
Manages the content displayed in the right pane of the main application layout, including settings, authentication, and feature panels.

### Settings Panel Redesign ([`client/src/features/settings/components/panels/SettingsPanelRedesign.tsx`](../../client/src/features/settings/components/panels/SettingsPanelRedesign.tsx))
Provides the tabbed interface for organizing different categories of settings (Visualisation, System, AI, XR) within the right pane, utilizing [`client/src/ui/Tabs.tsx`](../../client/src/ui/Tabs.tsx).

### Settings Sections ([`client/src/features/settings/components/SettingsSection.tsx`](../../client/src/features/settings/components/SettingsSection.tsx))
Used within panels (like `SettingsPanelRedesign`) to group related settings. Supports collapsible sections.

### Setting Control Component ([`client/src/features/settings/components/SettingControlComponent.tsx`](../../client/src/features/settings/components/SettingControlComponent.tsx))
Renders individual UI controls (sliders, toggles, inputs, color pickers, etc.) for each setting based on its definition in `settingsUIDefinition.ts`.

### Auth UI Handler ([`client/src/features/auth/components/AuthUIHandler.tsx`](../../client/src/features/auth/components/AuthUIHandler.tsx))
Manages the authentication user interface and logic, primarily for Nostr authentication, often hosting `NostrAuthSection.tsx`.

### Markdown Renderer ([`client/src/ui/markdown/MarkdownRenderer.tsx`](../../client/src/ui/markdown/MarkdownRenderer.tsx))
Renders Markdown content within the application, used for displaying detailed information or help texts.

### Conversation Pane ([`client/src/app/components/ConversationPane.tsx`](../../client/src/app/components/ConversationPane.tsx))
Provides the UI for interacting with AI chat services (e.g., RAGFlow).

### Narrative Goldmine Panel ([`client/src/app/components/NarrativeGoldminePanel.tsx`](../../client/src/app/components/NarrativeGoldminePanel.tsx))
A panel dedicated to features for exploring and analyzing narrative elements within the graph data.

## Component Initialization Sequence

The application initialization flow is orchestrated by [`client/src/app/main.tsx`](../../client/src/app/main.tsx) which renders [`client/src/app/AppInitializer.tsx`](../../client/src/app/AppInitializer.tsx).

```mermaid
sequenceDiagram
    participant AppInitializer
    participant SettingsStore
    participant NostrAuthService
    participant WebSocketService
    participant GraphDataManager
    participant GraphCanvas

    AppInitializer->>SettingsStore: initialise()
    SettingsStore-->>AppInitializer: Settings loaded

    AppInitializer->>NostrAuthService: initialise()
    NostrAuthService-->>AppInitializer: Auth state ready

    AppInitializer->>WebSocketService: connect()
    WebSocketService-->>AppInitializer: Connection established

    AppInitializer->>GraphDataManager: fetchInitialData()
    GraphDataManager-->>AppInitializer: Initial graph data

    AppInitializer->>GraphCanvas: Render 3D scene with initial data
```

## Component Communication Patterns

The application uses several communication patterns:

1. **React Props and State** - Standard React data flow for parent-child communication.
2. **Zustand Store Subscriptions** - Components subscribe to specific parts of the `SettingsStore` or `GraphDataManager` for reactive updates.
3. **React Context API** - Used for providing global state and services to components (e.g., `ApplicationModeContext`, `WindowSizeContext`, `control-panel-context`).
4. **WebSocket Messages** - For real-time server-client communication, managed by `WebSocketService` and `GraphDataManager`.

## Interface Contracts

Key interface contracts between components:

### Node Manager Interface
The concept of a `NodeManagerInterface` is primarily embodied by the [`GraphManager.tsx`](../../client/src/features/graph/components/GraphManager.tsx) component. It is responsible for taking data from `GraphDataManager` and rendering/managing the visual representation of nodes (and edges) in the R3F scene.

### WebSocket Service Interface
```typescript
interface WebSocketServiceInterface {
  connect(url?: string): Promise<void>;
  sendMessage(message: object): void; // For JSON messages
  sendRawBinaryData(data: ArrayBuffer): void; // For binary messages
  onMessage(callback: (data: any) => void): () => void; // For JSON messages
  onBinaryMessage(callback: (data: ArrayBuffer) => void): () => void; // For binary messages
  onConnectionStatusChange(handler: (status: { connected: boolean; error?: any }) => void): () => void;
  isReady(): boolean; // Checks if connected and server is ready
  close(): void;
  setCustomBackendUrl(url: string): void; // Allows overriding the default WebSocket URL
}
```
Corresponds to methods in [`client/src/services/WebSocketService.ts`](../../client/src/services/WebSocketService.ts).

### Graph Data Manager Interface
```typescript
interface GraphDataManagerInterface {
  fetchInitialData(): Promise<void>;
  setGraphData(nodes: Node[], edges: Edge[], metadata?: Record<string, any>): void;
  updateNodePositions(data: ArrayBuffer): void;
  // sendNodePositions(): void; // This might be handled internally or via a different mechanism
  getGraphData(): { nodes: Node[]; edges: Edge[]; metadata: Record<string, any> };
  getNodeById(id: string): Node | undefined;
  onGraphDataChange(listener: (graphData: { nodes: Node[]; edges: Edge[] }) => void): () => void; // Subscription for overall graph data changes
  onPositionUpdate(listener: (updates: { nodeId: number; position: { x: number; y: number; z: number }}[] ) => void): () => void; // Subscription for position updates
  setWebSocketService(wsService: WebSocketServiceInterface): void;
  setBinaryUpdatesEnabled(enabled: boolean): void;
  ensureNodeHasValidPosition(nodeId: string): void;
  // Other methods like addNode, removeNode, addEdge, removeEdge might exist
}
```
The `graphDataManager` now delegates binary data processing to a web worker.
Corresponds to methods and properties in [`client/src/features/graph/managers/graphDataManager.ts`](../../client/src/features/graph/managers/graphDataManager.ts).

## Dependency Injection

The application primarily uses React's built-in mechanisms for dependency injection:

1.  **Zustand Store**: Components directly import and use Zustand stores (`settingsStore`, potentially others) which act as global, injectable state containers. This is the primary method for managing shared application state.
2.  **React Context API**: Used for more localized state sharing or providing specific functionalities down a component subtree. Examples:
    - [`ApplicationModeContext`](../../client/src/contexts/ApplicationModeContext.tsx)
    - [`WindowSizeContext`](../../client/src/contexts/WindowSizeContext.tsx)
    - [`control-panel-context`](../../client/src/features/settings/components/control-panel-context.tsx) (for managing control panel specific state like detached panels).
3.  **Prop Drilling**: Standard React prop passing is used for direct parent-to-child dependency provision, especially for UI components.
4.  **Service Instantiation/Import**: Services like `WebSocketService.getInstance()`, `nostrAuthService`, and `apiService` are often singletons or directly imported modules, making them available globally or within specific parts of the application.

## Related Documentation

- [Architecture Overview](architecture.md)
- [State Management](state.md)
- [Rendering System](rendering.md)
- [XR Integration](xr.md)
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/client/core.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/client/core.md
```md
# Client Core Utilities and Hooks

This document describes the core utility functions and general-purpose React hooks used across the LogseqXR client application. These modules provide foundational functionalities that support various components and features.

## Core Utilities (`client/src/utils/`)

The `client/src/utils/` directory contains a collection of general-purpose utility functions designed for reusability and to encapsulate common logic.

### `logger.ts`

Provides a centralized logging mechanism for the client application. It allows for structured logging with different severity levels (e.g., `debug`, `info`, `warn`, `error`) and can be configured to control log output based on application settings.

**Key Features:**
-   **Level-based logging:** Filter messages based on their importance.
-   **Contextual logging:** Include additional data with log messages for better debugging.
-   **Conditional logging:** Enable/disable logging based on environment or debug flags.

**Usage Example:**
```typescript
import { logger } from './logger';

logger.info('Application started successfully.');
logger.debug('Processing data:', { data: someObject });
logger.error('Failed to fetch graph data:', error);
```

### `binaryUtils.ts` ([`client/src/utils/binaryUtils.ts`](../../client/src/utils/binaryUtils.ts))

Contains helper functions for working with binary data, particularly useful for encoding and decoding messages transmitted over WebSockets using the custom binary protocol.

**Key Features:**
-   Functions for converting between `ArrayBuffer`, `Float32Array`, and other binary representations.
-   Utilities for reading and writing specific data types (e.g., floats, integers) from/to `ArrayBuffer` views.
-   `isZlibCompressed(data: ArrayBuffer): boolean`: Checks if the provided `ArrayBuffer` likely contains zlib compressed data (by looking for a zlib header).
-   `decompressZlib(compressedData: ArrayBuffer): Promise<ArrayBuffer>`: Decompresses zlib-compressed data using the browser's `DecompressionStream` API.

### `caseConversion.ts`

Provides utilities for converting string cases, such as `camelCase` to `snake_case` and vice-versa. This is often used when interacting with API endpoints or data structures that follow different naming conventions (e.g., JavaScript frontend using `camelCase` and Rust backend using `snake_case`).

**Key Functions:**
-   `camelToSnakeCase(str: string): string`
-   `snakeToCamelCase(str: string): string`

### `cn.ts`

A small utility for conditionally joining CSS class names, often used with Tailwind CSS to build dynamic class strings. It's a common pattern for managing component styling based on props or state.

**Usage Example:**
```typescript
import { cn } from './cn';

const isActive = true;
const buttonClasses = cn('btn', isActive && 'btn-active', 'px-4');
```

### `debugState.ts` ([`client/src/utils/debugState.ts`](../../client/src/utils/debugState.ts))

Provides utilities for managing and inspecting the application's debug state. This can include flags for enabling/disabling various debug visualizations, logging verbosity, or performance overlays.

**Key Features:**
-   Functions to set and retrieve debug flags (e.g., `isDebugEnabled('physics')`).
-   Loads and saves debug state from/to `localStorage` for persistence across sessions.
-   May integrate with the `SettingsStore` for more complex or UI-configurable debug settings.

### `deepMerge.ts`

A utility function for performing a deep merge of two or more objects. This is useful for combining default settings with user-specific overrides or for merging complex configuration objects.

**Key Features:**
-   Recursively merges properties of source objects into a target object.
-   Handles various data types, including arrays and nested objects.

### `objectPath.ts` ([`client/src/utils/objectPath.ts`](../../client/src/utils/objectPath.ts))

Provides functions for safely accessing, setting, or deleting values within nested JavaScript objects using a dot-separated path string (e.g., `'visualisation.nodes.size'`). This is particularly useful for interacting with the `SettingsStore` (via `settingsService.ts`) where settings are often identified and updated by their path.

**Key Functions:**
-   `get(obj: object, path: string, defaultValue?: any): any`
-   `set(obj: object, path: string, value: any): object`
-   `del(obj: object, path: string): object`

### `utils.ts`

A general-purpose utility file that might contain miscellaneous helper functions that don't fit into more specific categories. This could include array manipulation, string formatting, or other common operations.

## General-Purpose Hooks (`client/src/hooks/`)

The `client/src/hooks/` directory contains custom React hooks that provide reusable logic for common UI patterns or data management.

### `useContainerSize.ts` ([`client/src/hooks/useContainerSize.ts`](../../client/src/hooks/useContainerSize.ts))

A custom React hook that measures and provides the current dimensions (width and height) of a referenced DOM element. It typically uses `ResizeObserver` to react to changes in the element's size, making it useful for responsive layouts or sizing elements like the R3F canvas.

**Usage Example:**
```typescript
import React, { useRef } from 'react';
import { useContainerSize } from './useContainerSize';

function MyComponent() {
  const ref = useRef(null);
  const { width, height } = useContainerSize(ref);

  return (
    <div ref={ref} style={{ width: '100%', height: '500px' }}>
      Container size: {width}x{height}
    </div>
  );
}
```

### `useWindowSize.ts` ([`client/src/hooks/useWindowSize.ts`](../../client/src/hooks/useWindowSize.ts))

A custom React hook that provides the current dimensions (width and height) of the browser window. It updates reactively when the window is resized by listening to the `resize` event, enabling responsive design and layout adjustments based on the viewport size.

**Usage Example:**
```typescript
import { useWindowSize } from './useWindowSize';

function ResponsiveHeader() {
  const { width, height } = useWindowSize();
  const isMobile = width < 768;

  return (
    <header>
      {isMobile ? 'Mobile Header' : 'Desktop Header'}
      <p>Window size: {width}x{height}</p>
    </header>
  );
}
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/client/index.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/client/index.md
```md
# Client Documentation

This section contains documentation for the client-side components of the system.

## Components

- [Architecture](architecture.md)
- [Components](components.md)
- [Core](core.md)
- [Rendering](rendering.md)
- [State Management](state.md)
- [Types](types.md)
- [Visualisation](visualisation.md)
- [WebSocket Communication](websocket.md)
- [WebXR Integration](xr.md)
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/client/rendering.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/client/rendering.md
```md
# Client Rendering System

This document provides a detailed overview of the 3D rendering system in the LogseqXR client, which is built using React Three Fiber (R3F) and Three.js. It covers the setup, key components, and how various visual elements are rendered.

## Overview

The rendering system is responsible for transforming the graph data (nodes, edges, metadata) into an interactive 3D visualization. It leverages the declarative nature of React with the power of Three.js through R3F, allowing for efficient management of the 3D scene graph and performance optimizations like instancing.

## React Three Fiber (R3F) Setup

The core of the 3D scene is established by `@react-three/fiber`.

### `GraphCanvas.tsx` (`client/src/features/graph/components/GraphCanvas.tsx`)

This is the main entry point for the 3D scene. It wraps the Three.js `Canvas` component from R3F and sets up the fundamental rendering environment.

**Responsibilities:**
-   Initializes the WebGL renderer.
-   Configures the camera (e.g., `PerspectiveCamera`).
-   Sets up basic scene elements like ambient lighting.
-   Hosts other 3D components that make up the graph visualization.
-   Manages the `dpr` (device pixel ratio) for rendering quality.

**Key Properties:**
-   `camera`: Defines the camera properties (e.g., `fov`, `near`, `far`, `position`).
-   `gl`: WebGL renderer settings (e.g., `antialias`, `alpha`).

## Core Rendering Components

### `GraphManager.tsx` (`client/src/features/graph/components/GraphManager.tsx`)

This component is central to rendering the graph's nodes and edges. It receives processed graph data and efficiently renders it in the 3D scene.

**Responsibilities:**
-   Manages the creation and updating of 3D objects for nodes and edges.
-   Utilizes **instancing** for nodes and edges to draw many similar objects with a single draw call, significantly improving performance for large graphs.
-   Applies visual properties (color, size, material) based on settings and node/edge attributes.
-   Orchestrates updates to node positions and other dynamic properties based on physics simulation data received from the server.

### `GraphViewport.tsx` (`client/src/features/graph/components/GraphViewport.tsx`)

This component manages the camera controls and applies post-processing effects to the rendered scene.

**Responsibilities:**
-   Integrates camera controls (e.g., `OrbitControls` or custom controls) to allow user navigation.
-   Applies visual enhancements like bloom, depth of field, or other effects using R3F's `Postprocessing` components.

## Node and Edge Rendering

### Nodes

Nodes are typically rendered as instanced meshes (e.g., spheres or custom geometries).

-   **Geometry:** A basic geometry (e.g., `SphereGeometry`) is created once.
-   **Material:** A material (e.g., `MeshStandardMaterial`, `MeshBasicMaterial`) is applied, often with custom shaders for unique visual effects.
-   **Instancing:** `InstancedMesh` is used to render thousands of nodes efficiently. Each instance has its own position, rotation, and scale, which are updated dynamically.

### Edges

Edges are rendered as lines or thin cylinders connecting nodes.

-   **Geometry:** Line geometries are dynamically generated based on connected node positions. For curved edges, `CatmullRomCurve3` or similar can be used.
-   **Material:** Line materials (`LineBasicMaterial`, `LineDashedMaterial`) or custom shader materials are used.
-   **Instancing:** For very large graphs, instancing can also be applied to edges, though it's more complex than for nodes due to varying lengths and orientations.

## Text Rendering

### `TextRenderer.tsx` (`client/src/features/visualisation/renderers/TextRenderer.tsx`)

This component is responsible for rendering text labels (e.g., node names, metadata) in the 3D scene.

**Key Features:**
-   Uses **Signed Distance Field (SDF) fonts** for crisp, scalable text that looks good at any distance and angle.
-   Handles text positioning, alignment, and scaling relative to the 3D objects they label.
-   Optimized for performance, often by batching text geometries or using instancing for common labels.

## Custom Shaders

### `HologramMaterial.tsx` (`client/src/features/visualisation/renderers/materials/HologramMaterial.tsx`)

This module defines a custom Three.js `ShaderMaterial` used to create a distinctive holographic visual effect for certain nodes or elements.

**Key Features:**
-   Utilizes GLSL shaders (vertex and fragment shaders) to achieve effects like:
    -   Animated scan lines or noise patterns.
    -   Color tinting and transparency.
    -   Edge glow or outline effects.
-   Integrates with R3F by being exposed as a custom material component.

## Distinction from `visualization.md`

While `rendering.md` focuses on the "how" of drawing elements in 3D space (technical implementation, R3F components, performance techniques), `visualization.md` (when populated) will focus on the "what" and "why" – the higher-level concepts of how data is mapped to visual properties, the meaning of different visual elements (e.g., node color representing file type), and the overall user experience of interacting with the visualized knowledge graph.
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/client/settings-panel-redesign.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/client/settings-panel-redesign.md
```md
# Settings Panel Redesign

## Overview

The settings panel has been completely redesigned to address critical UX issues:
- **Cluttered interface** with too many settings visible at once
- **Non-responsive inputs** that don't update properly
- **Overlapping content** when sections expand
- **Poor organization** making it hard to find settings

## New Design Principles

### 1. **Tabbed Organization**
Settings are now organized into logical tabs:
- **Appearance**: Visual customization (nodes, edges, labels, effects)
- **Performance**: Quality and optimization settings
- **XR/VR**: Virtual reality configuration
- **Advanced**: Power user features (requires authentication)

### 2. **Collapsible Sections**
Within each tab, settings are grouped into collapsible cards:
- Only one section expanded by default
- Clear headers with descriptions
- Smooth expand/collapse animations
- Visual indicators for expansion state

### 3. **Smart Controls**
Each setting uses the most appropriate control:
- **Sliders** for numeric ranges with live value display
- **Color pickers** with hex input for colors
- **Switches** for boolean toggles
- **Select dropdowns** for predefined options
- **Password fields** with visibility toggle for sensitive data

### 4. **Visual Feedback**
- Hover effects on interactive elements
- Save confirmation badges appear briefly after changes
- Disabled state for power-user features when not authenticated
- Clear status bar showing auto-save and user status

## Implementation Details

### Component Structure
```
SettingsPanelRedesign
├── Header (title + description)
├── Tabs Component
│   ├── Tab List (Appearance, Performance, XR/VR, Advanced)
│   └── Tab Content
│       └── Collapsible Setting Groups
│           └── Individual Setting Controls
└── Status Bar (auto-save info + power user status)
```

### Key Features

1. **Real-time Updates**
   - Changes immediately update the visualization
   - No need for manual save buttons
   - Visual confirmation when settings are saved

2. **Power User Gating**
   - Advanced settings only visible to authenticated users
   - Clear messaging about authentication requirements
   - Visual indicators (badges) for pro features

3. **Responsive Layout**
   - Fixed height with scrollable content area
   - Proper spacing prevents overlapping
   - Clean visual hierarchy

4. **Improved Organization**
   - Settings grouped by task/purpose
   - Most common settings easily accessible
   - Advanced options tucked away but discoverable

### File Structure
- [`client/src/features/settings/components/panels/SettingsPanelRedesign.tsx`](../../client/src/features/settings/components/panels/SettingsPanelRedesign.tsx) - Main redesigned component.
- [`client/src/app/components/RightPaneControlPanel.tsx`](../../client/src/app/components/RightPaneControlPanel.tsx) - Hosts the `SettingsPanelRedesign` and other control panels.

## Migration Notes

The new design maintains compatibility with existing core settings logic:
- Settings store ([`client/src/store/settingsStore.ts`](../../client/src/store/settingsStore.ts))
- Setting definitions ([`client/src/features/settings/config/settingsUIDefinition.ts`](../../client/src/features/settings/config/settingsUIDefinition.ts))
- Individual control components ([`client/src/features/settings/components/SettingControlComponent.tsx`](../../client/src/features/settings/components/SettingControlComponent.tsx))

No changes needed to backend or data flow - this is purely a UI/UX improvement.

## Benefits

1. **Reduced Cognitive Load**: Users see only relevant settings
2. **Better Discoverability**: Logical grouping helps users find settings
3. **Cleaner Interface**: No more overlapping or cluttered views
4. **Improved Performance**: Only renders visible settings
5. **Better Mobile Support**: Tab-based navigation works well on small screens
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/client/state.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/client/state.md
```md
# State Management

This document details the state management patterns and mechanisms used throughout the client application. The application uses several complementary approaches to state management to handle different types of state.

## State Management Overview

The client application manages several types of state:

1.  **Application Settings** - User preferences and application configuration
2.  **Graph Data** - Nodes, edges, and metadata for the visualisation
3.  **UI State** - Control panel state, selected items, and UI configuration
4.  **Rendering State** - Camera position, visibility settings, and rendering options
5.  **XR State** - XR session status, controller positions, and interaction state

```mermaid
flowchart TB
    subgraph ApplicationState
        Settings[Settings Store]
        GraphData[Graph Data]
        UIState[UI State]
        RenderState[Rendering State]
        XRState[XR State]
    end

    subgraph StateConsumers
        GraphManager[Graph Manager]
        ControlPanel[Control Panel]
        XRComponents[XR Components]
        VisualisationComponents[Visualisation Components]
    end

    Settings --> VisualisationComponents
    Settings --> ControlPanel
    Settings --> XRComponents

    GraphData --> GraphManager
    GraphData --> VisualisationComponents

    UIState --> ControlPanel
    RenderState --> VisualisationComponents
    XRState --> XRComponents
```

## Key State Management Components

### Settings Store ([`client/src/store/settingsStore.ts`](../../client/src/store/settingsStore.ts))

It uses Zustand for state management, `persist` middleware for saving to local storage, and `immer`'s `produce` utility for safe, immutable updates.

**Key Features:**
- Persistence to local storage (and potentially server-side sync via `settingsService.ts`).
- Observable changes through Zustand's subscription mechanism.
- Default values loaded from [`client/src/features/settings/config/defaultSettings.ts`](../../client/src/features/settings/config/defaultSettings.ts).
- Uses `immer` middleware for convenient immutable updates.
- Employs a `deepMerge` utility ([`client/src/utils/deepMerge.ts`](../../client/src/utils/deepMerge.ts)) for merging settings updates.

**Implementation Pattern (Zustand with Immer):**
The `set` and `updateSettings` methods in the store handle immutable updates for nested properties. The `set` method uses a path-based string to update specific values, while `updateSettings` accepts an Immer-style producer function for more complex mutations.

**Settings Validation:**
Settings validation primarily relies on **TypeScript's static type checking** during development and the structure enforced by UI components ([`SettingControlComponent.tsx`](../../client/src/features/settings/components/SettingControlComponent.tsx) based on [`settingsUIDefinition.ts`](../../client/src/features/settings/config/settingsUIDefinition.ts)). There is **no explicit runtime validation using Zod schemas** (like from `client/src/features/settings/types/settingsSchema.ts`) directly within the `settingsStore`'s `set` or `updateSettings` methods. Input validation is expected to occur in the UI components before attempting to update the store.

### Graph Data Manager ([`client/src/features/graph/managers/graphDataManager.ts`](../../client/src/features/graph/managers/graphDataManager.ts))

The Graph Data Manager maintains the state of the graph visualisation data.

**Key Features:**
- Loads and processes graph data from server
- Manages node and edge collections
- Handles real-time position updates via binary protocol
- Provides subscription mechanism for changes

**State Transitions:**
```mermaid
stateDiagram-v2
    [*] --> Empty
    Empty --> Loading: fetchInitialData()
    Loading --> PartiallyLoaded: First page loaded
    PartiallyLoaded --> FullyLoaded: All pages loaded
    FullyLoaded --> LiveUpdates: WebSocket connected
    LiveUpdates --> FullyLoaded: WebSocket disconnected
    LiveUpdates --> LiveUpdates: Position update
    FullyLoaded --> Empty: clear()
    LiveUpdates --> Empty: clear()
```

### Settings Observer
The file `SettingsObserver.ts` is **not used** in the current architecture. Zustand itself provides the subscription mechanism. Components subscribe directly to `useSettingsStore` (often using selectors to pick specific parts of the state) to react to changes.

## State Persistence

The application persists state in several ways:

1.  **Local Storage** - User preferences and UI state (managed by Zustand's `persist` middleware).
2.  **Server Storage** - User settings synchronized to server (for authenticated users).
3.  **URL Parameters** - Shareable state in URL (not extensively used for persistence, more for initial configuration).

### Persistence Flow

```mermaid
flowchart TD
    StateChange[State Change] --> ValidState{Is Valid?}
    ValidState -->|Yes| LocalStorage[Store in Local Storage]
    ValidState -->|Yes| SyncToServer{Sync to Server?}
    ValidState -->|No| LogError[Log Error]

    SyncToServer -->|Yes| APICall[POST to API]
    SyncToServer -->|No| Complete[Complete]

    APICall --> ServerResponse{Success?}
    ServerResponse -->|Yes| Complete
    ServerResponse -->|No| RetryStrategy[Apply Retry Strategy]

    RetryStrategy --> APICall
```

## State Change Propagation

The application uses several mechanisms to propagate state changes:

### Event Emitter
A dedicated global event emitter (e.g., `client/utils/eventEmitter.ts`) is **not present** in the current codebase. Communication and event-like propagation are handled by:
- **Zustand store subscriptions**: For changes in global state like settings.
- **React Context API**: For more localized state or function sharing.
- **Callbacks and Props**: Standard React patterns for component communication.
- **WebSocketService event handlers**: For server-sent messages (e.g., `onMessage`, `onBinaryMessage`).
- `graphDataManager` might expose its own subscription mechanism for graph-specific updates (e.g., `onGraphDataChange`, `onPositionUpdate`).

### Direct Subscriptions

Components can subscribe directly to state stores.

**Example:**
```typescript
const graphDataManager = GraphDataManager.getInstance(); // Or however it's accessed
const unsubscribeGraph = graphDataManager.onGraphDataChange((newGraphData) => {
  console.log('Graph data changed:', newGraphData);
  // Update component based on new graph data
});

const unsubscribeSettings = useSettingsStore.subscribe(
  (newSettings) => {
    console.log('Settings changed (entire settings object):', newSettings);
    // Update component based on new settings
  },
  state => state.settings // Selector for the entire settings object
);

const unsubscribeSpecificSetting = useSettingsStore.subscribe(
  (newNodeSize) => {
    console.log('Node size changed:', newNodeSize);
  },
  state => state.settings.visualisation.nodes.nodeSize // Selector for a specific value
);

```

## Settings Structure

```typescript

interface Settings {
  visualisation: {
    nodes: {
      nodeSize: number; // Note: This is a single number, not a range.
      baseColor: string;
      // ... other node properties
    };
    edges: {
      baseWidth: number;
      // ... other edge properties
    };
    physics: {
      enabled: boolean;
      // Note: gravityStrength and centerAttractionStrength are not in the config.
      // ... other physics properties
    };
    // ... other visualisation categories
  };
  system: {
    websocket: ClientWebSocketSettings;
    debug: DebugSettings;
    persistSettings: boolean;
  };
  xr: XRSettings;
  auth: AuthSettings;
  // Optional AI Service Settings (whisper is not a setting)
  ragflow?: RAGFlowSettings;
  perplexity?: PerplexitySettings;
  openai?: OpenAISettings;
  kokoro?: KokoroSettings;
}
```

### Settings Validation
As mentioned earlier, settings validation primarily relies on TypeScript's static type checking and UI component constraints. There is no explicit Zod validation layer directly within the `settingsStore`'s update methods.

## State Immutability

The application uses immutability patterns to prevent unexpected state changes, primarily facilitated by the `immer` middleware in Zustand. This ensures that state updates always result in new state objects, simplifying change detection and preventing unintended side effects.

**Example of Immutable Update (handled by Immer in Zustand):**
```typescript
set((state) => {
  state.user.name = "New Name"; // This is automatically converted to an immutable update
});

set((state) => ({
  ...state,
  user: {
    ...state.user,
    name: "New Name"
  }
}));
```

## Related Documentation

- [Components](components.md) - Component relationships and dependencies
- [Architecture](architecture.md) - Overall system architecture
- [WebSocket Communication](websocket.md) - Real-time state updates
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/client/types.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/client/types.md
```md
# Client TypeScript Types and Interfaces

This document summarizes key TypeScript types and interfaces used throughout the LogseqXR client application. It focuses on data structures related to graph management, settings, and core application entities.

## Core Graph Data Structures

These types define the fundamental elements of the knowledge graph.

### `Node`

Represents a node in the graph, typically corresponding to a file or a concept.

```typescript
export interface Node {
  id: string; // Unique identifier for the node (often numeric, but treated as string)
  label: string; // Display name of the node
  position: { x: number; y: number; z: number }; // Current 3D position
  metadata: Record<string, any>; // Arbitrary metadata (e.g., file type, size, custom tags)
  // Optional properties that might be populated:
  // velocity?: { x: number; y: number; z: number }; // Current velocity (if tracked client-side)
  // mass?: number;
  // fixed?: boolean; // If the node position is fixed
}
```
Note: The `data: BinaryNodeData` field mentioned in previous docs, which mirrored the server-side `BinaryNodeData` (with mass, flags etc.), is not directly part of the primary client-side `Node` interface in `graphDataManager.ts`. The client-side `Node` directly holds `position`. The separate `BinaryNodeData` type below is specifically for WebSocket communication.

```typescript
export interface BinaryNodeData {
  nodeId: number; // Typically the numeric part of the Node's 'id' string
  position: { x: number; y: number; z: number };
  velocity: { x: number; y: number; z: number };
}
```

### `Edge`

Represents a link or relationship between two nodes.

```typescript
export interface Edge {
  id: string; // Unique identifier for the edge (e.g., "sourceId_targetId")
  source: string; // ID of the source node
  target: string; // ID of the target node
  label?: string; // Optional display label for the edge
  weight?: number; // Strength or importance of the link
  metadata?: Record<string, any>; // Arbitrary metadata for the edge
  // Visual properties might be dynamically applied rather than stored directly on the edge object.
}
```

### `GraphData`

The primary container for all nodes and edges that constitute the graph.

```typescript
export interface GraphData {
  nodes: Node[];
  edges: Edge[];
  metadata?: Record<string, any>; // Global metadata about the graph (e.g., graph title, version)
}
```

## Settings Interfaces

These interfaces define the structure of the application settings, managed by `SettingsStore`.

### Main `Settings` Interface

The root interface for all application settings, located in `client/src/features/settings/config/settings.ts`.

```typescript

export interface Settings {
  visualisation: {
    nodes: {
      nodeSize: number; // Single number, not a range
      baseColor: string;
      // ... many other node properties
    };
    edges: {
      baseWidth: number;
      color: string;
      // ... many other edge properties
    };
    // ... other categories like labels, physics, rendering, hologram, camera (optional)
  };
  system: {
    websocket: { // ClientWebSocketSettings
      updateRate: number; // Example field
      // ... other websocket settings
    };
    debug: { // DebugSettings
      enabled: boolean;
      // ... other debug settings
    };
    persistSettings: boolean;
    customBackendUrl?: string;
  };
  xr: { // XRSettings
    enabled: boolean;
    clientSideEnableXR?: boolean; // Important client-side toggle
    enableHandTracking: boolean; // Note: not xr.handTracking
    // ... many other XR settings
  };
  auth: { // AuthSettings
    // ... auth related settings
  };
  ragflow?: { /* RAGFlowSettings */ }; // Optional
  perplexity?: { /* PerplexitySettings */ }; // Optional
  openai?: { /* OpenAISettings */ }; // Optional
  kokoro?: { /* KokoroSettings */ }; // Optional
}
```
**Important:** The above is a simplified representation. The definitive source for the `Settings` interface and all its nested types is [`client/src/features/settings/config/settings.ts`](../../client/src/features/settings/config/settings.ts). Please refer to this file for the complete and accurate structure.

## RAGFlow Specific Types

Types related to interactions with the RAGFlow API, defined in [`client/src/types/ragflowTypes.ts`](../../client/src/types/ragflowTypes.ts).

### `RagflowChatRequestPayload`

Defines the payload for sending a chat request to the RAGFlow service.
```typescript
export interface RagflowChatRequestPayload {
  question: string;
  sessionId?: string; // Optional: for continuing a conversation
  stream?: boolean;   // Optional: to stream the response (default: false)
}
```

### `RagflowChatResponsePayload` (or similar name in `ragflowTypes.ts`)

Defines the expected structure of a response from the RAGFlow chat service.
```typescript
export interface RagflowChatResponsePayload { // Name might vary slightly in the file
  answer: string;
  sessionId: string; // ID for the current conversation session
  // Note: The documentation mentioned 'conversation_id' but the plan specifies 'sessionId'.
  // Verify against ragflowTypes.ts and server model src/models/ragflow_chat.rs.
}
```

## Other Notable Types

### `BinaryProtocol` related types ([`client/src/types/binaryProtocol.ts`](../../client/src/types/binaryProtocol.ts))

This file contains types and constants related to the custom binary protocol used for WebSocket communication.
-   `BinaryNodeData`: As defined earlier (nodeId, position, velocity).
-   May include constants for message type identifiers if the binary protocol supports different message types, or for byte offsets/sizes.

### Feature-Specific Types

Many features have their own dedicated `types.ts` or `*.types.ts` files.

-   **Settings UI Types**:
    -   [`client/src/features/settings/types/settingsTypes.ts`](../../client/src/features/settings/types/settingsTypes.ts): This file appears to contain older or more generic UI-related type definitions like `SettingControlProps`, `SettingsSectionProps`.
    -   The primary types driving the current settings UI are `UISettingDefinition` and related types from [`client/src/features/settings/config/settingsUIDefinition.ts`](../../client/src/features/settings/config/settingsUIDefinition.ts). This documentation should clarify that `settingsUIDefinition.ts` is more central for the *current* settings panel structure.

-   **XR Types**:
    -   [`client/src/features/xr/types/xr.ts`](../../client/src/features/xr/types/xr.ts): Defines types specific to WebXR interactions, controller states, hand tracking data, and XR session management.

-   **Visualisation Types**:
    -   [`client/src/features/visualisation/types/visualisationTypes.ts`](../../client/src/features/visualisation/types/visualisationTypes.ts): This file defines a very simple `VisualisationSettings` interface. It's important to note that the comprehensive and detailed visualisation settings are part of the main `Settings` interface in [`client/src/features/settings/config/settings.ts`](../../client/src/features/settings/config/settings.ts) under the `visualisation` key. This `visualisationTypes.ts` might be for a different, more specific concept or could be outdated/less relevant for global settings.

These feature-specific type files help in modularizing the codebase and ensuring type safety within their respective domains.

This document provides a high-level summary. For the most accurate and detailed definitions, always refer to the source TypeScript files linked.
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/client/user-controls-summary.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/client/user-controls-summary.md
```md
# User Controls Summary - Settings Panel

## Intuitive Features Implemented

### 1. **Smart Control Type Selection**
The system automatically selects the most appropriate control type based on the `controlType` specified in the `UISettingDefinition` (from [`client/src/features/settings/config/settingsUIDefinition.ts`](../../client/src/features/settings/config/settingsUIDefinition.ts)) and the data type of the setting. Key control types rendered by [`SettingControlComponent.tsx`](../../client/src/features/settings/components/SettingControlComponent.tsx) include:

-   **`toggle`**: For boolean values (on/off settings) -> Renders a Switch.
-   **`slider`**: For numeric values with defined `min`, `max`, and `step` -> Renders a Slider.
-   **`numberInput`**: For general numeric values -> Renders a Number Input.
-   **`textInput`**: For string values.
-   **`passwordInput`**: A variant of `textInput` for sensitive string fields (API keys, secrets), providing masking.
-   **`select`**: For predefined options (enum-like strings) defined in `options` array in `UISettingDefinition` -> Renders a Select Dropdown.
-   **`colorPicker`**: For single string color values -> Renders a Color Picker with hex input.
-   **`rangeSlider`**: For `[number, number]` array values, representing a min/max range -> Renders a specialized Range Slider.
-   **`dualColorPicker`**: For `[string, string]` array values, representing two colors (e.g., for gradients) -> Renders two Color Pickers.
-   **`radioGroup`**: For selecting one option from a list (mutually exclusive choices) defined in `options` -> Renders a Radio Group.
-   **`buttonAction`**: For triggering an action (e.g., reset a section, trigger a backend process) -> Renders a Button. The action is defined by `actionId` in `UISettingDefinition`.

### 2. **User Experience Enhancements**

#### Visual Feedback
- **Live Value Display** - Shows current value next to sliders with appropriate decimal places
- **Unit Display** - Shows units (px, ms, etc.) where applicable
- **Hover Effects** - Subtle background highlight on hover for better interactivity
- **Tooltips** - Info icons with descriptions for complex settings

#### Input Handling
- **Debounced Inputs** - 300ms delay prevents excessive updates while typing
- **Validation** - Color inputs validate hex format and auto-correct invalid entries
- **Password Visibility Toggle** - Eye icon to show/hide sensitive values
- **Placeholder Text** - Contextual hints for input fields

#### Layout & Styling
- **Responsive Design** - Controls adapt to available space
- **Consistent Spacing** - Proper padding and margins for readability
- **Visual Hierarchy** - Clear label/control separation
- **Smooth Transitions** - CSS transitions for hover states

### 3. **Task-Appropriate Features**

#### For Visualization Settings
- **Real-time Updates** - Changes to visualization settings update the viewport immediately
- **Slider Preference** - Numeric inputs with ranges automatically use sliders for easier adjustment
- **Precise Control** - Step values configured appropriately (0.01 for decimals, 1 for integers)

#### For Security/Authentication
- **Automatic Masking** - API keys, secrets, and tokens are masked by default
- **Secure Placeholders** - "Enter secure value" for sensitive fields
- **Power User Gating** - Advanced settings only visible to authenticated power users

#### For Color Settings
- **Dual Input** - Both visual picker and text input for flexibility
- **Validation** - Ensures only valid hex colors are saved
- **Fallback Values** - Defaults to black (#000000) if invalid

### 4. **Accessibility Features**
- **Proper Labels** - All controls have associated labels
- **Keyboard Navigation** - Full keyboard support for all controls
- **ARIA Attributes** - Proper IDs and relationships
- **Focus Indicators** - Clear focus states for keyboard users

## Control Types by Use Case

### Basic Settings
- Enable/Disable features → **Toggle Switch**
- Adjust sizes/distances → **Slider with value display**
- Enter text/names → **Text Input with placeholder**

### Advanced Settings
- API Configuration → **Password Input with visibility toggle**
- Color Themes → **Color Picker with hex validation**
- Performance Ranges → **Range Slider for min/max**
- Display Modes → **Select Dropdown**

### Power User Settings
- Debug Options → **Hidden unless authenticated**
- Advanced XR Settings → **Gated by Nostr auth**
- AI Model Parameters → **Only visible to power users**

## Implementation Details

The controls are implemented in [`SettingControlComponent.tsx`](../../client/src/features/settings/components/SettingControlComponent.tsx) with:
- React hooks for state management (getting/setting values via `useSettingsStore`).
- Logic to determine the appropriate UI control based on `UISettingDefinition`.
- Custom debounce hook for input optimization on text/number inputs.
- TypeScript for type safety.
- Tailwind CSS for consistent styling.
- Lucide React icons for visual elements (e.g., tooltips, password visibility).

All controls follow the same pattern:
1. Receive value and onChange from parent
2. Manage local state for debouncing if needed
3. Validate input before calling onChange
4. Provide appropriate visual feedback
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/client/visualization.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/client/visualization.md
```md
# Client-Side Visualization Concepts

This document outlines the higher-level concepts behind the visualization of the knowledge graph in the LogseqXR client. It explains *what* is being visualized and *how* different visual elements represent data, distinguishing itself from `rendering.md` which details the technical "how-to" of drawing these elements.

## Core Visualization Metaphor

The primary goal is to transform an abstract knowledge graph, typically represented by Markdown files and their links, into a tangible and interactive 3D spatial environment.

-   **Nodes as Entities:** Each primary piece of information (e.g., a Logseq page, a specific block, or a concept) is represented as a **node** in the 3D space.
    -   Typically, nodes correspond to individual Markdown files.
    -   The visual appearance of a node (size, color, shape) can be mapped to its attributes (e.g., file size, type, metadata tags).
-   **Edges as Relationships:** Links and connections between these entities (e.g., hyperlinks, block references, tags) are represented as **edges** connecting the corresponding nodes.
    -   The visual properties of edges (thickness, color, style) can signify the type or strength of the relationship.

## Mapping Data to Visual Elements

The effectiveness of the visualization hinges on how data attributes are mapped to visual properties.

### Node Visuals

-   **Size:**
    -   Controlled by `visualisation.nodes.nodeSize` in [`settings.ts`](../../client/src/features/settings/config/settings.ts) for a base size.
    -   This can be modulated by data attributes (e.g., file size, connection count).
-   **Color:**
    -   Default color from `visualisation.nodes.baseColor` in [`settings.ts`](../../client/src/features/settings/config/settings.ts).
    -   Can be dynamically set based on metadata (e.g., file type, tags).
-   **Shape / Form:**
    -   Typically spheres for performance, but can be varied.
    -   `enableMetadataShape` in `NodeSettings` (from `settings.ts`) suggests potential for metadata-driven geometry.
-   **Holograms:**
    -   Enabled by `visualisation.nodes.enableHologram` and configured via `visualisation.hologram` (which is `HologramSettings`) in [`settings.ts`](../../client/src/features/settings/config/settings.ts).
    -   Rendered by [`HologramManager.tsx`](../../client/src/features/visualisation/renderers/HologramManager.tsx) using shaders like [`HologramMaterial.tsx`](../../client/src/features/visualisation/renderers/materials/HologramMaterial.tsx).

### Edge Visuals

-   **Thickness/Width:**
    -   Controlled by settings like `visualisation.edges.baseWidth` in [`settings.ts`](../../client/src/features/settings/config/settings.ts).
    -   Can represent link strength.
-   **Color:**
    -   Default from `visualisation.edges.color` in [`settings.ts`](../../client/src/features/settings/config/settings.ts).
    -   Can indicate link type or use gradients (e.g., `visualisation.edges.useGradient`, `visualisation.edges.gradientColors`).
-   **Style:**
    -   Arrows for directionality (e.g., `visualisation.edges.enableArrows`).
    -   Flow effects for activity (e.g., `visualisation.edges.enableFlowEffect`).
    -   All relevant settings are within `visualisation.edges` in [`settings.ts`](../../client/src/features/settings/config/settings.ts).

### Text Labels

-   Appearance controlled by `visualisation.labels` (which is `LabelSettings`) in [`settings.ts`](../../client/src/features/settings/config/settings.ts).
-   Node labels typically display titles or filenames.
-   Edge labels can show relationship types.

## Interactive Visualization

The visualization is not static; users can interact with it:

-   **Navigation:** Panning, zooming, and rotating the camera to explore the graph from different perspectives.
-   **Selection:** Clicking on nodes or edges to highlight them and display more detailed information (e.g., in a side panel).
-   **Filtering/Searching:** Dynamically showing/hiding nodes and edges based on criteria.
-   **Spatial Arrangement:** The layout of nodes in 3D space is crucial. This is typically handled by a server-side physics simulation (`GraphService` in Rust) that attempts to position connected nodes closer together and push unrelated nodes apart, revealing clusters and structures.

## Metadata Visualization

### `MetadataVisualizer.tsx` ([`client/src/features/visualisation/components/MetadataVisualizer.tsx`](../../client/src/features/visualisation/components/MetadataVisualizer.tsx))

This component is responsible for displaying additional information or visual cues based on the metadata associated with nodes.

**Possible Implementations:**
-   **Icons/Glyphs:** Displaying small icons on or near nodes to represent file types, tags, or status.
-   **Auras/Halos:** Using subtle visual effects around nodes to indicate certain metadata properties (e.g., a glowing aura for unread items).
-   **Dynamic Text Panels:** Showing detailed metadata in a 2D overlay when a node is selected or hovered.

## Distinction from `rendering.md`

-   **`visualization.md` (this document):** Focuses on the *conceptual* aspects.
    -   What do nodes and edges *represent*?
    -   How is data (size, type, connections) *encoded* into visual properties (size, color, shape)?
    -   What insights is the user intended to gain from these visual mappings?
    -   The *meaning* behind the visual design choices.
-   **[`rendering.md`](./rendering.md):** Focuses on the *technical implementation*.
    -   How are spheres, lines, and text *drawn* using React Three Fiber and Three.js?
    -   What specific components (`GraphCanvas`, `GraphManager`, `TextRenderer`) are involved?
    -   What techniques (instancing, shaders like `HologramMaterial.tsx`) are used for performance and visual effects?
    -   The *mechanics* of putting pixels on the screen.

In essence, `visualization.md` is about the "language" of the visual representation, while `rendering.md` is about the "grammar and tools" used to speak that language.
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/client/websocket-readiness.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/client/websocket-readiness.md
```md
# WebSocket Readiness Protocol

This document describes the improvements made to the WebSocket communication system to ensure proper connection establishment and binary data flow.

## Problem Statement

The original implementation encountered issues where:

1. Binary updates were enabled before the WebSocket connection was fully established
2. The GraphDataManager attempted to send data before the WebSocket service was ready
3. The WebSocket service didn't track its readiness state properly
4. Connection retry mechanisms didn't account for full readiness

## Improved Implementation

### WebSocket Readiness States

The WebSocket connection now has three distinct states:

1. **Disconnected**: No connection established
2. **Connected**: Socket connection is open but not fully established with server
3. **Ready**: Connection is open AND server has sent "connection_established" message

```mermaid
stateDiagram-v2
    [*] --> Disconnected
    Disconnected --> Connecting: connect()
    Connecting --> Connected: onopen
    Connected --> Ready: connection_established
    Ready --> Connected: server reset
    Connected --> Disconnected: onclose
    Ready --> Disconnected: onclose
```

### WebSocketService Readiness Tracking

The [`WebSocketService.ts`](../../client/src/services/WebSocketService.ts) now includes:

-   `isConnected`: A boolean flag indicating if the WebSocket's `readyState` is `OPEN`.
-   `isServerReady`: A boolean flag set to `true` when the server sends a `connection_established` message (or a similar indicator like `updatesStarted`).
-   `isReady()`: A method that returns `true` only if both `isConnected` and `isServerReady` are true.
-   Logic to reset `isServerReady` to `false` on disconnection or error events.

```typescript
private isConnected: boolean = false;
private isServerReady: boolean = false;


public isReady(): boolean {
    return this.isConnected && this.isServerReady;
}
```

### GraphDataManager Enhancements

The [`GraphDataManager.ts`](../../client/src/features/graph/managers/graphDataManager.ts) now:

1.  Uses the `setWebSocketService` method to receive an adapter/instance of `WebSocketService`.
2.  Checks the `isReady()` method of the provided WebSocket service adapter before attempting to send data or enabling features that depend on a live connection (like `enableBinaryUpdates`).
3.  The `enableBinaryUpdates` method in `graphDataManager.ts` contains logic to attempt enabling updates and may include retries or checks based on the WebSocket service's readiness.

```typescript
private wsServiceAdapter: WebSocketServiceAdapter | null = null;

public setWebSocketService(adapter: WebSocketServiceAdapter): void {
    this.wsServiceAdapter = adapter;
    // Potentially try to enable binary updates if ready
    this.enableBinaryUpdates();
}

public enableBinaryUpdates(force: boolean = false): void {
    if (this.wsServiceAdapter?.isReady()) {
        // Send a message to server to start binary updates if needed
        // Or set a flag to start processing incoming binary updates
        logger.info('Binary updates enabled as WebSocket is ready.');
        // this.wsServiceAdapter.sendMessage({ type: 'subscribe_position_updates', binary: true, interval: ... });
        this.binaryUpdatesEnabled = true;
    } else {
        logger.warn('Cannot enable binary updates: WebSocket not ready.');
        // Implement retry logic if desired, e.g., after a delay or on next readiness change
    }
}
```

### Adapter Pattern for Service Integration

An adapter pattern is used, typically during application initialization (e.g., in [`AppInitializer.tsx`](../../client/src/app/AppInitializer.tsx)), to provide the `GraphDataManager` with a way to interact with the `WebSocketService`.

```typescript

if (websocketService && graphDataManager) {
    const wsAdapter = {
        sendRawBinaryData: (data: ArrayBuffer) => {
            websocketService.sendRawBinaryData(data);
        },
        sendMessage: (message: object) => { // For JSON messages
            websocketService.sendMessage(message);
        },
        isReady: () => websocketService.isReady(),
        // Expose other necessary WebSocketService methods to GraphDataManager
        onBinaryMessage: (callback: (data: ArrayBuffer) => void) => {
            return websocketService.onBinaryMessage(callback);
        },
        onMessage: (callback: (data: any) => void) => { // For JSON messages
            return websocketService.onMessage(callback);
        }
    };
    graphDataManager.setWebSocketService(wsAdapter);
}
```
This adapter ensures that `GraphDataManager` can use the `WebSocketService` without being tightly coupled to its specific implementation details, focusing only on the necessary interface for sending/receiving data and checking readiness.

## Benefits of Improved Implementation

1. **Reliability**: Binary updates are only enabled when the WebSocket connection is truly ready
2. **Error Prevention**: Avoids attempting to send data before the connection is established
3. **Diagnostic**: Better logging identifies exact state of connection
4. **Recovery**: Enhanced retry mechanisms handle reconnection scenarios better

## Connection Sequence

```mermaid
sequenceDiagram
    participant Client
    participant WSService as WebSocketService
    participant GraphMgr as GraphDataManager
    participant Server

    Client->>WSService: connect()
    WSService->>Server: WebSocket connection
    Server-->>WSService: onopen
    WSService->>Client: onConnectionStatusChange(true)
    Server-->>WSService: connection_established
    WSService->>WSService: isReadyFlag = true
    WSService->>Client: notifyReadiness()
    Client->>GraphMgr: enableBinaryUpdates()
    GraphMgr->>WSService: isReady() check
    WSService-->>GraphMgr: true
    GraphMgr->>WSService: send binary data
    WSService->>Server: binary data
    Server-->>WSService: binary position updates
    WSService->>GraphMgr: updateNodePositions()
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/client/websocket.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/client/websocket.md
```md
# WebSocket Communication

This document describes the WebSocket communication system used in the client.

## Overview

The client uses WebSocket connections for real-time communication with the server, particularly for:
- Binary position updates for graph nodes
- Graph data synchronization
- Event notifications
- Connection status management

## Architecture

```mermaid
graph TB
    subgraph ClientSide [Client]
        App[Application UI/Logic] --> GDM[GraphDataManager]
        App --> WSS[WebSocketService]
        WSS --> GDM
        GDM --> RenderingEngine[Rendering Engine (GraphManager etc.)]
    end

    subgraph ServerSide [Server]
        ServerWSS[WebSocket Server Handler (socket_flow_handler.rs)]
        ClientMgr[ClientManager]
        GraphSvc[GraphService (Physics Engine)]

        ServerWSS <--> ClientMgr
        GraphSvc --> ClientMgr
    end

    WSS <--> ServerWSS
```

## WebSocket Service

The WebSocket service ([`client/src/services/WebSocketService.ts`](../../client/src/services/WebSocketService.ts)) is implemented as a singleton that manages:
- WebSocket connection establishment and maintenance (including reconnection logic).
- Sending and receiving JSON and binary messages.
- Handling binary protocol specifics (like potential decompression if not handled by `binaryUtils.ts` directly upon receipt).
- Exposing connection status and readiness (see `websocket-readiness.md`).
- Error handling for the connection itself.

### Key Features

- Automatic reconnection with exponential backoff
- Binary message support
- Connection status monitoring
- Event-based message handling

## Binary Protocol

The binary protocol is used for efficient transmission of node position updates.

### Message Format

The primary binary message format is for node position and velocity updates.

-   **Format per node:**
    -   Node ID: `uint16` (2 bytes)
    -   Position (X, Y, Z): 3 x `float32` (12 bytes)
    -   Velocity (VX, VY, VZ): 3 x `float32` (12 bytes)
-   **Total per node: 26 bytes.**
-   A single binary WebSocket message can contain data for multiple nodes, packed consecutively.
-   **Important Clarification:** The server-side `BinaryNodeData` struct (in `src/utils/socket_flow_messages.rs`) includes additional fields like `mass`, `flags`, and `padding`. These are used for the server's internal physics simulation but are **not** part of the 26-byte wire format sent to the client. The client-side `BinaryNodeData` type in [`client/src/types/binaryProtocol.ts`](../../client/src/types/binaryProtocol.ts) correctly reflects the 26-byte structure (nodeId, position, velocity).
-   Server-side compression (zlib) is applied if the total binary message size exceeds `system.websocket.compressionThreshold` (default 512 bytes). Client-side decompression is handled by [`client/src/utils/binaryUtils.ts`](../../client/src/utils/binaryUtils.ts).

### Processing Flow

```mermaid
sequenceDiagram
    participant Server
    participant WebSocket
    participant BinaryHandler
    participant GraphManager
    participant Visualisation

    Server->>WebSocket: Binary Message
    WebSocket->>BinaryHandler: Process ArrayBuffer
    BinaryHandler->>GraphManager: Update Node Positions
    GraphManager->>Visualisation: Trigger Update
```

## Message Types

The WebSocket service handles several types of messages:

1.  **Binary Position Updates (Server -> Client)**
    -   Format: `ArrayBuffer` (potentially zlib compressed).
    -   Handler: `onBinaryMessage` callback provided to `WebSocketService`.
    -   Content: Packed `BinaryNodeData` (nodeId, position, velocity) for multiple nodes.
    -   Usage: Real-time node position and velocity updates from the server's physics simulation.

2.  **JSON Control Messages (Bidirectional)**
    -   Format: JSON objects.
    -   Handler: `onMessage` callback provided to `WebSocketService`.
    -   Examples:
        -   Server -> Client: `{"type": "connection_established"}`, `{"type": "updatesStarted"}`, `{"type": "loading"}`.
        -   Client -> Server: `{"type": "requestInitialData"}`, `{"type": "ping"}`, `{"type": "subscribe_position_updates", "binary": true, "interval": ...}`. (The `subscribe_position_updates` is effectively handled by `requestInitialData` logic on the server).

3.  **Connection Status Changes**
    -   Not a message type per se, but an event emitted by `WebSocketService`.
    -   Handler: `onConnectionStatusChange` callback.
    -   Provides status like `{ connected: boolean; error?: any }`.

## Error Handling

The WebSocket service implements robust error handling, primarily by logging errors and attempting reconnection.

### Recovery Strategy

```mermaid
stateDiagram-v2
    [*] --> Connected
    Connected --> Disconnected: Connection Lost
    Disconnected --> Retrying: Auto Reconnect
    Retrying --> Connected: Success
    Retrying --> Failed: Max Retries
    Failed --> [*]: Fatal Error
    Retrying --> Disconnected: Retry Failed
```

## Configuration

WebSocket behavior can be configured through settings:

```typescript

interface ClientWebSocketSettings { // From settings.ts
    updateRate: number; // Target FPS for client-side rendering of updates
    reconnectAttempts: number;
    reconnectDelay: number; // ms
    compressionEnabled: boolean; // Client expects server to compress if true
    compressionThreshold: number; // Matches server setting
    // binaryChunkSize is not a direct client setting, more server-side or implicit.
    // minUpdateRate, maxUpdateRate, motionThreshold, motionDamping are server-side physics/update rate controls.
}
```
The client's `WebSocketService` uses `reconnectAttempts` and `reconnectDelay`. The `compressionEnabled` and `compressionThreshold` inform the client whether to expect compressed messages and how to handle them (though decompression logic is in `binaryUtils.ts`). The `updateRate` in client settings typically influences how often the client *requests* or *processes* updates, distinct from the server's actual send rate.

## Performance Considerations

1. **Binary Protocol**
   - Reduces message size by ~60% compared to JSON
   - Minimizes parsing overhead
   - Enables efficient batch updates

2. **Message Batching**
   - Position updates are batched for efficiency
   - Configurable batch size and update rate
   - Automatic throttling under high load

3. **Connection Management**
   - Heartbeat mechanism for connection health
   - Automatic reconnection with backoff
   - Connection status monitoring

## Usage Example

```typescript

const wsService = WebSocketService.getInstance();

wsService.onConnectionStatusChange((status) => {
    logger.info(`WebSocket connection status: ${status.connected ? 'Connected' : 'Disconnected'}`);
    if (status.connected && wsService.isReady()) { // Check full readiness
        // This might trigger graphDataManager to request initial data or enable binary updates
        // if it hasn't already due to the adapter pattern.
        graphDataManager.setBinaryUpdatesEnabled(true); // Or similar logic
    } else if (!status.connected) {
        graphDataManager.setBinaryUpdatesEnabled(false);
    }
});

wsService.onMessage((jsonData) => {
    logger.debug('WebSocket JSON message received:', jsonData);
    // Handle JSON messages (e.g., connection_established, loading)
    // This might also be handled by graphDataManager via the adapter.
});

wsService.onBinaryMessage((arrayBuffer) => {
    // Pass the raw ArrayBuffer to graphDataManager, which will handle decompression
    // (if needed, via binaryUtils) and parsing.
    graphDataManager.updateNodePositions(arrayBuffer);
});

wsService.connect().catch(error => {
    logger.error('Failed to connect WebSocket initial attempt:', error);
});

```
The `graphDataManager.updateNodePositions` method expects an `ArrayBuffer` which it will then process (potentially decompressing and then parsing into individual node updates). The call `graphDataManager.setBinaryUpdatesEnabled(true)` is a conceptual representation; the actual mechanism might involve `graphDataManager` sending a specific message via the WebSocket adapter to the server to start the flow of binary updates, or simply setting an internal flag to start processing them if they arrive.

## Related Documentation

- [State Management](state.md) - State management integration
- [Graph Data](graph.md) - Graph data structure and updates
- [Performance](performance.md) - Performance optimization details
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/client/xr.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/client/xr.md
```md
# WebXR Integration

This document details the WebXR integration within the LogseqXR client, enabling immersive virtual and augmented reality experiences. It covers the setup, key components, interaction handling, and how settings affect XR mode.

## Overview

The WebXR integration allows users to explore their knowledge graph in a fully immersive 3D environment using VR headsets or AR-compatible devices. It leverages the `@react-three/xr` library, which provides React components and hooks for building WebXR experiences with React Three Fiber.

## Core XR Setup and Components

The XR functionality is primarily managed within the `client/src/features/xr/` directory.

### `@react-three/xr`

This library is fundamental to the XR integration. It provides:
-   `<XR />` component: The main wrapper to enable WebXR capabilities in an R3F scene.
-   `<Controllers />`, `<Hands />`: Components for rendering and interacting with VR controllers and tracked hands.
-   Hooks like `useXR()`, `useController()`, `useHand()`: For accessing XR session state, controller input, and hand tracking data.

### `XRController.tsx` ([`client/src/features/xr/components/XRController.tsx`](../../client/src/features/xr/components/XRController.tsx))

This component acts as the central orchestrator for the XR experience.

**Responsibilities:**
-   Wraps the main 3D scene with the `<XR />` component from `@react-three/xr`.
-   Manages the conditional rendering of XR-specific UI and interaction elements.
-   Integrates other XR components like [`XRScene.tsx`](../../client/src/features/xr/components/XRScene.tsx) and [`HandInteractionSystem.tsx`](../../client/src/features/xr/systems/HandInteractionSystem.tsx).
-   Handles XR session initialization and teardown logic via [`xrInitializer.ts`](../../client/src/features/xr/managers/xrInitializer.ts) and [`xrSessionManager.ts`](../../client/src/features/xr/managers/xrSessionManager.ts).

### `XRScene.tsx` ([`client/src/features/xr/components/XRScene.tsx`](../../client/src/features/xr/components/XRScene.tsx))

This component contains the 3D content that will be rendered in XR. It often reuses or adapts components from the main 2D desktop visualization.

**Responsibilities:**
-   Renders the graph (nodes, edges) within the XR environment.
-   May include XR-specific UI elements (e.g., floating menus, gaze cursors).
-   Adapts lighting and camera setup for optimal viewing in VR/AR.

### `XRVisualisationConnector.tsx` ([`client/src/features/xr/components/XRVisualisationConnector.tsx`](../../client/src/features/xr/components/XRVisualisationConnector.tsx))

This component acts as a bridge, connecting the core graph visualization logic (e.g., `GraphManager.tsx`) to the XR environment.

**Responsibilities:**
-   Passes graph data and updates to components rendered within `XRScene.tsx`.
-   May transform or adapt data for XR-specific presentation.
-   Ensures that interactions in XR mode correctly affect the underlying graph data.

### `HandInteractionSystem.tsx` ([`client/src/features/xr/systems/HandInteractionSystem.tsx`](../../client/src/features/xr/systems/HandInteractionSystem.tsx))

Manages interactions using tracked hands in WebXR.

**Responsibilities:**
-   Uses `@react-three/xr`'s `<Hands />` component and `useHand()` hook.
-   Detects hand gestures (e.g., pinch, grab) for object manipulation or UI interaction.
-   Provides visual feedback for hand tracking (e.g., rendering hand models or pointers).
-   Translates hand movements and gestures into actions within the application (e.g., selecting nodes, navigating menus).

### `xrInitializer.ts` ([`client/src/features/xr/managers/xrInitializer.ts`](../../client/src/features/xr/managers/xrInitializer.ts))

Contains logic for initializing the WebXR session.

**Responsibilities:**
-   Checks for WebXR browser support.
-   Requests an XR session (e.g., `immersive-vr` or `immersive-ar`).
-   Handles session feature requests (e.g., hand tracking, plane detection).

### `xrSessionManager.ts` ([`client/src/features/xr/managers/xrSessionManager.ts`](../../client/src/features/xr/managers/xrSessionManager.ts))

Manages the lifecycle of an active WebXR session.

**Responsibilities:**
-   Handles session start, end, and visibility change events.
-   Provides access to the current `XRSession` object.
-   Coordinates updates based on session state.

### `SafeXRProvider.tsx` ([`client/src/features/xr/providers/SafeXRProvider.tsx`](../../client/src/features/xr/providers/SafeXRProvider.tsx)) and `XRContextWrapper.tsx` ([`client/src/features/xr/providers/XRContextWrapper.tsx`](../../client/src/features/xr/providers/XRContextWrapper.tsx))

These components provide a React Context for sharing XR-related state and utilities throughout the XR part of the application.

**Responsibilities:**
-   `SafeXRProvider`: Checks for WebXR availability and gracefully handles cases where WebXR is not supported, preventing errors.
-   `XRContextWrapper`: Provides context values like the current XR session, controller states, or hand tracking data to descendant components.

## XR Interaction Handling

Interactions in XR are typically handled through:

-   **VR Controllers:** Using `@react-three/xr`'s `<Controllers />` and `useController()` hook to detect button presses, trigger pulls, and joystick movements. These inputs are then mapped to actions like selection, teleportation, or menu navigation.
-   **Hand Tracking:** Using `<Hands />` and `useHand()` along with `HandInteractionSystem.tsx` to interpret hand gestures (e.g., pinch-to-select, grab-to-move) and hand positions for direct manipulation of objects or UI elements.
-   **Gaze/Focus:** For simpler interactions or as a fallback, gaze-based selection (where the user looks at an object for a short duration to select it) can be implemented.

## Settings Affecting XR Mode

Several settings from the application's `SettingsStore` can influence the XR experience. These are found under the `xr` key in the [`Settings`](../../client/src/features/settings/config/settings.ts) interface, defined in [`client/src/features/settings/config/settings.ts`](../../client/src/features/settings/config/settings.ts).

-   **`xr.enabled`**: A global toggle for enabling/disabling XR mode (often a server-side setting that the client respects).
-   **`xr.clientSideEnableXR`**: A key client-side toggle that allows the user to enable/disable attempting to enter XR mode, independent of the server's `xr.enabled` setting. This is useful for client devices that may not support XR well.
-   **`xr.mode`**: Specifies the desired XR mode (e.g., `'inline'`, `'immersive-vr'`, `'immersive-ar'`).
-   **`xr.quality`**: Adjusts rendering quality for performance in XR.
-   **`xr.enableHandTracking`**: Toggles the use of hand tracking (Note: the setting name is `enableHandTracking`, not `handTracking`).
-   **`xr.handMeshEnabled`**, **`xr.handMeshColor`**: Controls the visual representation of tracked hands.
-   **Locomotion settings** (e.g., `xr.locomotionMethod`, `xr.movementSpeed`): Configure how users move within the virtual environment.
-   **AR-specific settings** (e.g., `xr.enablePlaneDetection`, `xr.passthroughOpacity`): For augmented reality experiences.

These settings are typically accessed within XR components via the `useSettingsStore` hook and applied to configure the `@react-three/xr` components or custom interaction logic.
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/deployment/docker.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/deployment/docker.md
```md
# Docker Deployment

This document describes how to deploy the system using Docker.
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/deployment/index.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/deployment/index.md
```md
# Deployment Documentation

This section contains documentation for deploying the system.

## Deployment Options

- [Docker Deployment](docker.md)
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/index.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/index.md
```md
# Project Documentation

Welcome to the project documentation. This documentation provides comprehensive details about the client and server components of the system.

## Table of Contents

- [API Documentation](api/index.md)
- [Client Documentation](client/index.md)
- [Server Documentation](server/index.md)
- [Deployment](deployment/index.md)
- [Development](development/index.md)
- [Contributing](contributing.md)
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/overview/architecture.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/overview/architecture.md
```md
# Technical Architecture

LogseqXR is built on a robust and scalable architecture that combines a Rust-based backend server with a TypeScript-based frontend client.

## Core System Architecture

The following diagram illustrates the core components of the LogseqXR system and their interactions:

```mermaid
graph TD
    subgraph ClientApp [Frontend (TypeScript, React, R3F)]
        AppInitializer[AppInitializer.tsx] --> UIMain[TwoPaneLayout.tsx]
        UIMain --> GraphViewport[GraphViewport.tsx]
        UIMain --> RightPane[RightPaneControlPanel.tsx]
        UIMain --> ConversationPane[ConversationPane.tsx]
        UIMain --> NarrativeGoldmine[NarrativeGoldminePanel.tsx]
        RightPane --> SettingsPanel[SettingsPanelRedesign.tsx]

        SettingsPanel --> SettingsStore[settingsStore.ts (Zustand)]
        GraphViewport --> RenderingEngine[Rendering Engine (GraphCanvas, GraphManager)]

        DataManager[GraphDataManager.ts] <--> RenderingEngine
        DataManager <--> WebSocketClient[WebSocketService.ts]
        DataManager <--> APIService[api.ts]

        NostrAuthClient[nostrAuthService.ts] <--> APIService
        NostrAuthClient <--> UIMain % For Auth UI sections

        XRModule[XRController.tsx] <--> RenderingEngine
        XRModule <--> SettingsStore
    end

    subgraph ServerApp [Backend (Rust, Actix)]
        ActixServer[Actix Web Server]

        subgraph Handlers [API & WebSocket Handlers]
            direction LR
            SettingsHandler[settings_handler.rs]
            NostrAuthHandler[nostr_handler.rs]
            GraphAPIHandler[api_handler/graph/mod.rs]
            FilesAPIHandler[api_handler/files/mod.rs]
            RAGFlowAPIHandler[ragflow_handler.rs]
            SocketFlowHandler[socket_flow_handler.rs]
            SpeechSocketHandler[speech_socket_handler.rs]
            HealthHandler[health_handler.rs]
        end

        subgraph Services [Core Services]
            direction LR
            GraphService[GraphService (Physics)]
            FileService[FileService]
            NostrService[NostrService]
            SpeechService[SpeechService]
            RAGFlowService[RAGFlowService]
            PerplexityService[PerplexityService]
        end

        subgraph Actors [Actor System]
            direction LR
            GraphServiceActor[GraphServiceActor]
            SettingsActor[SettingsActor]
            MetadataActor[MetadataActor]
            ClientManagerActor[ClientManagerActor]
            GPUComputeActor[GPUComputeActor]
            ProtectedSettingsActor[ProtectedSettingsActor]
        end
        AppState[AppState holds Addr<...>]

        ActixServer --> SettingsHandler
        ActixServer --> NostrAuthHandler
        ActixServer --> GraphAPIHandler
        ActixServer --> FilesAPIHandler
        ActixServer --> RAGFlowAPIHandler
        ActixServer --> SocketFlowHandler
        ActixServer --> SpeechSocketHandler
        ActixServer --> HealthHandler

        SettingsHandler --> SettingsActor
        NostrAuthHandler --> NostrService
        NostrAuthHandler --> ProtectedSettingsActor
        GraphAPIHandler --> GraphServiceActor
        FilesAPIHandler --> FileService
        RAGFlowAPIHandler --> RAGFlowService

        SocketFlowHandler --> ClientManagerActor
        SpeechSocketHandler --> SpeechService

        GraphServiceActor --> ClientManagerActor % Broadcasts updates
        GraphServiceActor --> MetadataActor % Reads metadata
        GraphServiceActor --> GPUComputeActor % Uses GPU for physics
        GraphServiceActor --> SettingsActor % Accesses simulation settings

        FileService --> MetadataActor % Updates metadata

        NostrService --> ProtectedSettingsActor % Manages users and their API keys
        SpeechService --> SettingsActor % Accesses AI service configs (OpenAI, Kokoro)
        RAGFlowService --> SettingsActor % Accesses RAGFlow config
        PerplexityService --> SettingsActor % Accesses Perplexity config

        Handlers --> AppState % Handlers get actor addresses from AppState
    end

    subgraph ExternalServices [External Services]
        GitHubAPI[GitHub API]
        NostrRelays[Nostr Relays]
        OpenAI_API[OpenAI API (TTS, STT/Whisper)]
        PerplexityAI_API[Perplexity AI API]
        RAGFlow_API[RAGFlow API]
        KokoroAPI[Kokoro API (TTS)]
    end

    %% Client to Backend Communication
    WebSocketClient <--> SocketFlowHandler
    APIService <--> ActixServer % Represents REST API calls to various handlers

    %% Backend to External Services
    FileService --> GitHubAPI
    NostrService --> NostrRelays
    SpeechService --> OpenAI_API
    SpeechService --> KokoroAPI
    PerplexityService --> PerplexityAI_API
    RAGFlowService --> RAGFlow_API
```

## Component Breakdown

### Frontend Components (Client - TypeScript, React, R3F)

-   **AppInitializer ([`AppInitializer.tsx`](../../client/src/app/AppInitializer.tsx))**: Initializes core services, settings, and authentication.
-   **UI Layout ([`TwoPaneLayout.tsx`](../../client/src/app/TwoPaneLayout.tsx), [`RightPaneControlPanel.tsx`](../../client/src/app/components/RightPaneControlPanel.tsx))**: Manages the main application layout.
-   **Settings UI ([`SettingsPanelRedesign.tsx`](../../client/src/features/settings/components/panels/SettingsPanelRedesign.tsx))**: Provides the interface for user settings.
-   **Conversation UI ([`ConversationPane.tsx`](../../client/src/app/components/ConversationPane.tsx))**: Interface for AI chat.
-   **Narrative UI ([`NarrativeGoldminePanel.tsx`](../../client/src/app/components/NarrativeGoldminePanel.tsx))**: Interface for narrative exploration.
-   **Rendering Engine ([`GraphCanvas.tsx`](../../client/src/features/graph/components/GraphCanvas.tsx), [`GraphManager.tsx`](../../client/src/features/graph/components/GraphManager.tsx), [`GraphViewport.tsx`](../../client/src/features/graph/components/GraphViewport.tsx))**: Handles 3D graph visualization using React Three Fiber.
-   **State Management**:
    -   [`settingsStore.ts`](../../client/src/store/settingsStore.ts) (Zustand): Manages application settings.
    -   [`GraphDataManager.ts`](../../client/src/features/graph/managers/graphDataManager.ts): Manages graph data, updates, and interaction with WebSocketService.
-   **Communication**:
    -   [`WebSocketService.ts`](../../client/src/services/WebSocketService.ts): Handles real-time communication with the backend via WebSockets.
    -   [`api.ts`](../../client/src/services/api.ts): Handles REST API calls to the backend.
-   **Authentication ([`nostrAuthService.ts`](../../client/src/services/nostrAuthService.ts))**: Manages Nostr-based client-side authentication logic. (Often referred to as NostrAuthClient in diagrams).
-   **XR Module ([`XRController.tsx`](../../client/src/features/xr/components/XRController.tsx) and other components in `client/src/features/xr/`)**: Manages WebXR integration for VR/AR experiences.

### Backend Components (Server - Rust, Actix)

-   **Actix Web Server**: The core HTTP server framework.
-   **Request Handlers**:
    -   [`SocketFlowHandler`](../../src/handlers/socket_flow_handler.rs): Manages WebSocket connections for graph updates.
    -   [`SpeechSocketHandler`](../../src/handlers/speech_socket_handler.rs): Manages WebSocket connections for speech services.
    -   [`NostrAuthHandler`](../../src/handlers/nostr_handler.rs): Handles Nostr authentication requests.
    -   [`SettingsHandler`](../../src/handlers/settings_handler.rs): Manages API requests for user settings.
    -   [`GraphAPIHandler`](../../src/handlers/api_handler/graph/mod.rs): Handles API requests for graph data.
    -   [`FilesAPIHandler`](../../src/handlers/api_handler/files/mod.rs): Handles API requests for file operations.
    -   [`RAGFlowAPIHandler`](../../src/handlers/ragflow_handler.rs): Handles API requests for RAGFlow.
    -   [`HealthHandler`](../../src/handlers/health_handler.rs): Provides health check endpoints.
-   **Core Services**:
    -   [`GraphService`](../../src/services/graph_service.rs): Manages graph data, physics simulation (CPU/GPU), and broadcasts updates. Contains the **PhysicsEngine** logic.
    -   [`FileService`](../../src/services/file_service.rs): Handles file fetching (local, GitHub), processing, and metadata management.
    -   [`NostrService`](../../src/services/nostr_service.rs): Manages Nostr authentication logic, user profiles, and session tokens.
    -   [`SpeechService`](../../src/services/speech_service.rs): Orchestrates STT and TTS functionalities, interacting with external AI providers.
    -   [`RAGFlowService`](../../src/services/ragflow_service.rs): Interacts with the RAGFlow API.
    -   [`PerplexityService`](../../src/services/perplexity_service.rs): Interacts with the Perplexity AI API.
-   **Shared State & Utilities**:
    -   [`AppState`](../../src/app_state.rs): Holds shared application state like settings and references to some services.
    -   [`ProtectedSettings`](../../src/models/protected_settings.rs): Manages sensitive configurations like API keys and user data, stored separately.
    -   [`MetadataStore`](../../src/models/metadata.rs): In-memory store for file/node metadata, managed by `FileService` and read by `GraphService`.
    -   [`ClientManager`](../../src/handlers/socket_flow_handler.rs): (Often part of `socket_flow_handler` or a static utility) Manages active WebSocket clients for broadcasting.
    -   [`GPUCompute`](../../src/utils/gpu_compute.rs): Optional utility for CUDA-accelerated physics calculations.

### External Services

- **GitHub API**: Provides access to the GitHub API for fetching and updating files.
- **Perplexity AI**: Provides AI-powered question answering and content analysis.
- **RagFlow API**: Provides AI-powered conversational capabilities.
- **OpenAI API**: Provides text-to-speech functionality.
- **Nostr API**: Provides decentralized authentication and user management.

For more detailed technical information, please refer to:
- [Binary Protocol](../technical/binary-protocol.md)
- [Decoupled Graph Architecture](../technical/decoupled-graph-architecture.md)
- [Performance Optimizations](../technical/performance.md)
- [Class Diagrams](../technical/class-diagrams.md)
- [WebSockets Implementation](../api/websocket-updated.md)
- [Graph Node Stacking Fix](../technical/graph-node-stacking-fix.md)

## Server Architecture

The server now uses a continuous physics simulation system that pre-computes node positions independent of client connections. When clients connect, they receive the complete graph state and any ongoing updates. This architecture enables bidirectional synchronization of graph state between all connected clients.
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docs/technical/decoupled-graph-architecture.md
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docs/technical/decoupled-graph-architecture.md
```md
# Decoupled Graph Architecture

## Overview

The LogseqXR graph architecture has been modernized to decouple graph initialization and physics processing from client connections. This document outlines the new architecture and explains the key components and their interactions.

## Architecture Components

### Server-Side Components

-   **GraphService ([`src/services/graph_service.rs`](../../src/services/graph_service.rs))**: Continuously maintains the force-directed graph (nodes, edges, positions) independently of client connections. It runs the physics simulation.
-   **ClientManager** (typically part of or used by [`src/handlers/socket_flow_handler.rs`](../../src/handlers/socket_flow_handler.rs)): A static instance that tracks all connected WebSocket clients and handles broadcasting updates received from `GraphService`.
-   **Force-Directed Physics**: Pre-computes node positioning with server-side physics processing within `GraphService`.
-   **WebSocket Handler ([`src/handlers/socket_flow_handler.rs`](../../src/handlers/socket_flow_handler.rs))**: Manages WebSocket connections, client registration with `ClientManager`, and message relay.

### Client-Side Components

-   **WebSocketService ([`client/src/services/WebSocketService.ts`](../../client/src/services/WebSocketService.ts))**: Handles WebSocket communication with the server.
-   **GraphDataManager ([`client/src/features/graph/managers/graphDataManager.ts`](../../client/src/features/graph/managers/graphDataManager.ts))**: Manages client-side graph data, processes incoming node position updates from `WebSocketService`, and can send user interactions (like node drags) back to the server. (This component effectively acts as the "NodeManager" in this context).
-   **GraphRenderer (Components like [`GraphManager.tsx`](../../client/src/features/graph/components/GraphManager.tsx) and [`GraphCanvas.tsx`](../../client/src/features/graph/components/GraphCanvas.tsx))**: Visualizes the graph using data from `GraphDataManager`, updating node positions as they are received.

## Key Architectural Improvements

### 1. Independent Graph Initialization

The graph is now initialized once at server startup, regardless of client connections. Key benefits:

- Reduced resource utilization by avoiding redundant graph creation
- Consistent graph state across all clients
- Immediate graph availability for new client connections

```mermaid
sequenceDiagram
    participant Server
    participant GraphService
    participant Client

    Server->>GraphService: Initialize on startup
    GraphService->>GraphService: Pre-compute node positions
    GraphService->>GraphService: Continuously update physics

    Client->>Server: Connect via WebSocket
    Server->>Client: Send pre-computed graph state
    GraphService-->>Client: Stream position updates
```

### 2. Continuous Force-Directed Layout

The server now maintains a continuous physics simulation:

- Graph nodes find optimal positions before any client connects
- Reduced initial loading time for clients as layout is pre-calculated
- Physics simulation stabilizes over time, creating a more balanced visualisation

### 3. Bidirectional Synchronization

The new architecture supports true bidirectional updates:

- Server broadcasts position updates to all connected clients
- Any client can update node positions (e.g., during user interaction)
- All changes are synchronized across all clients in real-time
- Server maintains position authority for consistency

```mermaid
sequenceDiagram
    participant ClientA
    participant Server
    participant ClientB

    ClientA->>Server: Move node position
    Server->>Server: Apply to graph model
    Server->>ClientA: Confirm position update
    Server->>ClientB: Broadcast position update
```

### 4. Optimized Data Transfer

The system includes several optimizations:

- Selective updates: Only nodes that change significantly trigger updates
- Position deadbanding: Filters out minor position changes
- Automatic compression for larger messages
- Dynamic update rate based on graph activity level

## Implementation Details

### Server-Side Physics Processing

The server uses a hybrid approach to physics processing:

1.  GPU-accelerated computing when available, primarily via CUDA, managed by [`src/utils/gpu_compute.rs`](../../src/utils/gpu_compute.rs). WebGPU is not the primary target for server-side GPU compute in this context.
2.  CPU fallback for physics calculations within `GraphService::calculate_layout_cpu` if GPU is not available or disabled.
3.  Physics parameters (from `AppFullSettings.visualisation.physics` and `SimulationParams`) are tuned for stability and performance.

### Client Connection Lifecycle

When a client connects:
1. The server sends the complete, settled graph state (metadata, node positions, edge data)
2. The client renders the initial state
3. The server begins streaming position updates
4. The client can send position updates to the server
5. The server broadcasts these changes to all other clients

## Performance Benefits

- **Reduced CPU/GPU usage**: Physics calculations shared across all clients
- **Lower bandwidth usage**: Only changed positions are transmitted
- **Faster initialization**: Clients receive pre-computed positions
- **Better scalability**: Multiple clients supported with minimal additional resource usage

## Future Improvements

- Real-time collaborative editing of graph content
- Conflict resolution for simultaneous node edits
- Region-based updates for very large graphs
- Client-specific view customizations
```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: scripts/dev.sh
full_filepath: /mnt/mldata/githubs/logseqSpringThing/scripts/dev.sh
```sh
#!/bin/bash
set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Get the absolute path of the script's directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Global variables
DOCKER_COMPOSE_FILE="$PROJECT_ROOT/docker-compose.dev.yml"
CONTAINER_NAME="logseq_spring_thing_webxr"
PROJECT_IDENTIFIER="logseq_spring_thing_dev"  # Unique identifier for our project's processes

log() {
    echo -e "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# Cleanup function
cleanup() {
    log "${YELLOW}Cleaning up development environment...${NC}"

    # Stop Docker containers
    if docker ps -q -f name=$CONTAINER_NAME > /dev/null; then
        log "${YELLOW}Stopping Docker containers...${NC}"
        cd "$PROJECT_ROOT" && docker compose -f $DOCKER_COMPOSE_FILE stop # Changed 'down' to 'stop' to prevent container removal
    fi

    # Host process cleanup removed as Node/Vite run inside the container

    log "${GREEN}Cleanup complete${NC}"
}

# Trap signals
trap cleanup SIGINT SIGTERM EXIT

# Setup function removed as dependencies are installed during Docker build
# Start development servers
start_dev() {
    log "${YELLOW}Starting development servers...${NC}"

    # Build and start containers with updated configuration
    log "${YELLOW}Starting Docker containers...${NC}"
    cd "$PROJECT_ROOT" && DOCKER_BUILDKIT=1 docker compose -f $DOCKER_COMPOSE_FILE up --build
}

# Main execution
cleanup  # Clean up any existing processes first
# setup_dev call removed
start_dev

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: scripts/launch-production.sh
full_filepath: /mnt/mldata/githubs/logseqSpringThing/scripts/launch-production.sh
```sh
#!/usr/bin/env bash

###############################################################################
# PRODUCTION DEPLOYMENT SCRIPT
###############################################################################
# This script builds and deploys the application in production mode.
# Key differences from development mode:
# - No volume mounts for client code (static build included in container)
# - Production optimized builds
# - Cloudflared for secure WebSocket connections
# - Proper routing through Nginx
# - GPU acceleration configured for production use
###############################################################################

###############################################################################
# SAFETY SETTINGS
###############################################################################
# -e  Exit on any command returning a non-zero status
# -u  Treat unset variables as errors
# -o pipefail  Return error if any part of a pipeline fails
set -euo pipefail

###############################################################################
# DETECT SCRIPT & PROJECT ROOT
###############################################################################
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$( cd "$SCRIPT_DIR/.." && pwd )"

###############################################################################
# COLOR CONSTANTS
###############################################################################
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'  # No color

###############################################################################
# CONFIGURATION
###############################################################################
# Container names for easier management
WEBXR_CONTAINER="logseq-spring-thing-webxr"
CLOUDFLARED_CONTAINER="cloudflared-tunnel"

# Docker compose file for production
DOCKER_COMPOSE_FILE="docker-compose.production.yml"

# Default CUDA architecture if not specified in .env
DEFAULT_CUDA_ARCH="89"  # Ada Lovelace architecture

###############################################################################
# LOGGING & EXIT HANDLING
###############################################################################
log() {
    # Logs a message with a timestamp
    echo -e "[$(date "+%Y-%m-%d %H:%M:%S")] $1"
}

section() {
    # Prints a section header
    echo -e "\n${BLUE}=== $1 ===${NC}"
}

handle_exit() {
    # Called when the script receives a signal (Ctrl+C, kill, etc.)
    log "\n${YELLOW}Exiting to shell. Containers will continue running.${NC}"
    log "${YELLOW}Use 'docker compose down' to stop containers if needed.${NC}"
    exit 0
}

# Trap Ctrl+C, kill, etc. so we can exit gracefully
trap handle_exit INT TERM

###############################################################################
# UTILITY FUNCTIONS
###############################################################################

# Determine Docker Compose command (v1 or v2)
get_docker_compose_cmd() {
    if docker compose version &>/dev/null; then
        echo "docker compose"
    elif docker-compose version &>/dev/null; then
        echo "docker-compose"
    else
        log "${RED}Error: Docker Compose not found${NC}"
        exit 1
    fi
}

# Check if a command exists
command_exists() {
    command -v "$1" &> /dev/null
}

###############################################################################
# VALIDATION FUNCTIONS
###############################################################################

check_dependencies() {
    section "Checking Dependencies"

    # Check Docker
    if ! command_exists docker; then
        log "${RED}Error: Docker is not installed${NC}"
        return 1
    fi
    log "${GREEN}✓ Docker is installed${NC}"

    # Check Docker Compose
    if ! command_exists docker-compose && ! docker compose version &>/dev/null; then
        log "${RED}Error: Docker Compose not found${NC}"
        return 1
    fi
    log "${GREEN}✓ Docker Compose is installed${NC}"

    # Check NVIDIA tools for GPU support
    if ! command_exists nvidia-smi; then
        log "${YELLOW}Warning: nvidia-smi not found. GPU acceleration may not work.${NC}"
    else
        log "${GREEN}✓ NVIDIA drivers are installed${NC}"
    fi

    # Check CUDA compiler for PTX generation
    if ! command_exists nvcc; then
        log "${YELLOW}Warning: NVIDIA CUDA Compiler (nvcc) not found${NC}"
        log "${YELLOW}Will attempt to use pre-compiled PTX file if available${NC}"
    else
        log "${GREEN}✓ CUDA toolkit is installed${NC}"
    fi

    return 0
}

check_environment_file() {
    section "Checking Environment Configuration"

    # Check if .env file exists
    if [ ! -f "$PROJECT_ROOT/.env" ]; then
        log "${RED}Error: .env file not found in $PROJECT_ROOT${NC}"
        log "${YELLOW}Please create a .env file based on .env.template${NC}"
        return 1
    fi
    log "${GREEN}✓ .env file exists${NC}"

    # Check if settings.yaml exists
    if [ ! -f "$PROJECT_ROOT/data/settings.yaml" ]; then
        log "${RED}Error: settings.yaml not found in $PROJECT_ROOT/data${NC}"
        log "${YELLOW}Please create a settings.yaml file${NC}"
        return 1
    fi
    log "${GREEN}✓ settings.yaml file exists${NC}"

    return 0
}

check_gpu_availability() {
    section "Checking GPU Availability"

    if ! command_exists nvidia-smi; then
        log "${YELLOW}Warning: Cannot check GPU availability (nvidia-smi not found)${NC}"
        return 0
    fi

    # Check if GPU is available
    # Check if nvidia-smi command runs successfully.
    # It might return non-zero even if GPUs exist but are busy/inaccessible temporarily.
    if ! nvidia-smi > /dev/null 2>&1; then
        log "${YELLOW}Warning: nvidia-smi command failed or no NVIDIA GPU detected by it.${NC}"
        log "${YELLOW}GPU acceleration features might be unavailable. Script will continue.${NC}"
        # Allow script to continue, but log the warning. Return 0 as it's non-fatal for the script logic.
        return 0
    fi

    # Get GPU info
    log "${YELLOW}GPU Information:${NC}"
    nvidia-smi --query-gpu=name,memory.total,memory.used,memory.free --format=csv,noheader

    # Check if GPU has enough memory (at least 2GB free)
    local gpu_info
    gpu_info=$(nvidia-smi --query-gpu=memory.free --format=csv,noheader)
    local free_memory
    free_memory=$(echo "$gpu_info" | head -n1 | grep -o '[0-9]\+')

    if [ "$free_memory" -lt 2048 ]; then
        log "${YELLOW}Warning: Less than 2GB of GPU memory available (${free_memory} MiB)${NC}"
        log "${YELLOW}Performance may be degraded${NC}"
    else
        log "${GREEN}✓ Sufficient GPU memory available (${free_memory} MiB)${NC}"
    fi

    return 0
}

check_ragflow_network() {
    section "Checking RAGFlow Network"

    if ! docker network ls | grep -q "docker_ragflow"; then
        log "${YELLOW}RAGFlow network not found, creating it...${NC}"
        docker network create docker_ragflow
        log "${GREEN}✓ Created docker_ragflow network${NC}"
    else
        log "${GREEN}✓ RAGFlow network exists${NC}"
    fi

    return 0
}

###############################################################################
# BUILD FUNCTIONS
###############################################################################

check_ptx_status() {
    section "Checking PTX Status"

    # Check if PTX file exists
    if [ -f "$PROJECT_ROOT/src/utils/compute_forces.ptx" ]; then
        log "${GREEN}✓ PTX file exists${NC}"

        # Check if source CUDA file exists
        if [ -f "$PROJECT_ROOT/src/utils/compute_forces.cu" ]; then
            # Check if PTX is older than CUDA source
            if [ "$PROJECT_ROOT/src/utils/compute_forces.ptx" -ot "$PROJECT_ROOT/src/utils/compute_forces.cu" ]; then
                log "${YELLOW}PTX file is older than CUDA source${NC}"
                log "${YELLOW}PTX will be compiled during Docker build${NC}"
                # Set flag to force PTX compilation in Docker
                export REBUILD_PTX=true
            else
                log "${GREEN}✓ PTX file is up-to-date${NC}"
            fi
        fi
    else
        log "${YELLOW}PTX file not found${NC}"
        log "${YELLOW}PTX will be compiled during Docker build${NC}"
        # Set flag to force PTX compilation in Docker
        export REBUILD_PTX=true
    fi

    return 0
}

# build_client function removed as client is built inside Dockerfile.production
build_docker_images() {
    section "Building Docker Images"

    # Get Docker Compose command
    DOCKER_COMPOSE=$(get_docker_compose_cmd)

    # Set build arguments
    export NVIDIA_GPU_UUID=${NVIDIA_GPU_UUID:-"GPU-553dc306-dab3-32e2-c69b-28175a6f4da6"}
    export NVIDIA_VISIBLE_DEVICES=${NVIDIA_VISIBLE_DEVICES:-$NVIDIA_GPU_UUID}
    export GIT_HASH=$(git rev-parse HEAD 2>/dev/null || echo "production")
    export NODE_ENV=production
    export REBUILD_PTX=${REBUILD_PTX:-false}

    log "${YELLOW}Building Docker images with:${NC}"
    log "  - NVIDIA_GPU_UUID: $NVIDIA_GPU_UUID"
    log "  - GIT_HASH: $GIT_HASH"
    log "  - REBUILD_PTX: $REBUILD_PTX"

    # Build Docker images
    # Relying on exported variables from earlier 'source .env'
    $DOCKER_COMPOSE -f "$PROJECT_ROOT/$DOCKER_COMPOSE_FILE" build --no-cache

    log "${GREEN}✓ Docker images built successfully${NC}"

    return 0
}

###############################################################################
# DEPLOYMENT FUNCTIONS
###############################################################################

clean_existing_containers() {
    section "Cleaning Existing Containers"

    # Get Docker Compose command
    DOCKER_COMPOSE=$(get_docker_compose_cmd)

    # Stop and remove existing containers
    log "${YELLOW}Stopping and removing existing containers...${NC}"

    # Check if containers exist
    if docker ps -a --format '{{.Names}}' | grep -q "$WEBXR_CONTAINER"; then
        log "${YELLOW}Stopping and removing $WEBXR_CONTAINER...${NC}"
        docker stop "$WEBXR_CONTAINER" 2>/dev/null || true
        docker rm "$WEBXR_CONTAINER" 2>/dev/null || true
    fi

    if docker ps -a --format '{{.Names}}' | grep -q "$CLOUDFLARED_CONTAINER"; then
        log "${YELLOW}Stopping and removing $CLOUDFLARED_CONTAINER...${NC}"
        docker stop "$CLOUDFLARED_CONTAINER" 2>/dev/null || true
        docker rm "$CLOUDFLARED_CONTAINER" 2>/dev/null || true
    fi

    # Down any existing compose setup
    # More thorough cleanup: remove orphans and volumes associated with the compose file
    $DOCKER_COMPOSE -f "$PROJECT_ROOT/$DOCKER_COMPOSE_FILE" down --remove-orphans --volumes 2>/dev/null || true

    log "${GREEN}✓ Cleanup complete${NC}"

    return 0
}

start_containers() {
    section "Starting Containers"

    # Get Docker Compose command
    DOCKER_COMPOSE=$(get_docker_compose_cmd)

    # Start containers
    log "${YELLOW}Starting containers...${NC}"
    # Let Docker Compose load the .env file automatically
    $DOCKER_COMPOSE -f "$PROJECT_ROOT/$DOCKER_COMPOSE_FILE" up -d

    log "${GREEN}✓ Containers started${NC}"

    return 0
}

check_application_readiness() {
    section "Checking Application Readiness"

    local max_attempts=60
    local attempt=1
    local wait_secs=2

    log "${YELLOW}Waiting for application to be ready...${NC}"

    while [ "$attempt" -le "$max_attempts" ]; do
        # Check if containers are running
        if ! docker ps --format '{{.Names}}' | grep -q "$WEBXR_CONTAINER"; then
            log "${YELLOW}Attempt $attempt/$max_attempts: Container not running${NC}"
            sleep "$wait_secs"
            attempt=$((attempt + 1))
            continue
        fi

        # Check if HTTP endpoint is accessible
        if ! curl -s http://localhost:4000/health >/dev/null; then
            log "${YELLOW}Attempt $attempt/$max_attempts: HTTP endpoint not ready${NC}"
            sleep "$wait_secs"
            attempt=$((attempt + 1))
            continue
        fi

        # All checks passed
        log "${GREEN}✓ Application is ready${NC}"
        return 0
    done

    log "${RED}Error: Application failed to start properly${NC}"
    return 1
}

###############################################################################
# MAIN EXECUTION
###############################################################################

main() {
    section "Starting Production Deployment"

    # Change to project root
    cd "$PROJECT_ROOT"

    # Docker Compose will automatically load .env from the project root
    if [ ! -f .env ]; then
        log "${YELLOW}Warning: .env file not found in project root. CLOUDFLARE_TUNNEL_TOKEN and other variables may be missing.${NC}"
    fi

    # Run validation checks
    check_dependencies || exit 1
    check_environment_file || exit 1
    check_gpu_availability || true  # Non-fatal
    check_ragflow_network || exit 1

    # Build steps
    check_ptx_status || true  # Non-fatal, just sets flags
    # build_client call removed
    clean_existing_containers || exit 1
    build_docker_images || exit 1

    # Deployment
    start_containers || exit 1
    check_application_readiness || exit 1

    # Final status
    section "Deployment Complete"
    log "${GREEN}🚀 Application is running in production mode!${NC}"

    # Show resource usage
    log "\n${YELLOW}Resource Usage:${NC}"
    docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"

    # Show endpoints
    log "\n${YELLOW}Endpoints:${NC}"
    echo "HTTP:      http://localhost:4000"
    echo "WebSocket: wss://localhost:4000/wss"

    # Show useful commands
    log "\n${YELLOW}Useful Commands:${NC}"
    DOCKER_COMPOSE=$(get_docker_compose_cmd)
    echo "View logs:    $DOCKER_COMPOSE -f $DOCKER_COMPOSE_FILE logs -f"
    echo "Stop:         $DOCKER_COMPOSE -f $DOCKER_COMPOSE_FILE down"
    echo "Restart:      $DOCKER_COMPOSE -f $DOCKER_COMPOSE_FILE restart"

    # Show logs
    log "\n${YELLOW}Showing logs (Ctrl+C to exit)...${NC}"
    $DOCKER_COMPOSE -f "$DOCKER_COMPOSE_FILE" logs -f &

    wait
}

# Execute main function
main

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: data/settings.yaml
full_filepath: /mnt/mldata/githubs/logseqSpringThing/data/settings.yaml
```yaml
visualisation:
  nodes:
    base_color: '#66d9ef'
    metalness: 0.63
    opacity: 0.65
    roughness: 0.73
    node_size: 0.02
    quality: 'medium'
    enable_instancing: false
    enable_hologram: false
    enable_metadata_shape: false
    enable_metadata_visualisation: true
    size_range:
      - 0.01
      - 0.15
    color: '#ff4500'
    highlight_color: '#ffff00'
    outline_width: 0.1
    outline_color: '#ffffff'
    selected_color: '#00ff00'
  edges:
    arrow_size: 0.02
    base_width: 0.1
    color: '#56b6c2'
    enable_arrows: false
    opacity: 0.25
    width_range:
      - 0.1
      - 1.0
    quality: 'medium'
    enable_flow_effect: true
    flow_speed: 1
    flow_intensity: 0.6
    glow_strength: 1
    distance_intensity: 1
    use_gradient: true
    gradient_colors:
      - '#ffffff'
      - '#000000'
    width: 1
    highlight_color: '#ffff00'
    show_labels: false
    dash_size: 3
    gap_size: 1
  physics:
    attraction_strength: 0.05
    bounds_size: 15.0
    collision_radius: 0.5
    damping: 0.95
    enable_bounds: true
    enabled: true
    iterations: 100
    max_velocity: 0.02
    repulsion_strength: 0.1
    spring_strength: 0.2
    repulsion_distance: 2.0
    mass_scale: 1.0
    boundary_damping: 0.95
    gravity: 0
    friction: 0.9
    attraction: 0.5
    spring_length: 30
  rendering:
    ambient_light_intensity: 0.8
    background_color: '#181c28'
    directional_light_intensity: 0.7
    enable_ambient_occlusion: false
    enable_antialiasing: false
    enable_shadows: false
    environment_intensity: 0.7
    shadow_map_size: '2048'
    shadow_bias: 0.0001
    context: 'desktop'
    pixel_ratio: 1.5
    enable_bloom: true
    bloom_strength: 1.5
    bloom_threshold: 0.4
    bloom_radius: 0.85
  animations:
    enable_motion_blur: false
    enable_node_animations: false
    motion_blur_strength: 0.2
    selection_wave_enabled: false
    pulse_enabled: false
    pulse_speed: 0.8
    pulse_strength: 0.6
    wave_speed: 0.5
  labels:
    desktop_font_size: 0.15
    enable_labels: true # Note: JSON also has 'enabled: true', this one is more specific
    text_color: '#f8f8f2'
    text_outline_color: '#181c28'
    text_outline_width: 0.01
    text_resolution: 32
    text_padding: 0.3
    billboard_mode: 'camera'
    enabled: true # General enabled flag for labels
  bloom: # This is for visualisation.bloom specific settings
    edge_bloom_strength: 0.4
    enabled: true # This is visualisation.bloom.enabled
    environment_bloom_strength: 2.0
    node_bloom_strength: 3.0
    radius: 0.4
    strength: 1.77
    threshold: 0.06
  hologram:
    ring_count: 1
    ring_color: '#c2a200'
    ring_opacity: 0.001
    sphere_sizes:
      - 4
      - 8
    ring_rotation_speed: 10.0
    enable_buckminster: false
    buckminster_size: 10
    buckminster_opacity: 0.05
    enable_geodesic: false
    geodesic_size: 10
    geodesic_opacity: 0.05
    enable_triangle_sphere: false
    triangle_sphere_size: 10
    triangle_sphere_opacity: 0.05
    global_rotation_speed: 3.0
    color: 65535
    opacity: 0.7
  camera:
    fov: 75
    near: 0.1
    far: 2000
    position:
      x: 0
      y: 10
      z: 50
    look_at:
      x: 0
      y: 0
      z: 0
  scene_background: 0
  icons:
    enabled: true
    size: 1
    opacity: 0.8
    color: '#ffffff'
  metrics:
    enabled: false
    refresh_rate: 1000
    position: 'top-right'
  show_stats: false
  show_axes: false
  show_grid: false
system:
  network:
    bind_address: 0.0.0.0
    domain: visionflow.info
    enable_http2: false
    enable_rate_limiting: false
    enable_tls: false
    max_request_size: 10485760
    min_tls_version: ''
    port: 3001 # Changed from 4000 to avoid conflict with Nginx
    rate_limit_requests: 10000
    rate_limit_window: 600
    tunnel_id: dummy
    api_client_timeout: 30
    enable_metrics: false
    max_concurrent_requests: 1
    max_retries: 3
    metrics_port: 9090
    retry_delay: 5
  websocket:
    binary_chunk_size: 2048
    binary_update_rate: 30
    # Dynamic update rate parameters
    min_update_rate: 5
    max_update_rate: 60
    motion_threshold: 0.05
    motion_damping: 0.9
    binary_message_version: 1
    compression_enabled: false
    compression_threshold: 512
    heartbeat_interval: 10000
    heartbeat_timeout: 600000
    max_connections: 100
    max_message_size: 10485760
    reconnect_attempts: 5
    reconnect_delay: 1000
    update_rate: 60
  security:
    allowed_origins:
    - https://www.visionflow.info
    - https://visionflow.info
    audit_log_path: /app/logs/audit.log
    cookie_httponly: true
    cookie_samesite: Strict
    cookie_secure: true
    csrf_token_timeout: 3600
    enable_audit_logging: false
    enable_request_validation: false
    session_timeout: 3600
  debug:
    enabled: false
    enable_data_debug: false
    enable_websocket_debug: false
    log_binary_headers: false
    log_full_json: false
    log_level: warn
    log_format: json
xr:
  mode: inline
  room_scale: 1.0
  space_type: local-floor
  quality: medium
  enable_hand_tracking: true
  hand_mesh_enabled: true
  hand_mesh_color: '#4287f5'
  hand_mesh_opacity: 0.3
  hand_point_size: 0.006
  hand_ray_enabled: true
  hand_ray_color: '#4287f5'
  hand_ray_width: 0.003
  gesture_smoothing: 0.7
  enable_haptics: true
  haptic_intensity: 0.3
  drag_threshold: 0.08
  pinch_threshold: 0.3
  rotation_threshold: 0.08
  interaction_radius: 0.15
  movement_speed: 0.08
  dead_zone: 0.12
  movement_axes:
    horizontal: 2
    vertical: 3
  enable_light_estimation: false
  enable_plane_detection: false
  enable_scene_understanding: false
  plane_color: '#4287f5'
  plane_opacity: 0.001
  plane_detection_distance: 3.0
  show_plane_overlay: false
  snap_to_floor: false
  enable_passthrough_portal: false
  passthrough_opacity: 0.8
  passthrough_brightness: 1.1
  passthrough_contrast: 1.2
  portal_size: 2.5
  portal_edge_color: '#4287f5'
  portal_edge_width: 0.02
auth:
  enabled: false
  provider: ""
  required: false
ragflow:
  # api_key: SET_VIA_ENV_VARIABLE # Must be set via RAGFLOW_API_KEY environment variable
  agent_id: 'aa2e328812ef11f083dc0a0d6226f61b'
  # api_base_url: SET_VIA_ENV_VARIABLE # Must be set via RAGFLOW_API_BASE_URL environment variable
  timeout: 30
  max_retries: 3
  chat_id: ''
perplexity:
  api_key: ''
  model: llama-3.1-sonar-small-128k-online
  api_url: ''
  max_tokens: 4096
  temperature: 0.5
  top_p: 0.9
  presence_penalty: 0.0
  frequency_penalty: 0.0
  timeout: 30
  rate_limit: 100
openai:
  api_key: ''
  base_url: ''
  timeout: 30
  rate_limit: 100
kokoro:
  api_url: 'http://recursing_bhaskara:8880'
  default_voice: 'af_heart'
  default_format: 'mp3'
  default_speed: 1.0
  timeout: 30
  stream: true
  return_timestamps: true
  sample_rate: 24000
whisper:
  api_url: "http://whisper-webui-backend:8000" # Base URL for the Whisper WebUI backend API
  # model_size: "large-v2" # Optional: Default model size to use for transcriptions
  # lang: "en"             # Optional: Default language for transcriptions

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: Cargo.toml
full_filepath: /mnt/mldata/githubs/logseqSpringThing/Cargo.toml
```toml
[package]
name = "webxr"
version = "0.1.0"
edition = "2021"
description = "A WebXR graph visualisation server with GPU-accelerated physics"
authors = ["Your Name <your.email@example.com>"]

[dependencies]
# Web framework and WebSocket
actix-web = { version = "=4.5.1", features = ["compress-gzip", "compress-zstd", "macros"] }
actix-cors = "=0.7.0"
actix-files = "=0.6.5"
actix = "=0.13.1"
actix-web-actors = "=4.3.0"
tungstenite = "0.22"
tokio-tungstenite = { version = "0.22" }

# Async runtime
tokio = { version = "1.43", features = ["full"] }
futures = "0.3"
futures-util = "0.3"
async-trait = "0.1.86"

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
serde_yaml = "0.9"

# Configuration
config = { version = "0.13", features = ["toml"] }
dotenvy = "0.15"
toml = "0.8"

# Logging
log = "0.4"
simplelog = "0.12"

# Error handling
thiserror = "1.0"
anyhow = "1.0"

# GPU/Compute
bytemuck = { version = "1.21", features = ["derive"] }
pollster = "0.3"
cudarc = { version = "0.11", features = ["driver", "cuda-12040"] }

# HTTP client and API
reqwest = { version = "0.11", features = ["json", "stream"] }
async-openai = "0.14.3"
# Even though backoff is unmaintained (RUSTSEC-2025-0012), we'll use the latest version
# since it's used transitively by async-openai and our code doesn't directly import it
backoff = { version = "0.4.0", features = ["tokio"] }
nostr-sdk = "0.26"

# Utilities
uuid = { version = "1.12", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
static_assertions = "1.1"
base64 = "0.22"
rand = "0.8"
regex = "1.11"
lazy_static = "1.5"
once_cell = "1.19"
sha1 = "0.10.6"
scopeguard = "1.2"
url = "2.5.0"
flate2 = "1.0"
bytes = "1.5"
byteorder = "1.5"
urlencoding = "2.1"

# Math/Linear Algebra (needed for GPU compute)
nalgebra = "0.32"

# Added from the code block
glam = "0.24"

[dev-dependencies]
tokio-test = "0.4"
mockall = "0.11"
pretty_assertions = "1.4"

[features]
default = ["gpu"]
gpu = ["cudarc/driver"]  # Enable GPU support with CUDA driver
cpu = []  # CPU-only mode

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
panic = "abort"
strip = true

[profile.dev]
opt-level = 1

[package.metadata.rust-version]
min = "1.70.0"


```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: Dockerfile
full_filepath: /mnt/mldata/githubs/logseqSpringThing/Dockerfile
```
# Stage 1: Frontend Build
FROM node:20-slim AS frontend-builder

WORKDIR /app/client

# Copy package files
COPY client/package.json client/package-lock.json ./

# Clean install dependencies
RUN npm ci

# Copy source files and config
COPY client/src ./src
COPY client/index.html ./index.html
COPY client/vite.config.ts ./vite.config.ts
COPY client/tsconfig.json ./tsconfig.json

# Create dist directory
RUN mkdir -p ../data/public/dist

# Build frontend
ENV NODE_ENV=production
RUN npm run build

# Move the build output to the expected location
RUN mv dist/* ../data/public/dist/

# Stage 2: Rust Dependencies Cache
FROM nvidia/cuda:12.8.1-devel-ubuntu22.04 AS rust-deps-builder

# Install build dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    curl \
    libssl-dev \
    pkg-config \
    libegl1-mesa-dev \
    libasound2-dev \
    ca-certificates \
    jq \
    && rm -rf /var/lib/apt/lists/*

# Install Rust with better error handling
RUN curl --retry 5 --retry-delay 2 --retry-connrefused https://sh.rustup.rs -sSf | sh -s -- -y --default-toolchain 1.82.0
ENV PATH="/root/.cargo/bin:${PATH}"

# Configure cargo for better network resilience
RUN mkdir -p ~/.cargo && \
    echo '[source.crates-io]' >> ~/.cargo/config.toml && \
    echo 'registry = "https://github.com/rust-lang/crates.io-index"' >> ~/.cargo/config.toml && \
    echo 'replace-with = "ustc"' >> ~/.cargo/config.toml && \
    echo '[source.ustc]' >> ~/.cargo/config.toml && \
    echo 'registry = "sparse+https://mirrors.ustc.edu.cn/crates.io-index/"' >> ~/.cargo/config.toml && \
    echo '[net]' >> ~/.cargo/config.toml && \
    echo 'retry = 10' >> ~/.cargo/config.toml && \
    echo 'timeout = 120' >> ~/.cargo/config.toml && \
    echo 'git-fetch-with-cli = true' >> ~/.cargo/config.toml

WORKDIR /usr/src/app

# Copy Cargo files first for better layer caching
COPY Cargo.toml Cargo.lock ./

# Install git and set GIT_HASH
RUN apt-get update && apt-get install -y git && rm -rf /var/lib/apt/lists/*

# Create dummy src directory and build dependencies
RUN mkdir src && \
    echo "fn main() {}" > src/main.rs && \
    GIT_HASH=$(git rev-parse HEAD || echo "development") \
    CARGO_NET_GIT_FETCH_WITH_CLI=true \
    CARGO_HTTP_TIMEOUT=120 \
    CARGO_HTTP_CHECK_REVOKE=false \
    cargo build --release --features gpu --jobs $(nproc) || \
    (sleep 2 && GIT_HASH=$(git rev-parse HEAD || echo "development") CARGO_HTTP_MULTIPLEXING=false cargo build --release --jobs $(nproc)) || \
    (sleep 5 && GIT_HASH=$(git rev-parse HEAD || echo "development") CARGO_HTTP_MULTIPLEXING=false cargo build --release --jobs 1)

# Copy the real source code and build
COPY src ./src

RUN GIT_HASH=$(git rev-parse HEAD || echo "development") \
    cargo build --release --features gpu --jobs $(nproc) || \
    (sleep 2 && GIT_HASH=$(git rev-parse HEAD || echo "development") cargo build --release --jobs $(nproc)) || \
    (sleep 5 && GIT_HASH=$(git rev-parse HEAD || echo "development") cargo build --release --jobs 1)

# Stage 3: Final Runtime Image
FROM nvidia/cuda:12.8.1-devel-ubuntu22.04

ENV DEBIAN_FRONTEND=noninteractive \
    PYTHONUNBUFFERED=1 \
    PATH="/app/venv/bin:${PATH}" \
    NVIDIA_DRIVER_CAPABILITIES=all \
    RUST_LOG=off \
    RUST_BACKTRACE=0 \
    PORT=4000 \
    BIND_ADDRESS=0.0.0.0 \
    NODE_ENV=production \
    DOMAIN=localhost

# Install runtime dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    libssl3 \
    nginx \
    libegl1-mesa \
    libasound2 \
    ca-certificates \
    mesa-utils \
    libgl1-mesa-dri \
    libgl1-mesa-glx \
    netcat-openbsd \
    gettext-base \
    net-tools \
    iproute2 \
    procps \
    lsof \
    jq \
    wget \
    && wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq \
    && chmod +x /usr/bin/yq \
    && wget https://github.com/vi/websocat/releases/latest/download/websocat.x86_64-unknown-linux-musl -O /usr/bin/websocat \
    && chmod +x /usr/bin/websocat \
    && rm -rf /var/lib/apt/lists/* \
    && rm -rf /usr/share/doc/* \
    && rm -rf /usr/share/man/*

# Create non-root user
RUN groupadd -r webxr && useradd -r -g webxr webxr


# Create Nginx directories and set permissions for the webxr group
RUN mkdir -p /var/log/nginx /var/run/nginx && \
    chown -R root:webxr /var/log/nginx /var/run/nginx && \
    chmod -R 775 /var/log/nginx /var/run/nginx

# Create necessary directories
RUN mkdir -p /app/data/public/dist && \
    mkdir -p /app/src/utils && \
    chown -R webxr:webxr /app

# Switch to non-root user
USER webxr

# Copy built artifacts
COPY --from=rust-deps-builder /usr/src/app/target/release/webxr /app/
COPY src/utils/compute_forces.ptx /app/src/utils/compute_forces.ptx
COPY --from=frontend-builder /app/data/public/dist /app/data/public/dist

# Copy start script
COPY scripts/start.sh /app/start.sh

# Set proper permissions
USER root
RUN chown -R webxr:webxr /app && \
    chmod 755 /app/start.sh && \
    chmod -R g+w /app && \
    chmod 644 /app/src/utils/compute_forces.ptx
# Settings file is mounted via docker-compose, no need to touch/chmod here

USER webxr

EXPOSE 4000

CMD ["/app/start.sh"]

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: Dockerfile.dev
full_filepath: /mnt/mldata/githubs/logseqSpringThing/Dockerfile.dev
```dev
FROM nvidia/cuda:12.8.1-devel-ubuntu22.04

ENV DEBIAN_FRONTEND=noninteractive \
    RUST_LOG=off \
    PATH="/root/.cargo/bin:${PATH}" \
    NVIDIA_DRIVER_CAPABILITIES=all \
    CUDA_HOME=/usr/local/cuda

# Install dependencies including compilation tools
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    git \
    nginx \
    build-essential \
    gcc-11 \
    g++-11 \
    pkg-config \
    libssl-dev \
    netcat-openbsd \
    lsof \
    gzip \
    expect \
    && rm -rf /var/lib/apt/lists/*

# Create Nginx log directory
RUN mkdir -p /var/log/nginx

# Set gcc-11 as default compiler (needed for CUDA compilation)
RUN update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 100 \
    && update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11 100

# Install Node.js
RUN curl -fsSL https://deb.nodesource.com/setup_20.x | bash - && \
    apt-get install -y nodejs

# Install Rust
RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y

WORKDIR /app

# Create necessary directories
RUN mkdir -p /app/data/markdown \
    /app/data/metadata \
    /app/data/runtime \
    /app/user_settings \
    /app/client

# Copy Rust files first
COPY Cargo.toml Cargo.lock ./
COPY src ./src

# Copy client directory with all frontend files
COPY client ./client

# Install Node.js dependencies
WORKDIR /app/client
RUN npm install

WORKDIR /app

# Copy Nginx config
COPY nginx.dev.conf /etc/nginx/nginx.conf

# Build Rust with GPU features
RUN cargo build --features gpu && \
    cp target/debug/webxr /app/webxr

# PTX compilation - now happens during container build
COPY scripts/compile_ptx.sh ./scripts/
COPY src/utils/compute_forces.cu ./src/utils/
RUN chmod +x ./scripts/compile_ptx.sh && \
    # Get CUDA_ARCH from build arg or default to 86
    CUDA_ARCH=${CUDA_ARCH:-86} ./scripts/compile_ptx.sh

# Development entrypoint script
COPY scripts/dev-entrypoint.sh ./
RUN chmod +x ./dev-entrypoint.sh

EXPOSE 3001 4000 5173 24678

ENTRYPOINT ["./dev-entrypoint.sh"]

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: Dockerfile.production
full_filepath: /mnt/mldata/githubs/logseqSpringThing/Dockerfile.production
```production
FROM nvidia/cuda:12.8.1-devel-ubuntu22.04 as builder

ENV DEBIAN_FRONTEND=noninteractive \
    RUST_LOG=warn \
    PATH="/root/.cargo/bin:${PATH}" \
    NVIDIA_DRIVER_CAPABILITIES=all \
    CUDA_HOME=/usr/local/cuda \
    NODE_ENV=production

# Install build dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    git \
    build-essential \
    gcc-11 \
    g++-11 \
    pkg-config \
    libssl-dev \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

# Set gcc-11 as default compiler (needed for CUDA compilation)
RUN update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 100 \
    && update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11 100

# Install Node.js
RUN curl -fsSL https://deb.nodesource.com/setup_20.x | bash - && \
    apt-get install -y nodejs

# Install Rust
RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y

# Create app directory
WORKDIR /build

# Copy Rust files for server build
COPY Cargo.toml Cargo.lock ./
COPY src ./src

# Copy client files for frontend build
COPY client ./client

# Build client (production mode)
WORKDIR /build/client
# Temporarily set NODE_ENV=development for install to ensure devDeps, then run build
RUN NODE_ENV=development npm install && \
    npm run build

# Build Rust server (release mode with GPU features)
WORKDIR /build
RUN cargo build --release --features gpu

# Handle PTX compilation
# Ensure the script and the .cu file are in expected locations relative to WORKDIR /build
COPY scripts/compile_ptx.sh ./scripts/compile_ptx.sh
# The main `COPY src ./src` at line 38 should already make ./src/utils/compute_forces.cu available.
# If compile_ptx.sh expects paths relative to where it is, adjust accordingly or ensure it uses absolute paths or paths relative to WORKDIR.
# Assuming compile_ptx.sh uses paths relative to WORKDIR /build, like "src/utils/compute_forces.cu"

# First try to copy existing PTX file from the build context (host)
# This allows using a pre-compiled PTX if available and REBUILD_PTX is false.
COPY src/utils/compute_forces.ptx /build/src/utils/compute_forces.ptx

ARG REBUILD_PTX=false
ARG CUDA_ARCH=89
RUN chmod +x ./scripts/compile_ptx.sh && \
    if [ "$REBUILD_PTX" = "true" ] || [ ! -f "/build/src/utils/compute_forces.ptx" ]; then \
        echo "Compiling PTX file for sm_${CUDA_ARCH} using compile_ptx.sh..." && \
        # Pass CUDA_ARCH as an environment variable to the script
        CUDA_ARCH=${CUDA_ARCH} ./scripts/compile_ptx.sh && \
        echo "PTX compilation via script successful"; \
    else \
        echo "Using existing PTX file: /build/src/utils/compute_forces.ptx"; \
    fi
# Ensure the PTX file is in the correct final location for the COPY to runtime stage
# The compile_ptx.sh script writes to "src/utils/compute_forces.ptx" relative to its execution dir.
# If script is in /build/scripts/ and WORKDIR is /build, it writes to /build/src/utils/compute_forces.ptx

# Second stage: runtime image
FROM nvidia/cuda:12.8.1-runtime-ubuntu22.04

ENV DEBIAN_FRONTEND=noninteractive \
    RUST_LOG=warn \
    NODE_ENV=production \
    NVIDIA_DRIVER_CAPABILITIES=all

# Install runtime dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    nginx \
    ca-certificates \
    nodejs \
    npm \
    && rm -rf /var/lib/apt/lists/*

# Create app directory
WORKDIR /app

# Create necessary directories
RUN mkdir -p /app/data/markdown \
    /app/data/metadata \
    /app/data/runtime \
    /app/user_settings \
    /app/client/dist \
    /app/src/utils

# Copy built artifacts from builder stage
COPY --from=builder /build/target/release/webxr /app/webxr
COPY --from=builder /build/client/dist /app/client/dist
COPY --from=builder /build/src/utils/compute_forces.ptx /app/src/utils/compute_forces.ptx

# Copy nginx configuration
COPY nginx.conf /etc/nginx/nginx.conf

# Copy startup script
COPY scripts/start.sh /app/start.sh
RUN chmod +x /app/start.sh

# Expose port
EXPOSE 4000

# Set entrypoint
ENTRYPOINT ["/app/start.sh"]

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: config.yml
full_filepath: /mnt/mldata/githubs/logseqSpringThing/config.yml
```yml
tunnel: logseqXR

ingress:
  - hostname: www.visionflow.info
    service: http://webxr:4000
    originRequest:
      noTLSVerify: true
      connectTimeout: 30s
      tcpKeepAlive: 10s
      keepAliveTimeout: 10m
      idleTimeout: 10m
      websocketIdleTimeout: 10m
      keepAliveConnections: 100
      httpHostHeader: www.visionflow.info
      proxyProtocol: false
    config:
      webSockets: true
      http2Origin: true
  - service: http_status:404

# Connection settings
protocol: http2
no-autoupdate: true

# Logging settings
loglevel: debug

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docker-compose.dev.yml
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docker-compose.dev.yml
```yml
services:
  webxr:
    container_name: logseq_spring_thing_webxr
    build:
      context: .
      dockerfile: Dockerfile.dev
      args:
        CUDA_ARCH: ${CUDA_ARCH:-86}
    volumes:
      - ./client:/app/client
      - ./data/markdown:/app/data/markdown
      - ./data/metadata:/app/data/metadata
      - ./data/user_settings:/app/user_settings
      - ./data/settings.yaml:/app/settings.yaml
      - ./nginx.dev.conf:/etc/nginx/nginx.conf:ro # Mount dev Nginx config (read-only)
      - ./logs/nginx:/var/log/nginx # Mount nginx logs to host
      - ./scripts/logs:/app/logs
      - npm-cache:/root/.npm
      - cargo-cache:/root/.cargo/registry
      - cargo-git-cache:/root/.cargo/git
      - cargo-target-cache:/app/target # Cache Rust build artifacts
    env_file:
      - .env
    environment:
      - NVIDIA_VISIBLE_DEVICES=GPU-553dc306-dab3-32e2-c69b-28175a6f4da6
      - NVIDIA_GPU_UUID=GPU-553dc306-dab3-32e2-c69b-28175a6f4da6
      - RUST_LOG=info,webxr=warn,actix_web=warn
      - NODE_ENV=development
      - VITE_DEV_SERVER_PORT=5173 # Internal Vite port, accessed via Nginx
      - VITE_API_PORT=4000
      - VITE_HMR_PORT=24678 # Internal HMR port, accessed via Nginx
      - RUST_LOG_REDIRECT=true
      # Override the port from settings.yaml for development environment
      # Ensure Rust backend listens on 4000, which Vite proxies to.
      - SYSTEM_NETWORK_PORT=4000
    deploy: # Indentation: 4 spaces
      resources:
        reservations:
          devices:
            - driver: nvidia
              capabilities: [compute,utility]
              device_ids: ['0']
    ports: # Indentation: 4 spaces
      # Expose only Nginx port 3001 to the host.
      # Other services (Vite 5173, Rust 4000, HMR 24678) are accessed via Nginx proxy.
      - "3001:3001"  # Nginx entry point
    networks: # Indentation: 4 spaces
      - docker_ragflow

networks: # Indentation: 2 spaces
  docker_ragflow:
    external: true

volumes: # Indentation: 2 spaces
  npm-cache:
  cargo-cache:
  cargo-git-cache:
  cargo-target-cache:

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docker-compose.production.yml
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docker-compose.production.yml
```yml
version: '3.8'

services:
  webxr:
    container_name: logseq-spring-thing-webxr
    build:
      context: .
      dockerfile: Dockerfile.production
      args:
        CUDA_ARCH: ${CUDA_ARCH:-89}
        REBUILD_PTX: ${REBUILD_PTX:-false}
    env_file:
      - .env # Load all variables from .env file into the container
    environment:
      - NVIDIA_VISIBLE_DEVICES=${NVIDIA_VISIBLE_DEVICES:-GPU-553dc306-dab3-32e2-c69b-28175a6f4da6}
      - NVIDIA_GPU_UUID=${NVIDIA_GPU_UUID:-GPU-553dc306-dab3-32e2-c69b-28175a6f4da6}
      - RUST_LOG=${RUST_LOG:-info}
      - NODE_ENV=production
      - GIT_HASH=${GIT_HASH:-production}
    volumes:
      # Only mount data directories, not code
      - ./data/markdown:/app/data/markdown
      - ./data/metadata:/app/data/metadata
      - ./data/user_settings:/app/user_settings
      - ./data/settings.yaml:/app/settings.yaml
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              capabilities: [compute,utility]
              device_ids: ['0']
    ports:
      - "4000:4000"  # Expose API port
    networks:
      - docker_ragflow # Revert to simple network list item
    restart: unless-stopped
    healthcheck:
      # Check root path which Nginx serves, indicating Nginx is up
      test: ["CMD", "curl", "-f", "http://localhost:4000/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  cloudflared:
    container_name: cloudflared-tunnel
    image: cloudflare/cloudflared:latest
    command: tunnel --no-autoupdate run
    environment:
      # Use the standard variable name, expecting it from the .env file loaded by Compose
      - TUNNEL_TOKEN=${CLOUDFLARE_TUNNEL_TOKEN}
    volumes:
      - ./config.yml:/etc/cloudflared/config.yml:ro
    depends_on:
      - webxr
    networks:
      - docker_ragflow
    restart: unless-stopped

networks:
  docker_ragflow:
    external: true

# Removed duplicated cloudflared service definition

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: docker-compose.yml
full_filepath: /mnt/mldata/githubs/logseqSpringThing/docker-compose.yml
```yml
name: logseq-xr

services:
  webxr:
    build: .
    image: logseq-xr-image:latest
    container_name: logseq-xr-webxr
    read_only: false
    networks:
      ragflow:
        aliases:
          - webxr-client # Removed logseq-xr-webxr alias
    deploy:
      resources:
        limits:
          cpus: '16.0'
          memory: 64G
        reservations:
          devices:
            - driver: nvidia
              device_ids: ['0']  # Explicitly use GPU 0
              capabilities: [compute, utility]
    expose:
      - "4000"
    ports:
      - "4000:4000"  # Map container nginx port 4000 to host port 4000
    environment:
      - RUST_LOG=off                 # Changed from info
      - RUST_BACKTRACE=1
      - BIND_ADDRESS=0.0.0.0
      - PORT=3001  # Explicitly set Rust backend to use port 3001
      - NGINX_PORT=4000  # Set nginx to use port 4000
      - NVIDIA_GPU_UUID=GPU-553dc306-dab3-32e2-c69b-28175a6f4da6  # Direct UUID value for the specific GPU
      - NVIDIA_VISIBLE_DEVICES=GPU-553dc306-dab3-32e2-c69b-28175a6f4da6  # Pass the GPU UUID directly
      - NVIDIA_DRIVER_CAPABILITIES=compute,utility
      - NODE_ENV=production
      - GIT_HASH=${GIT_HASH:-development}  # Pass GIT_HASH from build environment
      - DEBUG_MODE=${DEBUG_MODE:-false}  # Control whether to start webxr or not
    env_file:
      - .env
    volumes:
      - ./data/markdown:/app/data/markdown
      - ./data/metadata:/app/data/metadata  # Added metadata volume mount
      - ./data/user_settings:/app/user_settings  # Added user settings volume mount
      - ./data/settings.yaml:/app/settings.yaml:rw # Simplified syntax, rw for read-write
      - type: tmpfs
        target: /tmp
        tmpfs:
          size: 4G
    user: "${UID:-1000}:${GID:-1000}"  # Use host user's UID/GID or default to 1000
    restart: unless-stopped
    stop_grace_period: 30s
    command: sh -c 'exec /app/start.sh'  # Always start WebXR with GPU enabled (via modified start.sh)
    init: true
    logging:
      driver: "json-file"
      options:
        max-size: "1g"
        max-file: "5"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:4000/"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 10s

# Removed cloudflared service definition - now defined in docker-compose.production.yml
networks:
  ragflow:
    external: true
    name: docker_ragflow  # RAGFlow's network name from docker network ls

```

workspace_name: logseqSpringThing
workspace_root: /mnt/mldata/githubs/logseqSpringThing
rel_path: nginx.conf
full_filepath: /mnt/mldata/githubs/logseqSpringThing/nginx.conf
```conf
# Use a standard, writable path for the PID file
pid /tmp/nginx.pid;
error_log /var/log/nginx/error.log debug;

events {
    worker_connections 1024;
    multi_accept on;
    use epoll;
}

http {
    # Basic settings
    include /etc/nginx/mime.types;
    default_type application/octet-stream;
    charset utf-8;

    # Override TypeScript MIME type (overriding video/mp2t from mime.types)
    types {
        application/typescript ts;
    }

    # Logging
    log_format debug_format '$remote_addr - $remote_user [$time_local] '
                          '"$request" $status $body_bytes_sent '
                          '"$http_referer" "$http_user_agent" '
                          'rt=$request_time uct="$upstream_connect_time" uht="$upstream_header_time" urt="$upstream_response_time"'
                          ' ws_status="$upstream_http_upgrade"';  # Added WebSocket status logging

    access_log /var/log/nginx/access.log debug_format;

    # Optimization
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 120;  # Increased to match cloudflared keepAliveTimeout
    keepalive_requests 100;

    # Gzip settings
    gzip on;
    gzip_disable "msie6";
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_buffers 16 8k;
    gzip_http_version 1.1;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

    # WebSocket configuration
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    # Upstream backend definition for the Rust server
    upstream backend {
        server 127.0.0.1:3001;  # Use localhost since both services are in same container
        keepalive 32;  # Keep connections alive
    }

    # Main server configuration
    server {
        listen 4000 default_server;  # Listen on port 4000 for external connections
        server_name _;  # Accept any server name
        root /app/client/dist;  # Set root to built client files directory

        # Security headers
        add_header X-Content-Type-Options nosniff;
        add_header X-Frame-Options SAMEORIGIN;
        add_header X-XSS-Protection "1; mode=block";
        add_header Referrer-Policy "same-origin" always;
        add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline' 'unsafe-eval'; connect-src 'self' ws: wss: http: https: *.visionflow.info; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://getalby.com; frame-src 'self' https://getalby.com" always;
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

        # WebSocket endpoint
        location /wss {
            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            proxy_set_header Host $host;

            # Pass through Cloudflare headers
            proxy_set_header CF-Connecting-IP $http_cf_connecting_ip;
            proxy_set_header CF-Ray $http_cf_ray;
            proxy_set_header CF-Visitor $http_cf_visitor;

            # Standard proxy headers
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;

            # WebSocket timeouts
            proxy_read_timeout 600m;  # Increased from 3600s to 600m (10 hours) to match websocketIdleTimeout
            proxy_send_timeout 3600s;
            proxy_connect_timeout 75s;
            proxy_buffering off;
            proxy_cache off;

            # Debug logging
            access_log /var/log/nginx/websocket.log debug_format;
            error_log /var/log/nginx/websocket-error.log debug;
        }

        # API endpoints
        location /api {
            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # API specific settings
            proxy_read_timeout 120s;  # Increased for larger graph data
            proxy_send_timeout 120s;  # Increased for larger graph data
            proxy_connect_timeout 60s;
            proxy_buffering on;       # Enable buffering for API responses
            proxy_buffer_size 256k;   # Increased for larger responses
            proxy_buffers 8 256k;     # Increased number of buffers
            proxy_busy_buffers_size 512k;  # Increased for larger responses
            proxy_max_temp_file_size 2048m;  # Allow larger temporary files
            add_header Cache-Control "no-store" always;  # Prevent caching of dynamic data
        }

        # Static files
        location / {
            try_files $uri $uri/ /index.html =404;
            expires 1h;
            add_header Cache-Control "public, no-transform";
            # error_page 404 = @backend;  # Remove fallback for root, let try_files handle index.html
        }

        # Static files with proper MIME types
        location /assets/ {
            expires 7d;
            add_header Cache-Control "public, no-transform" always;
            try_files $uri =404;
            access_log off;
        }

        # Fallback location for static files
        location @backend {
            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Error pages
        error_page 404 /404.html;
        error_page 500 502 503 504 /50x.html;
        location = /50x.html {
            root /usr/share/nginx/html;
        }
    }
}

```

</files>