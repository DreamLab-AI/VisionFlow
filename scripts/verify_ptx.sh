#!/bin/bash
#
# PTX Verification Script for VisionFlow System Architecture
# Validates compiled PTX kernels for runtime deployment
#

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
PTX_FILE="target/release/visionflow_unified.ptx"

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_success() { echo -e "${GREEN}[PTX Verify]${NC} $1"; }
log_error() { echo -e "${RED}[PTX Verify]${NC} $1"; }
log_warning() { echo -e "${YELLOW}[PTX Verify]${NC} $1"; }
log_info() { echo -e "${BLUE}[PTX Verify]${NC} $1"; }

# Comprehensive PTX validation
verify_ptx() {
    local ptx_path="$PROJECT_ROOT/$PTX_FILE"
    
    log_info "Verifying PTX file: $ptx_path"
    
    # File existence check
    if [[ ! -f "$ptx_path" ]]; then
        log_error "PTX file not found: $ptx_path"
        return 1
    fi
    
    # File size check
    local file_size
    file_size=$(stat -c%s "$ptx_path")
    if [[ "$file_size" -lt 50000 ]]; then
        log_error "PTX file too small ($file_size bytes), likely incomplete"
        return 1
    fi
    log_success "File size: $file_size bytes"
    
    # PTX header validation
    if ! grep -q "Generated by NVIDIA NVVM Compiler" "$ptx_path"; then
        log_error "Invalid PTX header - not generated by NVVM"
        return 1
    fi
    log_success "Valid NVVM compiler signature"
    
    # Architecture validation
    local target_arch
    target_arch=$(grep "^\.target" "$ptx_path" | cut -d' ' -f2)
    if [[ "$target_arch" != "sm_70" ]]; then
        log_warning "Unexpected target architecture: $target_arch (expected sm_70)"
    else
        log_success "Target architecture: $target_arch"
    fi
    
    # PTX version validation
    local ptx_version
    ptx_version=$(grep "^\.version" "$ptx_path" | cut -d' ' -f2)
    log_info "PTX version: $ptx_version"
    
    # Required kernel validation
    local required_kernels=(
        "build_grid_kernel"
        "compute_cell_bounds_kernel"
        "force_pass_kernel"
        "integrate_pass_kernel"
        "relaxation_step_kernel"
    )
    
    log_info "Checking for required kernel entry points..."
    local missing_kernels=0
    
    for kernel in "${required_kernels[@]}"; do
        if grep -q "^\.visible \.entry $kernel(" "$ptx_path"; then
            log_success "✓ Kernel: $kernel"
        else
            log_error "✗ Missing kernel: $kernel"
            ((missing_kernels++))
        fi
    done
    
    if [[ $missing_kernels -gt 0 ]]; then
        log_error "$missing_kernels required kernels are missing"
        return 1
    fi
    
    # Function signature validation
    log_info "Validating kernel signatures..."
    
    # Check thrust function exports
    if grep -q "thrust_sort_key_value" "$ptx_path" && grep -q "thrust_exclusive_scan" "$ptx_path"; then
        log_success "✓ Thrust wrapper functions present"
    else
        log_warning "⚠ Thrust wrapper functions may be missing"
    fi
    
    # Environment variable validation
    if [[ -n "${VISIONFLOW_PTX_PATH:-}" ]] && [[ -f "$VISIONFLOW_PTX_PATH" ]]; then
        log_success "VISIONFLOW_PTX_PATH is set and points to valid file"
    else
        log_warning "VISIONFLOW_PTX_PATH not set or invalid"
        log_info "Set with: export VISIONFLOW_PTX_PATH=\"$(realpath "$ptx_path")\""
    fi
    
    log_success "PTX verification completed successfully"
    
    # Summary report
    echo
    log_info "=== PTX COMPILATION SUMMARY ==="
    echo "PTX File: $(realpath "$ptx_path")"
    echo "File Size: $file_size bytes ($(numfmt --to=iec "$file_size"))"
    echo "Lines: $(wc -l < "$ptx_path")"
    echo "Target: $target_arch"
    echo "PTX Version: $ptx_version"
    echo "Kernels: ${#required_kernels[@]} validated"
    
    return 0
}

# Runtime readiness check
check_runtime_readiness() {
    log_info "Checking runtime readiness..."
    
    # CUDA runtime check
    if command -v nvidia-smi &> /dev/null; then
        log_success "nvidia-smi available"
        nvidia-smi --query-gpu=name,compute_cap --format=csv,noheader,nounits | while IFS=, read -r name compute_cap; do
            log_info "GPU: $name (Compute $compute_cap)"
            if (( $(echo "$compute_cap >= 7.0" | bc -l) )); then
                log_success "Compute capability $compute_cap >= 7.0 (sm_70 compatible)"
            else
                log_warning "Compute capability $compute_cap < 7.0 (may not support sm_70)"
            fi
        done
    else
        log_warning "nvidia-smi not available - cannot verify GPU compatibility"
    fi
    
    # Build system integration check
    if [[ -f "$PROJECT_ROOT/build.rs" ]]; then
        if grep -q "VISIONFLOW_PTX_PATH" "$PROJECT_ROOT/build.rs"; then
            log_success "build.rs configured for PTX path"
        else
            log_warning "build.rs may need PTX path configuration"
        fi
    fi
}

# Main execution
main() {
    log_info "Starting PTX verification..."
    
    cd "$PROJECT_ROOT"
    
    if verify_ptx && check_runtime_readiness; then
        log_success "All PTX verification checks passed!"
        echo
        echo "Next steps:"
        echo "1. Ensure VISIONFLOW_PTX_PATH is set in your environment"
        echo "2. Test GPU kernel loading in your Rust application"
        echo "3. Run smoke tests to validate kernel execution"
        return 0
    else
        log_error "PTX verification failed"
        return 1
    fi
}

main "$@"